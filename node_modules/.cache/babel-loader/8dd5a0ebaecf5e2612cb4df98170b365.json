{"ast":null,"code":"import _extends from '@babel/runtime/helpers/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport { number, func, bool } from 'prop-types';\nimport { Component, createElement } from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nvar clamp = function clamp(num, lower, upper) {\n  num = num <= upper ? num : upper;\n  num = num >= lower ? num : lower;\n  return num;\n};\n\nvar increment = function increment(progress) {\n  var amount = 0;\n\n  if (progress >= 0 && progress < 0.2) {\n    amount = 0.1;\n  } else if (progress >= 0.2 && progress < 0.5) {\n    amount = 0.04;\n  } else if (progress >= 0.5 && progress < 0.8) {\n    amount = 0.02;\n  } else if (progress >= 0.8 && progress < 0.99) {\n    amount = 0.005;\n  }\n\n  return clamp(progress + amount, 0, 0.994);\n};\n\nvar isRunning = false;\nvar pending = [];\n\nvar next = function next() {\n  isRunning = true;\n  var cb = pending.shift();\n\n  if (cb) {\n    return cb(next);\n  }\n\n  isRunning = false;\n};\n\nvar clear = function clear() {\n  isRunning = false;\n  pending = [];\n};\n\nvar queue = function queue(cb) {\n  pending.push(cb);\n\n  if (!isRunning && pending.length === 1) {\n    next();\n  }\n};\n\nvar handle;\n\nvar cancel = function cancel() {\n  if (handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\n\nvar timeout = function timeout(callback, delay) {\n  var deltaTime;\n  var start;\n\n  var frame = function frame(time) {\n    start = start || time;\n    deltaTime = time - start;\n\n    if (deltaTime > delay) {\n      callback();\n      return;\n    }\n\n    handle = window.requestAnimationFrame(frame);\n  };\n\n  handle = window.requestAnimationFrame(frame);\n};\n\nvar NProgress =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(NProgress, _React$Component);\n\n  function NProgress() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.initialState = {\n      isFinished: false,\n      progress: 0\n    };\n    _this.state = _this.initialState;\n    return _this;\n  }\n\n  var _proto = NProgress.prototype;\n\n  _proto.start = function start() {\n    var _this2 = this;\n\n    var work = function work() {\n      _this2.trickle();\n\n      queue(function (next) {\n        timeout(function () {\n          work();\n          next();\n        }, _this2.props.incrementDuration);\n      });\n    };\n\n    work();\n  };\n\n  _proto.trickle = function trickle() {\n    this.set(increment(this.state.progress));\n  };\n\n  _proto.set = function set(n) {\n    var _this3 = this;\n\n    n = clamp(n, this.props.minimum, 1);\n\n    if (n === 1) {\n      this.cleanup();\n      queue(function (next) {\n        _this3.setState(function () {\n          return {\n            progress: n\n          };\n        }, function () {\n          return timeout(next, _this3.props.animationDuration);\n        });\n      });\n      queue(function () {\n        _this3.setState(function () {\n          return {\n            isFinished: true\n          };\n        }, _this3.cleanup);\n      });\n      return;\n    }\n\n    queue(function (next) {\n      _this3.setState(function () {\n        return {\n          progress: n\n        };\n      }, function () {\n        return timeout(next, _this3.props.animationDuration);\n      });\n    });\n  };\n\n  _proto.cleanup = function cleanup() {\n    cancel();\n    clear();\n  };\n\n  _proto.done = function done() {\n    this.set(1);\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (this.props.isAnimating) {\n      this.start();\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this4 = this;\n\n    if (prevProps.isAnimating && !this.props.isAnimating) {\n      this.done();\n    }\n\n    if (!prevProps.isAnimating && this.props.isAnimating) {\n      this.setState(function () {\n        return _this4.initialState;\n      }, function () {\n        return _this4.start();\n      });\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cleanup();\n  };\n\n  _proto.render = function render() {\n    return this.props.children(_extends({}, this.state, {\n      animationDuration: this.props.animationDuration\n    }));\n  };\n\n  return NProgress;\n}(Component);\n\nNProgress.defaultProps = {\n  animationDuration: 200,\n  incrementDuration: 800,\n  isAnimating: false,\n  minimum: 0.08\n};\nNProgress.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  animationDuration: number,\n  children: func,\n  incrementDuration: number,\n  isAnimating: bool,\n  minimum: number\n} : {};\n\nfunction withNProgress(BaseComponent) {\n  var WithNProgress = function WithNProgress(props) {\n    return createElement(NProgress, props, function (p) {\n      return createElement(BaseComponent, _extends({}, props, p));\n    });\n  };\n\n  hoistNonReactStatics(WithNProgress, BaseComponent);\n  return WithNProgress;\n}\n\nexport { NProgress, withNProgress };","map":null,"metadata":{},"sourceType":"module"}