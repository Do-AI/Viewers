{"ast":null,"code":"import { createSelector } from 'reselect';\n\nvar getActiveViewportIndex = function getActiveViewportIndex(state) {\n  return state.viewports.activeViewportIndex;\n};\n\nvar getLayoutViewports = function getLayoutViewports(state) {\n  return state.viewports.layout.viewports;\n};\n\nvar getViewportSpecificData = function getViewportSpecificData(state) {\n  return state.viewports.viewportSpecificData;\n};\n/**\n * Think of this as a computed getter for our store. It lets us watch parts of\n * our redux state, and only update/recalculate when those values change.\n */\n\n\nexport var getActiveContexts = createSelector([getActiveViewportIndex, getLayoutViewports, getViewportSpecificData], function (activeViewportIndex, layoutViewports, viewportSpecificData) {\n  var activeContexts = ['VIEWER'];\n  var activeLayoutViewport = layoutViewports[activeViewportIndex] || {};\n  var activeViewportSpecificData = viewportSpecificData[activeViewportIndex] || {};\n  var activeViewportPluginName = activeLayoutViewport.plugin || activeViewportSpecificData.plugin;\n\n  if (activeViewportPluginName) {\n    var activeViewportExtension = \"ACTIVE_VIEWPORT::\".concat(activeViewportPluginName.toUpperCase());\n    activeContexts.push(activeViewportExtension);\n  }\n\n  return activeContexts;\n});","map":{"version":3,"sources":["/home/bitnami/Viewers/src/store/layout/selectors.js"],"names":["createSelector","getActiveViewportIndex","state","viewports","activeViewportIndex","getLayoutViewports","layout","getViewportSpecificData","viewportSpecificData","getActiveContexts","layoutViewports","activeContexts","activeLayoutViewport","activeViewportSpecificData","activeViewportPluginName","plugin","activeViewportExtension","toUpperCase","push"],"mappings":"AAAA,SAASA,cAAT,QAA+B,UAA/B;;AAEA,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAAC,KAAK;AAAA,SAAIA,KAAK,CAACC,SAAN,CAAgBC,mBAApB;AAAA,CAApC;;AACA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAAH,KAAK;AAAA,SAAIA,KAAK,CAACC,SAAN,CAAgBG,MAAhB,CAAuBH,SAA3B;AAAA,CAAhC;;AACA,IAAMI,uBAAuB,GAAG,SAA1BA,uBAA0B,CAAAL,KAAK;AAAA,SAAIA,KAAK,CAACC,SAAN,CAAgBK,oBAApB;AAAA,CAArC;AAEA;;;;;;AAIA,OAAO,IAAMC,iBAAiB,GAAGT,cAAc,CAC7C,CAACC,sBAAD,EAAyBI,kBAAzB,EAA6CE,uBAA7C,CAD6C,EAE7C,UAACH,mBAAD,EAAsBM,eAAtB,EAAuCF,oBAAvC,EAAgE;AAC9D,MAAMG,cAAc,GAAG,CAAC,QAAD,CAAvB;AACA,MAAMC,oBAAoB,GAAGF,eAAe,CAACN,mBAAD,CAAf,IAAwC,EAArE;AACA,MAAMS,0BAA0B,GAC9BL,oBAAoB,CAACJ,mBAAD,CAApB,IAA6C,EAD/C;AAEA,MAAMU,wBAAwB,GAC5BF,oBAAoB,CAACG,MAArB,IAA+BF,0BAA0B,CAACE,MAD5D;;AAGA,MAAID,wBAAJ,EAA8B;AAC5B,QAAME,uBAAuB,8BAAuBF,wBAAwB,CAACG,WAAzB,EAAvB,CAA7B;AACAN,IAAAA,cAAc,CAACO,IAAf,CAAoBF,uBAApB;AACD;;AAED,SAAOL,cAAP;AACD,CAhB4C,CAAxC","sourcesContent":["import { createSelector } from 'reselect';\n\nconst getActiveViewportIndex = state => state.viewports.activeViewportIndex;\nconst getLayoutViewports = state => state.viewports.layout.viewports;\nconst getViewportSpecificData = state => state.viewports.viewportSpecificData;\n\n/**\n * Think of this as a computed getter for our store. It lets us watch parts of\n * our redux state, and only update/recalculate when those values change.\n */\nexport const getActiveContexts = createSelector(\n  [getActiveViewportIndex, getLayoutViewports, getViewportSpecificData],\n  (activeViewportIndex, layoutViewports, viewportSpecificData) => {\n    const activeContexts = ['VIEWER'];\n    const activeLayoutViewport = layoutViewports[activeViewportIndex] || {};\n    const activeViewportSpecificData =\n      viewportSpecificData[activeViewportIndex] || {};\n    const activeViewportPluginName =\n      activeLayoutViewport.plugin || activeViewportSpecificData.plugin;\n\n    if (activeViewportPluginName) {\n      const activeViewportExtension = `ACTIVE_VIEWPORT::${activeViewportPluginName.toUpperCase()}`;\n      activeContexts.push(activeViewportExtension);\n    }\n\n    return activeContexts;\n  }\n);\n"]},"metadata":{},"sourceType":"module"}