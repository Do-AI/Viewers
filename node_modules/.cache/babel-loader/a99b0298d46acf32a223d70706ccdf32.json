{"ast":null,"code":"import _objectSpread from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport { connect } from 'react-redux';\nimport { MeasurementTable } from 'react-viewerbase';\nimport OHIF from 'ohif-core';\nimport moment from 'moment';\nimport cornerstone from 'cornerstone-core';\nimport jumpToRowItem from '../lib/jumpToRowItem.js';\nimport getMeasurementLocationCallback from '../lib/getMeasurementLocationCallback';\nvar setViewportSpecificData = OHIF.redux.actions.setViewportSpecificData;\nvar MeasurementApi = OHIF.measurements.MeasurementApi;\n\nfunction groupBy(list, props) {\n  return list.reduce(function (a, b) {\n    (a[b[props]] = a[b[props]] || []).push(b);\n    return a;\n  }, {});\n}\n\nfunction getAllTools() {\n  var config = OHIF.measurements.MeasurementApi.getConfiguration();\n  var tools = [];\n  config.measurementTools.forEach(function (toolGroup) {\n    return tools = tools.concat(toolGroup.childTools);\n  });\n  return tools;\n}\n\nfunction getMeasurementText(measurementData) {\n  var location = measurementData.location,\n      description = measurementData.description;\n  var text = '...';\n\n  if (location) {\n    text = location;\n\n    if (description) {\n      text += \"(\".concat(description, \")\");\n    }\n  }\n\n  return text;\n}\n\nfunction getDataForEachMeasurementNumber(measurementNumberList, timepoints, displayFunction) {\n  var data = []; // on each measurement number we should get each measurement data by available timepoint\n\n  measurementNumberList.forEach(function (measurement) {\n    timepoints.forEach(function (timepoint) {\n      var eachData = {\n        displayText: '...'\n      };\n\n      if (measurement.timepointId === timepoint.timepointId) {\n        eachData.displayText = displayFunction(measurement);\n      }\n\n      data.push(eachData);\n    });\n  });\n  return data;\n}\n\nfunction convertMeasurementsToTableData(toolCollections, timepoints) {\n  var config = OHIF.measurements.MeasurementApi.getConfiguration();\n  var toolGroups = config.measurementTools;\n  var tools = getAllTools();\n  var tableMeasurements = toolGroups.map(function (toolGroup) {\n    return {\n      groupName: toolGroup.name,\n      groupId: toolGroup.id,\n      measurements: []\n    };\n  });\n  Object.keys(toolCollections).forEach(function (toolId) {\n    var toolMeasurements = toolCollections[toolId];\n    var tool = tools.find(function (tool) {\n      return tool.id === toolId;\n    });\n    var displayFunction = tool.options.measurementTable.displayFunction; // Group by measurementNumber so we can display then all in the same line\n\n    var groupedMeasurements = groupBy(toolMeasurements, 'measurementNumber');\n    Object.keys(groupedMeasurements).forEach(function (groupedMeasurementsIndex) {\n      var measurementNumberList = groupedMeasurements[groupedMeasurementsIndex];\n      var measurementData = measurementNumberList[0];\n      var measurementNumber = measurementData.measurementNumber,\n          lesionNamingNumber = measurementData.lesionNamingNumber,\n          toolType = measurementData.toolType;\n      var measurementId = measurementData._id; //check if all measurements with same measurementNumber will have same LABEL\n\n      var tableMeasurement = {\n        itemNumber: lesionNamingNumber,\n        label: getMeasurementText(measurementData),\n        measurementId: measurementId,\n        measurementNumber: measurementNumber,\n        lesionNamingNumber: lesionNamingNumber,\n        toolType: toolType,\n        hasWarnings: false,\n        //TODO\n        warningTitle: '',\n        //TODO\n        isSplitLesion: false,\n        //TODO\n        warningList: [],\n        //TODO\n        data: getDataForEachMeasurementNumber(measurementNumberList, timepoints, displayFunction)\n      }; // find the group object for the tool\n\n      var toolGroupMeasurements = tableMeasurements.find(function (group) {\n        return group.groupId === tool.toolGroup;\n      }); // inject the new measurement for this measurementNumer\n\n      toolGroupMeasurements.measurements.push(tableMeasurement);\n    });\n  }); // Sort measurements by lesion naming number\n\n  tableMeasurements.forEach(function (tm) {\n    tm.measurements.sort(function (m1, m2) {\n      return m1.lesionNamingNumber > m2.lesionNamingNumber ? 1 : -1;\n    });\n  });\n  return tableMeasurements;\n}\n\nfunction convertTimepointsToTableData(timepoints) {\n  if (!timepoints || !timepoints.length) {\n    return [];\n  }\n\n  return [{\n    label: 'Study date:',\n    date: moment(timepoints[0].latestDate).format('DD-MMM-YY')\n  }];\n}\n\nvar mapStateToProps = function mapStateToProps(state) {\n  var _state$timepointManag = state.timepointManager,\n      timepoints = _state$timepointManag.timepoints,\n      measurements = _state$timepointManag.measurements;\n  return {\n    timepoints: convertTimepointsToTableData(timepoints),\n    measurementCollection: convertMeasurementsToTableData(measurements, timepoints),\n    timepointManager: state.timepointManager,\n    viewports: state.viewports\n  };\n};\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    dispatchRelabel: function dispatchRelabel(event, measurementData, viewportsState) {\n      var activeViewportIndex = viewportsState && viewportsState.activeViewportIndex || 0;\n      var enabledElements = cornerstone.getEnabledElements();\n\n      if (!enabledElements || enabledElements.length <= activeViewportIndex) {\n        OHIF.log.error('Failed to find the enabled element');\n        return;\n      }\n\n      var element = enabledElements[activeViewportIndex].element;\n      var eventData = {\n        event: {\n          clientX: event.clientX,\n          clientY: event.clientY\n        },\n        element: element\n      };\n      var toolType = measurementData.toolType,\n          measurementId = measurementData.measurementId;\n      var tool = MeasurementApi.Instance.tools[toolType].find(function (measurement) {\n        return measurement._id === measurementId;\n      });\n      var options = {\n        skipAddLabelButton: true,\n        editLocation: true\n      }; // Clone the tool not to set empty location initially\n\n      var toolForLocation = Object.assign({}, tool, {\n        location: null\n      });\n      getMeasurementLocationCallback(eventData, toolForLocation, options);\n    },\n    dispatchEditDescription: function dispatchEditDescription(event, measurementData, viewportsState) {\n      var activeViewportIndex = viewportsState && viewportsState.activeViewportIndex || 0;\n      var enabledElements = cornerstone.getEnabledElements();\n\n      if (!enabledElements || enabledElements.length <= activeViewportIndex) {\n        OHIF.log.error('Failed to find the enabled element');\n        return;\n      }\n\n      var element = enabledElements[activeViewportIndex].element;\n      var eventData = {\n        event: {\n          clientX: event.clientX,\n          clientY: event.clientY\n        },\n        element: element\n      };\n      var toolType = measurementData.toolType,\n          measurementId = measurementData.measurementId;\n      var tool = MeasurementApi.Instance.tools[toolType].find(function (measurement) {\n        return measurement._id === measurementId;\n      });\n      var options = {\n        editDescriptionOnDialog: true\n      };\n      getMeasurementLocationCallback(eventData, tool, options);\n    },\n    dispatchJumpToRowItem: function dispatchJumpToRowItem(measurementData, viewportsState, timepointManagerState, options) {\n      var actionData = jumpToRowItem(measurementData, viewportsState, timepointManagerState, dispatch, options);\n      actionData.viewportSpecificData.forEach(function (viewportSpecificData) {\n        var viewportIndex = viewportSpecificData.viewportIndex,\n            displaySet = viewportSpecificData.displaySet;\n        dispatch(setViewportSpecificData(viewportIndex, displaySet));\n      });\n      var toolType = measurementData.toolType,\n          measurementNumber = measurementData.measurementNumber;\n      var measurementApi = MeasurementApi.Instance;\n      Object.keys(measurementApi.tools).forEach(function (toolType) {\n        var measurements = measurementApi.tools[toolType];\n        measurements.forEach(function (measurement) {\n          measurement.active = false;\n        });\n      });\n      var measurementsToActive = measurementApi.tools[toolType].filter(function (measurement) {\n        return measurement.measurementNumber === measurementNumber;\n      });\n      measurementsToActive.forEach(function (measurementToActive) {\n        measurementToActive.active = true;\n      });\n      measurementApi.syncMeasurementsAndToolData();\n      cornerstone.getEnabledElements().forEach(function (enabledElement) {\n        cornerstone.updateImage(enabledElement.element);\n      }); // Needs to update viewports.layout state to set layout\n      //const layout = actionData.layout;\n      //dispatch(setLayout(layout))\n      // Needs to update viewports.activeViewportIndex to the first updated viewport\n      //const viewportIndex = actionData.viewportIndex;\n      //dispatch(setViewportActive(viewportIndex));\n      // Needs to update timepointsManager.measurements state to set active measurementId\n      // TODO: Not yet implemented\n      //dispatch(setActiveMeasurement(measurementData.measurementId))\n      // (later): Needs to set some property on state.extensions.cornerstone to synchronize viewport scrolling\n    }\n  };\n};\n\nvar mergeProps = function mergeProps(propsFromState, propsFromDispatch, ownProps) {\n  return _objectSpread({\n    timepoints: propsFromState.timepoints,\n    measurementCollection: propsFromState.measurementCollection,\n    selectedMeasurementNumber: ownProps.selectedMeasurementNumber\n  }, propsFromDispatch, {\n    onItemClick: function onItemClick(event, measurementData) {\n      // TODO: Add timepointId to .data for measurementData?\n      // TODO: Tooltype should be on the level below? This should\n      // provide the entire row item?\n      var viewportsState = propsFromState.viewports;\n      var timepointManagerState = propsFromState.timepointManager; // TODO: invertViewportTimepointsOrder should be stored in / read from user preferences\n      // TODO: childToolKey should come from the measurement table when it supports child tools\n\n      var options = {\n        invertViewportTimepointsOrder: false,\n        childToolKey: null\n      };\n      propsFromDispatch.dispatchJumpToRowItem(measurementData, viewportsState, timepointManagerState, options);\n    },\n    onRelabelClick: function onRelabelClick(event, measurementData) {\n      var viewportsState = propsFromState.viewports;\n      propsFromDispatch.dispatchRelabel(event, measurementData, viewportsState);\n    },\n    onEditDescriptionClick: function onEditDescriptionClick(event, measurementData) {\n      var viewportsState = propsFromState.viewports;\n      propsFromDispatch.dispatchEditDescription(event, measurementData, viewportsState);\n    },\n    onDeleteClick: function onDeleteClick(event, measurementData) {\n      var MeasurementHandlers = OHIF.measurements.MeasurementHandlers;\n      MeasurementHandlers.onRemoved({\n        detail: {\n          toolType: measurementData.toolType,\n          measurementData: {\n            _id: measurementData.measurementId,\n            lesionNamingNumber: measurementData.lesionNamingNumber,\n            measurementNumber: measurementData.measurementNumber\n          }\n        }\n      });\n    }\n  });\n};\n\nvar ConnectedMeasurementTable = connect(mapStateToProps, mapDispatchToProps, mergeProps)(MeasurementTable);\nexport default ConnectedMeasurementTable;","map":{"version":3,"sources":["/home/bitnami/Viewers/src/connectedComponents/ConnectedMeasurementTable.js"],"names":["connect","MeasurementTable","OHIF","moment","cornerstone","jumpToRowItem","getMeasurementLocationCallback","setViewportSpecificData","redux","actions","MeasurementApi","measurements","groupBy","list","props","reduce","a","b","push","getAllTools","config","getConfiguration","tools","measurementTools","forEach","toolGroup","concat","childTools","getMeasurementText","measurementData","location","description","text","getDataForEachMeasurementNumber","measurementNumberList","timepoints","displayFunction","data","measurement","timepoint","eachData","displayText","timepointId","convertMeasurementsToTableData","toolCollections","toolGroups","tableMeasurements","map","groupName","name","groupId","id","Object","keys","toolId","toolMeasurements","tool","find","options","measurementTable","groupedMeasurements","groupedMeasurementsIndex","measurementNumber","lesionNamingNumber","toolType","measurementId","_id","tableMeasurement","itemNumber","label","hasWarnings","warningTitle","isSplitLesion","warningList","toolGroupMeasurements","group","tm","sort","m1","m2","convertTimepointsToTableData","length","date","latestDate","format","mapStateToProps","state","timepointManager","measurementCollection","viewports","mapDispatchToProps","dispatch","dispatchRelabel","event","viewportsState","activeViewportIndex","enabledElements","getEnabledElements","log","error","element","eventData","clientX","clientY","Instance","skipAddLabelButton","editLocation","toolForLocation","assign","dispatchEditDescription","editDescriptionOnDialog","dispatchJumpToRowItem","timepointManagerState","actionData","viewportSpecificData","viewportIndex","displaySet","measurementApi","active","measurementsToActive","filter","measurementToActive","syncMeasurementsAndToolData","enabledElement","updateImage","mergeProps","propsFromState","propsFromDispatch","ownProps","selectedMeasurementNumber","onItemClick","invertViewportTimepointsOrder","childToolKey","onRelabelClick","onEditDescriptionClick","onDeleteClick","MeasurementHandlers","onRemoved","detail","ConnectedMeasurementTable"],"mappings":"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","sourcesContent":["import { connect } from 'react-redux';\nimport { MeasurementTable } from 'react-viewerbase';\nimport OHIF from 'ohif-core';\nimport moment from 'moment';\nimport cornerstone from 'cornerstone-core';\nimport jumpToRowItem from '../lib/jumpToRowItem.js';\nimport getMeasurementLocationCallback from '../lib/getMeasurementLocationCallback';\n\nconst { setViewportSpecificData } = OHIF.redux.actions;\nconst { MeasurementApi } = OHIF.measurements;\n\nfunction groupBy(list, props) {\n  return list.reduce((a, b) => {\n    (a[b[props]] = a[b[props]] || []).push(b);\n    return a;\n  }, {});\n}\n\nfunction getAllTools() {\n  const config = OHIF.measurements.MeasurementApi.getConfiguration();\n  let tools = [];\n  config.measurementTools.forEach(\n    toolGroup => (tools = tools.concat(toolGroup.childTools))\n  );\n\n  return tools;\n}\n\nfunction getMeasurementText(measurementData) {\n  const { location, description } = measurementData;\n  let text = '...';\n  if (location) {\n    text = location;\n    if (description) {\n      text += `(${description})`;\n    }\n  }\n  return text;\n}\n\nfunction getDataForEachMeasurementNumber(\n  measurementNumberList,\n  timepoints,\n  displayFunction\n) {\n  const data = [];\n  // on each measurement number we should get each measurement data by available timepoint\n  measurementNumberList.forEach(measurement => {\n    timepoints.forEach(timepoint => {\n      const eachData = {\n        displayText: '...',\n      };\n      if (measurement.timepointId === timepoint.timepointId) {\n        eachData.displayText = displayFunction(measurement);\n      }\n      data.push(eachData);\n    });\n  });\n\n  return data;\n}\n\nfunction convertMeasurementsToTableData(toolCollections, timepoints) {\n  const config = OHIF.measurements.MeasurementApi.getConfiguration();\n  const toolGroups = config.measurementTools;\n  const tools = getAllTools();\n\n  const tableMeasurements = toolGroups.map(toolGroup => {\n    return {\n      groupName: toolGroup.name,\n      groupId: toolGroup.id,\n      measurements: [],\n    };\n  });\n\n  Object.keys(toolCollections).forEach(toolId => {\n    const toolMeasurements = toolCollections[toolId];\n    const tool = tools.find(tool => tool.id === toolId);\n    const { displayFunction } = tool.options.measurementTable;\n\n    // Group by measurementNumber so we can display then all in the same line\n    const groupedMeasurements = groupBy(toolMeasurements, 'measurementNumber');\n\n    Object.keys(groupedMeasurements).forEach(groupedMeasurementsIndex => {\n      const measurementNumberList =\n        groupedMeasurements[groupedMeasurementsIndex];\n      const measurementData = measurementNumberList[0];\n      const {\n        measurementNumber,\n        lesionNamingNumber,\n        toolType,\n      } = measurementData;\n      const measurementId = measurementData._id;\n\n      //check if all measurements with same measurementNumber will have same LABEL\n      const tableMeasurement = {\n        itemNumber: lesionNamingNumber,\n        label: getMeasurementText(measurementData),\n        measurementId,\n        measurementNumber,\n        lesionNamingNumber,\n        toolType,\n        hasWarnings: false, //TODO\n        warningTitle: '', //TODO\n        isSplitLesion: false, //TODO\n        warningList: [], //TODO\n        data: getDataForEachMeasurementNumber(\n          measurementNumberList,\n          timepoints,\n          displayFunction\n        ),\n      };\n\n      // find the group object for the tool\n      const toolGroupMeasurements = tableMeasurements.find(group => {\n        return group.groupId === tool.toolGroup;\n      });\n      // inject the new measurement for this measurementNumer\n      toolGroupMeasurements.measurements.push(tableMeasurement);\n    });\n  });\n\n  // Sort measurements by lesion naming number\n  tableMeasurements.forEach(tm => {\n    tm.measurements.sort((m1, m2) =>\n      m1.lesionNamingNumber > m2.lesionNamingNumber ? 1 : -1\n    );\n  });\n\n  return tableMeasurements;\n}\n\nfunction convertTimepointsToTableData(timepoints) {\n  if (!timepoints || !timepoints.length) {\n    return [];\n  }\n\n  return [\n    {\n      label: 'Study date:',\n      date: moment(timepoints[0].latestDate).format('DD-MMM-YY'),\n    },\n  ];\n}\n\nconst mapStateToProps = state => {\n  const { timepoints, measurements } = state.timepointManager;\n  return {\n    timepoints: convertTimepointsToTableData(timepoints),\n    measurementCollection: convertMeasurementsToTableData(\n      measurements,\n      timepoints\n    ),\n    timepointManager: state.timepointManager,\n    viewports: state.viewports,\n  };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    dispatchRelabel: (event, measurementData, viewportsState) => {\n      const activeViewportIndex =\n        (viewportsState && viewportsState.activeViewportIndex) || 0;\n\n      const enabledElements = cornerstone.getEnabledElements();\n      if (!enabledElements || enabledElements.length <= activeViewportIndex) {\n        OHIF.log.error('Failed to find the enabled element');\n        return;\n      }\n\n      const { element } = enabledElements[activeViewportIndex];\n\n      const eventData = {\n        event: {\n          clientX: event.clientX,\n          clientY: event.clientY,\n        },\n        element,\n      };\n\n      const { toolType, measurementId } = measurementData;\n      const tool = MeasurementApi.Instance.tools[toolType].find(measurement => {\n        return measurement._id === measurementId;\n      });\n\n      const options = {\n        skipAddLabelButton: true,\n        editLocation: true,\n      };\n\n      // Clone the tool not to set empty location initially\n      const toolForLocation = Object.assign({}, tool, { location: null });\n      getMeasurementLocationCallback(eventData, toolForLocation, options);\n    },\n    dispatchEditDescription: (event, measurementData, viewportsState) => {\n      const activeViewportIndex =\n        (viewportsState && viewportsState.activeViewportIndex) || 0;\n\n      const enabledElements = cornerstone.getEnabledElements();\n      if (!enabledElements || enabledElements.length <= activeViewportIndex) {\n        OHIF.log.error('Failed to find the enabled element');\n        return;\n      }\n\n      const { element } = enabledElements[activeViewportIndex];\n\n      const eventData = {\n        event: {\n          clientX: event.clientX,\n          clientY: event.clientY,\n        },\n        element,\n      };\n\n      const { toolType, measurementId } = measurementData;\n      const tool = MeasurementApi.Instance.tools[toolType].find(measurement => {\n        return measurement._id === measurementId;\n      });\n\n      const options = {\n        editDescriptionOnDialog: true,\n      };\n\n      getMeasurementLocationCallback(eventData, tool, options);\n    },\n    dispatchJumpToRowItem: (\n      measurementData,\n      viewportsState,\n      timepointManagerState,\n      options\n    ) => {\n      const actionData = jumpToRowItem(\n        measurementData,\n        viewportsState,\n        timepointManagerState,\n        dispatch,\n        options\n      );\n\n      actionData.viewportSpecificData.forEach(viewportSpecificData => {\n        const { viewportIndex, displaySet } = viewportSpecificData;\n\n        dispatch(setViewportSpecificData(viewportIndex, displaySet));\n      });\n\n      const { toolType, measurementNumber } = measurementData;\n      const measurementApi = MeasurementApi.Instance;\n\n      Object.keys(measurementApi.tools).forEach(toolType => {\n        const measurements = measurementApi.tools[toolType];\n\n        measurements.forEach(measurement => {\n          measurement.active = false;\n        });\n      });\n\n      const measurementsToActive = measurementApi.tools[toolType].filter(\n        measurement => {\n          return measurement.measurementNumber === measurementNumber;\n        }\n      );\n\n      measurementsToActive.forEach(measurementToActive => {\n        measurementToActive.active = true;\n      });\n\n      measurementApi.syncMeasurementsAndToolData();\n\n      cornerstone.getEnabledElements().forEach(enabledElement => {\n        cornerstone.updateImage(enabledElement.element);\n      });\n\n      // Needs to update viewports.layout state to set layout\n      //const layout = actionData.layout;\n      //dispatch(setLayout(layout))\n\n      // Needs to update viewports.activeViewportIndex to the first updated viewport\n      //const viewportIndex = actionData.viewportIndex;\n      //dispatch(setViewportActive(viewportIndex));\n\n      // Needs to update timepointsManager.measurements state to set active measurementId\n      // TODO: Not yet implemented\n      //dispatch(setActiveMeasurement(measurementData.measurementId))\n\n      // (later): Needs to set some property on state.extensions.cornerstone to synchronize viewport scrolling\n    },\n  };\n};\n\nconst mergeProps = (propsFromState, propsFromDispatch, ownProps) => {\n  return {\n    timepoints: propsFromState.timepoints,\n    measurementCollection: propsFromState.measurementCollection,\n    selectedMeasurementNumber: ownProps.selectedMeasurementNumber,\n    ...propsFromDispatch,\n    onItemClick: (event, measurementData) => {\n      // TODO: Add timepointId to .data for measurementData?\n      // TODO: Tooltype should be on the level below? This should\n      // provide the entire row item?\n\n      const viewportsState = propsFromState.viewports;\n      const timepointManagerState = propsFromState.timepointManager;\n\n      // TODO: invertViewportTimepointsOrder should be stored in / read from user preferences\n      // TODO: childToolKey should come from the measurement table when it supports child tools\n      const options = {\n        invertViewportTimepointsOrder: false,\n        childToolKey: null,\n      };\n\n      propsFromDispatch.dispatchJumpToRowItem(\n        measurementData,\n        viewportsState,\n        timepointManagerState,\n        options\n      );\n    },\n    onRelabelClick: (event, measurementData) => {\n      const viewportsState = propsFromState.viewports;\n      propsFromDispatch.dispatchRelabel(event, measurementData, viewportsState);\n    },\n    onEditDescriptionClick: (event, measurementData) => {\n      const viewportsState = propsFromState.viewports;\n      propsFromDispatch.dispatchEditDescription(\n        event,\n        measurementData,\n        viewportsState\n      );\n    },\n    onDeleteClick: (event, measurementData) => {\n      const { MeasurementHandlers } = OHIF.measurements;\n\n      MeasurementHandlers.onRemoved({\n        detail: {\n          toolType: measurementData.toolType,\n          measurementData: {\n            _id: measurementData.measurementId,\n            lesionNamingNumber: measurementData.lesionNamingNumber,\n            measurementNumber: measurementData.measurementNumber,\n          },\n        },\n      });\n    },\n  };\n};\n\nconst ConnectedMeasurementTable = connect(\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps\n)(MeasurementTable);\n\nexport default ConnectedMeasurementTable;\n"]},"metadata":{},"sourceType":"module"}