{"ast":null,"code":"import _toConsumableArray from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _possibleConstructorReturn2 from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf2 from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits2 from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck2 from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass2 from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty2 from \"/home/bitnami/Viewers/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport OHIF from 'ohif-core';\nimport React, { Component } from 'react';\nvar utils = OHIF.utils;\nvar SOP_CLASS_UIDS = {\n  VL_WHOLE_SLIDE_MICROSCOPY_IMAGE_STORAGE: '1.2.840.10008.5.1.4.1.1.77.1.6'\n};\nvar DicomMicroscopySopClassHandler = {\n  id: 'DicomMicroscopySopClassHandlerPlugin',\n  sopClassUids: [SOP_CLASS_UIDS.VL_WHOLE_SLIDE_MICROSCOPY_IMAGE_STORAGE],\n  getDisplaySetFromSeries: function getDisplaySetFromSeries(series, study, dicomWebClient) {\n    var instance = series.getFirstInstance(); // Note: We are passing the dicomweb client into each viewport!\n\n    return {\n      plugin: 'microscopy',\n      displaySetInstanceUid: utils.guid(),\n      dicomWebClient: dicomWebClient,\n      sopInstanceUid: instance.getSOPInstanceUID(),\n      seriesInstanceUid: series.getSeriesInstanceUID(),\n      studyInstanceUid: study.getStudyInstanceUID()\n    };\n  }\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar dicomMicroscopyViewer = createCommonjsModule(function (module, exports) {\n  (function (global, factory) {\n    factory(exports);\n  })(commonjsGlobal, function (exports) {\n    var _keywordToTag;\n\n    /**\n     * @module ol/util\n     */\n\n    /**\n     * @return {?} Any return.\n     */\n    function _abstract() {\n      return (\n        /** @type {?} */\n        function () {\n          throw new Error('Unimplemented abstract method.');\n        }()\n      );\n    }\n    /**\n     * Counter for getUid.\n     * @type {number}\n     * @private\n     */\n\n\n    var uidCounter_ = 0;\n    /**\n     * Gets a unique ID for an object. This mutates the object so that further calls\n     * with the same object as a parameter returns the same value. Unique IDs are generated\n     * as a strictly increasing sequence. Adapted from goog.getUid.\n     *\n     * @param {Object} obj The object to get the unique ID for.\n     * @return {string} The unique ID for the object.\n     * @function module:ol.getUid\n     * @api\n     */\n\n    function getUid(obj) {\n      return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n    }\n    /**\n     * OpenLayers version.\n     * @type {string}\n     */\n\n\n    var VERSION = '5.3.0';\n    /**\n     * @module ol/AssertionError\n     */\n\n    /**\n     * Error object thrown when an assertion failed. This is an ECMA-262 Error,\n     * extended with a `code` property.\n     * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.\n     */\n\n    var AssertionError =\n    /*@__PURE__*/\n    function (Error) {\n      function AssertionError(code) {\n        var path = 'v' + VERSION.split('-')[0];\n        var message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';\n        Error.call(this, message);\n        /**\n         * Error code. The meaning of the code can be found on\n         * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with\n         * the version found in the OpenLayers script's header comment if a version\n         * other than the latest is used).\n         * @type {number}\n         * @api\n         */\n\n        this.code = code;\n        /**\n         * @type {string}\n         */\n\n        this.name = 'AssertionError'; // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40\n\n        this.message = message;\n      }\n\n      if (Error) AssertionError.__proto__ = Error;\n      AssertionError.prototype = Object.create(Error && Error.prototype);\n      AssertionError.prototype.constructor = AssertionError;\n      return AssertionError;\n    }(Error);\n    /**\n     * @module ol/CollectionEventType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var CollectionEventType = {\n      /**\n       * Triggered when an item is added to the collection.\n       * @event module:ol/Collection.CollectionEvent#add\n       * @api\n       */\n      ADD: 'add',\n\n      /**\n       * Triggered when an item is removed from the collection.\n       * @event module:ol/Collection.CollectionEvent#remove\n       * @api\n       */\n      REMOVE: 'remove'\n    };\n    /**\n     * @module ol/ObjectEventType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n    var ObjectEventType = {\n      /**\n       * Triggered when a property is changed.\n       * @event module:ol/Object.ObjectEvent#propertychange\n       * @api\n       */\n      PROPERTYCHANGE: 'propertychange'\n    };\n    /**\n     * @module ol/obj\n     */\n\n    /**\n     * Polyfill for Object.assign().  Assigns enumerable and own properties from\n     * one or more source objects to a target object.\n     * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.\n     *\n     * @param {!Object} target The target object.\n     * @param {...Object} var_sources The source object(s).\n     * @return {!Object} The modified target object.\n     */\n\n    var assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {\n      var arguments$1 = arguments;\n\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var i = 1, ii = arguments.length; i < ii; ++i) {\n        var source = arguments$1[i];\n\n        if (source !== undefined && source !== null) {\n          for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n              output[key] = source[key];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n    /**\n     * Removes all properties from an object.\n     * @param {Object} object The object to clear.\n     */\n\n    function clear(object) {\n      for (var property in object) {\n        delete object[property];\n      }\n    }\n    /**\n     * Get an array of property values from an object.\n     * @param {Object<K,V>} object The object from which to get the values.\n     * @return {!Array<V>} The property values.\n     * @template K,V\n     */\n\n\n    function getValues(object) {\n      var values = [];\n\n      for (var property in object) {\n        values.push(object[property]);\n      }\n\n      return values;\n    }\n    /**\n     * Determine if an object has any properties.\n     * @param {Object} object The object to check.\n     * @return {boolean} The object is empty.\n     */\n\n\n    function isEmpty(object) {\n      var property;\n\n      for (property in object) {\n        return false;\n      }\n\n      return !property;\n    }\n    /**\n     * @module ol/events\n     */\n\n    /**\n     * Key to use with {@link module:ol/Observable~Observable#unByKey}.\n     * @typedef {Object} EventsKey\n     * @property {Object} [bindTo]\n     * @property {ListenerFunction} [boundListener]\n     * @property {boolean} callOnce\n     * @property {number} [deleteIndex]\n     * @property {ListenerFunction} listener\n     * @property {import(\"./events/Target.js\").EventTargetLike} target\n     * @property {string} type\n     * @api\n     */\n\n    /**\n     * Listener function. This function is called with an event object as argument.\n     * When the function returns `false`, event propagation will stop.\n     *\n     * @typedef {function((Event|import(\"./events/Event.js\").default)): (void|boolean)} ListenerFunction\n     * @api\n     */\n\n    /**\n     * @param {EventsKey} listenerObj Listener object.\n     * @return {ListenerFunction} Bound listener.\n     */\n\n\n    function bindListener(listenerObj) {\n      var boundListener = function boundListener(evt) {\n        var listener = listenerObj.listener;\n        var bindTo = listenerObj.bindTo || listenerObj.target;\n\n        if (listenerObj.callOnce) {\n          unlistenByKey(listenerObj);\n        }\n\n        return listener.call(bindTo, evt);\n      };\n\n      listenerObj.boundListener = boundListener;\n      return boundListener;\n    }\n    /**\n     * Finds the matching {@link module:ol/events~EventsKey} in the given listener\n     * array.\n     *\n     * @param {!Array<!EventsKey>} listeners Array of listeners.\n     * @param {!Function} listener The listener function.\n     * @param {Object=} opt_this The `this` value inside the listener.\n     * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching\n     *     listener, for {@link module:ol/events~unlistenByKey}.\n     * @return {EventsKey|undefined} The matching listener object.\n     */\n\n\n    function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {\n      var listenerObj;\n\n      for (var i = 0, ii = listeners.length; i < ii; ++i) {\n        listenerObj = listeners[i];\n\n        if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {\n          if (opt_setDeleteIndex) {\n            listenerObj.deleteIndex = i;\n          }\n\n          return listenerObj;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * @param {import(\"./events/Target.js\").EventTargetLike} target Target.\n     * @param {string} type Type.\n     * @return {Array<EventsKey>|undefined} Listeners.\n     */\n\n\n    function getListeners(target, type) {\n      var listenerMap = getListenerMap(target);\n      return listenerMap ? listenerMap[type] : undefined;\n    }\n    /**\n     * Get the lookup of listeners.\n     * @param {Object} target Target.\n     * @param {boolean=} opt_create If a map should be created if it doesn't exist.\n     * @return {!Object<string, Array<EventsKey>>} Map of\n     *     listeners by event type.\n     */\n\n\n    function getListenerMap(target, opt_create) {\n      var listenerMap = target.ol_lm;\n\n      if (!listenerMap && opt_create) {\n        listenerMap = target.ol_lm = {};\n      }\n\n      return listenerMap;\n    }\n    /**\n     * Remove the listener map from a target.\n     * @param {Object} target Target.\n     */\n\n\n    function removeListenerMap(target) {\n      delete target.ol_lm;\n    }\n    /**\n     * Clean up all listener objects of the given type.  All properties on the\n     * listener objects will be removed, and if no listeners remain in the listener\n     * map, it will be removed from the target.\n     * @param {import(\"./events/Target.js\").EventTargetLike} target Target.\n     * @param {string} type Type.\n     */\n\n\n    function removeListeners(target, type) {\n      var listeners = getListeners(target, type);\n\n      if (listeners) {\n        for (var i = 0, ii = listeners.length; i < ii; ++i) {\n          /** @type {import(\"./events/Target.js\").default} */\n          target.removeEventListener(type, listeners[i].boundListener);\n          clear(listeners[i]);\n        }\n\n        listeners.length = 0;\n        var listenerMap = getListenerMap(target);\n\n        if (listenerMap) {\n          delete listenerMap[type];\n\n          if (Object.keys(listenerMap).length === 0) {\n            removeListenerMap(target);\n          }\n        }\n      }\n    }\n    /**\n     * Registers an event listener on an event target. Inspired by\n     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n     *\n     * This function efficiently binds a `listener` to a `this` object, and returns\n     * a key for use with {@link module:ol/events~unlistenByKey}.\n     *\n     * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n     * @param {string} type Event type.\n     * @param {ListenerFunction} listener Listener.\n     * @param {Object=} opt_this Object referenced by the `this` keyword in the\n     *     listener. Default is the `target`.\n     * @param {boolean=} opt_once If true, add the listener as one-off listener.\n     * @return {EventsKey} Unique key for the listener.\n     */\n\n\n    function listen(target, type, listener, opt_this, opt_once) {\n      var listenerMap = getListenerMap(target, true);\n      var listeners = listenerMap[type];\n\n      if (!listeners) {\n        listeners = listenerMap[type] = [];\n      }\n\n      var listenerObj = findListener(listeners, listener, opt_this, false);\n\n      if (listenerObj) {\n        if (!opt_once) {\n          // Turn one-off listener into a permanent one.\n          listenerObj.callOnce = false;\n        }\n      } else {\n        listenerObj =\n        /** @type {EventsKey} */\n        {\n          bindTo: opt_this,\n          callOnce: !!opt_once,\n          listener: listener,\n          target: target,\n          type: type\n        };\n        /** @type {import(\"./events/Target.js\").default} */\n\n        target.addEventListener(type, bindListener(listenerObj));\n        listeners.push(listenerObj);\n      }\n\n      return listenerObj;\n    }\n    /**\n     * Registers a one-off event listener on an event target. Inspired by\n     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n     *\n     * This function efficiently binds a `listener` as self-unregistering listener\n     * to a `this` object, and returns a key for use with\n     * {@link module:ol/events~unlistenByKey} in case the listener needs to be\n     * unregistered before it is called.\n     *\n     * When {@link module:ol/events~listen} is called with the same arguments after this\n     * function, the self-unregistering listener will be turned into a permanent\n     * listener.\n     *\n     * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n     * @param {string} type Event type.\n     * @param {ListenerFunction} listener Listener.\n     * @param {Object=} opt_this Object referenced by the `this` keyword in the\n     *     listener. Default is the `target`.\n     * @return {EventsKey} Key for unlistenByKey.\n     */\n\n\n    function listenOnce(target, type, listener, opt_this) {\n      return listen(target, type, listener, opt_this, true);\n    }\n    /**\n     * Unregisters an event listener on an event target. Inspired by\n     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n     *\n     * To return a listener, this function needs to be called with the exact same\n     * arguments that were used for a previous {@link module:ol/events~listen} call.\n     *\n     * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n     * @param {string} type Event type.\n     * @param {ListenerFunction} listener Listener.\n     * @param {Object=} opt_this Object referenced by the `this` keyword in the\n     *     listener. Default is the `target`.\n     */\n\n\n    function unlisten(target, type, listener, opt_this) {\n      var listeners = getListeners(target, type);\n\n      if (listeners) {\n        var listenerObj = findListener(listeners, listener, opt_this, true);\n\n        if (listenerObj) {\n          unlistenByKey(listenerObj);\n        }\n      }\n    }\n    /**\n     * Unregisters event listeners on an event target. Inspired by\n     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n     *\n     * The argument passed to this function is the key returned from\n     * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.\n     *\n     * @param {EventsKey} key The key.\n     */\n\n\n    function unlistenByKey(key) {\n      if (key && key.target) {\n        /** @type {import(\"./events/Target.js\").default} */\n        key.target.removeEventListener(key.type, key.boundListener);\n        var listeners = getListeners(key.target, key.type);\n\n        if (listeners) {\n          var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);\n\n          if (i !== -1) {\n            listeners.splice(i, 1);\n          }\n\n          if (listeners.length === 0) {\n            removeListeners(key.target, key.type);\n          }\n        }\n\n        clear(key);\n      }\n    }\n    /**\n     * Unregisters all event listeners on an event target. Inspired by\n     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n     *\n     * @param {import(\"./events/Target.js\").EventTargetLike} target Target.\n     */\n\n\n    function unlistenAll(target) {\n      var listenerMap = getListenerMap(target);\n\n      if (listenerMap) {\n        for (var type in listenerMap) {\n          removeListeners(target, type);\n        }\n      }\n    }\n    /**\n     * @module ol/Disposable\n     */\n\n    /**\n     * @classdesc\n     * Objects that need to clean up after themselves.\n     */\n\n\n    var Disposable = function Disposable() {\n      /**\n       * The object has already been disposed.\n       * @type {boolean}\n       * @private\n       */\n      this.disposed_ = false;\n    };\n    /**\n     * Clean up.\n     */\n\n\n    Disposable.prototype.dispose = function dispose() {\n      if (!this.disposed_) {\n        this.disposed_ = true;\n        this.disposeInternal();\n      }\n    };\n    /**\n     * Extension point for disposable objects.\n     * @protected\n     */\n\n\n    Disposable.prototype.disposeInternal = function disposeInternal() {};\n    /**\n     * @module ol/functions\n     */\n\n    /**\n     * Always returns true.\n     * @returns {boolean} true.\n     */\n\n\n    function TRUE() {\n      return true;\n    }\n    /**\n     * Always returns false.\n     * @returns {boolean} false.\n     */\n\n\n    function FALSE() {\n      return false;\n    }\n    /**\n     * A reusable function, used e.g. as a default for callbacks.\n     *\n     * @return {void} Nothing.\n     */\n\n\n    function VOID() {}\n    /**\n     * @module ol/events/Event\n     */\n\n    /**\n     * @classdesc\n     * Stripped down implementation of the W3C DOM Level 2 Event interface.\n     * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\n     *\n     * This implementation only provides `type` and `target` properties, and\n     * `stopPropagation` and `preventDefault` methods. It is meant as base class\n     * for higher level events defined in the library, and works with\n     * {@link module:ol/events/Target~Target}.\n     */\n\n\n    var Event = function Event(type) {\n      /**\n       * @type {boolean}\n       */\n      this.propagationStopped;\n      /**\n       * The event type.\n       * @type {string}\n       * @api\n       */\n\n      this.type = type;\n      /**\n       * The event target.\n       * @type {Object}\n       * @api\n       */\n\n      this.target = null;\n    };\n    /**\n     * Stop event propagation.\n     * @api\n     */\n\n\n    Event.prototype.preventDefault = function preventDefault() {\n      this.propagationStopped = true;\n    };\n    /**\n     * Stop event propagation.\n     * @api\n     */\n\n\n    Event.prototype.stopPropagation = function stopPropagation() {\n      this.propagationStopped = true;\n    };\n    /**\n     * @param {Event|import(\"./Event.js\").default} evt Event\n     */\n\n\n    function stopPropagation(evt) {\n      evt.stopPropagation();\n    }\n    /**\n     * @module ol/events/Target\n     */\n\n    /**\n     * @typedef {EventTarget|Target} EventTargetLike\n     */\n\n    /**\n     * @classdesc\n     * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n     * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n     *\n     * There are two important simplifications compared to the specification:\n     *\n     * 1. The handling of `useCapture` in `addEventListener` and\n     *    `removeEventListener`. There is no real capture model.\n     * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n     *    There is no event target hierarchy. When a listener calls\n     *    `stopPropagation` or `preventDefault` on an event object, it means that no\n     *    more listeners after this one will be called. Same as when the listener\n     *    returns false.\n     */\n\n\n    var Target =\n    /*@__PURE__*/\n    function (Disposable$$1) {\n      function Target() {\n        Disposable$$1.call(this);\n        /**\n         * @private\n         * @type {!Object<string, number>}\n         */\n\n        this.pendingRemovals_ = {};\n        /**\n         * @private\n         * @type {!Object<string, number>}\n         */\n\n        this.dispatching_ = {};\n        /**\n         * @private\n         * @type {!Object<string, Array<import(\"../events.js\").ListenerFunction>>}\n         */\n\n        this.listeners_ = {};\n      }\n\n      if (Disposable$$1) Target.__proto__ = Disposable$$1;\n      Target.prototype = Object.create(Disposable$$1 && Disposable$$1.prototype);\n      Target.prototype.constructor = Target;\n      /**\n       * @param {string} type Type.\n       * @param {import(\"../events.js\").ListenerFunction} listener Listener.\n       */\n\n      Target.prototype.addEventListener = function addEventListener(type, listener) {\n        var listeners = this.listeners_[type];\n\n        if (!listeners) {\n          listeners = this.listeners_[type] = [];\n        }\n\n        if (listeners.indexOf(listener) === -1) {\n          listeners.push(listener);\n        }\n      };\n      /**\n       * Dispatches an event and calls all listeners listening for events\n       * of this type. The event parameter can either be a string or an\n       * Object with a `type` property.\n       *\n       * @param {{type: string,\n       *     target: (EventTargetLike|undefined),\n       *     propagationStopped: (boolean|undefined)}|\n       *     import(\"./Event.js\").default|string} event Event object.\n       * @return {boolean|undefined} `false` if anyone called preventDefault on the\n       *     event object or if any of the listeners returned false.\n       * @api\n       */\n\n\n      Target.prototype.dispatchEvent = function dispatchEvent(event) {\n        var evt = typeof event === 'string' ? new Event(event) : event;\n        var type = evt.type;\n        evt.target = this;\n        var listeners = this.listeners_[type];\n        var propagate;\n\n        if (listeners) {\n          if (!(type in this.dispatching_)) {\n            this.dispatching_[type] = 0;\n            this.pendingRemovals_[type] = 0;\n          }\n\n          ++this.dispatching_[type];\n\n          for (var i = 0, ii = listeners.length; i < ii; ++i) {\n            if (listeners[i].call(this, evt) === false || evt.propagationStopped) {\n              propagate = false;\n              break;\n            }\n          }\n\n          --this.dispatching_[type];\n\n          if (this.dispatching_[type] === 0) {\n            var pendingRemovals = this.pendingRemovals_[type];\n            delete this.pendingRemovals_[type];\n\n            while (pendingRemovals--) {\n              this.removeEventListener(type, VOID);\n            }\n\n            delete this.dispatching_[type];\n          }\n\n          return propagate;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Target.prototype.disposeInternal = function disposeInternal() {\n        unlistenAll(this);\n      };\n      /**\n       * Get the listeners for a specified event type. Listeners are returned in the\n       * order that they will be called in.\n       *\n       * @param {string} type Type.\n       * @return {Array<import(\"../events.js\").ListenerFunction>} Listeners.\n       */\n\n\n      Target.prototype.getListeners = function getListeners$$1(type) {\n        return this.listeners_[type];\n      };\n      /**\n       * @param {string=} opt_type Type. If not provided,\n       *     `true` will be returned if this event target has any listeners.\n       * @return {boolean} Has listeners.\n       */\n\n\n      Target.prototype.hasListener = function hasListener(opt_type) {\n        return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n      };\n      /**\n       * @param {string} type Type.\n       * @param {import(\"../events.js\").ListenerFunction} listener Listener.\n       */\n\n\n      Target.prototype.removeEventListener = function removeEventListener(type, listener) {\n        var listeners = this.listeners_[type];\n\n        if (listeners) {\n          var index = listeners.indexOf(listener);\n\n          if (type in this.pendingRemovals_) {\n            // make listener a no-op, and remove later in #dispatchEvent()\n            listeners[index] = VOID;\n            ++this.pendingRemovals_[type];\n          } else {\n            listeners.splice(index, 1);\n\n            if (listeners.length === 0) {\n              delete this.listeners_[type];\n            }\n          }\n        }\n      };\n\n      return Target;\n    }(Disposable);\n    /**\n     * @module ol/events/EventType\n     */\n\n    /**\n     * @enum {string}\n     * @const\n     */\n\n\n    var EventType = {\n      /**\n       * Generic change event. Triggered when the revision counter is increased.\n       * @event module:ol/events/Event~Event#change\n       * @api\n       */\n      CHANGE: 'change',\n      CLEAR: 'clear',\n      CONTEXTMENU: 'contextmenu',\n      CLICK: 'click',\n      DBLCLICK: 'dblclick',\n      DRAGENTER: 'dragenter',\n      DRAGOVER: 'dragover',\n      DROP: 'drop',\n      ERROR: 'error',\n      KEYDOWN: 'keydown',\n      KEYPRESS: 'keypress',\n      LOAD: 'load',\n      MOUSEDOWN: 'mousedown',\n      MOUSEMOVE: 'mousemove',\n      MOUSEOUT: 'mouseout',\n      MOUSEUP: 'mouseup',\n      MOUSEWHEEL: 'mousewheel',\n      MSPOINTERDOWN: 'MSPointerDown',\n      RESIZE: 'resize',\n      TOUCHSTART: 'touchstart',\n      TOUCHMOVE: 'touchmove',\n      TOUCHEND: 'touchend',\n      WHEEL: 'wheel'\n    };\n    /**\n     * @module ol/Observable\n     */\n\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * An event target providing convenient methods for listener registration\n     * and unregistration. A generic `change` event is always available through\n     * {@link module:ol/Observable~Observable#changed}.\n     *\n     * @fires import(\"./events/Event.js\").Event\n     * @api\n     */\n\n    var Observable =\n    /*@__PURE__*/\n    function (EventTarget) {\n      function Observable() {\n        EventTarget.call(this);\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.revision_ = 0;\n      }\n\n      if (EventTarget) Observable.__proto__ = EventTarget;\n      Observable.prototype = Object.create(EventTarget && EventTarget.prototype);\n      Observable.prototype.constructor = Observable;\n      /**\n       * Increases the revision counter and dispatches a 'change' event.\n       * @api\n       */\n\n      Observable.prototype.changed = function changed() {\n        ++this.revision_;\n        this.dispatchEvent(EventType.CHANGE);\n      };\n      /**\n       * Get the version number for this object.  Each time the object is modified,\n       * its version number will be incremented.\n       * @return {number} Revision.\n       * @api\n       */\n\n\n      Observable.prototype.getRevision = function getRevision() {\n        return this.revision_;\n      };\n      /**\n       * Listen for a certain type of event.\n       * @param {string|Array<string>} type The event type or array of event types.\n       * @param {function(?): ?} listener The listener function.\n       * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n       *     called with an array of event types as the first argument, the return\n       *     will be an array of keys.\n       * @api\n       */\n\n\n      Observable.prototype.on = function on(type, listener) {\n        if (Array.isArray(type)) {\n          var len = type.length;\n          var keys = new Array(len);\n\n          for (var i = 0; i < len; ++i) {\n            keys[i] = listen(this, type[i], listener);\n          }\n\n          return keys;\n        } else {\n          return listen(this,\n          /** @type {string} */\n          type, listener);\n        }\n      };\n      /**\n       * Listen once for a certain type of event.\n       * @param {string|Array<string>} type The event type or array of event types.\n       * @param {function(?): ?} listener The listener function.\n       * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n       *     called with an array of event types as the first argument, the return\n       *     will be an array of keys.\n       * @api\n       */\n\n\n      Observable.prototype.once = function once(type, listener) {\n        if (Array.isArray(type)) {\n          var len = type.length;\n          var keys = new Array(len);\n\n          for (var i = 0; i < len; ++i) {\n            keys[i] = listenOnce(this, type[i], listener);\n          }\n\n          return keys;\n        } else {\n          return listenOnce(this,\n          /** @type {string} */\n          type, listener);\n        }\n      };\n      /**\n       * Unlisten for a certain type of event.\n       * @param {string|Array<string>} type The event type or array of event types.\n       * @param {function(?): ?} listener The listener function.\n       * @api\n       */\n\n\n      Observable.prototype.un = function un(type, listener) {\n        if (Array.isArray(type)) {\n          for (var i = 0, ii = type.length; i < ii; ++i) {\n            unlisten(this, type[i], listener);\n          }\n\n          return;\n        } else {\n          unlisten(this,\n          /** @type {string} */\n          type, listener);\n        }\n      };\n\n      return Observable;\n    }(Target);\n    /**\n     * @module ol/Object\n     */\n\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.\n     */\n\n\n    var ObjectEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function ObjectEvent(type, key, oldValue) {\n        Event$$1.call(this, type);\n        /**\n         * The name of the property whose value is changing.\n         * @type {string}\n         * @api\n         */\n\n        this.key = key;\n        /**\n         * The old value. To get the new value use `e.target.get(e.key)` where\n         * `e` is the event object.\n         * @type {*}\n         * @api\n         */\n\n        this.oldValue = oldValue;\n      }\n\n      if (Event$$1) ObjectEvent.__proto__ = Event$$1;\n      ObjectEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      ObjectEvent.prototype.constructor = ObjectEvent;\n      return ObjectEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * Most non-trivial classes inherit from this.\n     *\n     * This extends {@link module:ol/Observable} with observable\n     * properties, where each property is observable as well as the object as a\n     * whole.\n     *\n     * Classes that inherit from this have pre-defined properties, to which you can\n     * add your owns. The pre-defined properties are listed in this documentation as\n     * 'Observable Properties', and have their own accessors; for example,\n     * {@link module:ol/Map~Map} has a `target` property, accessed with\n     * `getTarget()` and changed with `setTarget()`. Not all properties are however\n     * settable. There are also general-purpose accessors `get()` and `set()`. For\n     * example, `get('target')` is equivalent to `getTarget()`.\n     *\n     * The `set` accessors trigger a change event, and you can monitor this by\n     * registering a listener. For example, {@link module:ol/View~View} has a\n     * `center` property, so `view.on('change:center', function(evt) {...});` would\n     * call the function whenever the value of the center property changes. Within\n     * the function, `evt.target` would be the view, so `evt.target.getCenter()`\n     * would return the new center.\n     *\n     * You can add your own observable properties with\n     * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\n     * You can listen for changes on that property value with\n     * `object.on('change:prop', listener)`. You can get a list of all\n     * properties with {@link module:ol/Object~BaseObject#getProperties}.\n     *\n     * Note that the observable properties are separate from standard JS properties.\n     * You can, for example, give your map object a title with\n     * `map.title='New title'` and with `map.set('title', 'Another title')`. The\n     * first will be a `hasOwnProperty`; the second will appear in\n     * `getProperties()`. Only the second is observable.\n     *\n     * Properties can be deleted by using the unset method. E.g.\n     * object.unset('foo').\n     *\n     * @fires ObjectEvent\n     * @api\n     */\n\n\n    var BaseObject =\n    /*@__PURE__*/\n    function (Observable$$1) {\n      function BaseObject(opt_values) {\n        Observable$$1.call(this); // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is\n        // the same as the order in which they were created.  This also helps to\n        // ensure that object properties are always added in the same order, which\n        // helps many JavaScript engines generate faster code.\n\n        getUid(this);\n        /**\n         * @private\n         * @type {!Object<string, *>}\n         */\n\n        this.values_ = {};\n\n        if (opt_values !== undefined) {\n          this.setProperties(opt_values);\n        }\n      }\n\n      if (Observable$$1) BaseObject.__proto__ = Observable$$1;\n      BaseObject.prototype = Object.create(Observable$$1 && Observable$$1.prototype);\n      BaseObject.prototype.constructor = BaseObject;\n      /**\n       * Gets a value.\n       * @param {string} key Key name.\n       * @return {*} Value.\n       * @api\n       */\n\n      BaseObject.prototype.get = function get(key) {\n        var value;\n\n        if (this.values_.hasOwnProperty(key)) {\n          value = this.values_[key];\n        }\n\n        return value;\n      };\n      /**\n       * Get a list of object property names.\n       * @return {Array<string>} List of property names.\n       * @api\n       */\n\n\n      BaseObject.prototype.getKeys = function getKeys() {\n        return Object.keys(this.values_);\n      };\n      /**\n       * Get an object of all property names and values.\n       * @return {Object<string, *>} Object.\n       * @api\n       */\n\n\n      BaseObject.prototype.getProperties = function getProperties() {\n        return assign({}, this.values_);\n      };\n      /**\n       * @param {string} key Key name.\n       * @param {*} oldValue Old value.\n       */\n\n\n      BaseObject.prototype.notify = function notify(key, oldValue) {\n        var eventType;\n        eventType = getChangeEventType(key);\n        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n        eventType = ObjectEventType.PROPERTYCHANGE;\n        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n      };\n      /**\n       * Sets a value.\n       * @param {string} key Key name.\n       * @param {*} value Value.\n       * @param {boolean=} opt_silent Update without triggering an event.\n       * @api\n       */\n\n\n      BaseObject.prototype.set = function set(key, value, opt_silent) {\n        if (opt_silent) {\n          this.values_[key] = value;\n        } else {\n          var oldValue = this.values_[key];\n          this.values_[key] = value;\n\n          if (oldValue !== value) {\n            this.notify(key, oldValue);\n          }\n        }\n      };\n      /**\n       * Sets a collection of key-value pairs.  Note that this changes any existing\n       * properties and adds new ones (it does not remove any existing properties).\n       * @param {Object<string, *>} values Values.\n       * @param {boolean=} opt_silent Update without triggering an event.\n       * @api\n       */\n\n\n      BaseObject.prototype.setProperties = function setProperties(values, opt_silent) {\n        for (var key in values) {\n          this.set(key, values[key], opt_silent);\n        }\n      };\n      /**\n       * Unsets a property.\n       * @param {string} key Key name.\n       * @param {boolean=} opt_silent Unset without triggering an event.\n       * @api\n       */\n\n\n      BaseObject.prototype.unset = function unset(key, opt_silent) {\n        if (key in this.values_) {\n          var oldValue = this.values_[key];\n          delete this.values_[key];\n\n          if (!opt_silent) {\n            this.notify(key, oldValue);\n          }\n        }\n      };\n\n      return BaseObject;\n    }(Observable);\n    /**\n     * @type {Object<string, string>}\n     */\n\n\n    var changeEventTypeCache = {};\n    /**\n     * @param {string} key Key name.\n     * @return {string} Change name.\n     */\n\n    function getChangeEventType(key) {\n      return changeEventTypeCache.hasOwnProperty(key) ? changeEventTypeCache[key] : changeEventTypeCache[key] = 'change:' + key;\n    }\n    /**\n     * @module ol/Collection\n     */\n\n    /**\n     * @enum {string}\n     * @private\n     */\n\n\n    var Property = {\n      LENGTH: 'length'\n    };\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this\n     * type.\n     */\n\n    var CollectionEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function CollectionEvent(type, opt_element) {\n        Event$$1.call(this, type);\n        /**\n         * The element that is added to or removed from the collection.\n         * @type {*}\n         * @api\n         */\n\n        this.element = opt_element;\n      }\n\n      if (Event$$1) CollectionEvent.__proto__ = Event$$1;\n      CollectionEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      CollectionEvent.prototype.constructor = CollectionEvent;\n      return CollectionEvent;\n    }(Event);\n    /**\n     * @typedef {Object} Options\n     * @property {boolean} [unique=false] Disallow the same item from being added to\n     * the collection twice.\n     */\n\n    /**\n     * @classdesc\n     * An expanded version of standard JS Array, adding convenience methods for\n     * manipulation. Add and remove changes to the Collection trigger a Collection\n     * event. Note that this does not cover changes to the objects _within_ the\n     * Collection; they trigger events on the appropriate object, not on the\n     * Collection as a whole.\n     *\n     * @fires CollectionEvent\n     *\n     * @template T\n     * @api\n     */\n\n\n    var Collection =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function Collection(opt_array, opt_options) {\n        BaseObject$$1.call(this);\n        var options = opt_options || {};\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.unique_ = !!options.unique;\n        /**\n         * @private\n         * @type {!Array<T>}\n         */\n\n        this.array_ = opt_array ? opt_array : [];\n\n        if (this.unique_) {\n          for (var i = 0, ii = this.array_.length; i < ii; ++i) {\n            this.assertUnique_(this.array_[i], i);\n          }\n        }\n\n        this.updateLength_();\n      }\n\n      if (BaseObject$$1) Collection.__proto__ = BaseObject$$1;\n      Collection.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      Collection.prototype.constructor = Collection;\n      /**\n       * Remove all elements from the collection.\n       * @api\n       */\n\n      Collection.prototype.clear = function clear() {\n        while (this.getLength() > 0) {\n          this.pop();\n        }\n      };\n      /**\n       * Add elements to the collection.  This pushes each item in the provided array\n       * to the end of the collection.\n       * @param {!Array<T>} arr Array.\n       * @return {Collection<T>} This collection.\n       * @api\n       */\n\n\n      Collection.prototype.extend = function extend(arr) {\n        for (var i = 0, ii = arr.length; i < ii; ++i) {\n          this.push(arr[i]);\n        }\n\n        return this;\n      };\n      /**\n       * Iterate over each element, calling the provided callback.\n       * @param {function(T, number, Array<T>): *} f The function to call\n       *     for every element. This function takes 3 arguments (the element, the\n       *     index and the array). The return value is ignored.\n       * @api\n       */\n\n\n      Collection.prototype.forEach = function forEach(f) {\n        var array = this.array_;\n\n        for (var i = 0, ii = array.length; i < ii; ++i) {\n          f(array[i], i, array);\n        }\n      };\n      /**\n       * Get a reference to the underlying Array object. Warning: if the array\n       * is mutated, no events will be dispatched by the collection, and the\n       * collection's \"length\" property won't be in sync with the actual length\n       * of the array.\n       * @return {!Array<T>} Array.\n       * @api\n       */\n\n\n      Collection.prototype.getArray = function getArray() {\n        return this.array_;\n      };\n      /**\n       * Get the element at the provided index.\n       * @param {number} index Index.\n       * @return {T} Element.\n       * @api\n       */\n\n\n      Collection.prototype.item = function item(index) {\n        return this.array_[index];\n      };\n      /**\n       * Get the length of this collection.\n       * @return {number} The length of the array.\n       * @observable\n       * @api\n       */\n\n\n      Collection.prototype.getLength = function getLength() {\n        return this.get(Property.LENGTH);\n      };\n      /**\n       * Insert an element at the provided index.\n       * @param {number} index Index.\n       * @param {T} elem Element.\n       * @api\n       */\n\n\n      Collection.prototype.insertAt = function insertAt(index, elem) {\n        if (this.unique_) {\n          this.assertUnique_(elem);\n        }\n\n        this.array_.splice(index, 0, elem);\n        this.updateLength_();\n        this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem));\n      };\n      /**\n       * Remove the last element of the collection and return it.\n       * Return `undefined` if the collection is empty.\n       * @return {T|undefined} Element.\n       * @api\n       */\n\n\n      Collection.prototype.pop = function pop() {\n        return this.removeAt(this.getLength() - 1);\n      };\n      /**\n       * Insert the provided element at the end of the collection.\n       * @param {T} elem Element.\n       * @return {number} New length of the collection.\n       * @api\n       */\n\n\n      Collection.prototype.push = function push(elem) {\n        if (this.unique_) {\n          this.assertUnique_(elem);\n        }\n\n        var n = this.getLength();\n        this.insertAt(n, elem);\n        return this.getLength();\n      };\n      /**\n       * Remove the first occurrence of an element from the collection.\n       * @param {T} elem Element.\n       * @return {T|undefined} The removed element or undefined if none found.\n       * @api\n       */\n\n\n      Collection.prototype.remove = function remove(elem) {\n        var arr = this.array_;\n\n        for (var i = 0, ii = arr.length; i < ii; ++i) {\n          if (arr[i] === elem) {\n            return this.removeAt(i);\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * Remove the element at the provided index and return it.\n       * Return `undefined` if the collection does not contain this index.\n       * @param {number} index Index.\n       * @return {T|undefined} Value.\n       * @api\n       */\n\n\n      Collection.prototype.removeAt = function removeAt(index) {\n        var prev = this.array_[index];\n        this.array_.splice(index, 1);\n        this.updateLength_();\n        this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev));\n        return prev;\n      };\n      /**\n       * Set the element at the provided index.\n       * @param {number} index Index.\n       * @param {T} elem Element.\n       * @api\n       */\n\n\n      Collection.prototype.setAt = function setAt(index, elem) {\n        var n = this.getLength();\n\n        if (index < n) {\n          if (this.unique_) {\n            this.assertUnique_(elem, index);\n          }\n\n          var prev = this.array_[index];\n          this.array_[index] = elem;\n          this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev));\n          this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem));\n        } else {\n          for (var j = n; j < index; ++j) {\n            this.insertAt(j, undefined);\n          }\n\n          this.insertAt(index, elem);\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      Collection.prototype.updateLength_ = function updateLength_() {\n        this.set(Property.LENGTH, this.array_.length);\n      };\n      /**\n       * @private\n       * @param {T} elem Element.\n       * @param {number=} opt_except Optional index to ignore.\n       */\n\n\n      Collection.prototype.assertUnique_ = function assertUnique_(elem, opt_except) {\n        for (var i = 0, ii = this.array_.length; i < ii; ++i) {\n          if (this.array_[i] === elem && i !== opt_except) {\n            throw new AssertionError(58);\n          }\n        }\n      };\n\n      return Collection;\n    }(BaseObject);\n    /**\n     * @module ol/MapEvent\n     */\n\n    /**\n     * @classdesc\n     * Events emitted as map events are instances of this type.\n     * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.\n     */\n\n\n    var MapEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function MapEvent(type, map, opt_frameState) {\n        Event$$1.call(this, type);\n        /**\n         * The map where the event occurred.\n         * @type {import(\"./PluggableMap.js\").default}\n         * @api\n         */\n\n        this.map = map;\n        /**\n         * The frame state at the time of the event.\n         * @type {?import(\"./PluggableMap.js\").FrameState}\n         * @api\n         */\n\n        this.frameState = opt_frameState !== undefined ? opt_frameState : null;\n      }\n\n      if (Event$$1) MapEvent.__proto__ = Event$$1;\n      MapEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      MapEvent.prototype.constructor = MapEvent;\n      return MapEvent;\n    }(Event);\n    /**\n     * @module ol/MapBrowserEvent\n     */\n\n    /**\n     * @classdesc\n     * Events emitted as map browser events are instances of this type.\n     * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.\n     */\n\n\n    var MapBrowserEvent =\n    /*@__PURE__*/\n    function (MapEvent$$1) {\n      function MapBrowserEvent(type, map, browserEvent, opt_dragging, opt_frameState) {\n        MapEvent$$1.call(this, type, map, opt_frameState);\n        /**\n         * The original browser event.\n         * @const\n         * @type {Event}\n         * @api\n         */\n\n        this.originalEvent = browserEvent;\n        /**\n         * The map pixel relative to the viewport corresponding to the original browser event.\n         * @type {import(\"./pixel.js\").Pixel}\n         * @api\n         */\n\n        this.pixel = map.getEventPixel(browserEvent);\n        /**\n         * The coordinate in view projection corresponding to the original browser event.\n         * @type {import(\"./coordinate.js\").Coordinate}\n         * @api\n         */\n\n        this.coordinate = map.getCoordinateFromPixel(this.pixel);\n        /**\n         * Indicates if the map is currently being dragged. Only set for\n         * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.\n         *\n         * @type {boolean}\n         * @api\n         */\n\n        this.dragging = opt_dragging !== undefined ? opt_dragging : false;\n      }\n\n      if (MapEvent$$1) MapBrowserEvent.__proto__ = MapEvent$$1;\n      MapBrowserEvent.prototype = Object.create(MapEvent$$1 && MapEvent$$1.prototype);\n      MapBrowserEvent.prototype.constructor = MapBrowserEvent;\n      /**\n       * Prevents the default browser action.\n       * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.\n       * @override\n       * @api\n       */\n\n      MapBrowserEvent.prototype.preventDefault = function preventDefault() {\n        MapEvent$$1.prototype.preventDefault.call(this);\n        this.originalEvent.preventDefault();\n      };\n      /**\n       * Prevents further propagation of the current event.\n       * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.\n       * @override\n       * @api\n       */\n\n\n      MapBrowserEvent.prototype.stopPropagation = function stopPropagation() {\n        MapEvent$$1.prototype.stopPropagation.call(this);\n        this.originalEvent.stopPropagation();\n      };\n\n      return MapBrowserEvent;\n    }(MapEvent);\n    /**\n     * @module ol/webgl\n     */\n\n    /**\n     * Constants taken from goog.webgl\n     */\n\n    /**\n     * @const\n     * @type {number}\n     */\n\n\n    var ONE = 1;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var SRC_ALPHA = 0x0302;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var COLOR_ATTACHMENT0 = 0x8CE0;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var COLOR_BUFFER_BIT = 0x00004000;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TRIANGLES = 0x0004;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TRIANGLE_STRIP = 0x0005;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var ONE_MINUS_SRC_ALPHA = 0x0303;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var ARRAY_BUFFER = 0x8892;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var ELEMENT_ARRAY_BUFFER = 0x8893;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var STREAM_DRAW = 0x88E0;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var STATIC_DRAW = 0x88E4;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var DYNAMIC_DRAW = 0x88E8;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var CULL_FACE = 0x0B44;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var BLEND = 0x0BE2;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var STENCIL_TEST = 0x0B90;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var DEPTH_TEST = 0x0B71;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var SCISSOR_TEST = 0x0C11;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var UNSIGNED_BYTE = 0x1401;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var UNSIGNED_SHORT = 0x1403;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var UNSIGNED_INT = 0x1405;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var FLOAT = 0x1406;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var RGBA = 0x1908;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var FRAGMENT_SHADER = 0x8B30;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var VERTEX_SHADER = 0x8B31;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var LINEAR = 0x2601;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TEXTURE_MAG_FILTER = 0x2800;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TEXTURE_MIN_FILTER = 0x2801;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TEXTURE_WRAP_S = 0x2802;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TEXTURE_WRAP_T = 0x2803;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TEXTURE_2D = 0x0DE1;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var TEXTURE0 = 0x84C0;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var CLAMP_TO_EDGE = 0x812F;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var FRAMEBUFFER = 0x8D40;\n    /** end of goog.webgl constants\n     */\n\n    /**\n     * @const\n     * @type {Array<string>}\n     */\n\n    var CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];\n    /**\n     * @param {HTMLCanvasElement} canvas Canvas.\n     * @param {Object=} opt_attributes Attributes.\n     * @return {WebGLRenderingContext} WebGL rendering context.\n     */\n\n    function getContext(canvas, opt_attributes) {\n      var ii = CONTEXT_IDS.length;\n\n      for (var i = 0; i < ii; ++i) {\n        try {\n          var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);\n\n          if (context) {\n            return (\n              /** @type {!WebGLRenderingContext} */\n              context\n            );\n          }\n        } catch (e) {// pass\n        }\n      }\n\n      return null;\n    }\n    /**\n     * The maximum supported WebGL texture size in pixels. If WebGL is not\n     * supported, the value is set to `undefined`.\n     * @type {number|undefined}\n     */\n\n\n    var MAX_TEXTURE_SIZE; // value is set below\n\n    /**\n     * List of supported WebGL extensions.\n     * @type {Array<string>}\n     */\n\n    var EXTENSIONS; // value is set below\n    //TODO Remove side effects\n\n    if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {\n      try {\n        var canvas =\n        /** @type {HTMLCanvasElement} */\n        document.createElement('canvas');\n        var gl = getContext(canvas, {\n          failIfMajorPerformanceCaveat: true\n        });\n\n        if (gl) {\n          MAX_TEXTURE_SIZE =\n          /** @type {number} */\n          gl.getParameter(gl.MAX_TEXTURE_SIZE);\n          EXTENSIONS = gl.getSupportedExtensions();\n        }\n      } catch (e) {// pass\n      }\n    }\n    /**\n     * @module ol/has\n     */\n\n\n    var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\n    /**\n     * User agent string says we are dealing with Firefox as browser.\n     * @type {boolean}\n     */\n\n    var FIREFOX = ua.indexOf('firefox') !== -1;\n    /**\n     * User agent string says we are dealing with Safari as browser.\n     * @type {boolean}\n     */\n\n    var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;\n    /**\n     * User agent string says we are dealing with a WebKit engine.\n     * @type {boolean}\n     */\n\n    var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;\n    /**\n     * User agent string says we are dealing with a Mac as platform.\n     * @type {boolean}\n     */\n\n    var MAC = ua.indexOf('macintosh') !== -1;\n    /**\n     * The ratio between physical pixels and device-independent pixels\n     * (dips) on the device (`window.devicePixelRatio`).\n     * @const\n     * @type {number}\n     * @api\n     */\n\n    var DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;\n    /**\n     * True if the browser's Canvas implementation implements {get,set}LineDash.\n     * @type {boolean}\n     */\n\n    var CANVAS_LINE_DASH = function () {\n      var has = false;\n\n      try {\n        has = !!document.createElement('canvas').getContext('2d').setLineDash;\n      } catch (e) {// pass\n      }\n\n      return has;\n    }();\n    /**\n     * True if browser supports touch events.\n     * @const\n     * @type {boolean}\n     * @api\n     */\n\n\n    var TOUCH = 'ontouchstart' in window;\n    /**\n     * True if browser supports pointer events.\n     * @const\n     * @type {boolean}\n     */\n\n    var POINTER = 'PointerEvent' in window;\n    /**\n     * True if browser supports ms pointer events (IE 10).\n     * @const\n     * @type {boolean}\n     */\n\n    var MSPOINTER = !!navigator.msPointerEnabled;\n    /**\n     * @module ol/MapBrowserEventType\n     */\n\n    /**\n     * Constants for event names.\n     * @enum {string}\n     */\n\n    var MapBrowserEventType = {\n      /**\n       * A true single click with no dragging and no double click. Note that this\n       * event is delayed by 250 ms to ensure that it is not a double click.\n       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick\n       * @api\n       */\n      SINGLECLICK: 'singleclick',\n\n      /**\n       * A click with no dragging. A double click will fire two of this.\n       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click\n       * @api\n       */\n      CLICK: EventType.CLICK,\n\n      /**\n       * A true double click, with no dragging.\n       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick\n       * @api\n       */\n      DBLCLICK: EventType.DBLCLICK,\n\n      /**\n       * Triggered when a pointer is dragged.\n       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag\n       * @api\n       */\n      POINTERDRAG: 'pointerdrag',\n\n      /**\n       * Triggered when a pointer is moved. Note that on touch devices this is\n       * triggered when the map is panned, so is not the same as mousemove.\n       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove\n       * @api\n       */\n      POINTERMOVE: 'pointermove',\n      POINTERDOWN: 'pointerdown',\n      POINTERUP: 'pointerup',\n      POINTEROVER: 'pointerover',\n      POINTEROUT: 'pointerout',\n      POINTERENTER: 'pointerenter',\n      POINTERLEAVE: 'pointerleave',\n      POINTERCANCEL: 'pointercancel'\n    };\n    /**\n     * @module ol/MapBrowserPointerEvent\n     */\n\n    var MapBrowserPointerEvent =\n    /*@__PURE__*/\n    function (MapBrowserEvent$$1) {\n      function MapBrowserPointerEvent(type, map, pointerEvent, opt_dragging, opt_frameState) {\n        MapBrowserEvent$$1.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);\n        /**\n         * @const\n         * @type {import(\"./pointer/PointerEvent.js\").default}\n         */\n\n        this.pointerEvent = pointerEvent;\n      }\n\n      if (MapBrowserEvent$$1) MapBrowserPointerEvent.__proto__ = MapBrowserEvent$$1;\n      MapBrowserPointerEvent.prototype = Object.create(MapBrowserEvent$$1 && MapBrowserEvent$$1.prototype);\n      MapBrowserPointerEvent.prototype.constructor = MapBrowserPointerEvent;\n      return MapBrowserPointerEvent;\n    }(MapBrowserEvent);\n    /**\n     * @module ol/pointer/EventType\n     */\n\n    /**\n     * Constants for event names.\n     * @enum {string}\n     */\n\n\n    var PointerEventType = {\n      POINTERMOVE: 'pointermove',\n      POINTERDOWN: 'pointerdown',\n      POINTERUP: 'pointerup',\n      POINTEROVER: 'pointerover',\n      POINTEROUT: 'pointerout',\n      POINTERENTER: 'pointerenter',\n      POINTERLEAVE: 'pointerleave',\n      POINTERCANCEL: 'pointercancel'\n    };\n    /**\n     * @module ol/pointer/EventSource\n     */\n\n    var EventSource = function EventSource(dispatcher, mapping) {\n      /**\n       * @type {import(\"./PointerEventHandler.js\").default}\n       */\n      this.dispatcher = dispatcher;\n      /**\n       * @private\n       * @const\n       * @type {!Object<string, function(Event)>}\n       */\n\n      this.mapping_ = mapping;\n    };\n    /**\n     * List of events supported by this source.\n     * @return {Array<string>} Event names\n     */\n\n\n    EventSource.prototype.getEvents = function getEvents() {\n      return Object.keys(this.mapping_);\n    };\n    /**\n     * Returns the handler that should handle a given event type.\n     * @param {string} eventType The event type.\n     * @return {function(Event)} Handler\n     */\n\n\n    EventSource.prototype.getHandlerForEvent = function getHandlerForEvent(eventType) {\n      return this.mapping_[eventType];\n    };\n    /**\n     * @module ol/pointer/MouseSource\n     */\n\n    /**\n     * @type {number}\n     */\n\n\n    var POINTER_ID = 1;\n    /**\n     * @type {string}\n     */\n\n    var POINTER_TYPE = 'mouse';\n    /**\n     * Radius around touchend that swallows mouse events.\n     *\n     * @type {number}\n     */\n\n    var DEDUP_DIST = 25;\n    /**\n     * Handler for `mousedown`.\n     *\n     * @this {MouseSource}\n     * @param {MouseEvent} inEvent The in event.\n     */\n\n    function mousedown(inEvent) {\n      if (!this.isEventSimulatedFromTouch_(inEvent)) {\n        // TODO(dfreedman) workaround for some elements not sending mouseup\n        // http://crbug/149091\n        if (POINTER_ID.toString() in this.pointerMap) {\n          this.cancel(inEvent);\n        }\n\n        var e = prepareEvent(inEvent, this.dispatcher);\n        this.pointerMap[POINTER_ID.toString()] = inEvent;\n        this.dispatcher.down(e, inEvent);\n      }\n    }\n    /**\n     * Handler for `mousemove`.\n     *\n     * @this {MouseSource}\n     * @param {MouseEvent} inEvent The in event.\n     */\n\n\n    function mousemove(inEvent) {\n      if (!this.isEventSimulatedFromTouch_(inEvent)) {\n        var e = prepareEvent(inEvent, this.dispatcher);\n        this.dispatcher.move(e, inEvent);\n      }\n    }\n    /**\n     * Handler for `mouseup`.\n     *\n     * @this {MouseSource}\n     * @param {MouseEvent} inEvent The in event.\n     */\n\n\n    function mouseup(inEvent) {\n      if (!this.isEventSimulatedFromTouch_(inEvent)) {\n        var p = this.pointerMap[POINTER_ID.toString()];\n\n        if (p && p.button === inEvent.button) {\n          var e = prepareEvent(inEvent, this.dispatcher);\n          this.dispatcher.up(e, inEvent);\n          this.cleanupMouse();\n        }\n      }\n    }\n    /**\n     * Handler for `mouseover`.\n     *\n     * @this {MouseSource}\n     * @param {MouseEvent} inEvent The in event.\n     */\n\n\n    function mouseover(inEvent) {\n      if (!this.isEventSimulatedFromTouch_(inEvent)) {\n        var e = prepareEvent(inEvent, this.dispatcher);\n        this.dispatcher.enterOver(e, inEvent);\n      }\n    }\n    /**\n     * Handler for `mouseout`.\n     *\n     * @this {MouseSource}\n     * @param {MouseEvent} inEvent The in event.\n     */\n\n\n    function mouseout(inEvent) {\n      if (!this.isEventSimulatedFromTouch_(inEvent)) {\n        var e = prepareEvent(inEvent, this.dispatcher);\n        this.dispatcher.leaveOut(e, inEvent);\n      }\n    }\n\n    var MouseSource =\n    /*@__PURE__*/\n    function (EventSource$$1) {\n      function MouseSource(dispatcher) {\n        var mapping = {\n          'mousedown': mousedown,\n          'mousemove': mousemove,\n          'mouseup': mouseup,\n          'mouseover': mouseover,\n          'mouseout': mouseout\n        };\n        EventSource$$1.call(this, dispatcher, mapping);\n        /**\n         * @const\n         * @type {!Object<string, Event|Object>}\n         */\n\n        this.pointerMap = dispatcher.pointerMap;\n        /**\n         * @const\n         * @type {Array<import(\"../pixel.js\").Pixel>}\n         */\n\n        this.lastTouches = [];\n      }\n\n      if (EventSource$$1) MouseSource.__proto__ = EventSource$$1;\n      MouseSource.prototype = Object.create(EventSource$$1 && EventSource$$1.prototype);\n      MouseSource.prototype.constructor = MouseSource;\n      /**\n       * Detect if a mouse event was simulated from a touch by\n       * checking if previously there was a touch event at the\n       * same position.\n       *\n       * FIXME - Known problem with the native Android browser on\n       * Samsung GT-I9100 (Android 4.1.2):\n       * In case the page is scrolled, this function does not work\n       * correctly when a canvas is used (WebGL or canvas renderer).\n       * Mouse listeners on canvas elements (for this browser), create\n       * two mouse events: One 'good' and one 'bad' one (on other browsers or\n       * when a div is used, there is only one event). For the 'bad' one,\n       * clientX/clientY and also pageX/pageY are wrong when the page\n       * is scrolled. Because of that, this function can not detect if\n       * the events were simulated from a touch event. As result, a\n       * pointer event at a wrong position is dispatched, which confuses\n       * the map interactions.\n       * It is unclear, how one can get the correct position for the event\n       * or detect that the positions are invalid.\n       *\n       * @private\n       * @param {MouseEvent} inEvent The in event.\n       * @return {boolean} True, if the event was generated by a touch.\n       */\n\n      MouseSource.prototype.isEventSimulatedFromTouch_ = function isEventSimulatedFromTouch_(inEvent) {\n        var lts = this.lastTouches;\n        var x = inEvent.clientX;\n        var y = inEvent.clientY;\n\n        for (var i = 0, l = lts.length, t = void 0; i < l && (t = lts[i]); i++) {\n          // simulated mouse events will be swallowed near a primary touchend\n          var dx = Math.abs(x - t[0]);\n          var dy = Math.abs(y - t[1]);\n\n          if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n      /**\n       * Dispatches a `pointercancel` event.\n       *\n       * @param {Event} inEvent The in event.\n       */\n\n\n      MouseSource.prototype.cancel = function cancel(inEvent) {\n        var e = prepareEvent(inEvent, this.dispatcher);\n        this.dispatcher.cancel(e, inEvent);\n        this.cleanupMouse();\n      };\n      /**\n       * Remove the mouse from the list of active pointers.\n       */\n\n\n      MouseSource.prototype.cleanupMouse = function cleanupMouse() {\n        delete this.pointerMap[POINTER_ID.toString()];\n      };\n\n      return MouseSource;\n    }(EventSource);\n    /**\n     * Creates a copy of the original event that will be used\n     * for the fake pointer event.\n     *\n     * @param {Event} inEvent The in event.\n     * @param {import(\"./PointerEventHandler.js\").default} dispatcher Event handler.\n     * @return {Object} The copied event.\n     */\n\n\n    function prepareEvent(inEvent, dispatcher) {\n      var e = dispatcher.cloneEvent(inEvent, inEvent); // forward mouse preventDefault\n\n      var pd = e.preventDefault;\n\n      e.preventDefault = function () {\n        inEvent.preventDefault();\n        pd();\n      };\n\n      e.pointerId = POINTER_ID;\n      e.isPrimary = true;\n      e.pointerType = POINTER_TYPE;\n      return e;\n    }\n    /**\n     * @module ol/pointer/MsSource\n     */\n\n    /**\n     * @const\n     * @type {Array<string>}\n     */\n\n\n    var POINTER_TYPES = ['', 'unavailable', 'touch', 'pen', 'mouse'];\n    /**\n     * Handler for `msPointerDown`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n    function msPointerDown(inEvent) {\n      this.pointerMap[inEvent.pointerId.toString()] = inEvent;\n      var e = this.prepareEvent_(inEvent);\n      this.dispatcher.down(e, inEvent);\n    }\n    /**\n     * Handler for `msPointerMove`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n\n    function msPointerMove(inEvent) {\n      var e = this.prepareEvent_(inEvent);\n      this.dispatcher.move(e, inEvent);\n    }\n    /**\n     * Handler for `msPointerUp`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n\n    function msPointerUp(inEvent) {\n      var e = this.prepareEvent_(inEvent);\n      this.dispatcher.up(e, inEvent);\n      this.cleanup(inEvent.pointerId);\n    }\n    /**\n     * Handler for `msPointerOut`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n\n    function msPointerOut(inEvent) {\n      var e = this.prepareEvent_(inEvent);\n      this.dispatcher.leaveOut(e, inEvent);\n    }\n    /**\n     * Handler for `msPointerOver`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n\n    function msPointerOver(inEvent) {\n      var e = this.prepareEvent_(inEvent);\n      this.dispatcher.enterOver(e, inEvent);\n    }\n    /**\n     * Handler for `msPointerCancel`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n\n    function msPointerCancel(inEvent) {\n      var e = this.prepareEvent_(inEvent);\n      this.dispatcher.cancel(e, inEvent);\n      this.cleanup(inEvent.pointerId);\n    }\n    /**\n     * Handler for `msLostPointerCapture`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n\n    function msLostPointerCapture(inEvent) {\n      var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);\n      this.dispatcher.dispatchEvent(e);\n    }\n    /**\n     * Handler for `msGotPointerCapture`.\n     *\n     * @this {MsSource}\n     * @param {MSPointerEvent} inEvent The in event.\n     */\n\n\n    function msGotPointerCapture(inEvent) {\n      var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);\n      this.dispatcher.dispatchEvent(e);\n    }\n\n    var MsSource =\n    /*@__PURE__*/\n    function (EventSource$$1) {\n      function MsSource(dispatcher) {\n        var mapping = {\n          'MSPointerDown': msPointerDown,\n          'MSPointerMove': msPointerMove,\n          'MSPointerUp': msPointerUp,\n          'MSPointerOut': msPointerOut,\n          'MSPointerOver': msPointerOver,\n          'MSPointerCancel': msPointerCancel,\n          'MSGotPointerCapture': msGotPointerCapture,\n          'MSLostPointerCapture': msLostPointerCapture\n        };\n        EventSource$$1.call(this, dispatcher, mapping);\n        /**\n         * @const\n         * @type {!Object<string, MSPointerEvent|Object>}\n         */\n\n        this.pointerMap = dispatcher.pointerMap;\n      }\n\n      if (EventSource$$1) MsSource.__proto__ = EventSource$$1;\n      MsSource.prototype = Object.create(EventSource$$1 && EventSource$$1.prototype);\n      MsSource.prototype.constructor = MsSource;\n      /**\n       * Creates a copy of the original event that will be used\n       * for the fake pointer event.\n       *\n       * @private\n       * @param {MSPointerEvent} inEvent The in event.\n       * @return {Object} The copied event.\n       */\n\n      MsSource.prototype.prepareEvent_ = function prepareEvent_(inEvent) {\n        /** @type {MSPointerEvent|Object} */\n        var e = inEvent;\n\n        if (typeof inEvent.pointerType === 'number') {\n          e = this.dispatcher.cloneEvent(inEvent, inEvent);\n          e.pointerType = POINTER_TYPES[inEvent.pointerType];\n        }\n\n        return e;\n      };\n      /**\n       * Remove this pointer from the list of active pointers.\n       * @param {number} pointerId Pointer identifier.\n       */\n\n\n      MsSource.prototype.cleanup = function cleanup(pointerId) {\n        delete this.pointerMap[pointerId.toString()];\n      };\n\n      return MsSource;\n    }(EventSource);\n    /**\n     * @module ol/pointer/NativeSource\n     */\n\n    /**\n     * Handler for `pointerdown`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function pointerDown(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n    /**\n     * Handler for `pointermove`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function pointerMove(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n    /**\n     * Handler for `pointerup`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function pointerUp(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n    /**\n     * Handler for `pointerout`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function pointerOut(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n    /**\n     * Handler for `pointerover`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function pointerOver(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n    /**\n     * Handler for `pointercancel`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function pointerCancel(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n    /**\n     * Handler for `lostpointercapture`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function lostPointerCapture(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n    /**\n     * Handler for `gotpointercapture`.\n     *\n     * @this {NativeSource}\n     * @param {Event} inEvent The in event.\n     */\n\n\n    function gotPointerCapture(inEvent) {\n      this.dispatcher.fireNativeEvent(inEvent);\n    }\n\n    var NativeSource =\n    /*@__PURE__*/\n    function (EventSource$$1) {\n      function NativeSource(dispatcher) {\n        var mapping = {\n          'pointerdown': pointerDown,\n          'pointermove': pointerMove,\n          'pointerup': pointerUp,\n          'pointerout': pointerOut,\n          'pointerover': pointerOver,\n          'pointercancel': pointerCancel,\n          'gotpointercapture': gotPointerCapture,\n          'lostpointercapture': lostPointerCapture\n        };\n        EventSource$$1.call(this, dispatcher, mapping);\n      }\n\n      if (EventSource$$1) NativeSource.__proto__ = EventSource$$1;\n      NativeSource.prototype = Object.create(EventSource$$1 && EventSource$$1.prototype);\n      NativeSource.prototype.constructor = NativeSource;\n      return NativeSource;\n    }(EventSource);\n    /**\n     * @module ol/pointer/PointerEvent\n     */\n\n    /**\n     * Is the `buttons` property supported?\n     * @type {boolean}\n     */\n\n\n    var HAS_BUTTONS = false;\n\n    var PointerEvent =\n    /*@__PURE__*/\n    function (_Event) {\n      function PointerEvent(type, originalEvent, opt_eventDict) {\n        _Event.call(this, type);\n        /**\n         * @const\n         * @type {Event}\n         */\n\n\n        this.originalEvent = originalEvent;\n        var eventDict = opt_eventDict ? opt_eventDict : {};\n        /**\n         * @type {number}\n         */\n\n        this.buttons = getButtons(eventDict);\n        /**\n         * @type {number}\n         */\n\n        this.pressure = getPressure(eventDict, this.buttons); // MouseEvent related properties\n\n        /**\n         * @type {boolean}\n         */\n\n        this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;\n        /**\n         * @type {boolean}\n         */\n\n        this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;\n        /**\n         * @type {Object}\n         */\n\n        this.view = 'view' in eventDict ? eventDict['view'] : null;\n        /**\n         * @type {number}\n         */\n\n        this.detail = 'detail' in eventDict ? eventDict['detail'] : null;\n        /**\n         * @type {number}\n         */\n\n        this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;\n        /**\n         * @type {number}\n         */\n\n        this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;\n        /**\n         * @type {number}\n         */\n\n        this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;\n        /**\n         * @type {number}\n         */\n\n        this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;\n        /**\n         * @type {boolean}\n         */\n\n        this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;\n        /**\n         * @type {boolean}\n         */\n\n        this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;\n        /**\n         * @type {boolean}\n         */\n\n        this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;\n        /**\n         * @type {boolean}\n         */\n\n        this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;\n        /**\n         * @type {number}\n         */\n\n        this.button = 'button' in eventDict ? eventDict['button'] : 0;\n        /**\n         * @type {Node}\n         */\n\n        this.relatedTarget = 'relatedTarget' in eventDict ? eventDict['relatedTarget'] : null; // PointerEvent related properties\n\n        /**\n         * @const\n         * @type {number}\n         */\n\n        this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;\n        /**\n         * @type {number}\n         */\n\n        this.width = 'width' in eventDict ? eventDict['width'] : 0;\n        /**\n         * @type {number}\n         */\n\n        this.height = 'height' in eventDict ? eventDict['height'] : 0;\n        /**\n         * @type {number}\n         */\n\n        this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;\n        /**\n         * @type {number}\n         */\n\n        this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;\n        /**\n         * @type {string}\n         */\n\n        this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';\n        /**\n         * @type {number}\n         */\n\n        this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;\n        /**\n         * @type {boolean}\n         */\n\n        this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false; // keep the semantics of preventDefault\n\n        if (originalEvent.preventDefault) {\n          this.preventDefault = function () {\n            originalEvent.preventDefault();\n          };\n        }\n      }\n\n      if (_Event) PointerEvent.__proto__ = _Event;\n      PointerEvent.prototype = Object.create(_Event && _Event.prototype);\n      PointerEvent.prototype.constructor = PointerEvent;\n      return PointerEvent;\n    }(Event);\n    /**\n     * @param {Object<string, ?>} eventDict The event dictionary.\n     * @return {number} Button indicator.\n     */\n\n\n    function getButtons(eventDict) {\n      // According to the w3c spec,\n      // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button\n      // MouseEvent.button == 0 can mean either no mouse button depressed, or the\n      // left mouse button depressed.\n      //\n      // As of now, the only way to distinguish between the two states of\n      // MouseEvent.button is by using the deprecated MouseEvent.which property, as\n      // this maps mouse buttons to positive integers > 0, and uses 0 to mean that\n      // no mouse button is held.\n      //\n      // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,\n      // but initMouseEvent does not expose an argument with which to set\n      // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set\n      // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations\n      // of app developers.\n      //\n      // The only way to propagate the correct state of MouseEvent.which and\n      // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0\n      // is to call initMouseEvent with a buttonArg value of -1.\n      //\n      // This is fixed with DOM Level 4's use of buttons\n      var buttons;\n\n      if (eventDict.buttons || HAS_BUTTONS) {\n        buttons = eventDict.buttons;\n      } else {\n        switch (eventDict.which) {\n          case 1:\n            buttons = 1;\n            break;\n\n          case 2:\n            buttons = 4;\n            break;\n\n          case 3:\n            buttons = 2;\n            break;\n\n          default:\n            buttons = 0;\n        }\n      }\n\n      return buttons;\n    }\n    /**\n     * @param {Object<string, ?>} eventDict The event dictionary.\n     * @param {number} buttons Button indicator.\n     * @return {number} The pressure.\n     */\n\n\n    function getPressure(eventDict, buttons) {\n      // Spec requires that pointers without pressure specified use 0.5 for down\n      // state and 0 for up state.\n      var pressure = 0;\n\n      if (eventDict.pressure) {\n        pressure = eventDict.pressure;\n      } else {\n        pressure = buttons ? 0.5 : 0;\n      }\n\n      return pressure;\n    }\n    /**\n     * Checks if the `buttons` property is supported.\n     */\n\n\n    (function () {\n      try {\n        var ev = new MouseEvent('click', {\n          buttons: 1\n        });\n        HAS_BUTTONS = ev.buttons === 1;\n      } catch (e) {// pass\n      }\n    })();\n    /**\n     * @module ol/array\n     */\n\n    /**\n     * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n     * https://github.com/darkskyapp/binary-search\n     *\n     * @param {Array<*>} haystack Items to search through.\n     * @param {*} needle The item to look for.\n     * @param {Function=} opt_comparator Comparator function.\n     * @return {number} The index of the item if found, -1 if not.\n     */\n\n\n    function binarySearch(haystack, needle, opt_comparator) {\n      var mid, cmp;\n      var comparator = opt_comparator || numberSafeCompareFunction;\n      var low = 0;\n      var high = haystack.length;\n      var found = false;\n\n      while (low < high) {\n        /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n         * to double (which gives the wrong results). */\n        mid = low + (high - low >> 1);\n        cmp = +comparator(haystack[mid], needle);\n\n        if (cmp < 0.0) {\n          /* Too low. */\n          low = mid + 1;\n        } else {\n          /* Key found or too high */\n          high = mid;\n          found = !cmp;\n        }\n      }\n      /* Key not found. */\n\n\n      return found ? low : ~low;\n    }\n    /**\n     * Compare function for array sort that is safe for numbers.\n     * @param {*} a The first object to be compared.\n     * @param {*} b The second object to be compared.\n     * @return {number} A negative number, zero, or a positive number as the first\n     *     argument is less than, equal to, or greater than the second.\n     */\n\n\n    function numberSafeCompareFunction(a, b) {\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n    /**\n     * Whether the array contains the given object.\n     * @param {Array<*>} arr The array to test for the presence of the element.\n     * @param {*} obj The object for which to test.\n     * @return {boolean} The object is in the array.\n     */\n\n\n    function includes(arr, obj) {\n      return arr.indexOf(obj) >= 0;\n    }\n    /**\n     * @param {Array<number>} arr Array.\n     * @param {number} target Target.\n     * @param {number} direction 0 means return the nearest, > 0\n     *    means return the largest nearest, < 0 means return the\n     *    smallest nearest.\n     * @return {number} Index.\n     */\n\n\n    function linearFindNearest(arr, target, direction) {\n      var n = arr.length;\n\n      if (arr[0] <= target) {\n        return 0;\n      } else if (target <= arr[n - 1]) {\n        return n - 1;\n      } else {\n        var i;\n\n        if (direction > 0) {\n          for (i = 1; i < n; ++i) {\n            if (arr[i] < target) {\n              return i - 1;\n            }\n          }\n        } else if (direction < 0) {\n          for (i = 1; i < n; ++i) {\n            if (arr[i] <= target) {\n              return i;\n            }\n          }\n        } else {\n          for (i = 1; i < n; ++i) {\n            if (arr[i] == target) {\n              return i;\n            } else if (arr[i] < target) {\n              if (arr[i - 1] - target < target - arr[i]) {\n                return i - 1;\n              } else {\n                return i;\n              }\n            }\n          }\n        }\n\n        return n - 1;\n      }\n    }\n    /**\n     * @param {Array<*>} arr Array.\n     * @param {number} begin Begin index.\n     * @param {number} end End index.\n     */\n\n\n    function reverseSubArray(arr, begin, end) {\n      while (begin < end) {\n        var tmp = arr[begin];\n        arr[begin] = arr[end];\n        arr[end] = tmp;\n        ++begin;\n        --end;\n      }\n    }\n    /**\n     * @param {Array<VALUE>} arr The array to modify.\n     * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n     * @template VALUE\n     */\n\n\n    function extend(arr, data) {\n      var extension = Array.isArray(data) ? data : [data];\n      var length = extension.length;\n\n      for (var i = 0; i < length; i++) {\n        arr[arr.length] = extension[i];\n      }\n    }\n    /**\n     * @param {Array<VALUE>} arr The array to modify.\n     * @param {VALUE} obj The element to remove.\n     * @template VALUE\n     * @return {boolean} If the element was removed.\n     */\n\n\n    function remove(arr, obj) {\n      var i = arr.indexOf(obj);\n      var found = i > -1;\n\n      if (found) {\n        arr.splice(i, 1);\n      }\n\n      return found;\n    }\n    /**\n     * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n     * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n     * @return {boolean} Whether the two arrays are equal.\n     */\n\n\n    function equals(arr1, arr2) {\n      var len1 = arr1.length;\n\n      if (len1 !== arr2.length) {\n        return false;\n      }\n\n      for (var i = 0; i < len1; i++) {\n        if (arr1[i] !== arr2[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Sort the passed array such that the relative order of equal elements is preverved.\n     * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n     * @param {Array<*>} arr The array to sort (modifies original).\n     * @param {!function(*, *): number} compareFnc Comparison function.\n     * @api\n     */\n\n\n    function stableSort(arr, compareFnc) {\n      var length = arr.length;\n      var tmp = Array(arr.length);\n      var i;\n\n      for (i = 0; i < length; i++) {\n        tmp[i] = {\n          index: i,\n          value: arr[i]\n        };\n      }\n\n      tmp.sort(function (a, b) {\n        return compareFnc(a.value, b.value) || a.index - b.index;\n      });\n\n      for (i = 0; i < arr.length; i++) {\n        arr[i] = tmp[i].value;\n      }\n    }\n    /**\n     * @param {Array<*>} arr The array to test.\n     * @param {Function=} opt_func Comparison function.\n     * @param {boolean=} opt_strict Strictly sorted (default false).\n     * @return {boolean} Return index.\n     */\n\n\n    function isSorted(arr, opt_func, opt_strict) {\n      var compare = opt_func || numberSafeCompareFunction;\n      return arr.every(function (currentVal, index) {\n        if (index === 0) {\n          return true;\n        }\n\n        var res = compare(arr[index - 1], currentVal);\n        return !(res > 0 || opt_strict && res === 0);\n      });\n    }\n    /**\n     * @module ol/pointer/TouchSource\n     */\n\n    /**\n     * @type {number}\n     */\n\n\n    var CLICK_COUNT_TIMEOUT = 200;\n    /**\n     * @type {string}\n     */\n\n    var POINTER_TYPE$1 = 'touch';\n    /**\n     * Handler for `touchstart`, triggers `pointerover`,\n     * `pointerenter` and `pointerdown` events.\n     *\n     * @this {TouchSource}\n     * @param {TouchEvent} inEvent The in event.\n     */\n\n    function touchstart(inEvent) {\n      this.vacuumTouches_(inEvent);\n      this.setPrimaryTouch_(inEvent.changedTouches[0]);\n      this.dedupSynthMouse_(inEvent);\n      this.clickCount_++;\n      this.processTouches_(inEvent, this.overDown_);\n    }\n    /**\n     * Handler for `touchmove`.\n     *\n     * @this {TouchSource}\n     * @param {TouchEvent} inEvent The in event.\n     */\n\n\n    function touchmove(inEvent) {\n      this.processTouches_(inEvent, this.moveOverOut_);\n    }\n    /**\n     * Handler for `touchend`, triggers `pointerup`,\n     * `pointerout` and `pointerleave` events.\n     *\n     * @this {TouchSource}\n     * @param {TouchEvent} inEvent The event.\n     */\n\n\n    function touchend(inEvent) {\n      this.dedupSynthMouse_(inEvent);\n      this.processTouches_(inEvent, this.upOut_);\n    }\n    /**\n     * Handler for `touchcancel`, triggers `pointercancel`,\n     * `pointerout` and `pointerleave` events.\n     *\n     * @this {TouchSource}\n     * @param {TouchEvent} inEvent The in event.\n     */\n\n\n    function touchcancel(inEvent) {\n      this.processTouches_(inEvent, this.cancelOut_);\n    }\n\n    var TouchSource =\n    /*@__PURE__*/\n    function (EventSource$$1) {\n      function TouchSource(dispatcher, mouseSource) {\n        var mapping = {\n          'touchstart': touchstart,\n          'touchmove': touchmove,\n          'touchend': touchend,\n          'touchcancel': touchcancel\n        };\n        EventSource$$1.call(this, dispatcher, mapping);\n        /**\n         * @const\n         * @type {!Object<string, Event|Object>}\n         */\n\n        this.pointerMap = dispatcher.pointerMap;\n        /**\n         * @const\n         * @type {import(\"./MouseSource.js\").default}\n         */\n\n        this.mouseSource = mouseSource;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.firstTouchId_ = undefined;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.clickCount_ = 0;\n        /**\n         * @private\n         * @type {?}\n         */\n\n        this.resetId_;\n        /**\n         * Mouse event timeout: This should be long enough to\n         * ignore compat mouse events made by touch.\n         * @private\n         * @type {number}\n         */\n\n        this.dedupTimeout_ = 2500;\n      }\n\n      if (EventSource$$1) TouchSource.__proto__ = EventSource$$1;\n      TouchSource.prototype = Object.create(EventSource$$1 && EventSource$$1.prototype);\n      TouchSource.prototype.constructor = TouchSource;\n      /**\n       * @private\n       * @param {Touch} inTouch The in touch.\n       * @return {boolean} True, if this is the primary touch.\n       */\n\n      TouchSource.prototype.isPrimaryTouch_ = function isPrimaryTouch_(inTouch) {\n        return this.firstTouchId_ === inTouch.identifier;\n      };\n      /**\n       * Set primary touch if there are no pointers, or the only pointer is the mouse.\n       * @param {Touch} inTouch The in touch.\n       * @private\n       */\n\n\n      TouchSource.prototype.setPrimaryTouch_ = function setPrimaryTouch_(inTouch) {\n        var count = Object.keys(this.pointerMap).length;\n\n        if (count === 0 || count === 1 && POINTER_ID.toString() in this.pointerMap) {\n          this.firstTouchId_ = inTouch.identifier;\n          this.cancelResetClickCount_();\n        }\n      };\n      /**\n       * @private\n       * @param {PointerEvent} inPointer The in pointer object.\n       */\n\n\n      TouchSource.prototype.removePrimaryPointer_ = function removePrimaryPointer_(inPointer) {\n        if (inPointer.isPrimary) {\n          this.firstTouchId_ = undefined;\n          this.resetClickCount_();\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      TouchSource.prototype.resetClickCount_ = function resetClickCount_() {\n        this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), CLICK_COUNT_TIMEOUT);\n      };\n      /**\n       * @private\n       */\n\n\n      TouchSource.prototype.resetClickCountHandler_ = function resetClickCountHandler_() {\n        this.clickCount_ = 0;\n        this.resetId_ = undefined;\n      };\n      /**\n       * @private\n       */\n\n\n      TouchSource.prototype.cancelResetClickCount_ = function cancelResetClickCount_() {\n        if (this.resetId_ !== undefined) {\n          clearTimeout(this.resetId_);\n        }\n      };\n      /**\n       * @private\n       * @param {TouchEvent} browserEvent Browser event\n       * @param {Touch} inTouch Touch event\n       * @return {PointerEvent} A pointer object.\n       */\n\n\n      TouchSource.prototype.touchToPointer_ = function touchToPointer_(browserEvent, inTouch) {\n        var e = this.dispatcher.cloneEvent(browserEvent, inTouch); // Spec specifies that pointerId 1 is reserved for Mouse.\n        // Touch identifiers can start at 0.\n        // Add 2 to the touch identifier for compatibility.\n\n        e.pointerId = inTouch.identifier + 2; // TODO: check if this is necessary?\n        //e.target = findTarget(e);\n\n        e.bubbles = true;\n        e.cancelable = true;\n        e.detail = this.clickCount_;\n        e.button = 0;\n        e.buttons = 1;\n        e.width = inTouch.radiusX || 0;\n        e.height = inTouch.radiusY || 0;\n        e.pressure = inTouch.force || 0.5;\n        e.isPrimary = this.isPrimaryTouch_(inTouch);\n        e.pointerType = POINTER_TYPE$1; // make sure that the properties that are different for\n        // each `Touch` object are not copied from the BrowserEvent object\n\n        e.clientX = inTouch.clientX;\n        e.clientY = inTouch.clientY;\n        e.screenX = inTouch.screenX;\n        e.screenY = inTouch.screenY;\n        return e;\n      };\n      /**\n       * @private\n       * @param {TouchEvent} inEvent Touch event\n       * @param {function(TouchEvent, PointerEvent)} inFunction In function.\n       */\n\n\n      TouchSource.prototype.processTouches_ = function processTouches_(inEvent, inFunction) {\n        var touches = Array.prototype.slice.call(inEvent.changedTouches);\n        var count = touches.length;\n\n        function preventDefault() {\n          inEvent.preventDefault();\n        }\n\n        for (var i = 0; i < count; ++i) {\n          var pointer = this.touchToPointer_(inEvent, touches[i]); // forward touch preventDefaults\n\n          pointer.preventDefault = preventDefault;\n          inFunction.call(this, inEvent, pointer);\n        }\n      };\n      /**\n       * @private\n       * @param {TouchList} touchList The touch list.\n       * @param {number} searchId Search identifier.\n       * @return {boolean} True, if the `Touch` with the given id is in the list.\n       */\n\n\n      TouchSource.prototype.findTouch_ = function findTouch_(touchList, searchId) {\n        var l = touchList.length;\n\n        for (var i = 0; i < l; i++) {\n          var touch = touchList[i];\n\n          if (touch.identifier === searchId) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n      /**\n       * In some instances, a touchstart can happen without a touchend. This\n       * leaves the pointermap in a broken state.\n       * Therefore, on every touchstart, we remove the touches that did not fire a\n       * touchend event.\n       * To keep state globally consistent, we fire a pointercancel for\n       * this \"abandoned\" touch\n       *\n       * @private\n       * @param {TouchEvent} inEvent The in event.\n       */\n\n\n      TouchSource.prototype.vacuumTouches_ = function vacuumTouches_(inEvent) {\n        var touchList = inEvent.touches; // pointerMap.getCount() should be < touchList.length here,\n        // as the touchstart has not been processed yet.\n\n        var keys = Object.keys(this.pointerMap);\n        var count = keys.length;\n\n        if (count >= touchList.length) {\n          var d = [];\n\n          for (var i = 0; i < count; ++i) {\n            var key = Number(keys[i]);\n            var value = this.pointerMap[key]; // Never remove pointerId == 1, which is mouse.\n            // Touch identifiers are 2 smaller than their pointerId, which is the\n            // index in pointermap.\n\n            if (key != POINTER_ID && !this.findTouch_(touchList, key - 2)) {\n              d.push(value.out);\n            }\n          }\n\n          for (var i$1 = 0; i$1 < d.length; ++i$1) {\n            this.cancelOut_(inEvent, d[i$1]);\n          }\n        }\n      };\n      /**\n       * @private\n       * @param {TouchEvent} browserEvent The event.\n       * @param {PointerEvent} inPointer The in pointer object.\n       */\n\n\n      TouchSource.prototype.overDown_ = function overDown_(browserEvent, inPointer) {\n        this.pointerMap[inPointer.pointerId] = {\n          target: inPointer.target,\n          out: inPointer,\n          outTarget: inPointer.target\n        };\n        this.dispatcher.over(inPointer, browserEvent);\n        this.dispatcher.enter(inPointer, browserEvent);\n        this.dispatcher.down(inPointer, browserEvent);\n      };\n      /**\n       * @private\n       * @param {TouchEvent} browserEvent The event.\n       * @param {PointerEvent} inPointer The in pointer.\n       */\n\n\n      TouchSource.prototype.moveOverOut_ = function moveOverOut_(browserEvent, inPointer) {\n        var event = inPointer;\n        var pointer = this.pointerMap[event.pointerId]; // a finger drifted off the screen, ignore it\n\n        if (!pointer) {\n          return;\n        }\n\n        var outEvent = pointer.out;\n        var outTarget = pointer.outTarget;\n        this.dispatcher.move(event, browserEvent);\n\n        if (outEvent && outTarget !== event.target) {\n          outEvent.relatedTarget = event.target;\n          /** @type {Object} */\n\n          event.relatedTarget = outTarget; // recover from retargeting by shadow\n\n          outEvent.target = outTarget;\n\n          if (event.target) {\n            this.dispatcher.leaveOut(outEvent, browserEvent);\n            this.dispatcher.enterOver(event, browserEvent);\n          } else {\n            // clean up case when finger leaves the screen\n\n            /** @type {Object} */\n            event.target = outTarget;\n            /** @type {Object} */\n\n            event.relatedTarget = null;\n            this.cancelOut_(browserEvent, event);\n          }\n        }\n\n        pointer.out = event;\n        pointer.outTarget = event.target;\n      };\n      /**\n       * @private\n       * @param {TouchEvent} browserEvent An event.\n       * @param {PointerEvent} inPointer The inPointer object.\n       */\n\n\n      TouchSource.prototype.upOut_ = function upOut_(browserEvent, inPointer) {\n        this.dispatcher.up(inPointer, browserEvent);\n        this.dispatcher.out(inPointer, browserEvent);\n        this.dispatcher.leave(inPointer, browserEvent);\n        this.cleanUpPointer_(inPointer);\n      };\n      /**\n       * @private\n       * @param {TouchEvent} browserEvent The event.\n       * @param {PointerEvent} inPointer The in pointer.\n       */\n\n\n      TouchSource.prototype.cancelOut_ = function cancelOut_(browserEvent, inPointer) {\n        this.dispatcher.cancel(inPointer, browserEvent);\n        this.dispatcher.out(inPointer, browserEvent);\n        this.dispatcher.leave(inPointer, browserEvent);\n        this.cleanUpPointer_(inPointer);\n      };\n      /**\n       * @private\n       * @param {PointerEvent} inPointer The inPointer object.\n       */\n\n\n      TouchSource.prototype.cleanUpPointer_ = function cleanUpPointer_(inPointer) {\n        delete this.pointerMap[inPointer.pointerId];\n        this.removePrimaryPointer_(inPointer);\n      };\n      /**\n       * Prevent synth mouse events from creating pointer events.\n       *\n       * @private\n       * @param {TouchEvent} inEvent The in event.\n       */\n\n\n      TouchSource.prototype.dedupSynthMouse_ = function dedupSynthMouse_(inEvent) {\n        var lts = this.mouseSource.lastTouches;\n        var t = inEvent.changedTouches[0]; // only the primary finger will synth mouse events\n\n        if (this.isPrimaryTouch_(t)) {\n          // remember x/y of last touch\n          var lt = [t.clientX, t.clientY];\n          lts.push(lt);\n          setTimeout(function () {\n            // remove touch after timeout\n            remove(lts, lt);\n          }, this.dedupTimeout_);\n        }\n      };\n\n      return TouchSource;\n    }(EventSource);\n    /**\n     * @module ol/pointer/PointerEventHandler\n     */\n\n    /**\n     * Properties to copy when cloning an event, with default values.\n     * @type {Array<Array>}\n     */\n\n\n    var CLONE_PROPS = [// MouseEvent\n    ['bubbles', false], ['cancelable', false], ['view', null], ['detail', null], ['screenX', 0], ['screenY', 0], ['clientX', 0], ['clientY', 0], ['ctrlKey', false], ['altKey', false], ['shiftKey', false], ['metaKey', false], ['button', 0], ['relatedTarget', null], // DOM Level 3\n    ['buttons', 0], // PointerEvent\n    ['pointerId', 0], ['width', 0], ['height', 0], ['pressure', 0], ['tiltX', 0], ['tiltY', 0], ['pointerType', ''], ['hwTimestamp', 0], ['isPrimary', false], // event instance\n    ['type', ''], ['target', null], ['currentTarget', null], ['which', 0]];\n\n    var PointerEventHandler =\n    /*@__PURE__*/\n    function (EventTarget) {\n      function PointerEventHandler(element) {\n        EventTarget.call(this);\n        /**\n         * @const\n         * @private\n         * @type {Element|HTMLDocument}\n         */\n\n        this.element_ = element;\n        /**\n         * @const\n         * @type {!Object<string, Event|Object>}\n         */\n\n        this.pointerMap = {};\n        /**\n         * @type {Object<string, function(Event)>}\n         * @private\n         */\n\n        this.eventMap_ = {};\n        /**\n         * @type {Array<import(\"./EventSource.js\").default>}\n         * @private\n         */\n\n        this.eventSourceList_ = [];\n        this.registerSources();\n      }\n\n      if (EventTarget) PointerEventHandler.__proto__ = EventTarget;\n      PointerEventHandler.prototype = Object.create(EventTarget && EventTarget.prototype);\n      PointerEventHandler.prototype.constructor = PointerEventHandler;\n      /**\n       * Set up the event sources (mouse, touch and native pointers)\n       * that generate pointer events.\n       */\n\n      PointerEventHandler.prototype.registerSources = function registerSources() {\n        if (POINTER) {\n          this.registerSource('native', new NativeSource(this));\n        } else if (MSPOINTER) {\n          this.registerSource('ms', new MsSource(this));\n        } else {\n          var mouseSource = new MouseSource(this);\n          this.registerSource('mouse', mouseSource);\n\n          if (TOUCH) {\n            this.registerSource('touch', new TouchSource(this, mouseSource));\n          }\n        } // register events on the viewport element\n\n\n        this.register_();\n      };\n      /**\n       * Add a new event source that will generate pointer events.\n       *\n       * @param {string} name A name for the event source\n       * @param {import(\"./EventSource.js\").default} source The source event.\n       */\n\n\n      PointerEventHandler.prototype.registerSource = function registerSource(name, source) {\n        var s = source;\n        var newEvents = s.getEvents();\n\n        if (newEvents) {\n          newEvents.forEach(function (e) {\n            var handler = s.getHandlerForEvent(e);\n\n            if (handler) {\n              this.eventMap_[e] = handler.bind(s);\n            }\n          }.bind(this));\n          this.eventSourceList_.push(s);\n        }\n      };\n      /**\n       * Set up the events for all registered event sources.\n       * @private\n       */\n\n\n      PointerEventHandler.prototype.register_ = function register_() {\n        var l = this.eventSourceList_.length;\n\n        for (var i = 0; i < l; i++) {\n          var eventSource = this.eventSourceList_[i];\n          this.addEvents_(eventSource.getEvents());\n        }\n      };\n      /**\n       * Remove all registered events.\n       * @private\n       */\n\n\n      PointerEventHandler.prototype.unregister_ = function unregister_() {\n        var l = this.eventSourceList_.length;\n\n        for (var i = 0; i < l; i++) {\n          var eventSource = this.eventSourceList_[i];\n          this.removeEvents_(eventSource.getEvents());\n        }\n      };\n      /**\n       * Calls the right handler for a new event.\n       * @private\n       * @param {Event} inEvent Browser event.\n       */\n\n\n      PointerEventHandler.prototype.eventHandler_ = function eventHandler_(inEvent) {\n        var type = inEvent.type;\n        var handler = this.eventMap_[type];\n\n        if (handler) {\n          handler(inEvent);\n        }\n      };\n      /**\n       * Setup listeners for the given events.\n       * @private\n       * @param {Array<string>} events List of events.\n       */\n\n\n      PointerEventHandler.prototype.addEvents_ = function addEvents_(events) {\n        events.forEach(function (eventName) {\n          listen(this.element_, eventName, this.eventHandler_, this);\n        }.bind(this));\n      };\n      /**\n       * Unregister listeners for the given events.\n       * @private\n       * @param {Array<string>} events List of events.\n       */\n\n\n      PointerEventHandler.prototype.removeEvents_ = function removeEvents_(events) {\n        events.forEach(function (e) {\n          unlisten(this.element_, e, this.eventHandler_, this);\n        }.bind(this));\n      };\n      /**\n       * Returns a snapshot of inEvent, with writable properties.\n       *\n       * @param {Event} event Browser event.\n       * @param {Event|Touch} inEvent An event that contains\n       *    properties to copy.\n       * @return {Object} An object containing shallow copies of\n       *    `inEvent`'s properties.\n       */\n\n\n      PointerEventHandler.prototype.cloneEvent = function cloneEvent(event, inEvent) {\n        var eventCopy = {};\n\n        for (var i = 0, ii = CLONE_PROPS.length; i < ii; i++) {\n          var p = CLONE_PROPS[i][0];\n          eventCopy[p] = event[p] || inEvent[p] || CLONE_PROPS[i][1];\n        }\n\n        return eventCopy;\n      }; // EVENTS\n\n      /**\n       * Triggers a 'pointerdown' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.down = function down(data, event) {\n        this.fireEvent(PointerEventType.POINTERDOWN, data, event);\n      };\n      /**\n       * Triggers a 'pointermove' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.move = function move(data, event) {\n        this.fireEvent(PointerEventType.POINTERMOVE, data, event);\n      };\n      /**\n       * Triggers a 'pointerup' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.up = function up(data, event) {\n        this.fireEvent(PointerEventType.POINTERUP, data, event);\n      };\n      /**\n       * Triggers a 'pointerenter' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.enter = function enter(data, event) {\n        data.bubbles = false;\n        this.fireEvent(PointerEventType.POINTERENTER, data, event);\n      };\n      /**\n       * Triggers a 'pointerleave' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.leave = function leave(data, event) {\n        data.bubbles = false;\n        this.fireEvent(PointerEventType.POINTERLEAVE, data, event);\n      };\n      /**\n       * Triggers a 'pointerover' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.over = function over(data, event) {\n        data.bubbles = true;\n        this.fireEvent(PointerEventType.POINTEROVER, data, event);\n      };\n      /**\n       * Triggers a 'pointerout' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.out = function out(data, event) {\n        data.bubbles = true;\n        this.fireEvent(PointerEventType.POINTEROUT, data, event);\n      };\n      /**\n       * Triggers a 'pointercancel' event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.cancel = function cancel(data, event) {\n        this.fireEvent(PointerEventType.POINTERCANCEL, data, event);\n      };\n      /**\n       * Triggers a combination of 'pointerout' and 'pointerleave' events.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.leaveOut = function leaveOut(data, event) {\n        this.out(data, event);\n\n        if (!this.contains_(data.target, data.relatedTarget)) {\n          this.leave(data, event);\n        }\n      };\n      /**\n       * Triggers a combination of 'pointerover' and 'pointerevents' events.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.enterOver = function enterOver(data, event) {\n        this.over(data, event);\n\n        if (!this.contains_(data.target, data.relatedTarget)) {\n          this.enter(data, event);\n        }\n      };\n      /**\n       * @private\n       * @param {Element} container The container element.\n       * @param {Element} contained The contained element.\n       * @return {boolean} Returns true if the container element\n       *   contains the other element.\n       */\n\n\n      PointerEventHandler.prototype.contains_ = function contains_(container, contained) {\n        if (!container || !contained) {\n          return false;\n        }\n\n        return container.contains(contained);\n      }; // EVENT CREATION AND TRACKING\n\n      /**\n       * Creates a new Event of type `inType`, based on the information in\n       * `data`.\n       *\n       * @param {string} inType A string representing the type of event to create.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       * @return {PointerEvent} A PointerEvent of type `inType`.\n       */\n\n\n      PointerEventHandler.prototype.makeEvent = function makeEvent(inType, data, event) {\n        return new PointerEvent(inType, event, data);\n      };\n      /**\n       * Make and dispatch an event in one call.\n       * @param {string} inType A string representing the type of event.\n       * @param {Object} data Pointer event data.\n       * @param {Event} event The event.\n       */\n\n\n      PointerEventHandler.prototype.fireEvent = function fireEvent(inType, data, event) {\n        var e = this.makeEvent(inType, data, event);\n        this.dispatchEvent(e);\n      };\n      /**\n       * Creates a pointer event from a native pointer event\n       * and dispatches this event.\n       * @param {Event} event A platform event with a target.\n       */\n\n\n      PointerEventHandler.prototype.fireNativeEvent = function fireNativeEvent(event) {\n        var e = this.makeEvent(event.type, event, event);\n        this.dispatchEvent(e);\n      };\n      /**\n       * Wrap a native mouse event into a pointer event.\n       * This proxy method is required for the legacy IE support.\n       * @param {string} eventType The pointer event type.\n       * @param {Event} event The event.\n       * @return {PointerEvent} The wrapped event.\n       */\n\n\n      PointerEventHandler.prototype.wrapMouseEvent = function wrapMouseEvent(eventType, event) {\n        var pointerEvent = this.makeEvent(eventType, prepareEvent(event, this), event);\n        return pointerEvent;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      PointerEventHandler.prototype.disposeInternal = function disposeInternal() {\n        this.unregister_();\n        EventTarget.prototype.disposeInternal.call(this);\n      };\n\n      return PointerEventHandler;\n    }(Target);\n    /**\n     * @module ol/MapBrowserEventHandler\n     */\n\n\n    var MapBrowserEventHandler =\n    /*@__PURE__*/\n    function (EventTarget) {\n      function MapBrowserEventHandler(map, moveTolerance) {\n        EventTarget.call(this);\n        /**\n         * This is the element that we will listen to the real events on.\n         * @type {import(\"./PluggableMap.js\").default}\n         * @private\n         */\n\n        this.map_ = map;\n        /**\n         * @type {any}\n         * @private\n         */\n\n        this.clickTimeoutId_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.dragging_ = false;\n        /**\n         * @type {!Array<import(\"./events.js\").EventsKey>}\n         * @private\n         */\n\n        this.dragListenerKeys_ = [];\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.moveTolerance_ = moveTolerance ? moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;\n        /**\n         * The most recent \"down\" type event (or null if none have occurred).\n         * Set on pointerdown.\n         * @type {import(\"./pointer/PointerEvent.js\").default}\n         * @private\n         */\n\n        this.down_ = null;\n        var element = this.map_.getViewport();\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.activePointers_ = 0;\n        /**\n         * @type {!Object<number, boolean>}\n         * @private\n         */\n\n        this.trackedTouches_ = {};\n        /**\n         * Event handler which generates pointer events for\n         * the viewport element.\n         *\n         * @type {PointerEventHandler}\n         * @private\n         */\n\n        this.pointerEventHandler_ = new PointerEventHandler(element);\n        /**\n         * Event handler which generates pointer events for\n         * the document (used when dragging).\n         *\n         * @type {PointerEventHandler}\n         * @private\n         */\n\n        this.documentPointerEventHandler_ = null;\n        /**\n         * @type {?import(\"./events.js\").EventsKey}\n         * @private\n         */\n\n        this.pointerdownListenerKey_ = listen(this.pointerEventHandler_, PointerEventType.POINTERDOWN, this.handlePointerDown_, this);\n        /**\n         * @type {?import(\"./events.js\").EventsKey}\n         * @private\n         */\n\n        this.relayedListenerKey_ = listen(this.pointerEventHandler_, PointerEventType.POINTERMOVE, this.relayEvent_, this);\n      }\n\n      if (EventTarget) MapBrowserEventHandler.__proto__ = EventTarget;\n      MapBrowserEventHandler.prototype = Object.create(EventTarget && EventTarget.prototype);\n      MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;\n      /**\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @private\n       */\n\n      MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_(pointerEvent) {\n        var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n\n        if (this.clickTimeoutId_ !== undefined) {\n          // double-click\n          clearTimeout(this.clickTimeoutId_);\n          this.clickTimeoutId_ = undefined;\n          newEvent = new MapBrowserPointerEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n          this.dispatchEvent(newEvent);\n        } else {\n          // click\n          this.clickTimeoutId_ = setTimeout(function () {\n            this.clickTimeoutId_ = undefined;\n            var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n            this.dispatchEvent(newEvent);\n          }.bind(this), 250);\n        }\n      };\n      /**\n       * Keeps track on how many pointers are currently active.\n       *\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @private\n       */\n\n\n      MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_(pointerEvent) {\n        var event = pointerEvent;\n\n        if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n          delete this.trackedTouches_[event.pointerId];\n        } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n          this.trackedTouches_[event.pointerId] = true;\n        }\n\n        this.activePointers_ = Object.keys(this.trackedTouches_).length;\n      };\n      /**\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @private\n       */\n\n\n      MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_(pointerEvent) {\n        this.updateActivePointers_(pointerEvent);\n        var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen\n        // contact. isMouseActionButton returns true in these cases (evt.button is set\n        // to 0).\n        // See http://www.w3.org/TR/pointerevents/#button-states\n        // We only fire click, singleclick, and doubleclick if nobody has called\n        // event.stopPropagation() or event.preventDefault().\n\n        if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n          this.emulateClick_(this.down_);\n        }\n\n        if (this.activePointers_ === 0) {\n          this.dragListenerKeys_.forEach(unlistenByKey);\n          this.dragListenerKeys_.length = 0;\n          this.dragging_ = false;\n          this.down_ = null;\n          this.documentPointerEventHandler_.dispose();\n          this.documentPointerEventHandler_ = null;\n        }\n      };\n      /**\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @return {boolean} If the left mouse button was pressed.\n       * @private\n       */\n\n\n      MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_(pointerEvent) {\n        return pointerEvent.button === 0;\n      };\n      /**\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @private\n       */\n\n\n      MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_(pointerEvent) {\n        this.updateActivePointers_(pointerEvent);\n        var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n        this.down_ = pointerEvent;\n\n        if (this.dragListenerKeys_.length === 0) {\n          /* Set up a pointer event handler on the `document`,\n           * which is required when the pointer is moved outside\n           * the viewport when dragging.\n           */\n          this.documentPointerEventHandler_ = new PointerEventHandler(document);\n          this.dragListenerKeys_.push(listen(this.documentPointerEventHandler_, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(this.documentPointerEventHandler_, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n          /* Note that the listener for `pointercancel is set up on\n           * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n           * the `pointerup` and `pointermove` listeners.\n           *\n           * The reason for this is the following: `TouchSource.vacuumTouches_()`\n           * issues `pointercancel` events, when there was no `touchend` for a\n           * `touchstart`. Now, let's say a first `touchstart` is registered on\n           * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n           * But `documentPointerEventHandler_` doesn't know about the first\n           * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n           * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n           * only registered there.\n           */\n          listen(this.pointerEventHandler_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n        }\n      };\n      /**\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @private\n       */\n\n\n      MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_(pointerEvent) {\n        // Between pointerdown and pointerup, pointermove events are triggered.\n        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n        // moved a significant distance.\n        if (this.isMoving_(pointerEvent)) {\n          this.dragging_ = true;\n          var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n          this.dispatchEvent(newEvent);\n        } // Some native android browser triggers mousemove events during small period\n        // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n        // https://code.google.com/p/android/issues/detail?id=19827\n        // ex: Galaxy Tab P3110 + Android 4.1.1\n\n\n        pointerEvent.preventDefault();\n      };\n      /**\n       * Wrap and relay a pointer event.  Note that this requires that the type\n       * string for the MapBrowserPointerEvent matches the PointerEvent type.\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @private\n       */\n\n\n      MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_(pointerEvent) {\n        var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n        this.dispatchEvent(new MapBrowserPointerEvent(pointerEvent.type, this.map_, pointerEvent, dragging));\n      };\n      /**\n       * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n       * event.\n       * @return {boolean} Is moving.\n       * @private\n       */\n\n\n      MapBrowserEventHandler.prototype.isMoving_ = function isMoving_(pointerEvent) {\n        return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal() {\n        if (this.relayedListenerKey_) {\n          unlistenByKey(this.relayedListenerKey_);\n          this.relayedListenerKey_ = null;\n        }\n\n        if (this.pointerdownListenerKey_) {\n          unlistenByKey(this.pointerdownListenerKey_);\n          this.pointerdownListenerKey_ = null;\n        }\n\n        this.dragListenerKeys_.forEach(unlistenByKey);\n        this.dragListenerKeys_.length = 0;\n\n        if (this.documentPointerEventHandler_) {\n          this.documentPointerEventHandler_.dispose();\n          this.documentPointerEventHandler_ = null;\n        }\n\n        if (this.pointerEventHandler_) {\n          this.pointerEventHandler_.dispose();\n          this.pointerEventHandler_ = null;\n        }\n\n        EventTarget.prototype.disposeInternal.call(this);\n      };\n\n      return MapBrowserEventHandler;\n    }(Target);\n    /**\n     * @module ol/MapEventType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var MapEventType = {\n      /**\n       * Triggered after a map frame is rendered.\n       * @event module:ol/MapEvent~MapEvent#postrender\n       * @api\n       */\n      POSTRENDER: 'postrender',\n\n      /**\n       * Triggered when the map starts moving.\n       * @event module:ol/MapEvent~MapEvent#movestart\n       * @api\n       */\n      MOVESTART: 'movestart',\n\n      /**\n       * Triggered after the map is moved.\n       * @event module:ol/MapEvent~MapEvent#moveend\n       * @api\n       */\n      MOVEEND: 'moveend'\n    };\n    /**\n     * @module ol/MapProperty\n     */\n\n    /**\n     * @enum {string}\n     */\n\n    var MapProperty = {\n      LAYERGROUP: 'layergroup',\n      SIZE: 'size',\n      TARGET: 'target',\n      VIEW: 'view'\n    };\n    /**\n     * @module ol/render/EventType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n    var RenderEventType = {\n      /**\n       * @event module:ol/render/Event~RenderEvent#postcompose\n       * @api\n       */\n      POSTCOMPOSE: 'postcompose',\n\n      /**\n       * @event module:ol/render/Event~RenderEvent#precompose\n       * @api\n       */\n      PRECOMPOSE: 'precompose',\n\n      /**\n       * @event module:ol/render/Event~RenderEvent#render\n       * @api\n       */\n      RENDER: 'render',\n\n      /**\n       * Triggered when rendering is complete, i.e. all sources and tiles have\n       * finished loading for the current viewport, and all tiles are faded in.\n       * @event module:ol/render/Event~RenderEvent#rendercomplete\n       * @api\n       */\n      RENDERCOMPLETE: 'rendercomplete'\n    };\n    /**\n     * @module ol/TileState\n     */\n\n    /**\n     * @enum {number}\n     */\n\n    var TileState = {\n      IDLE: 0,\n      LOADING: 1,\n      LOADED: 2,\n\n      /**\n       * Indicates that tile loading failed\n       * @type {number}\n       */\n      ERROR: 3,\n      EMPTY: 4,\n      ABORT: 5\n    };\n    /**\n     * @module ol/asserts\n     */\n\n    /**\n     * @param {*} assertion Assertion we expected to be truthy.\n     * @param {number} errorCode Error code.\n     */\n\n    function assert(assertion, errorCode) {\n      if (!assertion) {\n        throw new AssertionError(errorCode);\n      }\n    }\n    /**\n     * @module ol/structs/PriorityQueue\n     */\n\n    /**\n     * @type {number}\n     */\n\n\n    var DROP = Infinity;\n    /**\n     * @classdesc\n     * Priority queue.\n     *\n     * The implementation is inspired from the Closure Library's Heap class and\n     * Python's heapq module.\n     *\n     * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html\n     * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.\n     *\n     * @template T\n     */\n\n    var PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {\n      /**\n       * @type {function(T): number}\n       * @private\n       */\n      this.priorityFunction_ = priorityFunction;\n      /**\n       * @type {function(T): string}\n       * @private\n       */\n\n      this.keyFunction_ = keyFunction;\n      /**\n       * @type {Array<T>}\n       * @private\n       */\n\n      this.elements_ = [];\n      /**\n       * @type {Array<number>}\n       * @private\n       */\n\n      this.priorities_ = [];\n      /**\n       * @type {!Object<string, boolean>}\n       * @private\n       */\n\n      this.queuedElements_ = {};\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n\n\n    PriorityQueue.prototype.clear = function clear$1() {\n      this.elements_.length = 0;\n      this.priorities_.length = 0;\n      clear(this.queuedElements_);\n    };\n    /**\n     * Remove and return the highest-priority element. O(log N).\n     * @return {T} Element.\n     */\n\n\n    PriorityQueue.prototype.dequeue = function dequeue() {\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var element = elements[0];\n\n      if (elements.length == 1) {\n        elements.length = 0;\n        priorities.length = 0;\n      } else {\n        elements[0] = elements.pop();\n        priorities[0] = priorities.pop();\n        this.siftUp_(0);\n      }\n\n      var elementKey = this.keyFunction_(element);\n      delete this.queuedElements_[elementKey];\n      return element;\n    };\n    /**\n     * Enqueue an element. O(log N).\n     * @param {T} element Element.\n     * @return {boolean} The element was added to the queue.\n     */\n\n\n    PriorityQueue.prototype.enqueue = function enqueue(element) {\n      assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue\n\n      var priority = this.priorityFunction_(element);\n\n      if (priority != DROP) {\n        this.elements_.push(element);\n        this.priorities_.push(priority);\n        this.queuedElements_[this.keyFunction_(element)] = true;\n        this.siftDown_(0, this.elements_.length - 1);\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     * @return {number} Count.\n     */\n\n\n    PriorityQueue.prototype.getCount = function getCount() {\n      return this.elements_.length;\n    };\n    /**\n     * Gets the index of the left child of the node at the given index.\n     * @param {number} index The index of the node to get the left child for.\n     * @return {number} The index of the left child.\n     * @private\n     */\n\n\n    PriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_(index) {\n      return index * 2 + 1;\n    };\n    /**\n     * Gets the index of the right child of the node at the given index.\n     * @param {number} index The index of the node to get the right child for.\n     * @return {number} The index of the right child.\n     * @private\n     */\n\n\n    PriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_(index) {\n      return index * 2 + 2;\n    };\n    /**\n     * Gets the index of the parent of the node at the given index.\n     * @param {number} index The index of the node to get the parent for.\n     * @return {number} The index of the parent.\n     * @private\n     */\n\n\n    PriorityQueue.prototype.getParentIndex_ = function getParentIndex_(index) {\n      return index - 1 >> 1;\n    };\n    /**\n     * Make this a heap. O(N).\n     * @private\n     */\n\n\n    PriorityQueue.prototype.heapify_ = function heapify_() {\n      var i;\n\n      for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n        this.siftUp_(i);\n      }\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n\n\n    PriorityQueue.prototype.isEmpty = function isEmpty$$1() {\n      return this.elements_.length === 0;\n    };\n    /**\n     * @param {string} key Key.\n     * @return {boolean} Is key queued.\n     */\n\n\n    PriorityQueue.prototype.isKeyQueued = function isKeyQueued(key) {\n      return key in this.queuedElements_;\n    };\n    /**\n     * @param {T} element Element.\n     * @return {boolean} Is queued.\n     */\n\n\n    PriorityQueue.prototype.isQueued = function isQueued(element) {\n      return this.isKeyQueued(this.keyFunction_(element));\n    };\n    /**\n     * @param {number} index The index of the node to move down.\n     * @private\n     */\n\n\n    PriorityQueue.prototype.siftUp_ = function siftUp_(index) {\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var count = elements.length;\n      var element = elements[index];\n      var priority = priorities[index];\n      var startIndex = index;\n\n      while (index < count >> 1) {\n        var lIndex = this.getLeftChildIndex_(index);\n        var rIndex = this.getRightChildIndex_(index);\n        var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;\n        elements[index] = elements[smallerChildIndex];\n        priorities[index] = priorities[smallerChildIndex];\n        index = smallerChildIndex;\n      }\n\n      elements[index] = element;\n      priorities[index] = priority;\n      this.siftDown_(startIndex, index);\n    };\n    /**\n     * @param {number} startIndex The index of the root.\n     * @param {number} index The index of the node to move up.\n     * @private\n     */\n\n\n    PriorityQueue.prototype.siftDown_ = function siftDown_(startIndex, index) {\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var element = elements[index];\n      var priority = priorities[index];\n\n      while (index > startIndex) {\n        var parentIndex = this.getParentIndex_(index);\n\n        if (priorities[parentIndex] > priority) {\n          elements[index] = elements[parentIndex];\n          priorities[index] = priorities[parentIndex];\n          index = parentIndex;\n        } else {\n          break;\n        }\n      }\n\n      elements[index] = element;\n      priorities[index] = priority;\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n\n\n    PriorityQueue.prototype.reprioritize = function reprioritize() {\n      var priorityFunction = this.priorityFunction_;\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var index = 0;\n      var n = elements.length;\n      var element, i, priority;\n\n      for (i = 0; i < n; ++i) {\n        element = elements[i];\n        priority = priorityFunction(element);\n\n        if (priority == DROP) {\n          delete this.queuedElements_[this.keyFunction_(element)];\n        } else {\n          priorities[index] = priority;\n          elements[index++] = element;\n        }\n      }\n\n      elements.length = index;\n      priorities.length = index;\n      this.heapify_();\n    };\n    /**\n     * @module ol/TileQueue\n     */\n\n    /**\n     * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n     */\n\n\n    var TileQueue =\n    /*@__PURE__*/\n    function (PriorityQueue$$1) {\n      function TileQueue(tilePriorityFunction, tileChangeCallback) {\n        PriorityQueue$$1.call(\n        /**\n         * @param {Array} element Element.\n         * @return {number} Priority.\n         */\n        this, function (element) {\n          return tilePriorityFunction.apply(null, element);\n        },\n        /**\n         * @param {Array} element Element.\n         * @return {string} Key.\n         */\n        function (element) {\n          return (\n            /** @type {import(\"./Tile.js\").default} */\n            element[0].getKey()\n          );\n        });\n        /**\n         * @private\n         * @type {function(): ?}\n         */\n\n        this.tileChangeCallback_ = tileChangeCallback;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.tilesLoading_ = 0;\n        /**\n         * @private\n         * @type {!Object<string,boolean>}\n         */\n\n        this.tilesLoadingKeys_ = {};\n      }\n\n      if (PriorityQueue$$1) TileQueue.__proto__ = PriorityQueue$$1;\n      TileQueue.prototype = Object.create(PriorityQueue$$1 && PriorityQueue$$1.prototype);\n      TileQueue.prototype.constructor = TileQueue;\n      /**\n       * @inheritDoc\n       */\n\n      TileQueue.prototype.enqueue = function enqueue(element) {\n        var added = PriorityQueue$$1.prototype.enqueue.call(this, element);\n\n        if (added) {\n          var tile = element[0];\n          listen(tile, EventType.CHANGE, this.handleTileChange, this);\n        }\n\n        return added;\n      };\n      /**\n       * @return {number} Number of tiles loading.\n       */\n\n\n      TileQueue.prototype.getTilesLoading = function getTilesLoading() {\n        return this.tilesLoading_;\n      };\n      /**\n       * @param {import(\"./events/Event.js\").default} event Event.\n       * @protected\n       */\n\n\n      TileQueue.prototype.handleTileChange = function handleTileChange(event) {\n        var tile =\n        /** @type {import(\"./Tile.js\").default} */\n        event.target;\n        var state = tile.getState();\n\n        if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY || state === TileState.ABORT) {\n          unlisten(tile, EventType.CHANGE, this.handleTileChange, this);\n          var tileKey = tile.getKey();\n\n          if (tileKey in this.tilesLoadingKeys_) {\n            delete this.tilesLoadingKeys_[tileKey];\n            --this.tilesLoading_;\n          }\n\n          this.tileChangeCallback_();\n        }\n      };\n      /**\n       * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n       * @param {number} maxNewLoads Maximum number of new tiles to load.\n       */\n\n\n      TileQueue.prototype.loadMoreTiles = function loadMoreTiles(maxTotalLoading, maxNewLoads) {\n        var newLoads = 0;\n        var abortedTiles = false;\n        var state, tile, tileKey;\n\n        while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n          tile =\n          /** @type {import(\"./Tile.js\").default} */\n          this.dequeue()[0];\n          tileKey = tile.getKey();\n          state = tile.getState();\n\n          if (state === TileState.ABORT) {\n            abortedTiles = true;\n          } else if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n            this.tilesLoadingKeys_[tileKey] = true;\n            ++this.tilesLoading_;\n            ++newLoads;\n            tile.load();\n          }\n        }\n\n        if (newLoads === 0 && abortedTiles) {\n          // Do not stop the render loop when all wanted tiles were aborted due to\n          // a small, saturated tile cache.\n          this.tileChangeCallback_();\n        }\n      };\n\n      return TileQueue;\n    }(PriorityQueue);\n    /**\n     * @module ol/tilegrid/common\n     */\n\n    /**\n     * Default maximum zoom for default tile grids.\n     * @type {number}\n     */\n\n\n    var DEFAULT_MAX_ZOOM = 42;\n    /**\n     * Default tile size.\n     * @type {number}\n     */\n\n    var DEFAULT_TILE_SIZE = 256;\n    /**\n     * @module ol/math\n     */\n\n    /**\n     * Takes a number and clamps it to within the provided bounds.\n     * @param {number} value The input number.\n     * @param {number} min The minimum value to return.\n     * @param {number} max The maximum value to return.\n     * @return {number} The input number if it is within bounds, or the nearest\n     *     number within the bounds.\n     */\n\n    function clamp(value, min, max) {\n      return Math.min(Math.max(value, min), max);\n    }\n    /**\n     * Return the hyperbolic cosine of a given number. The method will use the\n     * native `Math.cosh` function if it is available, otherwise the hyperbolic\n     * cosine will be calculated via the reference implementation of the Mozilla\n     * developer network.\n     *\n     * @param {number} x X.\n     * @return {number} Hyperbolic cosine of x.\n     */\n\n\n    var cosh = function () {\n      // Wrapped in a iife, to save the overhead of checking for the native\n      // implementation on every invocation.\n      var cosh;\n\n      if ('cosh' in Math) {\n        // The environment supports the native Math.cosh function, use it\n        cosh = Math.cosh;\n      } else {\n        //  else, use the reference implementation of MDN:\n        cosh = function cosh(x) {\n          var y =\n          /** @type {Math} */\n          Math.exp(x);\n          return (y + 1 / y) / 2;\n        };\n      }\n\n      return cosh;\n    }();\n    /**\n     * @param {number} x X.\n     * @return {number} The smallest power of two greater than or equal to x.\n     */\n\n\n    function roundUpToPowerOfTwo(x) {\n      assert(0 < x, 29); // `x` must be greater than `0`\n\n      return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));\n    }\n    /**\n     * Returns the square of the closest distance between the point (x, y) and the\n     * line segment (x1, y1) to (x2, y2).\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} x1 X1.\n     * @param {number} y1 Y1.\n     * @param {number} x2 X2.\n     * @param {number} y2 Y2.\n     * @return {number} Squared distance.\n     */\n\n\n    function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n\n      if (dx !== 0 || dy !== 0) {\n        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n          x1 = x2;\n          y1 = y2;\n        } else if (t > 0) {\n          x1 += dx * t;\n          y1 += dy * t;\n        }\n      }\n\n      return squaredDistance(x, y, x1, y1);\n    }\n    /**\n     * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n     * @param {number} x1 X1.\n     * @param {number} y1 Y1.\n     * @param {number} x2 X2.\n     * @param {number} y2 Y2.\n     * @return {number} Squared distance.\n     */\n\n\n    function squaredDistance(x1, y1, x2, y2) {\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      return dx * dx + dy * dy;\n    }\n    /**\n     * Solves system of linear equations using Gaussian elimination method.\n     *\n     * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n     *                                     in row-major order.\n     * @return {Array<number>} The resulting vector.\n     */\n\n\n    function solveLinearSystem(mat) {\n      var n = mat.length;\n\n      for (var i = 0; i < n; i++) {\n        // Find max in the i-th column (ignoring i - 1 first rows)\n        var maxRow = i;\n        var maxEl = Math.abs(mat[i][i]);\n\n        for (var r = i + 1; r < n; r++) {\n          var absValue = Math.abs(mat[r][i]);\n\n          if (absValue > maxEl) {\n            maxEl = absValue;\n            maxRow = r;\n          }\n        }\n\n        if (maxEl === 0) {\n          return null; // matrix is singular\n        } // Swap max row with i-th (current) row\n\n\n        var tmp = mat[maxRow];\n        mat[maxRow] = mat[i];\n        mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n\n        for (var j = i + 1; j < n; j++) {\n          var coef = -mat[j][i] / mat[i][i];\n\n          for (var k = i; k < n + 1; k++) {\n            if (i == k) {\n              mat[j][k] = 0;\n            } else {\n              mat[j][k] += coef * mat[i][k];\n            }\n          }\n        }\n      } // Solve Ax=b for upper triangular matrix A (mat)\n\n\n      var x = new Array(n);\n\n      for (var l = n - 1; l >= 0; l--) {\n        x[l] = mat[l][n] / mat[l][l];\n\n        for (var m = l - 1; m >= 0; m--) {\n          mat[m][n] -= mat[m][l] * x[l];\n        }\n      }\n\n      return x;\n    }\n    /**\n     * Converts degrees to radians.\n     *\n     * @param {number} angleInDegrees Angle in degrees.\n     * @return {number} Angle in radians.\n     */\n\n\n    function toRadians(angleInDegrees) {\n      return angleInDegrees * Math.PI / 180;\n    }\n    /**\n     * Returns the modulo of a / b, depending on the sign of b.\n     *\n     * @param {number} a Dividend.\n     * @param {number} b Divisor.\n     * @return {number} Modulo.\n     */\n\n\n    function modulo(a, b) {\n      var r = a % b;\n      return r * b < 0 ? r + b : r;\n    }\n    /**\n     * Calculates the linearly interpolated value of x between a and b.\n     *\n     * @param {number} a Number\n     * @param {number} b Number\n     * @param {number} x Value to be interpolated.\n     * @return {number} Interpolated value.\n     */\n\n\n    function lerp(a, b, x) {\n      return a + x * (b - a);\n    }\n    /**\n     * @module ol/centerconstraint\n     */\n\n    /**\n     * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined)): (import(\"./coordinate.js\").Coordinate|undefined)} Type\n     */\n\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @return {Type} The constraint.\n     */\n\n\n    function createExtent(extent) {\n      return (\n        /**\n         * @param {import(\"./coordinate.js\").Coordinate=} center Center.\n         * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n         */\n        function (center) {\n          if (center) {\n            return [clamp(center[0], extent[0], extent[2]), clamp(center[1], extent[1], extent[3])];\n          } else {\n            return undefined;\n          }\n        }\n      );\n    }\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate=} center Center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n     */\n\n\n    function none(center) {\n      return center;\n    }\n    /**\n     * @module ol/resolutionconstraint\n     */\n\n    /**\n     * @typedef {function((number|undefined), number, number): (number|undefined)} Type\n     */\n\n    /**\n     * @param {Array<number>} resolutions Resolutions.\n     * @return {Type} Zoom function.\n     */\n\n\n    function createSnapToResolutions(resolutions) {\n      return (\n        /**\n         * @param {number|undefined} resolution Resolution.\n         * @param {number} delta Delta.\n         * @param {number} direction Direction.\n         * @return {number|undefined} Resolution.\n         */\n        function (resolution, delta, direction) {\n          if (resolution !== undefined) {\n            var z = linearFindNearest(resolutions, resolution, direction);\n            z = clamp(z + delta, 0, resolutions.length - 1);\n            var index = Math.floor(z);\n\n            if (z != index && index < resolutions.length - 1) {\n              var power = resolutions[index] / resolutions[index + 1];\n              return resolutions[index] / Math.pow(power, z - index);\n            } else {\n              return resolutions[index];\n            }\n          } else {\n            return undefined;\n          }\n        }\n      );\n    }\n    /**\n     * @param {number} power Power.\n     * @param {number} maxResolution Maximum resolution.\n     * @param {number=} opt_maxLevel Maximum level.\n     * @return {Type} Zoom function.\n     */\n\n\n    function createSnapToPower(power, maxResolution, opt_maxLevel) {\n      return (\n        /**\n         * @param {number|undefined} resolution Resolution.\n         * @param {number} delta Delta.\n         * @param {number} direction Direction.\n         * @return {number|undefined} Resolution.\n         */\n        function (resolution, delta, direction) {\n          if (resolution !== undefined) {\n            var offset = -direction / 2 + 0.5;\n            var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);\n            var newLevel = Math.max(oldLevel + delta, 0);\n\n            if (opt_maxLevel !== undefined) {\n              newLevel = Math.min(newLevel, opt_maxLevel);\n            }\n\n            return maxResolution / Math.pow(power, newLevel);\n          } else {\n            return undefined;\n          }\n        }\n      );\n    }\n    /**\n     * @module ol/rotationconstraint\n     */\n\n    /**\n     * @typedef {function((number|undefined), number): (number|undefined)} Type\n     */\n\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {number} delta Delta.\n     * @return {number|undefined} Rotation.\n     */\n\n\n    function disable(rotation, delta) {\n      if (rotation !== undefined) {\n        return 0;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {number} delta Delta.\n     * @return {number|undefined} Rotation.\n     */\n\n\n    function none$1(rotation, delta) {\n      if (rotation !== undefined) {\n        return rotation + delta;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * @param {number} n N.\n     * @return {Type} Rotation constraint.\n     */\n\n\n    function createSnapToN(n) {\n      var theta = 2 * Math.PI / n;\n      return (\n        /**\n         * @param {number|undefined} rotation Rotation.\n         * @param {number} delta Delta.\n         * @return {number|undefined} Rotation.\n         */\n        function (rotation, delta) {\n          if (rotation !== undefined) {\n            rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;\n            return rotation;\n          } else {\n            return undefined;\n          }\n        }\n      );\n    }\n    /**\n     * @param {number=} opt_tolerance Tolerance.\n     * @return {Type} Rotation constraint.\n     */\n\n\n    function createSnapToZero(opt_tolerance) {\n      var tolerance = opt_tolerance || toRadians(5);\n      return (\n        /**\n         * @param {number|undefined} rotation Rotation.\n         * @param {number} delta Delta.\n         * @return {number|undefined} Rotation.\n         */\n        function (rotation, delta) {\n          if (rotation !== undefined) {\n            if (Math.abs(rotation + delta) <= tolerance) {\n              return 0;\n            } else {\n              return rotation + delta;\n            }\n          } else {\n            return undefined;\n          }\n        }\n      );\n    }\n    /**\n     * @module ol/ViewHint\n     */\n\n    /**\n     * @enum {number}\n     */\n\n\n    var ViewHint = {\n      ANIMATING: 0,\n      INTERACTING: 1\n    };\n    /**\n     * @module ol/ViewProperty\n     */\n\n    /**\n     * @enum {string}\n     */\n\n    var ViewProperty = {\n      CENTER: 'center',\n      RESOLUTION: 'resolution',\n      ROTATION: 'rotation'\n    };\n    /**\n     * @module ol/string\n     */\n\n    /**\n     * @module ol/coordinate\n     */\n\n    /**\n     * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\n     * @typedef {Array<number>} Coordinate\n     * @api\n     */\n\n    /**\n     * A function that takes a {@link module:ol/coordinate~Coordinate} and\n     * transforms it into a `{string}`.\n     *\n     * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n     * @api\n     */\n\n    /**\n     * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n     * by the function.\n     *\n     * Example:\n     *\n     *     import {add} from 'ol/coordinate';\n     *\n     *     var coord = [7.85, 47.983333];\n     *     add(coord, [-2, 4]);\n     *     // coord is now [5.85, 51.983333]\n     *\n     * @param {Coordinate} coordinate Coordinate.\n     * @param {Coordinate} delta Delta.\n     * @return {Coordinate} The input coordinate adjusted by\n     * the given delta.\n     * @api\n     */\n\n    function add(coordinate, delta) {\n      coordinate[0] += delta[0];\n      coordinate[1] += delta[1];\n      return coordinate;\n    }\n    /**\n     * Calculates the point closest to the passed coordinate on the passed circle.\n     *\n     * @param {Coordinate} coordinate The coordinate.\n     * @param {import(\"./geom/Circle.js\").default} circle The circle.\n     * @return {Coordinate} Closest point on the circumference.\n     */\n\n\n    function closestOnCircle(coordinate, circle) {\n      var r = circle.getRadius();\n      var center = circle.getCenter();\n      var x0 = center[0];\n      var y0 = center[1];\n      var x1 = coordinate[0];\n      var y1 = coordinate[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n\n      if (dx === 0 && dy === 0) {\n        dx = 1;\n      }\n\n      var d = Math.sqrt(dx * dx + dy * dy);\n      var x = x0 + r * dx / d;\n      var y = y0 + r * dy / d;\n      return [x, y];\n    }\n    /**\n     * Calculates the point closest to the passed coordinate on the passed segment.\n     * This is the foot of the perpendicular of the coordinate to the segment when\n     * the foot is on the segment, or the closest segment coordinate when the foot\n     * is outside the segment.\n     *\n     * @param {Coordinate} coordinate The coordinate.\n     * @param {Array<Coordinate>} segment The two coordinates\n     * of the segment.\n     * @return {Coordinate} The foot of the perpendicular of\n     * the coordinate to the segment.\n     */\n\n\n    function closestOnSegment(coordinate, segment) {\n      var x0 = coordinate[0];\n      var y0 = coordinate[1];\n      var start = segment[0];\n      var end = segment[1];\n      var x1 = start[0];\n      var y1 = start[1];\n      var x2 = end[0];\n      var y2 = end[1];\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n      var x, y;\n\n      if (along <= 0) {\n        x = x1;\n        y = y1;\n      } else if (along >= 1) {\n        x = x2;\n        y = y2;\n      } else {\n        x = x1 + along * dx;\n        y = y1 + along * dy;\n      }\n\n      return [x, y];\n    }\n    /**\n     * @param {Coordinate} coordinate1 First coordinate.\n     * @param {Coordinate} coordinate2 Second coordinate.\n     * @return {boolean} The two coordinates are equal.\n     */\n\n\n    function equals$1(coordinate1, coordinate2) {\n      var equals = true;\n\n      for (var i = coordinate1.length - 1; i >= 0; --i) {\n        if (coordinate1[i] != coordinate2[i]) {\n          equals = false;\n          break;\n        }\n      }\n\n      return equals;\n    }\n    /**\n     * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n     * returned by the function.\n     *\n     * Example:\n     *\n     *     import {rotate} from 'ol/coordinate';\n     *\n     *     var coord = [7.85, 47.983333];\n     *     var rotateRadians = Math.PI / 2; // 90 degrees\n     *     rotate(coord, rotateRadians);\n     *     // coord is now [-47.983333, 7.85]\n     *\n     * @param {Coordinate} coordinate Coordinate.\n     * @param {number} angle Angle in radian.\n     * @return {Coordinate} Coordinate.\n     * @api\n     */\n\n\n    function rotate(coordinate, angle) {\n      var cosAngle = Math.cos(angle);\n      var sinAngle = Math.sin(angle);\n      var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n      var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n      coordinate[0] = x;\n      coordinate[1] = y;\n      return coordinate;\n    }\n    /**\n     * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n     * by the function.\n     *\n     * Example:\n     *\n     *     import {scale as scaleCoordinate} from 'ol/coordinate';\n     *\n     *     var coord = [7.85, 47.983333];\n     *     var scale = 1.2;\n     *     scaleCoordinate(coord, scale);\n     *     // coord is now [9.42, 57.5799996]\n     *\n     * @param {Coordinate} coordinate Coordinate.\n     * @param {number} scale Scale factor.\n     * @return {Coordinate} Coordinate.\n     */\n\n\n    function scale(coordinate, scale) {\n      coordinate[0] *= scale;\n      coordinate[1] *= scale;\n      return coordinate;\n    }\n    /**\n     * @param {Coordinate} coord1 First coordinate.\n     * @param {Coordinate} coord2 Second coordinate.\n     * @return {number} Squared distance between coord1 and coord2.\n     */\n\n\n    function squaredDistance$1(coord1, coord2) {\n      var dx = coord1[0] - coord2[0];\n      var dy = coord1[1] - coord2[1];\n      return dx * dx + dy * dy;\n    }\n    /**\n     * @param {Coordinate} coord1 First coordinate.\n     * @param {Coordinate} coord2 Second coordinate.\n     * @return {number} Distance between coord1 and coord2.\n     */\n\n\n    function distance(coord1, coord2) {\n      return Math.sqrt(squaredDistance$1(coord1, coord2));\n    }\n    /**\n     * Calculate the squared distance from a coordinate to a line segment.\n     *\n     * @param {Coordinate} coordinate Coordinate of the point.\n     * @param {Array<Coordinate>} segment Line segment (2\n     * coordinates).\n     * @return {number} Squared distance from the point to the line segment.\n     */\n\n\n    function squaredDistanceToSegment(coordinate, segment) {\n      return squaredDistance$1(coordinate, closestOnSegment(coordinate, segment));\n    }\n    /**\n     * @module ol/easing\n     */\n\n    /**\n     * Start slow and speed up.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     * @api\n     */\n\n\n    function easeIn(t) {\n      return Math.pow(t, 3);\n    }\n    /**\n     * Start fast and slow down.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     * @api\n     */\n\n\n    function easeOut(t) {\n      return 1 - easeIn(1 - t);\n    }\n    /**\n     * Start slow, speed up, and then slow down again.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     * @api\n     */\n\n\n    function inAndOut(t) {\n      return 3 * t * t - 2 * t * t * t;\n    }\n    /**\n     * Maintain a constant speed over time.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     * @api\n     */\n\n\n    function linear(t) {\n      return t;\n    }\n    /**\n     * @module ol/extent/Corner\n     */\n\n    /**\n     * Extent corner.\n     * @enum {string}\n     */\n\n\n    var Corner = {\n      BOTTOM_LEFT: 'bottom-left',\n      BOTTOM_RIGHT: 'bottom-right',\n      TOP_LEFT: 'top-left',\n      TOP_RIGHT: 'top-right'\n    };\n    /**\n     * @module ol/extent/Relationship\n     */\n\n    /**\n     * Relationship to an extent.\n     * @enum {number}\n     */\n\n    var Relationship = {\n      UNKNOWN: 0,\n      INTERSECTING: 1,\n      ABOVE: 2,\n      RIGHT: 4,\n      BELOW: 8,\n      LEFT: 16\n    };\n    /**\n     * @module ol/extent\n     */\n\n    /**\n     * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n     * @typedef {Array<number>} Extent\n     * @api\n     */\n\n    /**\n     * Build an extent that includes all given coordinates.\n     *\n     * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @return {Extent} Bounding extent.\n     * @api\n     */\n\n    function boundingExtent(coordinates) {\n      var extent = createEmpty();\n\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n      }\n\n      return extent;\n    }\n    /**\n     * Return extent increased by the provided value.\n     * @param {Extent} extent Extent.\n     * @param {number} value The amount by which the extent should be buffered.\n     * @param {Extent=} opt_extent Extent.\n     * @return {Extent} Extent.\n     * @api\n     */\n\n\n    function buffer(extent, value, opt_extent) {\n      if (opt_extent) {\n        opt_extent[0] = extent[0] - value;\n        opt_extent[1] = extent[1] - value;\n        opt_extent[2] = extent[2] + value;\n        opt_extent[3] = extent[3] + value;\n        return opt_extent;\n      } else {\n        return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];\n      }\n    }\n    /**\n     * Creates a clone of an extent.\n     *\n     * @param {Extent} extent Extent to clone.\n     * @param {Extent=} opt_extent Extent.\n     * @return {Extent} The clone.\n     */\n\n\n    function clone(extent, opt_extent) {\n      if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n      } else {\n        return extent.slice();\n      }\n    }\n    /**\n     * @param {Extent} extent Extent.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {number} Closest squared distance.\n     */\n\n\n    function closestSquaredDistanceXY(extent, x, y) {\n      var dx, dy;\n\n      if (x < extent[0]) {\n        dx = extent[0] - x;\n      } else if (extent[2] < x) {\n        dx = x - extent[2];\n      } else {\n        dx = 0;\n      }\n\n      if (y < extent[1]) {\n        dy = extent[1] - y;\n      } else if (extent[3] < y) {\n        dy = y - extent[3];\n      } else {\n        dy = 0;\n      }\n\n      return dx * dx + dy * dy;\n    }\n    /**\n     * Check if the passed coordinate is contained or on the edge of the extent.\n     *\n     * @param {Extent} extent Extent.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} The coordinate is contained in the extent.\n     * @api\n     */\n\n\n    function containsCoordinate(extent, coordinate) {\n      return containsXY(extent, coordinate[0], coordinate[1]);\n    }\n    /**\n     * Check if one extent contains another.\n     *\n     * An extent is deemed contained if it lies completely within the other extent,\n     * including if they share one or more edges.\n     *\n     * @param {Extent} extent1 Extent 1.\n     * @param {Extent} extent2 Extent 2.\n     * @return {boolean} The second extent is contained by or on the edge of the\n     *     first.\n     * @api\n     */\n\n\n    function containsExtent(extent1, extent2) {\n      return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n    }\n    /**\n     * Check if the passed coordinate is contained or on the edge of the extent.\n     *\n     * @param {Extent} extent Extent.\n     * @param {number} x X coordinate.\n     * @param {number} y Y coordinate.\n     * @return {boolean} The x, y values are contained in the extent.\n     * @api\n     */\n\n\n    function containsXY(extent, x, y) {\n      return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n    }\n    /**\n     * Get the relationship between a coordinate and extent.\n     * @param {Extent} extent The extent.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n     * @return {Relationship} The relationship (bitwise compare with\n     *     import(\"./extent/Relationship.js\").Relationship).\n     */\n\n\n    function coordinateRelationship(extent, coordinate) {\n      var minX = extent[0];\n      var minY = extent[1];\n      var maxX = extent[2];\n      var maxY = extent[3];\n      var x = coordinate[0];\n      var y = coordinate[1];\n      var relationship = Relationship.UNKNOWN;\n\n      if (x < minX) {\n        relationship = relationship | Relationship.LEFT;\n      } else if (x > maxX) {\n        relationship = relationship | Relationship.RIGHT;\n      }\n\n      if (y < minY) {\n        relationship = relationship | Relationship.BELOW;\n      } else if (y > maxY) {\n        relationship = relationship | Relationship.ABOVE;\n      }\n\n      if (relationship === Relationship.UNKNOWN) {\n        relationship = Relationship.INTERSECTING;\n      }\n\n      return relationship;\n    }\n    /**\n     * Create an empty extent.\n     * @return {Extent} Empty extent.\n     * @api\n     */\n\n\n    function createEmpty() {\n      return [Infinity, Infinity, -Infinity, -Infinity];\n    }\n    /**\n     * Create a new extent or update the provided extent.\n     * @param {number} minX Minimum X.\n     * @param {number} minY Minimum Y.\n     * @param {number} maxX Maximum X.\n     * @param {number} maxY Maximum Y.\n     * @param {Extent=} opt_extent Destination extent.\n     * @return {Extent} Extent.\n     */\n\n\n    function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n      if (opt_extent) {\n        opt_extent[0] = minX;\n        opt_extent[1] = minY;\n        opt_extent[2] = maxX;\n        opt_extent[3] = maxY;\n        return opt_extent;\n      } else {\n        return [minX, minY, maxX, maxY];\n      }\n    }\n    /**\n     * Create a new empty extent or make the provided one empty.\n     * @param {Extent=} opt_extent Extent.\n     * @return {Extent} Extent.\n     */\n\n\n    function createOrUpdateEmpty(opt_extent) {\n      return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n    }\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {Extent=} opt_extent Extent.\n     * @return {Extent} Extent.\n     */\n\n\n    function createOrUpdateFromCoordinate(coordinate, opt_extent) {\n      var x = coordinate[0];\n      var y = coordinate[1];\n      return createOrUpdate(x, y, x, y, opt_extent);\n    }\n    /**\n     * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {Extent=} opt_extent Extent.\n     * @return {Extent} Extent.\n     */\n\n\n    function createOrUpdateFromCoordinates(coordinates, opt_extent) {\n      var extent = createOrUpdateEmpty(opt_extent);\n      return extendCoordinates(extent, coordinates);\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {Extent=} opt_extent Extent.\n     * @return {Extent} Extent.\n     */\n\n\n    function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\n      var extent = createOrUpdateEmpty(opt_extent);\n      return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n    }\n    /**\n     * Determine if two extents are equivalent.\n     * @param {Extent} extent1 Extent 1.\n     * @param {Extent} extent2 Extent 2.\n     * @return {boolean} The two extents are equivalent.\n     * @api\n     */\n\n\n    function equals$2(extent1, extent2) {\n      return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];\n    }\n    /**\n     * Modify an extent to include another extent.\n     * @param {Extent} extent1 The extent to be modified.\n     * @param {Extent} extent2 The extent that will be included in the first.\n     * @return {Extent} A reference to the first (extended) extent.\n     * @api\n     */\n\n\n    function extend$1(extent1, extent2) {\n      if (extent2[0] < extent1[0]) {\n        extent1[0] = extent2[0];\n      }\n\n      if (extent2[2] > extent1[2]) {\n        extent1[2] = extent2[2];\n      }\n\n      if (extent2[1] < extent1[1]) {\n        extent1[1] = extent2[1];\n      }\n\n      if (extent2[3] > extent1[3]) {\n        extent1[3] = extent2[3];\n      }\n\n      return extent1;\n    }\n    /**\n     * @param {Extent} extent Extent.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n     */\n\n\n    function extendCoordinate(extent, coordinate) {\n      if (coordinate[0] < extent[0]) {\n        extent[0] = coordinate[0];\n      }\n\n      if (coordinate[0] > extent[2]) {\n        extent[2] = coordinate[0];\n      }\n\n      if (coordinate[1] < extent[1]) {\n        extent[1] = coordinate[1];\n      }\n\n      if (coordinate[1] > extent[3]) {\n        extent[3] = coordinate[1];\n      }\n    }\n    /**\n     * @param {Extent} extent Extent.\n     * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @return {Extent} Extent.\n     */\n\n\n    function extendCoordinates(extent, coordinates) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n      }\n\n      return extent;\n    }\n    /**\n     * @param {Extent} extent Extent.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @return {Extent} Extent.\n     */\n\n\n    function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n      for (; offset < end; offset += stride) {\n        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n      }\n\n      return extent;\n    }\n    /**\n     * @param {Extent} extent Extent.\n     * @param {number} x X.\n     * @param {number} y Y.\n     */\n\n\n    function extendXY(extent, x, y) {\n      extent[0] = Math.min(extent[0], x);\n      extent[1] = Math.min(extent[1], y);\n      extent[2] = Math.max(extent[2], x);\n      extent[3] = Math.max(extent[3], y);\n    }\n    /**\n     * This function calls `callback` for each corner of the extent. If the\n     * callback returns a truthy value the function returns that value\n     * immediately. Otherwise the function returns `false`.\n     * @param {Extent} extent Extent.\n     * @param {function(this:T, import(\"./coordinate.js\").Coordinate): S} callback Callback.\n     * @param {T=} opt_this Value to use as `this` when executing `callback`.\n     * @return {S|boolean} Value.\n     * @template S, T\n     */\n\n\n    function forEachCorner(extent, callback, opt_this) {\n      var val;\n      val = callback.call(opt_this, getBottomLeft(extent));\n\n      if (val) {\n        return val;\n      }\n\n      val = callback.call(opt_this, getBottomRight(extent));\n\n      if (val) {\n        return val;\n      }\n\n      val = callback.call(opt_this, getTopRight(extent));\n\n      if (val) {\n        return val;\n      }\n\n      val = callback.call(opt_this, getTopLeft(extent));\n\n      if (val) {\n        return val;\n      }\n\n      return false;\n    }\n    /**\n     * Get the size of an extent.\n     * @param {Extent} extent Extent.\n     * @return {number} Area.\n     * @api\n     */\n\n\n    function getArea(extent) {\n      var area = 0;\n\n      if (!isEmpty$1(extent)) {\n        area = getWidth(extent) * getHeight(extent);\n      }\n\n      return area;\n    }\n    /**\n     * Get the bottom left coordinate of an extent.\n     * @param {Extent} extent Extent.\n     * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n     * @api\n     */\n\n\n    function getBottomLeft(extent) {\n      return [extent[0], extent[1]];\n    }\n    /**\n     * Get the bottom right coordinate of an extent.\n     * @param {Extent} extent Extent.\n     * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n     * @api\n     */\n\n\n    function getBottomRight(extent) {\n      return [extent[2], extent[1]];\n    }\n    /**\n     * Get the center coordinate of an extent.\n     * @param {Extent} extent Extent.\n     * @return {import(\"./coordinate.js\").Coordinate} Center.\n     * @api\n     */\n\n\n    function getCenter(extent) {\n      return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n    }\n    /**\n     * Get a corner coordinate of an extent.\n     * @param {Extent} extent Extent.\n     * @param {Corner} corner Corner.\n     * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n     */\n\n\n    function getCorner(extent, corner) {\n      var coordinate;\n\n      if (corner === Corner.BOTTOM_LEFT) {\n        coordinate = getBottomLeft(extent);\n      } else if (corner === Corner.BOTTOM_RIGHT) {\n        coordinate = getBottomRight(extent);\n      } else if (corner === Corner.TOP_LEFT) {\n        coordinate = getTopLeft(extent);\n      } else if (corner === Corner.TOP_RIGHT) {\n        coordinate = getTopRight(extent);\n      } else {\n        assert(false, 13); // Invalid corner\n      }\n\n      return coordinate;\n    }\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate} center Center.\n     * @param {number} resolution Resolution.\n     * @param {number} rotation Rotation.\n     * @param {import(\"./size.js\").Size} size Size.\n     * @param {Extent=} opt_extent Destination extent.\n     * @return {Extent} Extent.\n     */\n\n\n    function getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n      var dx = resolution * size[0] / 2;\n      var dy = resolution * size[1] / 2;\n      var cosRotation = Math.cos(rotation);\n      var sinRotation = Math.sin(rotation);\n      var xCos = dx * cosRotation;\n      var xSin = dx * sinRotation;\n      var yCos = dy * cosRotation;\n      var ySin = dy * sinRotation;\n      var x = center[0];\n      var y = center[1];\n      var x0 = x - xCos + ySin;\n      var x1 = x - xCos - ySin;\n      var x2 = x + xCos - ySin;\n      var x3 = x + xCos + ySin;\n      var y0 = y - xSin - yCos;\n      var y1 = y - xSin + yCos;\n      var y2 = y + xSin + yCos;\n      var y3 = y + xSin - yCos;\n      return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);\n    }\n    /**\n     * Get the height of an extent.\n     * @param {Extent} extent Extent.\n     * @return {number} Height.\n     * @api\n     */\n\n\n    function getHeight(extent) {\n      return extent[3] - extent[1];\n    }\n    /**\n     * Get the intersection of two extents.\n     * @param {Extent} extent1 Extent 1.\n     * @param {Extent} extent2 Extent 2.\n     * @param {Extent=} opt_extent Optional extent to populate with intersection.\n     * @return {Extent} Intersecting extent.\n     * @api\n     */\n\n\n    function getIntersection(extent1, extent2, opt_extent) {\n      var intersection = opt_extent ? opt_extent : createEmpty();\n\n      if (intersects(extent1, extent2)) {\n        if (extent1[0] > extent2[0]) {\n          intersection[0] = extent1[0];\n        } else {\n          intersection[0] = extent2[0];\n        }\n\n        if (extent1[1] > extent2[1]) {\n          intersection[1] = extent1[1];\n        } else {\n          intersection[1] = extent2[1];\n        }\n\n        if (extent1[2] < extent2[2]) {\n          intersection[2] = extent1[2];\n        } else {\n          intersection[2] = extent2[2];\n        }\n\n        if (extent1[3] < extent2[3]) {\n          intersection[3] = extent1[3];\n        } else {\n          intersection[3] = extent2[3];\n        }\n      } else {\n        createOrUpdateEmpty(intersection);\n      }\n\n      return intersection;\n    }\n    /**\n     * Get the top left coordinate of an extent.\n     * @param {Extent} extent Extent.\n     * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n     * @api\n     */\n\n\n    function getTopLeft(extent) {\n      return [extent[0], extent[3]];\n    }\n    /**\n     * Get the top right coordinate of an extent.\n     * @param {Extent} extent Extent.\n     * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n     * @api\n     */\n\n\n    function getTopRight(extent) {\n      return [extent[2], extent[3]];\n    }\n    /**\n     * Get the width of an extent.\n     * @param {Extent} extent Extent.\n     * @return {number} Width.\n     * @api\n     */\n\n\n    function getWidth(extent) {\n      return extent[2] - extent[0];\n    }\n    /**\n     * Determine if one extent intersects another.\n     * @param {Extent} extent1 Extent 1.\n     * @param {Extent} extent2 Extent.\n     * @return {boolean} The two extents intersect.\n     * @api\n     */\n\n\n    function intersects(extent1, extent2) {\n      return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];\n    }\n    /**\n     * Determine if an extent is empty.\n     * @param {Extent} extent Extent.\n     * @return {boolean} Is empty.\n     * @api\n     */\n\n\n    function isEmpty$1(extent) {\n      return extent[2] < extent[0] || extent[3] < extent[1];\n    }\n    /**\n     * @param {Extent} extent Extent.\n     * @param {Extent=} opt_extent Extent.\n     * @return {Extent} Extent.\n     */\n\n\n    function returnOrUpdate(extent, opt_extent) {\n      if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n      } else {\n        return extent;\n      }\n    }\n    /**\n     * @param {Extent} extent Extent.\n     * @param {number} value Value.\n     */\n\n\n    function scaleFromCenter(extent, value) {\n      var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);\n      var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);\n      extent[0] -= deltaX;\n      extent[2] += deltaX;\n      extent[1] -= deltaY;\n      extent[3] += deltaY;\n    }\n    /**\n     * Determine if the segment between two coordinates intersects (crosses,\n     * touches, or is contained by) the provided extent.\n     * @param {Extent} extent The extent.\n     * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n     * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n     * @return {boolean} The segment intersects the extent.\n     */\n\n\n    function intersectsSegment(extent, start, end) {\n      var intersects = false;\n      var startRel = coordinateRelationship(extent, start);\n      var endRel = coordinateRelationship(extent, end);\n\n      if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {\n        intersects = true;\n      } else {\n        var minX = extent[0];\n        var minY = extent[1];\n        var maxX = extent[2];\n        var maxY = extent[3];\n        var startX = start[0];\n        var startY = start[1];\n        var endX = end[0];\n        var endY = end[1];\n        var slope = (endY - startY) / (endX - startX);\n        var x, y;\n\n        if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n          // potentially intersects top\n          x = endX - (endY - maxY) / slope;\n          intersects = x >= minX && x <= maxX;\n        }\n\n        if (!intersects && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {\n          // potentially intersects right\n          y = endY - (endX - maxX) * slope;\n          intersects = y >= minY && y <= maxY;\n        }\n\n        if (!intersects && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {\n          // potentially intersects bottom\n          x = endX - (endY - minY) / slope;\n          intersects = x >= minX && x <= maxX;\n        }\n\n        if (!intersects && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {\n          // potentially intersects left\n          y = endY - (endX - minX) * slope;\n          intersects = y >= minY && y <= maxY;\n        }\n      }\n\n      return intersects;\n    }\n    /**\n     * @module ol/geom/GeometryType\n     */\n\n    /**\n     * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n     * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n     * `'GeometryCollection'`, `'Circle'`.\n     * @enum {string}\n     */\n\n\n    var GeometryType = {\n      POINT: 'Point',\n      LINE_STRING: 'LineString',\n      LINEAR_RING: 'LinearRing',\n      POLYGON: 'Polygon',\n      MULTI_POINT: 'MultiPoint',\n      MULTI_LINE_STRING: 'MultiLineString',\n      MULTI_POLYGON: 'MultiPolygon',\n      GEOMETRY_COLLECTION: 'GeometryCollection',\n      CIRCLE: 'Circle'\n    };\n    /**\n     * @module ol/geom/GeometryLayout\n     */\n\n    /**\n     * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n     * or measure ('M') coordinate is available. Supported values are `'XY'`,\n     * `'XYZ'`, `'XYM'`, `'XYZM'`.\n     * @enum {string}\n     */\n\n    var GeometryLayout = {\n      XY: 'XY',\n      XYZ: 'XYZ',\n      XYM: 'XYM',\n      XYZM: 'XYZM'\n    };\n    /**\n     * @module ol/geom/flat/transform\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {Array<number>=} opt_dest Destination.\n     * @return {Array<number>} Transformed coordinates.\n     */\n\n    function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\n      var dest = opt_dest ? opt_dest : [];\n      var i = 0;\n\n      for (var j = offset; j < end; j += stride) {\n        var x = flatCoordinates[j];\n        var y = flatCoordinates[j + 1];\n        dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n        dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n      }\n\n      if (opt_dest && dest.length != i) {\n        dest.length = i;\n      }\n\n      return dest;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} angle Angle.\n     * @param {Array<number>} anchor Rotation anchor point.\n     * @param {Array<number>=} opt_dest Destination.\n     * @return {Array<number>} Transformed coordinates.\n     */\n\n\n    function rotate$1(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n      var dest = opt_dest ? opt_dest : [];\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      var anchorX = anchor[0];\n      var anchorY = anchor[1];\n      var i = 0;\n\n      for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n        dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n\n        for (var k = j + 2; k < j + stride; ++k) {\n          dest[i++] = flatCoordinates[k];\n        }\n      }\n\n      if (opt_dest && dest.length != i) {\n        dest.length = i;\n      }\n\n      return dest;\n    }\n    /**\n     * Scale the coordinates.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} sx Scale factor in the x-direction.\n     * @param {number} sy Scale factor in the y-direction.\n     * @param {Array<number>} anchor Scale anchor point.\n     * @param {Array<number>=} opt_dest Destination.\n     * @return {Array<number>} Transformed coordinates.\n     */\n\n\n    function scale$1(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n      var dest = opt_dest ? opt_dest : [];\n      var anchorX = anchor[0];\n      var anchorY = anchor[1];\n      var i = 0;\n\n      for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + sx * deltaX;\n        dest[i++] = anchorY + sy * deltaY;\n\n        for (var k = j + 2; k < j + stride; ++k) {\n          dest[i++] = flatCoordinates[k];\n        }\n      }\n\n      if (opt_dest && dest.length != i) {\n        dest.length = i;\n      }\n\n      return dest;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @param {Array<number>=} opt_dest Destination.\n     * @return {Array<number>} Transformed coordinates.\n     */\n\n\n    function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n      var dest = opt_dest ? opt_dest : [];\n      var i = 0;\n\n      for (var j = offset; j < end; j += stride) {\n        dest[i++] = flatCoordinates[j] + deltaX;\n        dest[i++] = flatCoordinates[j + 1] + deltaY;\n\n        for (var k = j + 2; k < j + stride; ++k) {\n          dest[i++] = flatCoordinates[k];\n        }\n      }\n\n      if (opt_dest && dest.length != i) {\n        dest.length = i;\n      }\n\n      return dest;\n    }\n    /**\n     * @license\n     * Latitude/longitude spherical geodesy formulae taken from\n     * http://www.movable-type.co.uk/scripts/latlong.html\n     * Licensed under CC-BY-3.0.\n     */\n\n    /**\n     * Object literal with options for the {@link getLength} or {@link getArea}\n     * functions.\n     * @typedef {Object} SphereMetricOptions\n     * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n     * Projection of the  geometry.  By default, the geometry is assumed to be in\n     * Web Mercator.\n     * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the\n     * earth is used (Clarke 1866 Authalic Sphere).\n     */\n\n    /**\n     * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n     * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n     * @type {number}\n     */\n\n\n    var DEFAULT_RADIUS = 6371008.8;\n    /**\n     * Get the great circle distance (in meters) between two geographic coordinates.\n     * @param {Array} c1 Starting coordinate.\n     * @param {Array} c2 Ending coordinate.\n     * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n     *     mean radius using the WGS84 ellipsoid.\n     * @return {number} The great circle distance between the points (in meters).\n     * @api\n     */\n\n    function getDistance(c1, c2, opt_radius) {\n      var radius = opt_radius || DEFAULT_RADIUS;\n      var lat1 = toRadians(c1[1]);\n      var lat2 = toRadians(c2[1]);\n      var deltaLatBy2 = (lat2 - lat1) / 2;\n      var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n      var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n      return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    }\n    /**\n     * @module ol/proj/Units\n     */\n\n    /**\n     * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or\n     * `'us-ft'`.\n     * @enum {string}\n     */\n\n\n    var Units = {\n      DEGREES: 'degrees',\n      FEET: 'ft',\n      METERS: 'm',\n      PIXELS: 'pixels',\n      TILE_PIXELS: 'tile-pixels',\n      USFEET: 'us-ft'\n    };\n    /**\n     * Meters per unit lookup table.\n     * @const\n     * @type {Object<Units, number>}\n     * @api\n     */\n\n    var METERS_PER_UNIT = {}; // use the radius of the Normal sphere\n\n    METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;\n    METERS_PER_UNIT[Units.FEET] = 0.3048;\n    METERS_PER_UNIT[Units.METERS] = 1;\n    METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;\n    /**\n     * @module ol/proj/Projection\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n     * @property {import(\"./Units.js\").default|string} [units] Units. Required unless a\n     * proj4 projection is defined for `code`.\n     * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n     * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n     * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n     * @property {number} [metersPerUnit] The meters per unit for the SRS.\n     * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}\n     * lookup table.\n     * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n     * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n     * Function to determine resolution at a point. The function is called with a\n     * `{number}` view resolution and an `{import(\"../coordinate.js\").Coordinate}` as arguments, and returns\n     * the `{number}` resolution at the passed coordinate. If this is `undefined`,\n     * the default {@link module:ol/proj#getPointResolution} function will be used.\n     */\n\n    /**\n     * @classdesc\n     * Projection definition class. One of these is created for each projection\n     * supported in the application and stored in the {@link module:ol/proj} namespace.\n     * You can use these in applications, but this is not required, as API params\n     * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n     * code will suffice.\n     *\n     * You can use {@link module:ol/proj~get} to retrieve the object for a particular\n     * projection.\n     *\n     * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n     * with the following aliases:\n     * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n     *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n     *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n     *     urn:x-ogc:def:crs:EPSG:4326\n     * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n     *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n     *     http://www.opengis.net/gml/srs/epsg.xml#3857\n     *\n     * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n     * be added using `proj4.defs()`. After all required projection definitions are\n     * added, call the {@link module:ol/proj/proj4~register} function.\n     *\n     * @api\n     */\n\n    var Projection = function Projection(options) {\n      /**\n       * @private\n       * @type {string}\n       */\n      this.code_ = options.code;\n      /**\n       * Units of projected coordinates. When set to `TILE_PIXELS`, a\n       * `this.extent_` and `this.worldExtent_` must be configured properly for each\n       * tile.\n       * @private\n       * @type {import(\"./Units.js\").default}\n       */\n\n      this.units_ =\n      /** @type {import(\"./Units.js\").default} */\n      options.units;\n      /**\n       * Validity extent of the projection in projected coordinates. For projections\n       * with `TILE_PIXELS` units, this is the extent of the tile in\n       * tile pixel space.\n       * @private\n       * @type {import(\"../extent.js\").Extent}\n       */\n\n      this.extent_ = options.extent !== undefined ? options.extent : null;\n      /**\n       * Extent of the world in EPSG:4326. For projections with\n       * `TILE_PIXELS` units, this is the extent of the tile in\n       * projected coordinate space.\n       * @private\n       * @type {import(\"../extent.js\").Extent}\n       */\n\n      this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;\n      /**\n       * @private\n       * @type {string}\n       */\n\n      this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n      /**\n       * @private\n       * @type {boolean}\n       */\n\n      this.global_ = options.global !== undefined ? options.global : false;\n      /**\n       * @private\n       * @type {boolean}\n       */\n\n      this.canWrapX_ = !!(this.global_ && this.extent_);\n      /**\n       * @private\n       * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n       */\n\n      this.getPointResolutionFunc_ = options.getPointResolution;\n      /**\n       * @private\n       * @type {import(\"../tilegrid/TileGrid.js\").default}\n       */\n\n      this.defaultTileGrid_ = null;\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n\n      this.metersPerUnit_ = options.metersPerUnit;\n    };\n    /**\n     * @return {boolean} The projection is suitable for wrapping the x-axis\n     */\n\n\n    Projection.prototype.canWrapX = function canWrapX() {\n      return this.canWrapX_;\n    };\n    /**\n     * Get the code for this projection, e.g. 'EPSG:4326'.\n     * @return {string} Code.\n     * @api\n     */\n\n\n    Projection.prototype.getCode = function getCode() {\n      return this.code_;\n    };\n    /**\n     * Get the validity extent for this projection.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n\n\n    Projection.prototype.getExtent = function getExtent() {\n      return this.extent_;\n    };\n    /**\n     * Get the units of this projection.\n     * @return {import(\"./Units.js\").default} Units.\n     * @api\n     */\n\n\n    Projection.prototype.getUnits = function getUnits() {\n      return this.units_;\n    };\n    /**\n     * Get the amount of meters per unit of this projection.If the projection is\n     * not configured with `metersPerUnit` or a units identifier, the return is\n     * `undefined`.\n     * @return {number|undefined} Meters.\n     * @api\n     */\n\n\n    Projection.prototype.getMetersPerUnit = function getMetersPerUnit() {\n      return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n    };\n    /**\n     * Get the world extent for this projection.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n\n\n    Projection.prototype.getWorldExtent = function getWorldExtent() {\n      return this.worldExtent_;\n    };\n    /**\n     * Get the axis orientation of this projection.\n     * Example values are:\n     * enu - the default easting, northing, elevation.\n     * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n     *   or south orientated transverse mercator.\n     * wnu - westing, northing, up - some planetary coordinate systems have\n     *   \"west positive\" coordinate systems\n     * @return {string} Axis orientation.\n     * @api\n     */\n\n\n    Projection.prototype.getAxisOrientation = function getAxisOrientation() {\n      return this.axisOrientation_;\n    };\n    /**\n     * Is this projection a global projection which spans the whole world?\n     * @return {boolean} Whether the projection is global.\n     * @api\n     */\n\n\n    Projection.prototype.isGlobal = function isGlobal() {\n      return this.global_;\n    };\n    /**\n     * Set if the projection is a global projection which spans the whole world\n     * @param {boolean} global Whether the projection is global.\n     * @api\n     */\n\n\n    Projection.prototype.setGlobal = function setGlobal(global) {\n      this.global_ = global;\n      this.canWrapX_ = !!(global && this.extent_);\n    };\n    /**\n     * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n     */\n\n\n    Projection.prototype.getDefaultTileGrid = function getDefaultTileGrid() {\n      return this.defaultTileGrid_;\n    };\n    /**\n     * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n     */\n\n\n    Projection.prototype.setDefaultTileGrid = function setDefaultTileGrid(tileGrid) {\n      this.defaultTileGrid_ = tileGrid;\n    };\n    /**\n     * Set the validity extent for this projection.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @api\n     */\n\n\n    Projection.prototype.setExtent = function setExtent(extent) {\n      this.extent_ = extent;\n      this.canWrapX_ = !!(this.global_ && extent);\n    };\n    /**\n     * Set the world extent for this projection.\n     * @param {import(\"../extent.js\").Extent} worldExtent World extent\n     *   [minlon, minlat, maxlon, maxlat].\n     * @api\n     */\n\n\n    Projection.prototype.setWorldExtent = function setWorldExtent(worldExtent) {\n      this.worldExtent_ = worldExtent;\n    };\n    /**\n     * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}\n     * for this projection.\n     * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n     * @api\n     */\n\n\n    Projection.prototype.setGetPointResolution = function setGetPointResolution(func) {\n      this.getPointResolutionFunc_ = func;\n    };\n    /**\n     * Get the custom point resolution function for this projection (if set).\n     * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n     * resolution function (if set).\n     */\n\n\n    Projection.prototype.getPointResolutionFunc = function getPointResolutionFunc() {\n      return this.getPointResolutionFunc_;\n    };\n    /**\n     * @module ol/proj/epsg3857\n     */\n\n    /**\n     * Radius of WGS84 sphere\n     *\n     * @const\n     * @type {number}\n     */\n\n\n    var RADIUS = 6378137;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var HALF_SIZE = Math.PI * RADIUS;\n    /**\n     * @const\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n    /**\n     * @const\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    var WORLD_EXTENT = [-180, -85, 180, 85];\n    /**\n     * @classdesc\n     * Projection object for web/spherical Mercator (EPSG:3857).\n     */\n\n    var EPSG3857Projection =\n    /*@__PURE__*/\n    function (Projection$$1) {\n      function EPSG3857Projection(code) {\n        Projection$$1.call(this, {\n          code: code,\n          units: Units.METERS,\n          extent: EXTENT,\n          global: true,\n          worldExtent: WORLD_EXTENT,\n          getPointResolution: function getPointResolution(resolution, point) {\n            return resolution / cosh(point[1] / RADIUS);\n          }\n        });\n      }\n\n      if (Projection$$1) EPSG3857Projection.__proto__ = Projection$$1;\n      EPSG3857Projection.prototype = Object.create(Projection$$1 && Projection$$1.prototype);\n      EPSG3857Projection.prototype.constructor = EPSG3857Projection;\n      return EPSG3857Projection;\n    }(Projection);\n    /**\n     * Projections equal to EPSG:3857.\n     *\n     * @const\n     * @type {Array<import(\"./Projection.js\").default>}\n     */\n\n\n    var PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'), new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];\n    /**\n     * Transformation from EPSG:4326 to EPSG:3857.\n     *\n     * @param {Array<number>} input Input array of coordinate values.\n     * @param {Array<number>=} opt_output Output array of coordinate values.\n     * @param {number=} opt_dimension Dimension (default is `2`).\n     * @return {Array<number>} Output array of coordinate values.\n     */\n\n    function fromEPSG4326(input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension > 1 ? opt_dimension : 2;\n      var output = opt_output;\n\n      if (output === undefined) {\n        if (dimension > 2) {\n          // preserve values beyond second dimension\n          output = input.slice();\n        } else {\n          output = new Array(length);\n        }\n      }\n\n      var halfSize = HALF_SIZE;\n\n      for (var i = 0; i < length; i += dimension) {\n        output[i] = halfSize * input[i] / 180;\n        var y = RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));\n\n        if (y > halfSize) {\n          y = halfSize;\n        } else if (y < -halfSize) {\n          y = -halfSize;\n        }\n\n        output[i + 1] = y;\n      }\n\n      return output;\n    }\n    /**\n     * Transformation from EPSG:3857 to EPSG:4326.\n     *\n     * @param {Array<number>} input Input array of coordinate values.\n     * @param {Array<number>=} opt_output Output array of coordinate values.\n     * @param {number=} opt_dimension Dimension (default is `2`).\n     * @return {Array<number>} Output array of coordinate values.\n     */\n\n\n    function toEPSG4326(input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension > 1 ? opt_dimension : 2;\n      var output = opt_output;\n\n      if (output === undefined) {\n        if (dimension > 2) {\n          // preserve values beyond second dimension\n          output = input.slice();\n        } else {\n          output = new Array(length);\n        }\n      }\n\n      for (var i = 0; i < length; i += dimension) {\n        output[i] = 180 * input[i] / HALF_SIZE;\n        output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;\n      }\n\n      return output;\n    }\n    /**\n     * @module ol/proj/epsg4326\n     */\n\n    /**\n     * Semi-major radius of the WGS84 ellipsoid.\n     *\n     * @const\n     * @type {number}\n     */\n\n\n    var RADIUS$1 = 6378137;\n    /**\n     * Extent of the EPSG:4326 projection which is the whole world.\n     *\n     * @const\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    var EXTENT$1 = [-180, -90, 180, 90];\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var METERS_PER_UNIT$1 = Math.PI * RADIUS$1 / 180;\n    /**\n     * @classdesc\n     * Projection object for WGS84 geographic coordinates (EPSG:4326).\n     *\n     * Note that OpenLayers does not strictly comply with the EPSG definition.\n     * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n     * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n     */\n\n    var EPSG4326Projection =\n    /*@__PURE__*/\n    function (Projection$$1) {\n      function EPSG4326Projection(code, opt_axisOrientation) {\n        Projection$$1.call(this, {\n          code: code,\n          units: Units.DEGREES,\n          extent: EXTENT$1,\n          axisOrientation: opt_axisOrientation,\n          global: true,\n          metersPerUnit: METERS_PER_UNIT$1,\n          worldExtent: EXTENT$1\n        });\n      }\n\n      if (Projection$$1) EPSG4326Projection.__proto__ = Projection$$1;\n      EPSG4326Projection.prototype = Object.create(Projection$$1 && Projection$$1.prototype);\n      EPSG4326Projection.prototype.constructor = EPSG4326Projection;\n      return EPSG4326Projection;\n    }(Projection);\n    /**\n     * Projections equal to EPSG:4326.\n     *\n     * @const\n     * @type {Array<import(\"./Projection.js\").default>}\n     */\n\n\n    var PROJECTIONS$1 = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')];\n    /**\n     * @module ol/proj/projections\n     */\n\n    /**\n     * @type {Object<string, import(\"./Projection.js\").default>}\n     */\n\n    var cache = {};\n    /**\n     * Get a cached projection by code.\n     * @param {string} code The code for the projection.\n     * @return {import(\"./Projection.js\").default} The projection (if cached).\n     */\n\n    function get(code) {\n      return cache[code] || null;\n    }\n    /**\n     * Add a projection to the cache.\n     * @param {string} code The projection code.\n     * @param {import(\"./Projection.js\").default} projection The projection to cache.\n     */\n\n\n    function add$1(code, projection) {\n      cache[code] = projection;\n    }\n    /**\n     * @module ol/proj/transforms\n     */\n\n    /**\n     * @private\n     * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n     */\n\n\n    var transforms = {};\n    /**\n     * Registers a conversion function to convert coordinates from the source\n     * projection to the destination projection.\n     *\n     * @param {import(\"./Projection.js\").default} source Source.\n     * @param {import(\"./Projection.js\").default} destination Destination.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n     */\n\n    function add$2(source, destination, transformFn) {\n      var sourceCode = source.getCode();\n      var destinationCode = destination.getCode();\n\n      if (!(sourceCode in transforms)) {\n        transforms[sourceCode] = {};\n      }\n\n      transforms[sourceCode][destinationCode] = transformFn;\n    }\n    /**\n     * Get a transform given a source code and a destination code.\n     * @param {string} sourceCode The code for the source projection.\n     * @param {string} destinationCode The code for the destination projection.\n     * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n     */\n\n\n    function get$1(sourceCode, destinationCode) {\n      var transform;\n\n      if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n        transform = transforms[sourceCode][destinationCode];\n      }\n\n      return transform;\n    }\n    /**\n     * @module ol/proj\n     */\n\n    /**\n     * @param {Array<number>} input Input coordinate array.\n     * @param {Array<number>=} opt_output Output array of coordinate values.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array<number>} Output coordinate array (new array, same coordinate\n     *     values).\n     */\n\n\n    function cloneTransform(input, opt_output, opt_dimension) {\n      var output;\n\n      if (opt_output !== undefined) {\n        for (var i = 0, ii = input.length; i < ii; ++i) {\n          opt_output[i] = input[i];\n        }\n\n        output = opt_output;\n      } else {\n        output = input.slice();\n      }\n\n      return output;\n    }\n    /**\n     * @param {Array<number>} input Input coordinate array.\n     * @param {Array<number>=} opt_output Output array of coordinate values.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array<number>} Input coordinate array (same array as input).\n     */\n\n\n    function identityTransform(input, opt_output, opt_dimension) {\n      if (opt_output !== undefined && input !== opt_output) {\n        for (var i = 0, ii = input.length; i < ii; ++i) {\n          opt_output[i] = input[i];\n        }\n\n        input = opt_output;\n      }\n\n      return input;\n    }\n    /**\n     * Add a Projection object to the list of supported projections that can be\n     * looked up by their code.\n     *\n     * @param {Projection} projection Projection instance.\n     * @api\n     */\n\n\n    function addProjection(projection) {\n      add$1(projection.getCode(), projection);\n      add$2(projection, projection, cloneTransform);\n    }\n    /**\n     * @param {Array<Projection>} projections Projections.\n     */\n\n\n    function addProjections(projections) {\n      projections.forEach(addProjection);\n    }\n    /**\n     * Fetches a Projection object for the code specified.\n     *\n     * @param {ProjectionLike} projectionLike Either a code string which is\n     *     a combination of authority and identifier such as \"EPSG:4326\", or an\n     *     existing projection object, or undefined.\n     * @return {Projection} Projection object, or null if not in list.\n     * @api\n     */\n\n\n    function get$2(projectionLike) {\n      return typeof projectionLike === 'string' ? get(\n      /** @type {string} */\n      projectionLike) :\n      /** @type {Projection} */\n      projectionLike || null;\n    }\n    /**\n     * Get the resolution of the point in degrees or distance units.\n     * For projections with degrees as the unit this will simply return the\n     * provided resolution. For other projections the point resolution is\n     * by default estimated by transforming the 'point' pixel to EPSG:4326,\n     * measuring its width and height on the normal sphere,\n     * and taking the average of the width and height.\n     * A custom function can be provided for a specific projection, either\n     * by setting the `getPointResolution` option in the\n     * {@link module:ol/proj/Projection~Projection} constructor or by using\n     * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n     * projection object.\n     * @param {ProjectionLike} projection The projection.\n     * @param {number} resolution Nominal resolution in projection units.\n     * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n     * @param {Units=} opt_units Units to get the point resolution in.\n     * Default is the projection's units.\n     * @return {number} Point resolution.\n     * @api\n     */\n\n\n    function getPointResolution(projection, resolution, point, opt_units) {\n      projection = get$2(projection);\n      var pointResolution;\n      var getter = projection.getPointResolutionFunc();\n\n      if (getter) {\n        pointResolution = getter(resolution, point);\n      } else {\n        var units = projection.getUnits();\n\n        if (units == Units.DEGREES && !opt_units || opt_units == Units.DEGREES) {\n          pointResolution = resolution;\n        } else {\n          // Estimate point resolution by transforming the center pixel to EPSG:4326,\n          // measuring its width and height on the normal sphere, and taking the\n          // average of the width and height.\n          var toEPSG4326$$1 = getTransformFromProjections(projection, get$2('EPSG:4326'));\n          var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];\n          vertices = toEPSG4326$$1(vertices, vertices, 2);\n          var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n          var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n          pointResolution = (width + height) / 2;\n          var metersPerUnit = opt_units ? METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();\n\n          if (metersPerUnit !== undefined) {\n            pointResolution /= metersPerUnit;\n          }\n        }\n      }\n\n      return pointResolution;\n    }\n    /**\n     * Registers transformation functions that don't alter coordinates. Those allow\n     * to transform between projections with equal meaning.\n     *\n     * @param {Array<Projection>} projections Projections.\n     * @api\n     */\n\n\n    function addEquivalentProjections(projections) {\n      addProjections(projections);\n      projections.forEach(function (source) {\n        projections.forEach(function (destination) {\n          if (source !== destination) {\n            add$2(source, destination, cloneTransform);\n          }\n        });\n      });\n    }\n    /**\n     * Registers transformation functions to convert coordinates in any projection\n     * in projection1 to any projection in projection2.\n     *\n     * @param {Array<Projection>} projections1 Projections with equal\n     *     meaning.\n     * @param {Array<Projection>} projections2 Projections with equal\n     *     meaning.\n     * @param {TransformFunction} forwardTransform Transformation from any\n     *   projection in projection1 to any projection in projection2.\n     * @param {TransformFunction} inverseTransform Transform from any projection\n     *   in projection2 to any projection in projection1..\n     */\n\n\n    function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\n      projections1.forEach(function (projection1) {\n        projections2.forEach(function (projection2) {\n          add$2(projection1, projection2, forwardTransform);\n          add$2(projection2, projection1, inverseTransform);\n        });\n      });\n    }\n    /**\n     * @param {Projection|string|undefined} projection Projection.\n     * @param {string} defaultCode Default code.\n     * @return {Projection} Projection.\n     */\n\n\n    function createProjection(projection, defaultCode) {\n      if (!projection) {\n        return get$2(defaultCode);\n      } else if (typeof projection === 'string') {\n        return get$2(projection);\n      } else {\n        return (\n          /** @type {Projection} */\n          projection\n        );\n      }\n    }\n    /**\n     * Checks if two projections are the same, that is every coordinate in one\n     * projection does represent the same geographic point as the same coordinate in\n     * the other projection.\n     *\n     * @param {Projection} projection1 Projection 1.\n     * @param {Projection} projection2 Projection 2.\n     * @return {boolean} Equivalent.\n     * @api\n     */\n\n\n    function equivalent(projection1, projection2) {\n      if (projection1 === projection2) {\n        return true;\n      }\n\n      var equalUnits = projection1.getUnits() === projection2.getUnits();\n\n      if (projection1.getCode() === projection2.getCode()) {\n        return equalUnits;\n      } else {\n        var transformFunc = getTransformFromProjections(projection1, projection2);\n        return transformFunc === cloneTransform && equalUnits;\n      }\n    }\n    /**\n     * Searches in the list of transform functions for the function for converting\n     * coordinates from the source projection to the destination projection.\n     *\n     * @param {Projection} sourceProjection Source Projection object.\n     * @param {Projection} destinationProjection Destination Projection\n     *     object.\n     * @return {TransformFunction} Transform function.\n     */\n\n\n    function getTransformFromProjections(sourceProjection, destinationProjection) {\n      var sourceCode = sourceProjection.getCode();\n      var destinationCode = destinationProjection.getCode();\n      var transformFunc = get$1(sourceCode, destinationCode);\n\n      if (!transformFunc) {\n        transformFunc = identityTransform;\n      }\n\n      return transformFunc;\n    }\n    /**\n     * Given the projection-like objects, searches for a transformation\n     * function to convert a coordinates array from the source projection to the\n     * destination projection.\n     *\n     * @param {ProjectionLike} source Source.\n     * @param {ProjectionLike} destination Destination.\n     * @return {TransformFunction} Transform function.\n     * @api\n     */\n\n\n    function getTransform(source, destination) {\n      var sourceProjection = get$2(source);\n      var destinationProjection = get$2(destination);\n      return getTransformFromProjections(sourceProjection, destinationProjection);\n    }\n    /**\n     * Transforms a coordinate from source projection to destination projection.\n     * This returns a new coordinate (and does not modify the original).\n     *\n     * See {@link module:ol/proj~transformExtent} for extent transformation.\n     * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n     * subclasses for geometry transforms.\n     *\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {ProjectionLike} source Source projection-like.\n     * @param {ProjectionLike} destination Destination projection-like.\n     * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n     * @api\n     */\n\n\n    function transform(coordinate, source, destination) {\n      var transformFunc = getTransform(source, destination);\n      return transformFunc(coordinate, undefined, coordinate.length);\n    }\n    /**\n     * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n     * by when this module is executed and should only need to be called again after\n     * `clearAllProjections()` is called (e.g. in tests).\n     */\n\n\n    function addCommon() {\n      // Add transformations that don't alter coordinates to convert within set of\n      // projections with equal meaning.\n      addEquivalentProjections(PROJECTIONS);\n      addEquivalentProjections(PROJECTIONS$1); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n      // coordinates and back.\n\n      addEquivalentTransforms(PROJECTIONS$1, PROJECTIONS, fromEPSG4326, toEPSG4326);\n    }\n\n    addCommon();\n    /**\n     * @module ol/transform\n     */\n\n    /**\n     * An array representing an affine 2d transformation for use with\n     * {@link module:ol/transform} functions. The array has 6 elements.\n     * @typedef {!Array<number>} Transform\n     */\n\n    /**\n     * Collection of affine 2d transformation functions. The functions work on an\n     * array of 6 elements. The element order is compatible with the [SVGMatrix\n     * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n     * a subset (elements a to f) of a 33 matrix:\n     * ```\n     * [ a c e ]\n     * [ b d f ]\n     * [ 0 0 1 ]\n     * ```\n     */\n\n    /**\n     * @private\n     * @type {Transform}\n     */\n\n    var tmp_ = new Array(6);\n    /**\n     * Create an identity transform.\n     * @return {!Transform} Identity transform.\n     */\n\n    function create() {\n      return [1, 0, 0, 1, 0, 0];\n    }\n    /**\n     * Resets the given transform to an identity transform.\n     * @param {!Transform} transform Transform.\n     * @return {!Transform} Transform.\n     */\n\n\n    function reset(transform) {\n      return set(transform, 1, 0, 0, 1, 0, 0);\n    }\n    /**\n     * Multiply the underlying matrices of two transforms and return the result in\n     * the first transform.\n     * @param {!Transform} transform1 Transform parameters of matrix 1.\n     * @param {!Transform} transform2 Transform parameters of matrix 2.\n     * @return {!Transform} transform1 multiplied with transform2.\n     */\n\n\n    function multiply(transform1, transform2) {\n      var a1 = transform1[0];\n      var b1 = transform1[1];\n      var c1 = transform1[2];\n      var d1 = transform1[3];\n      var e1 = transform1[4];\n      var f1 = transform1[5];\n      var a2 = transform2[0];\n      var b2 = transform2[1];\n      var c2 = transform2[2];\n      var d2 = transform2[3];\n      var e2 = transform2[4];\n      var f2 = transform2[5];\n      transform1[0] = a1 * a2 + c1 * b2;\n      transform1[1] = b1 * a2 + d1 * b2;\n      transform1[2] = a1 * c2 + c1 * d2;\n      transform1[3] = b1 * c2 + d1 * d2;\n      transform1[4] = a1 * e2 + c1 * f2 + e1;\n      transform1[5] = b1 * e2 + d1 * f2 + f1;\n      return transform1;\n    }\n    /**\n     * Set the transform components a-f on a given transform.\n     * @param {!Transform} transform Transform.\n     * @param {number} a The a component of the transform.\n     * @param {number} b The b component of the transform.\n     * @param {number} c The c component of the transform.\n     * @param {number} d The d component of the transform.\n     * @param {number} e The e component of the transform.\n     * @param {number} f The f component of the transform.\n     * @return {!Transform} Matrix with transform applied.\n     */\n\n\n    function set(transform, a, b, c, d, e, f) {\n      transform[0] = a;\n      transform[1] = b;\n      transform[2] = c;\n      transform[3] = d;\n      transform[4] = e;\n      transform[5] = f;\n      return transform;\n    }\n    /**\n     * Set transform on one matrix from another matrix.\n     * @param {!Transform} transform1 Matrix to set transform to.\n     * @param {!Transform} transform2 Matrix to set transform from.\n     * @return {!Transform} transform1 with transform from transform2 applied.\n     */\n\n\n    function setFromArray(transform1, transform2) {\n      transform1[0] = transform2[0];\n      transform1[1] = transform2[1];\n      transform1[2] = transform2[2];\n      transform1[3] = transform2[3];\n      transform1[4] = transform2[4];\n      transform1[5] = transform2[5];\n      return transform1;\n    }\n    /**\n     * Transforms the given coordinate with the given transform returning the\n     * resulting, transformed coordinate. The coordinate will be modified in-place.\n     *\n     * @param {Transform} transform The transformation.\n     * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n     * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n     *     chained together.\n     */\n\n\n    function apply(transform, coordinate) {\n      var x = coordinate[0];\n      var y = coordinate[1];\n      coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n      coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n      return coordinate;\n    }\n    /**\n     * Applies rotation to the given transform.\n     * @param {!Transform} transform Transform.\n     * @param {number} angle Angle in radians.\n     * @return {!Transform} The rotated transform.\n     */\n\n\n    function rotate$2(transform, angle) {\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n    }\n    /**\n     * Applies scale to a given transform.\n     * @param {!Transform} transform Transform.\n     * @param {number} x Scale factor x.\n     * @param {number} y Scale factor y.\n     * @return {!Transform} The scaled transform.\n     */\n\n\n    function scale$2(transform, x, y) {\n      return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n    }\n    /**\n     * Applies translation to the given transform.\n     * @param {!Transform} transform Transform.\n     * @param {number} dx Translation x.\n     * @param {number} dy Translation y.\n     * @return {!Transform} The translated transform.\n     */\n\n\n    function translate$1(transform, dx, dy) {\n      return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n    }\n    /**\n     * Creates a composite transform given an initial translation, scale, rotation, and\n     * final translation (in that order only, not commutative).\n     * @param {!Transform} transform The transform (will be modified in place).\n     * @param {number} dx1 Initial translation x.\n     * @param {number} dy1 Initial translation y.\n     * @param {number} sx Scale factor x.\n     * @param {number} sy Scale factor y.\n     * @param {number} angle Rotation (in counter-clockwise radians).\n     * @param {number} dx2 Final translation x.\n     * @param {number} dy2 Final translation y.\n     * @return {!Transform} The composite transform.\n     */\n\n\n    function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n      var sin = Math.sin(angle);\n      var cos = Math.cos(angle);\n      transform[0] = sx * cos;\n      transform[1] = sy * sin;\n      transform[2] = -sx * sin;\n      transform[3] = sy * cos;\n      transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n      transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n      return transform;\n    }\n    /**\n     * Invert the given transform.\n     * @param {!Transform} transform Transform.\n     * @return {!Transform} Inverse of the transform.\n     */\n\n\n    function invert(transform) {\n      var det = determinant(transform);\n      assert(det !== 0, 32); // Transformation matrix cannot be inverted\n\n      var a = transform[0];\n      var b = transform[1];\n      var c = transform[2];\n      var d = transform[3];\n      var e = transform[4];\n      var f = transform[5];\n      transform[0] = d / det;\n      transform[1] = -b / det;\n      transform[2] = -c / det;\n      transform[3] = a / det;\n      transform[4] = (c * f - d * e) / det;\n      transform[5] = -(a * f - b * e) / det;\n      return transform;\n    }\n    /**\n     * Returns the determinant of the given matrix.\n     * @param {!Transform} mat Matrix.\n     * @return {number} Determinant.\n     */\n\n\n    function determinant(mat) {\n      return mat[0] * mat[3] - mat[1] * mat[2];\n    }\n    /**\n     * @module ol/geom/Geometry\n     */\n\n    /**\n     * @type {import(\"../transform.js\").Transform}\n     */\n\n\n    var tmpTransform = create();\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * Base class for vector geometries.\n     *\n     * To get notified of changes to the geometry, register a listener for the\n     * generic `change` event on your geometry instance.\n     *\n     * @abstract\n     * @api\n     */\n\n    var Geometry =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function Geometry() {\n        BaseObject$$1.call(this);\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n\n        this.extent_ = createEmpty();\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.extentRevision_ = -1;\n        /**\n         * @protected\n         * @type {Object<string, Geometry>}\n         */\n\n        this.simplifiedGeometryCache = {};\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.simplifiedGeometryRevision = 0;\n      }\n\n      if (BaseObject$$1) Geometry.__proto__ = BaseObject$$1;\n      Geometry.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      Geometry.prototype.constructor = Geometry;\n      /**\n       * Make a complete copy of the geometry.\n       * @abstract\n       * @return {!Geometry} Clone.\n       */\n\n      Geometry.prototype.clone = function clone$$1() {\n        return _abstract();\n      };\n      /**\n       * @abstract\n       * @param {number} x X.\n       * @param {number} y Y.\n       * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n       * @param {number} minSquaredDistance Minimum squared distance.\n       * @return {number} Minimum squared distance.\n       */\n\n\n      Geometry.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        return _abstract();\n      };\n      /**\n       * @param {number} x X.\n       * @param {number} y Y.\n       * @return {boolean} Contains (x, y).\n       */\n\n\n      Geometry.prototype.containsXY = function containsXY$$1(x, y) {\n        return false;\n      };\n      /**\n       * Return the closest point of the geometry to the passed point as\n       * {@link module:ol/coordinate~Coordinate coordinate}.\n       * @param {import(\"../coordinate.js\").Coordinate} point Point.\n       * @param {import(\"../coordinate.js\").Coordinate=} opt_closestPoint Closest point.\n       * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n       * @api\n       */\n\n\n      Geometry.prototype.getClosestPoint = function getClosestPoint(point, opt_closestPoint) {\n        var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n        this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n        return closestPoint;\n      };\n      /**\n       * Returns true if this geometry includes the specified coordinate. If the\n       * coordinate is on the boundary of the geometry, returns false.\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @return {boolean} Contains coordinate.\n       * @api\n       */\n\n\n      Geometry.prototype.intersectsCoordinate = function intersectsCoordinate(coordinate) {\n        return this.containsXY(coordinate[0], coordinate[1]);\n      };\n      /**\n       * @abstract\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @protected\n       * @return {import(\"../extent.js\").Extent} extent Extent.\n       */\n\n\n      Geometry.prototype.computeExtent = function computeExtent(extent) {\n        return _abstract();\n      };\n      /**\n       * Get the extent of the geometry.\n       * @param {import(\"../extent.js\").Extent=} opt_extent Extent.\n       * @return {import(\"../extent.js\").Extent} extent Extent.\n       * @api\n       */\n\n\n      Geometry.prototype.getExtent = function getExtent(opt_extent) {\n        if (this.extentRevision_ != this.getRevision()) {\n          this.extent_ = this.computeExtent(this.extent_);\n          this.extentRevision_ = this.getRevision();\n        }\n\n        return returnOrUpdate(this.extent_, opt_extent);\n      };\n      /**\n       * Rotate the geometry around a given coordinate. This modifies the geometry\n       * coordinates in place.\n       * @abstract\n       * @param {number} angle Rotation angle in radians.\n       * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n       * @api\n       */\n\n\n      Geometry.prototype.rotate = function rotate(angle, anchor) {\n        _abstract();\n      };\n      /**\n       * Scale the geometry (with an optional origin).  This modifies the geometry\n       * coordinates in place.\n       * @abstract\n       * @param {number} sx The scaling factor in the x-direction.\n       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n       *     sx).\n       * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n       *     of the geometry extent).\n       * @api\n       */\n\n\n      Geometry.prototype.scale = function scale(sx, opt_sy, opt_anchor) {\n        _abstract();\n      };\n      /**\n       * Create a simplified version of this geometry.  For linestrings, this uses\n       * the the {@link\n       * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n       * Douglas Peucker} algorithm.  For polygons, a quantization-based\n       * simplification is used to preserve topology.\n       * @param {number} tolerance The tolerance distance for simplification.\n       * @return {Geometry} A new, simplified version of the original geometry.\n       * @api\n       */\n\n\n      Geometry.prototype.simplify = function simplify(tolerance) {\n        return this.getSimplifiedGeometry(tolerance * tolerance);\n      };\n      /**\n       * Create a simplified version of this geometry using the Douglas Peucker\n       * algorithm.\n       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n       * @abstract\n       * @param {number} squaredTolerance Squared tolerance.\n       * @return {Geometry} Simplified geometry.\n       */\n\n\n      Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry(squaredTolerance) {\n        return _abstract();\n      };\n      /**\n       * Get the type of this geometry.\n       * @abstract\n       * @return {import(\"./GeometryType.js\").default} Geometry type.\n       */\n\n\n      Geometry.prototype.getType = function getType() {\n        return _abstract();\n      };\n      /**\n       * Apply a transform function to each coordinate of the geometry.\n       * The geometry is modified in place.\n       * If you do not want the geometry modified in place, first `clone()` it and\n       * then use this function on the clone.\n       * @abstract\n       * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n       */\n\n\n      Geometry.prototype.applyTransform = function applyTransform$$1(transformFn) {\n        _abstract();\n      };\n      /**\n       * Test if the geometry and the passed extent intersect.\n       * @abstract\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @return {boolean} `true` if the geometry and the extent intersect.\n       */\n\n\n      Geometry.prototype.intersectsExtent = function intersectsExtent(extent) {\n        return _abstract();\n      };\n      /**\n       * Translate the geometry.  This modifies the geometry coordinates in place.  If\n       * instead you want a new geometry, first `clone()` this geometry.\n       * @abstract\n       * @param {number} deltaX Delta X.\n       * @param {number} deltaY Delta Y.\n       * @api\n       */\n\n\n      Geometry.prototype.translate = function translate$$1(deltaX, deltaY) {\n        _abstract();\n      };\n      /**\n       * Transform each coordinate of the geometry from one coordinate reference\n       * system to another. The geometry is modified in place.\n       * For example, a line will be transformed to a line and a circle to a circle.\n       * If you do not want the geometry modified in place, first `clone()` it and\n       * then use this function on the clone.\n       *\n       * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n       * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n       * @return {Geometry} This geometry.  Note that original geometry is\n       *     modified in place.\n       * @api\n       */\n\n\n      Geometry.prototype.transform = function transform$$1(source, destination) {\n        /** @type {import(\"../proj/Projection.js\").default} */\n        var sourceProj = get$2(source);\n        var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {\n          var pixelExtent = sourceProj.getExtent();\n          var projectedExtent = sourceProj.getWorldExtent();\n          var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n          compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n          transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n          return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n        } : getTransform(sourceProj, destination);\n        this.applyTransform(transformFn);\n        return this;\n      };\n\n      return Geometry;\n    }(BaseObject);\n    /**\n     * @module ol/geom/SimpleGeometry\n     */\n\n    /**\n     * @classdesc\n     * Abstract base class; only used for creating subclasses; do not instantiate\n     * in apps, as cannot be rendered.\n     *\n     * @abstract\n     * @api\n     */\n\n\n    var SimpleGeometry =\n    /*@__PURE__*/\n    function (Geometry$$1) {\n      function SimpleGeometry() {\n        Geometry$$1.call(this);\n        /**\n         * @protected\n         * @type {GeometryLayout}\n         */\n\n        this.layout = GeometryLayout.XY;\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.stride = 2;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n\n        this.flatCoordinates = null;\n      }\n\n      if (Geometry$$1) SimpleGeometry.__proto__ = Geometry$$1;\n      SimpleGeometry.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);\n      SimpleGeometry.prototype.constructor = SimpleGeometry;\n      /**\n       * @inheritDoc\n       */\n\n      SimpleGeometry.prototype.computeExtent = function computeExtent(extent) {\n        return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n      };\n      /**\n       * @abstract\n       * @return {Array} Coordinates.\n       */\n\n\n      SimpleGeometry.prototype.getCoordinates = function getCoordinates() {\n        return _abstract();\n      };\n      /**\n       * Return the first coordinate of the geometry.\n       * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n       * @api\n       */\n\n\n      SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate() {\n        return this.flatCoordinates.slice(0, this.stride);\n      };\n      /**\n       * @return {Array<number>} Flat coordinates.\n       */\n\n\n      SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates() {\n        return this.flatCoordinates;\n      };\n      /**\n       * Return the last coordinate of the geometry.\n       * @return {import(\"../coordinate.js\").Coordinate} Last point.\n       * @api\n       */\n\n\n      SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate() {\n        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n      };\n      /**\n       * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\n       * @return {GeometryLayout} Layout.\n       * @api\n       */\n\n\n      SimpleGeometry.prototype.getLayout = function getLayout() {\n        return this.layout;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry(squaredTolerance) {\n        if (this.simplifiedGeometryRevision != this.getRevision()) {\n          clear(this.simplifiedGeometryCache);\n          this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n          this.simplifiedGeometryRevision = this.getRevision();\n        } // If squaredTolerance is negative or if we know that simplification will not\n        // have any effect then just return this.\n\n\n        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n          return this;\n        }\n\n        var key = squaredTolerance.toString();\n\n        if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n          return this.simplifiedGeometryCache[key];\n        } else {\n          var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n          var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n\n          if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n            this.simplifiedGeometryCache[key] = simplifiedGeometry;\n            return simplifiedGeometry;\n          } else {\n            // Simplification did not actually remove any coordinates.  We now know\n            // that any calls to getSimplifiedGeometry with a squaredTolerance less\n            // than or equal to the current squaredTolerance will also not have any\n            // effect.  This allows us to short circuit simplification (saving CPU\n            // cycles) and prevents the cache of simplified geometries from filling\n            // up with useless identical copies of this geometry (saving memory).\n            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n            return this;\n          }\n        }\n      };\n      /**\n       * @param {number} squaredTolerance Squared tolerance.\n       * @return {SimpleGeometry} Simplified geometry.\n       * @protected\n       */\n\n\n      SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n        return this;\n      };\n      /**\n       * @return {number} Stride.\n       */\n\n\n      SimpleGeometry.prototype.getStride = function getStride() {\n        return this.stride;\n      };\n      /**\n       * @param {GeometryLayout} layout Layout.\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       */\n\n\n      SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates(layout, flatCoordinates) {\n        this.stride = getStrideForLayout(layout);\n        this.layout = layout;\n        this.flatCoordinates = flatCoordinates;\n      };\n      /**\n       * @abstract\n       * @param {!Array} coordinates Coordinates.\n       * @param {GeometryLayout=} opt_layout Layout.\n       */\n\n\n      SimpleGeometry.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        _abstract();\n      };\n      /**\n       * @param {GeometryLayout|undefined} layout Layout.\n       * @param {Array} coordinates Coordinates.\n       * @param {number} nesting Nesting.\n       * @protected\n       */\n\n\n      SimpleGeometry.prototype.setLayout = function setLayout(layout, coordinates, nesting) {\n        /** @type {number} */\n        var stride;\n\n        if (layout) {\n          stride = getStrideForLayout(layout);\n        } else {\n          for (var i = 0; i < nesting; ++i) {\n            if (coordinates.length === 0) {\n              this.layout = GeometryLayout.XY;\n              this.stride = 2;\n              return;\n            } else {\n              coordinates =\n              /** @type {Array} */\n              coordinates[0];\n            }\n          }\n\n          stride = coordinates.length;\n          layout = getLayoutForStride(stride);\n        }\n\n        this.layout = layout;\n        this.stride = stride;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      SimpleGeometry.prototype.applyTransform = function applyTransform$$1(transformFn) {\n        if (this.flatCoordinates) {\n          transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n          this.changed();\n        }\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      SimpleGeometry.prototype.rotate = function rotate$1$$1(angle, anchor) {\n        var flatCoordinates = this.getFlatCoordinates();\n\n        if (flatCoordinates) {\n          var stride = this.getStride();\n          rotate$1(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n          this.changed();\n        }\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      SimpleGeometry.prototype.scale = function scale$1$$1(sx, opt_sy, opt_anchor) {\n        var sy = opt_sy;\n\n        if (sy === undefined) {\n          sy = sx;\n        }\n\n        var anchor = opt_anchor;\n\n        if (!anchor) {\n          anchor = getCenter(this.getExtent());\n        }\n\n        var flatCoordinates = this.getFlatCoordinates();\n\n        if (flatCoordinates) {\n          var stride = this.getStride();\n          scale$1(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n          this.changed();\n        }\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      SimpleGeometry.prototype.translate = function translate$1(deltaX, deltaY) {\n        var flatCoordinates = this.getFlatCoordinates();\n\n        if (flatCoordinates) {\n          var stride = this.getStride();\n          translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n          this.changed();\n        }\n      };\n\n      return SimpleGeometry;\n    }(Geometry);\n    /**\n     * @param {number} stride Stride.\n     * @return {GeometryLayout} layout Layout.\n     */\n\n\n    function getLayoutForStride(stride) {\n      var layout;\n\n      if (stride == 2) {\n        layout = GeometryLayout.XY;\n      } else if (stride == 3) {\n        layout = GeometryLayout.XYZ;\n      } else if (stride == 4) {\n        layout = GeometryLayout.XYZM;\n      }\n\n      return (\n        /** @type {GeometryLayout} */\n        layout\n      );\n    }\n    /**\n     * @param {GeometryLayout} layout Layout.\n     * @return {number} Stride.\n     */\n\n\n    function getStrideForLayout(layout) {\n      var stride;\n\n      if (layout == GeometryLayout.XY) {\n        stride = 2;\n      } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n        stride = 3;\n      } else if (layout == GeometryLayout.XYZM) {\n        stride = 4;\n      }\n\n      return (\n        /** @type {number} */\n        stride\n      );\n    }\n    /**\n     * @param {SimpleGeometry} simpleGeometry Simple geometry.\n     * @param {import(\"../transform.js\").Transform} transform Transform.\n     * @param {Array<number>=} opt_dest Destination.\n     * @return {Array<number>} Transformed flat coordinates.\n     */\n\n\n    function transformGeom2D(simpleGeometry, transform, opt_dest) {\n      var flatCoordinates = simpleGeometry.getFlatCoordinates();\n\n      if (!flatCoordinates) {\n        return null;\n      } else {\n        var stride = simpleGeometry.getStride();\n        return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);\n      }\n    }\n    /**\n     * @module ol/geom/flat/area\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @return {number} Area.\n     */\n\n\n    function linearRing(flatCoordinates, offset, end, stride) {\n      var twiceArea = 0;\n      var x1 = flatCoordinates[end - stride];\n      var y1 = flatCoordinates[end - stride + 1];\n\n      for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        twiceArea += y1 * x2 - x1 * y2;\n        x1 = x2;\n        y1 = y2;\n      }\n\n      return twiceArea / 2;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @return {number} Area.\n     */\n\n\n    function linearRings(flatCoordinates, offset, ends, stride) {\n      var area = 0;\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        area += linearRing(flatCoordinates, offset, end, stride);\n        offset = end;\n      }\n\n      return area;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @return {number} Area.\n     */\n\n\n    function linearRingss(flatCoordinates, offset, endss, stride) {\n      var area = 0;\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        area += linearRings(flatCoordinates, offset, ends, stride);\n        offset = ends[ends.length - 1];\n      }\n\n      return area;\n    }\n    /**\n     * @module ol/geom/flat/closest\n     */\n\n    /**\n     * Returns the point on the 2D line segment flatCoordinates[offset1] to\n     * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n     * dimensions are linearly interpolated.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset1 Offset 1.\n     * @param {number} offset2 Offset 2.\n     * @param {number} stride Stride.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {Array<number>} closestPoint Closest point.\n     */\n\n\n    function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n      var x1 = flatCoordinates[offset1];\n      var y1 = flatCoordinates[offset1 + 1];\n      var dx = flatCoordinates[offset2] - x1;\n      var dy = flatCoordinates[offset2 + 1] - y1;\n      var offset;\n\n      if (dx === 0 && dy === 0) {\n        offset = offset1;\n      } else {\n        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n          offset = offset2;\n        } else if (t > 0) {\n          for (var i = 0; i < stride; ++i) {\n            closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n          }\n\n          closestPoint.length = stride;\n          return;\n        } else {\n          offset = offset1;\n        }\n      }\n\n      for (var i$1 = 0; i$1 < stride; ++i$1) {\n        closestPoint[i$1] = flatCoordinates[offset + i$1];\n      }\n\n      closestPoint.length = stride;\n    }\n    /**\n     * Return the squared of the largest distance between any pair of consecutive\n     * coordinates.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} max Max squared delta.\n     * @return {number} Max squared delta.\n     */\n\n\n    function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n      var x1 = flatCoordinates[offset];\n      var y1 = flatCoordinates[offset + 1];\n\n      for (offset += stride; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        var squaredDelta = squaredDistance(x1, y1, x2, y2);\n\n        if (squaredDelta > max) {\n          max = squaredDelta;\n        }\n\n        x1 = x2;\n        y1 = y2;\n      }\n\n      return max;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {number} max Max squared delta.\n     * @return {number} Max squared delta.\n     */\n\n\n    function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n        offset = end;\n      }\n\n      return max;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @param {number} max Max squared delta.\n     * @return {number} Max squared delta.\n     */\n\n\n    function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n        offset = ends[ends.length - 1];\n      }\n\n      return max;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} maxDelta Max delta.\n     * @param {boolean} isRing Is ring.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {Array<number>} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @param {Array<number>=} opt_tmpPoint Temporary point object.\n     * @return {number} Minimum squared distance.\n     */\n\n\n    function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n      if (offset == end) {\n        return minSquaredDistance;\n      }\n\n      var i, squaredDistance$$1;\n\n      if (maxDelta === 0) {\n        // All points are identical, so just test the first point.\n        squaredDistance$$1 = squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n\n        if (squaredDistance$$1 < minSquaredDistance) {\n          for (i = 0; i < stride; ++i) {\n            closestPoint[i] = flatCoordinates[offset + i];\n          }\n\n          closestPoint.length = stride;\n          return squaredDistance$$1;\n        } else {\n          return minSquaredDistance;\n        }\n      }\n\n      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n      var index = offset + stride;\n\n      while (index < end) {\n        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n        squaredDistance$$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n\n        if (squaredDistance$$1 < minSquaredDistance) {\n          minSquaredDistance = squaredDistance$$1;\n\n          for (i = 0; i < stride; ++i) {\n            closestPoint[i] = tmpPoint[i];\n          }\n\n          closestPoint.length = stride;\n          index += stride;\n        } else {\n          // Skip ahead multiple points, because we know that all the skipped\n          // points cannot be any closer than the closest point we have found so\n          // far.  We know this because we know how close the current point is, how\n          // close the closest point we have found so far is, and the maximum\n          // distance between consecutive points.  For example, if we're currently\n          // at distance 10, the best we've found so far is 3, and that the maximum\n          // distance between consecutive points is 2, then we'll need to skip at\n          // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n          // finding a closer point.  We use Math.max(..., 1) to ensure that we\n          // always advance at least one point, to avoid an infinite loop.\n          index += stride * Math.max((Math.sqrt(squaredDistance$$1) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n        }\n      }\n\n      if (isRing) {\n        // Check the closing segment.\n        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n        squaredDistance$$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n\n        if (squaredDistance$$1 < minSquaredDistance) {\n          minSquaredDistance = squaredDistance$$1;\n\n          for (i = 0; i < stride; ++i) {\n            closestPoint[i] = tmpPoint[i];\n          }\n\n          closestPoint.length = stride;\n        }\n      }\n\n      return minSquaredDistance;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {number} maxDelta Max delta.\n     * @param {boolean} isRing Is ring.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {Array<number>} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @param {Array<number>=} opt_tmpPoint Temporary point object.\n     * @return {number} Minimum squared distance.\n     */\n\n\n    function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = end;\n      }\n\n      return minSquaredDistance;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @param {number} maxDelta Max delta.\n     * @param {boolean} isRing Is ring.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {Array<number>} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @param {Array<number>=} opt_tmpPoint Temporary point object.\n     * @return {number} Minimum squared distance.\n     */\n\n\n    function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = ends[ends.length - 1];\n      }\n\n      return minSquaredDistance;\n    }\n    /**\n     * @module ol/geom/flat/deflate\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} stride Stride.\n     * @return {number} offset Offset.\n     */\n\n\n    function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n      for (var i = 0, ii = coordinate.length; i < ii; ++i) {\n        flatCoordinates[offset++] = coordinate[i];\n      }\n\n      return offset;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {number} stride Stride.\n     * @return {number} offset Offset.\n     */\n\n\n    function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        var coordinate = coordinates[i];\n\n        for (var j = 0; j < stride; ++j) {\n          flatCoordinates[offset++] = coordinate[j];\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n     * @param {number} stride Stride.\n     * @param {Array<number>=} opt_ends Ends.\n     * @return {Array<number>} Ends.\n     */\n\n\n    function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n      var ends = opt_ends ? opt_ends : [];\n      var i = 0;\n\n      for (var j = 0, jj = coordinatess.length; j < jj; ++j) {\n        var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);\n        ends[i++] = end;\n        offset = end;\n      }\n\n      ends.length = i;\n      return ends;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n     * @param {number} stride Stride.\n     * @param {Array<Array<number>>=} opt_endss Endss.\n     * @return {Array<Array<number>>} Endss.\n     */\n\n\n    function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n      var endss = opt_endss ? opt_endss : [];\n      var i = 0;\n\n      for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {\n        var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n        endss[i++] = ends;\n        offset = ends[ends.length - 1];\n      }\n\n      endss.length = i;\n      return endss;\n    }\n    /**\n     * @module ol/geom/flat/inflate\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {Array<import(\"../../coordinate.js\").Coordinate>=} opt_coordinates Coordinates.\n     * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n     */\n\n\n    function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\n      var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n      var i = 0;\n\n      for (var j = offset; j < end; j += stride) {\n        coordinates[i++] = flatCoordinates.slice(j, j + stride);\n      }\n\n      coordinates.length = i;\n      return coordinates;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>=} opt_coordinatess Coordinatess.\n     * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n     */\n\n\n    function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n      var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n      var i = 0;\n\n      for (var j = 0, jj = ends.length; j < jj; ++j) {\n        var end = ends[j];\n        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);\n        offset = end;\n      }\n\n      coordinatess.length = i;\n      return coordinatess;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>=} opt_coordinatesss\n     *     Coordinatesss.\n     * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n     */\n\n\n    function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n      var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n      var i = 0;\n\n      for (var j = 0, jj = endss.length; j < jj; ++j) {\n        var ends = endss[j];\n        coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);\n        offset = ends[ends.length - 1];\n      }\n\n      coordinatesss.length = i;\n      return coordinatesss;\n    }\n    /**\n     * @module ol/geom/flat/simplify\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n     *     coordinates.\n     * @param {number} simplifiedOffset Simplified offset.\n     * @return {number} Simplified offset.\n     */\n\n\n    function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n      var n = (end - offset) / stride;\n\n      if (n < 3) {\n        for (; offset < end; offset += stride) {\n          simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n          simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n        }\n\n        return simplifiedOffset;\n      }\n      /** @type {Array<number>} */\n\n\n      var markers = new Array(n);\n      markers[0] = 1;\n      markers[n - 1] = 1;\n      /** @type {Array<number>} */\n\n      var stack = [offset, end - stride];\n      var index = 0;\n\n      while (stack.length > 0) {\n        var last = stack.pop();\n        var first = stack.pop();\n        var maxSquaredDistance = 0;\n        var x1 = flatCoordinates[first];\n        var y1 = flatCoordinates[first + 1];\n        var x2 = flatCoordinates[last];\n        var y2 = flatCoordinates[last + 1];\n\n        for (var i = first + stride; i < last; i += stride) {\n          var x = flatCoordinates[i];\n          var y = flatCoordinates[i + 1];\n          var squaredDistance$$1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n\n          if (squaredDistance$$1 > maxSquaredDistance) {\n            index = i;\n            maxSquaredDistance = squaredDistance$$1;\n          }\n        }\n\n        if (maxSquaredDistance > squaredTolerance) {\n          markers[(index - offset) / stride] = 1;\n\n          if (first + stride < index) {\n            stack.push(first, index);\n          }\n\n          if (index + stride < last) {\n            stack.push(index, last);\n          }\n        }\n      }\n\n      for (var i$1 = 0; i$1 < n; ++i$1) {\n        if (markers[i$1]) {\n          simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride];\n          simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride + 1];\n        }\n      }\n\n      return simplifiedOffset;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n     *     coordinates.\n     * @param {number} simplifiedOffset Simplified offset.\n     * @param {Array<number>} simplifiedEnds Simplified ends.\n     * @return {number} Simplified offset.\n     */\n\n\n    function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n      }\n\n      return simplifiedOffset;\n    }\n    /**\n     * @param {number} value Value.\n     * @param {number} tolerance Tolerance.\n     * @return {number} Rounded value.\n     */\n\n\n    function snap(value, tolerance) {\n      return tolerance * Math.round(value / tolerance);\n    }\n    /**\n     * Simplifies a line string using an algorithm designed by Tim Schaub.\n     * Coordinates are snapped to the nearest value in a virtual grid and\n     * consecutive duplicate coordinates are discarded.  This effectively preserves\n     * topology as the simplification of any subsection of a line string is\n     * independent of the rest of the line string.  This means that, for examples,\n     * the common edge between two polygons will be simplified to the same line\n     * string independently in both polygons.  This implementation uses a single\n     * pass over the coordinates and eliminates intermediate collinear points.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} tolerance Tolerance.\n     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n     *     coordinates.\n     * @param {number} simplifiedOffset Simplified offset.\n     * @return {number} Simplified offset.\n     */\n\n\n    function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n      // do nothing if the line is empty\n      if (offset == end) {\n        return simplifiedOffset;\n      } // snap the first coordinate (P1)\n\n\n      var x1 = snap(flatCoordinates[offset], tolerance);\n      var y1 = snap(flatCoordinates[offset + 1], tolerance);\n      offset += stride; // add the first coordinate to the output\n\n      simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first\n      // coordinate (P2)\n\n      var x2, y2;\n\n      do {\n        x2 = snap(flatCoordinates[offset], tolerance);\n        y2 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n\n        if (offset == end) {\n          // all coordinates snap to the same value, the line collapses to a point\n          // push the last snapped value anyway to ensure that the output contains\n          // at least two points\n          // FIXME should we really return at least two points anyway?\n          simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n          simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n          return simplifiedOffset;\n        }\n      } while (x2 == x1 && y2 == y1);\n\n      while (offset < end) {\n        // snap the next coordinate (P3)\n        var x3 = snap(flatCoordinates[offset], tolerance);\n        var y3 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride; // skip P3 if it is equal to P2\n\n        if (x3 == x2 && y3 == y2) {\n          continue;\n        } // calculate the delta between P1 and P2\n\n\n        var dx1 = x2 - x1;\n        var dy1 = y2 - y1; // calculate the delta between P3 and P1\n\n        var dx2 = x3 - x1;\n        var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n        // P1 in the same direction then P2 is on the straight line between P1 and\n        // P3\n\n        if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n          // discard P2 and set P2 = P3\n          x2 = x3;\n          y2 = y3;\n          continue;\n        } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n        // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n        // and continue with P1 = P2 and P2 = P3\n\n\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n        x1 = x2;\n        y1 = y2;\n        x2 = x3;\n        y2 = y3;\n      } // add the last point (P2)\n\n\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {number} tolerance Tolerance.\n     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n     *     coordinates.\n     * @param {number} simplifiedOffset Simplified offset.\n     * @param {Array<number>} simplifiedEnds Simplified ends.\n     * @return {number} Simplified offset.\n     */\n\n\n    function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n      }\n\n      return simplifiedOffset;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @param {number} tolerance Tolerance.\n     * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n     *     coordinates.\n     * @param {number} simplifiedOffset Simplified offset.\n     * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n     * @return {number} Simplified offset.\n     */\n\n\n    function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n      }\n\n      return simplifiedOffset;\n    }\n    /**\n     * @module ol/geom/LinearRing\n     */\n\n    /**\n     * @classdesc\n     * Linear ring geometry. Only used as part of polygon; cannot be rendered\n     * on its own.\n     *\n     * @api\n     */\n\n\n    var LinearRing =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function LinearRing(coordinates, opt_layout) {\n        SimpleGeometry$$1.call(this);\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDeltaRevision_ = -1;\n\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n          this.setFlatCoordinates(opt_layout,\n          /** @type {Array<number>} */\n          coordinates);\n        } else {\n          this.setCoordinates(\n          /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n          coordinates, opt_layout);\n        }\n      }\n\n      if (SimpleGeometry$$1) LinearRing.__proto__ = SimpleGeometry$$1;\n      LinearRing.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      LinearRing.prototype.constructor = LinearRing;\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!LinearRing} Clone.\n       * @override\n       * @api\n       */\n\n      LinearRing.prototype.clone = function clone$$1() {\n        return new LinearRing(this.flatCoordinates.slice(), this.layout);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LinearRing.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n          return minSquaredDistance;\n        }\n\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n          this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n          this.maxDeltaRevision_ = this.getRevision();\n        }\n\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n      };\n      /**\n       * Return the area of the linear ring on projected plane.\n       * @return {number} Area (on projected plane).\n       * @api\n       */\n\n\n      LinearRing.prototype.getArea = function getArea$$1() {\n        return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n      };\n      /**\n       * Return the coordinates of the linear ring.\n       * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n       * @override\n       * @api\n       */\n\n\n      LinearRing.prototype.getCoordinates = function getCoordinates() {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LinearRing.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      LinearRing.prototype.getType = function getType() {\n        return GeometryType.LINEAR_RING;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LinearRing.prototype.intersectsExtent = function intersectsExtent(extent) {\n        return false;\n      };\n      /**\n       * Set the coordinates of the linear ring.\n       * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n       * @param {GeometryLayout=} opt_layout Layout.\n       * @override\n       * @api\n       */\n\n\n      LinearRing.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n      };\n\n      return LinearRing;\n    }(SimpleGeometry);\n    /**\n     * @module ol/geom/Point\n     */\n\n    /**\n     * @classdesc\n     * Point geometry.\n     *\n     * @api\n     */\n\n\n    var Point =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function Point(coordinates, opt_layout) {\n        SimpleGeometry$$1.call(this);\n        this.setCoordinates(coordinates, opt_layout);\n      }\n\n      if (SimpleGeometry$$1) Point.__proto__ = SimpleGeometry$$1;\n      Point.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      Point.prototype.constructor = Point;\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!Point} Clone.\n       * @override\n       * @api\n       */\n\n      Point.prototype.clone = function clone$$1() {\n        var point = new Point(this.flatCoordinates.slice(), this.layout);\n        return point;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Point.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var squaredDistance$$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);\n\n        if (squaredDistance$$1 < minSquaredDistance) {\n          var stride = this.stride;\n\n          for (var i = 0; i < stride; ++i) {\n            closestPoint[i] = flatCoordinates[i];\n          }\n\n          closestPoint.length = stride;\n          return squaredDistance$$1;\n        } else {\n          return minSquaredDistance;\n        }\n      };\n      /**\n       * Return the coordinate of the point.\n       * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n       * @override\n       * @api\n       */\n\n\n      Point.prototype.getCoordinates = function getCoordinates() {\n        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Point.prototype.computeExtent = function computeExtent(extent) {\n        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      Point.prototype.getType = function getType() {\n        return GeometryType.POINT;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      Point.prototype.intersectsExtent = function intersectsExtent(extent) {\n        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      Point.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 0);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n\n        this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n      };\n\n      return Point;\n    }(SimpleGeometry);\n    /**\n     * @module ol/geom/flat/contains\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @return {boolean} Contains extent.\n     */\n\n\n    function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {\n      var outside = forEachCorner(extent,\n      /**\n       * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @return {boolean} Contains (x, y).\n       */\n      function (coordinate) {\n        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);\n      });\n      return !outside;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n\n\n    function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {\n      // http://geomalgorithms.com/a03-_inclusion.html\n      // Copyright 2000 softSurfer, 2012 Dan Sunday\n      // This code may be freely used and modified for any purpose\n      // providing that this copyright notice is included with it.\n      // SoftSurfer makes no warranty for this code, and cannot be held\n      // liable for any real or imagined damage resulting from its use.\n      // Users of this code must verify correctness for their application.\n      var wn = 0;\n      var x1 = flatCoordinates[end - stride];\n      var y1 = flatCoordinates[end - stride + 1];\n\n      for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n\n        if (y1 <= y) {\n          if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n            wn++;\n          }\n        } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n          wn--;\n        }\n\n        x1 = x2;\n        y1 = y2;\n      }\n\n      return wn !== 0;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n\n\n    function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {\n      if (ends.length === 0) {\n        return false;\n      }\n\n      if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n        return false;\n      }\n\n      for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n\n\n    function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {\n      if (endss.length === 0) {\n        return false;\n      }\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n\n        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n          return true;\n        }\n\n        offset = ends[ends.length - 1];\n      }\n\n      return false;\n    }\n    /**\n     * @module ol/geom/flat/interiorpoint\n     */\n\n    /**\n     * Calculates a point that is likely to lie in the interior of the linear rings.\n     * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<number>} flatCenters Flat centers.\n     * @param {number} flatCentersOffset Flat center offset.\n     * @param {Array<number>=} opt_dest Destination.\n     * @return {Array<number>} Destination point as XYM coordinate, where M is the\n     * length of the horizontal intersection that the point belongs to.\n     */\n\n\n    function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n      var i, ii, x, x1, x2, y1, y2;\n      var y = flatCenters[flatCentersOffset + 1];\n      /** @type {Array<number>} */\n\n      var intersections = []; // Calculate intersections with the horizontal line\n\n      for (var r = 0, rr = ends.length; r < rr; ++r) {\n        var end = ends[r];\n        x1 = flatCoordinates[end - stride];\n        y1 = flatCoordinates[end - stride + 1];\n\n        for (i = offset; i < end; i += stride) {\n          x2 = flatCoordinates[i];\n          y2 = flatCoordinates[i + 1];\n\n          if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {\n            x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\n            intersections.push(x);\n          }\n\n          x1 = x2;\n          y1 = y2;\n        }\n      } // Find the longest segment of the horizontal line that has its center point\n      // inside the linear ring.\n\n\n      var pointX = NaN;\n      var maxSegmentLength = -Infinity;\n      intersections.sort(numberSafeCompareFunction);\n      x1 = intersections[0];\n\n      for (i = 1, ii = intersections.length; i < ii; ++i) {\n        x2 = intersections[i];\n        var segmentLength = Math.abs(x2 - x1);\n\n        if (segmentLength > maxSegmentLength) {\n          x = (x1 + x2) / 2;\n\n          if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n            pointX = x;\n            maxSegmentLength = segmentLength;\n          }\n        }\n\n        x1 = x2;\n      }\n\n      if (isNaN(pointX)) {\n        // There is no horizontal line that has its center point inside the linear\n        // ring.  Use the center of the the linear ring's extent.\n        pointX = flatCenters[flatCentersOffset];\n      }\n\n      if (opt_dest) {\n        opt_dest.push(pointX, y, maxSegmentLength);\n        return opt_dest;\n      } else {\n        return [pointX, y, maxSegmentLength];\n      }\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @param {Array<number>} flatCenters Flat centers.\n     * @return {Array<number>} Interior points as XYM coordinates, where M is the\n     * length of the horizontal intersection that the point belongs to.\n     */\n\n\n    function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n      var interiorPoints = [];\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n        offset = ends[ends.length - 1];\n      }\n\n      return interiorPoints;\n    }\n    /**\n     * @module ol/geom/flat/segments\n     */\n\n    /**\n     * This function calls `callback` for each segment of the flat coordinates\n     * array. If the callback returns a truthy value the function returns that\n     * value immediately. Otherwise the function returns `false`.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {function(this: S, import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n     *     called for each segment.\n     * @param {S=} opt_this The object to be used as the value of 'this'\n     *     within callback.\n     * @return {T|boolean} Value.\n     * @template T,S\n     */\n\n\n    function forEach(flatCoordinates, offset, end, stride, callback, opt_this) {\n      var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n      var point2 = [];\n      var ret;\n\n      for (; offset + stride < end; offset += stride) {\n        point2[0] = flatCoordinates[offset + stride];\n        point2[1] = flatCoordinates[offset + stride + 1];\n        ret = callback.call(opt_this, point1, point2);\n\n        if (ret) {\n          return ret;\n        }\n\n        point1[0] = point2[0];\n        point1[1] = point2[1];\n      }\n\n      return false;\n    }\n    /**\n     * @module ol/geom/flat/intersectsextent\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @return {boolean} True if the geometry and the extent intersect.\n     */\n\n\n    function intersectsLineString(flatCoordinates, offset, end, stride, extent) {\n      var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n\n      if (!intersects(extent, coordinatesExtent)) {\n        return false;\n      }\n\n      if (containsExtent(extent, coordinatesExtent)) {\n        return true;\n      }\n\n      if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n        return true;\n      }\n\n      if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n        return true;\n      }\n\n      return forEach(flatCoordinates, offset, end, stride,\n      /**\n       * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n       * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n       * @return {boolean} `true` if the segment and the extent intersect,\n       *     `false` otherwise.\n       */\n      function (point1, point2) {\n        return intersectsSegment(extent, point1, point2);\n      });\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @return {boolean} True if the geometry and the extent intersect.\n     */\n\n\n    function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {\n          return true;\n        }\n\n        offset = ends[i];\n      }\n\n      return false;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @return {boolean} True if the geometry and the extent intersect.\n     */\n\n\n    function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\n      if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n        return true;\n      }\n\n      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n        return true;\n      }\n\n      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n        return true;\n      }\n\n      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n        return true;\n      }\n\n      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @return {boolean} True if the geometry and the extent intersect.\n     */\n\n\n    function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\n      if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n        return false;\n      }\n\n      if (ends.length === 1) {\n        return true;\n      }\n\n      for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n          if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @return {boolean} True if the geometry and the extent intersect.\n     */\n\n\n    function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n\n        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {\n          return true;\n        }\n\n        offset = ends[ends.length - 1];\n      }\n\n      return false;\n    }\n    /**\n     * @module ol/geom/flat/reverse\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     */\n\n\n    function coordinates(flatCoordinates, offset, end, stride) {\n      while (offset < end - stride) {\n        for (var i = 0; i < stride; ++i) {\n          var tmp = flatCoordinates[offset + i];\n          flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n          flatCoordinates[end - stride + i] = tmp;\n        }\n\n        offset += stride;\n        end -= stride;\n      }\n    }\n    /**\n     * @module ol/geom/flat/orient\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @return {boolean} Is clockwise.\n     */\n\n\n    function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n      // http://tinyurl.com/clockwise-method\n      // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n      var edge = 0;\n      var x1 = flatCoordinates[end - stride];\n      var y1 = flatCoordinates[end - stride + 1];\n\n      for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        edge += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n      }\n\n      return edge > 0;\n    }\n    /**\n     * Determines if linear rings are oriented.  By default, left-hand orientation\n     * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n     * To test for right-hand orientation, use the `opt_right` argument.\n     *\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Array of end indexes.\n     * @param {number} stride Stride.\n     * @param {boolean=} opt_right Test for right-hand orientation\n     *     (counter-clockwise exterior ring and clockwise interior rings).\n     * @return {boolean} Rings are correctly oriented.\n     */\n\n\n    function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {\n      var right = opt_right !== undefined ? opt_right : false;\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n\n        if (i === 0) {\n          if (right && isClockwise || !right && !isClockwise) {\n            return false;\n          }\n        } else {\n          if (right && !isClockwise || !right && isClockwise) {\n            return false;\n          }\n        }\n\n        offset = end;\n      }\n\n      return true;\n    }\n    /**\n     * Determines if linear rings are oriented.  By default, left-hand orientation\n     * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n     * To test for right-hand orientation, use the `opt_right` argument.\n     *\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Array of array of end indexes.\n     * @param {number} stride Stride.\n     * @param {boolean=} opt_right Test for right-hand orientation\n     *     (counter-clockwise exterior ring and clockwise interior rings).\n     * @return {boolean} Rings are correctly oriented.\n     */\n\n\n    function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        if (!linearRingIsOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Orient coordinates in a flat array of linear rings.  By default, rings\n     * are oriented following the left-hand rule (clockwise for exterior and\n     * counter-clockwise for interior rings).  To orient according to the\n     * right-hand rule, use the `opt_right` argument.\n     *\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n     * @return {number} End.\n     */\n\n\n    function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n      var right = opt_right !== undefined ? opt_right : false;\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n\n        if (reverse) {\n          coordinates(flatCoordinates, offset, end, stride);\n        }\n\n        offset = end;\n      }\n\n      return offset;\n    }\n    /**\n     * Orient coordinates in a flat array of linear rings.  By default, rings\n     * are oriented following the left-hand rule (clockwise for exterior and\n     * counter-clockwise for interior rings).  To orient according to the\n     * right-hand rule, use the `opt_right` argument.\n     *\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Array of array of end indexes.\n     * @param {number} stride Stride.\n     * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n     * @return {number} End.\n     */\n\n\n    function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n      }\n\n      return offset;\n    }\n    /**\n     * @module ol/geom/Polygon\n     */\n\n    /**\n     * @classdesc\n     * Polygon geometry.\n     *\n     * @api\n     */\n\n\n    var Polygon =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function Polygon(coordinates, opt_layout, opt_ends) {\n        SimpleGeometry$$1.call(this);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n\n        this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.flatInteriorPointRevision_ = -1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n\n        this.flatInteriorPoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.orientedFlatCoordinates_ = null;\n\n        if (opt_layout !== undefined && opt_ends) {\n          this.setFlatCoordinates(opt_layout,\n          /** @type {Array<number>} */\n          coordinates);\n          this.ends_ = opt_ends;\n        } else {\n          this.setCoordinates(\n          /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */\n          coordinates, opt_layout);\n        }\n      }\n\n      if (SimpleGeometry$$1) Polygon.__proto__ = SimpleGeometry$$1;\n      Polygon.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      Polygon.prototype.constructor = Polygon;\n      /**\n       * Append the passed linear ring to this polygon.\n       * @param {LinearRing} linearRing Linear ring.\n       * @api\n       */\n\n      Polygon.prototype.appendLinearRing = function appendLinearRing(linearRing$$1) {\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = linearRing$$1.getFlatCoordinates().slice();\n        } else {\n          extend(this.flatCoordinates, linearRing$$1.getFlatCoordinates());\n        }\n\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n      };\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!Polygon} Clone.\n       * @override\n       * @api\n       */\n\n\n      Polygon.prototype.clone = function clone$$1() {\n        return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Polygon.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n          return minSquaredDistance;\n        }\n\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n          this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n          this.maxDeltaRevision_ = this.getRevision();\n        }\n\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Polygon.prototype.containsXY = function containsXY$$1(x, y) {\n        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n      };\n      /**\n       * Return the area of the polygon on projected plane.\n       * @return {number} Area (on projected plane).\n       * @api\n       */\n\n\n      Polygon.prototype.getArea = function getArea$$1() {\n        return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n      };\n      /**\n       * Get the coordinate array for this geometry.  This array has the structure\n       * of a GeoJSON coordinate array for polygons.\n       *\n       * @param {boolean=} opt_right Orient coordinates according to the right-hand\n       *     rule (counter-clockwise for exterior and clockwise for interior rings).\n       *     If `false`, coordinates will be oriented according to the left-hand rule\n       *     (clockwise for exterior and counter-clockwise for interior rings).\n       *     By default, coordinate orientation will depend on how the geometry was\n       *     constructed.\n       * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n       * @override\n       * @api\n       */\n\n\n      Polygon.prototype.getCoordinates = function getCoordinates(opt_right) {\n        var flatCoordinates;\n\n        if (opt_right !== undefined) {\n          flatCoordinates = this.getOrientedFlatCoordinates().slice();\n          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n        } else {\n          flatCoordinates = this.flatCoordinates;\n        }\n\n        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n      };\n      /**\n       * @return {Array<number>} Ends.\n       */\n\n\n      Polygon.prototype.getEnds = function getEnds() {\n        return this.ends_;\n      };\n      /**\n       * @return {Array<number>} Interior point.\n       */\n\n\n      Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint() {\n        if (this.flatInteriorPointRevision_ != this.getRevision()) {\n          var flatCenter = getCenter(this.getExtent());\n          this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n          this.flatInteriorPointRevision_ = this.getRevision();\n        }\n\n        return this.flatInteriorPoint_;\n      };\n      /**\n       * Return an interior point of the polygon.\n       * @return {Point} Interior point as XYM coordinate, where M is the\n       * length of the horizontal intersection that the point belongs to.\n       * @api\n       */\n\n\n      Polygon.prototype.getInteriorPoint = function getInteriorPoint() {\n        return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n      };\n      /**\n       * Return the number of rings of the polygon,  this includes the exterior\n       * ring and any interior rings.\n       *\n       * @return {number} Number of rings.\n       * @api\n       */\n\n\n      Polygon.prototype.getLinearRingCount = function getLinearRingCount() {\n        return this.ends_.length;\n      };\n      /**\n       * Return the Nth linear ring of the polygon geometry. Return `null` if the\n       * given index is out of range.\n       * The exterior linear ring is available at index `0` and the interior rings\n       * at index `1` and beyond.\n       *\n       * @param {number} index Index.\n       * @return {LinearRing} Linear ring.\n       * @api\n       */\n\n\n      Polygon.prototype.getLinearRing = function getLinearRing(index) {\n        if (index < 0 || this.ends_.length <= index) {\n          return null;\n        }\n\n        return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n      };\n      /**\n       * Return the linear rings of the polygon.\n       * @return {Array<LinearRing>} Linear rings.\n       * @api\n       */\n\n\n      Polygon.prototype.getLinearRings = function getLinearRings() {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var linearRings$$1 = [];\n        var offset$$1 = 0;\n\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n          var linearRing$$1 = new LinearRing(flatCoordinates.slice(offset$$1, end), layout);\n          linearRings$$1.push(linearRing$$1);\n          offset$$1 = end;\n        }\n\n        return linearRings$$1;\n      };\n      /**\n       * @return {Array<number>} Oriented flat coordinates.\n       */\n\n\n      Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates() {\n        if (this.orientedRevision_ != this.getRevision()) {\n          var flatCoordinates = this.flatCoordinates;\n\n          if (linearRingIsOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n            this.orientedFlatCoordinates_ = flatCoordinates;\n          } else {\n            this.orientedFlatCoordinates_ = flatCoordinates.slice();\n            this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n          }\n\n          this.orientedRevision_ = this.getRevision();\n        }\n\n        return this.orientedFlatCoordinates_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      Polygon.prototype.getType = function getType() {\n        return GeometryType.POLYGON;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      Polygon.prototype.intersectsExtent = function intersectsExtent(extent) {\n        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n      };\n      /**\n       * Set the coordinates of the polygon.\n       * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n       * @param {GeometryLayout=} opt_layout Layout.\n       * @override\n       * @api\n       */\n\n\n      Polygon.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n      };\n\n      return Polygon;\n    }(SimpleGeometry);\n    /**\n     * Create a polygon from an extent. The layout used is `XY`.\n     * @param {import(\"../extent.js\").Extent} extent The extent.\n     * @return {Polygon} The polygon.\n     * @api\n     */\n\n\n    function fromExtent(extent) {\n      var minX = extent[0];\n      var minY = extent[1];\n      var maxX = extent[2];\n      var maxY = extent[3];\n      var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n      return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n    }\n    /**\n     * Create a regular polygon from a circle.\n     * @param {import(\"./Circle.js\").default} circle Circle geometry.\n     * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n     * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n     *     radians. Default is 0.\n     * @return {Polygon} Polygon geometry.\n     * @api\n     */\n\n\n    function fromCircle(circle, opt_sides, opt_angle) {\n      var sides = opt_sides ? opt_sides : 32;\n      var stride = circle.getStride();\n      var layout = circle.getLayout();\n      var center = circle.getCenter();\n      var arrayLength = stride * (sides + 1);\n      var flatCoordinates = new Array(arrayLength);\n\n      for (var i = 0; i < arrayLength; i += stride) {\n        flatCoordinates[i] = 0;\n        flatCoordinates[i + 1] = 0;\n\n        for (var j = 2; j < stride; j++) {\n          flatCoordinates[i + j] = center[j];\n        }\n      }\n\n      var ends = [flatCoordinates.length];\n      var polygon = new Polygon(flatCoordinates, layout, ends);\n      makeRegular(polygon, center, circle.getRadius(), opt_angle);\n      return polygon;\n    }\n    /**\n     * Modify the coordinates of a polygon to make it a regular polygon.\n     * @param {Polygon} polygon Polygon geometry.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n     * @param {number} radius Radius of the regular polygon.\n     * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n     *     radians. Default is 0.\n     */\n\n\n    function makeRegular(polygon, center, radius, opt_angle) {\n      var flatCoordinates = polygon.getFlatCoordinates();\n      var stride = polygon.getStride();\n      var sides = flatCoordinates.length / stride - 1;\n      var startAngle = opt_angle ? opt_angle : 0;\n\n      for (var i = 0; i <= sides; ++i) {\n        var offset$$1 = i * stride;\n        var angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;\n        flatCoordinates[offset$$1] = center[0] + radius * Math.cos(angle);\n        flatCoordinates[offset$$1 + 1] = center[1] + radius * Math.sin(angle);\n      }\n\n      polygon.changed();\n    }\n    /**\n     * @module ol/View\n     */\n\n    /**\n     * An animation configuration\n     *\n     * @typedef {Object} Animation\n     * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter]\n     * @property {import(\"./coordinate.js\").Coordinate} [targetCenter]\n     * @property {number} [sourceResolution]\n     * @property {number} [targetResolution]\n     * @property {number} [sourceRotation]\n     * @property {number} [targetRotation]\n     * @property {import(\"./coordinate.js\").Coordinate} [anchor]\n     * @property {number} start\n     * @property {number} duration\n     * @property {boolean} complete\n     * @property {function(number):number} easing\n     * @property {function(boolean)} callback\n     */\n\n    /**\n     * @typedef {Object} Constraints\n     * @property {import(\"./centerconstraint.js\").Type} center\n     * @property {import(\"./resolutionconstraint.js\").Type} resolution\n     * @property {import(\"./rotationconstraint.js\").Type} rotation\n     */\n\n    /**\n     * @typedef {Object} FitOptions\n     * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to fit\n     * the extent into. Default is the current size of the first map in the DOM that\n     * uses this view, or `[100, 100]` if no such map is found.\n     * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n     * cleared inside the view. Values in the array are top, right, bottom and left\n     * padding.\n     * @property {boolean} [constrainResolution=true] Constrain the resolution.\n     * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get\n     * the nearest extent instead of the closest that actually fits the view.\n     * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n     * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n     * `minResolution` is given, this property is ignored.\n     * @property {number} [duration] The duration of the animation in milliseconds.\n     * By default, there is no animation to the target extent.\n     * @property {function(number):number} [easing] The easing function used during\n     * the animation (defaults to {@link module:ol/easing~inAndOut}).\n     * The function will be called for each frame with a number representing a\n     * fraction of the animation's duration.  The function should return a number\n     * between 0 and 1 representing the progress toward the destination state.\n     * @property {function(boolean)} [callback] Function called when the view is in\n     * its final position. The callback will be called with `true` if the animation\n     * series completed on its own or `false` if it was cancelled.\n     */\n\n    /**\n     * @typedef {Object} ViewOptions\n     * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n     * the view. The coordinate system for the center is specified with the\n     * `projection` option. Layer sources will not be fetched if this is not set,\n     * but the center can be set later with {@link #setCenter}.\n     * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n     * `false` means no constraint. `true` means no constraint, but snap to zero\n     * near zero. A number constrains the rotation to that number of values. For\n     * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n     * @property {boolean} [enableRotation=true] Enable rotation.\n     * If `false`, a rotation constraint that always sets the rotation to zero is\n     * used. The `constrainRotation` option has no effect if `enableRotation` is\n     * `false`.\n     * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n     * center, in other words, center cannot be set outside this extent.\n     * @property {number} [maxResolution] The maximum resolution used to determine\n     * the resolution constraint. It is used together with `minResolution` (or\n     * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n     * that the projection's validity extent fits in a 256x256 px tile. If the\n     * projection is Spherical Mercator (the default) then `maxResolution` defaults\n     * to `40075016.68557849 / 256 = 156543.03392804097`.\n     * @property {number} [minResolution] The minimum resolution used to determine\n     * the resolution constraint.  It is used together with `maxResolution` (or\n     * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n     * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n     * (the default) then `minResolution` defaults to\n     * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n     * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n     * resolution constraint. It is used together with `minZoom` (or\n     * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n     * provided, it is given precedence over `maxZoom`.\n     * @property {number} [minZoom=0] The minimum zoom level used to determine the\n     * resolution constraint. It is used together with `maxZoom` (or\n     * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n     * provided, it is given precedence over `minZoom`.\n     * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n     * projection. The default is Spherical Mercator.\n     * @property {number} [resolution] The initial resolution for the view. The\n     * units are `projection` units per pixel (e.g. meters per pixel). An\n     * alternative to setting this is to set `zoom`. Layer sources will not be\n     * fetched if neither this nor `zoom` are defined, but they can be set later\n     * with {@link #setZoom} or {@link #setResolution}.\n     * @property {Array<number>} [resolutions] Resolutions to determine the\n     * resolution constraint. If set the `maxResolution`, `minResolution`,\n     * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n     * @property {number} [rotation=0] The initial rotation for the view in radians\n     * (positive rotation clockwise, 0 means North).\n     * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n     * level used to calculate the initial resolution for the view. The initial\n     * resolution is determined using the {@link #constrainResolution} method.\n     * @property {number} [zoomFactor=2] The zoom factor used to determine the\n     * resolution constraint.\n     */\n\n    /**\n     * @typedef {Object} AnimationOptions\n     * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n     * the animation.\n     * @property {number} [zoom] The zoom level of the view at the end of the\n     * animation. This takes precedence over `resolution`.\n     * @property {number} [resolution] The resolution of the view at the end\n     * of the animation.  If `zoom` is also provided, this option will be ignored.\n     * @property {number} [rotation] The rotation of the view at the end of\n     * the animation.\n     * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remained fixed\n     * during a rotation or resolution animation.\n     * @property {number} [duration=1000] The duration of the animation in milliseconds.\n     * @property {function(number):number} [easing] The easing function used\n     * during the animation (defaults to {@link module:ol/easing~inAndOut}).\n     * The function will be called for each frame with a number representing a\n     * fraction of the animation's duration.  The function should return a number\n     * between 0 and 1 representing the progress toward the destination state.\n     */\n\n    /**\n     * @typedef {Object} State\n     * @property {import(\"./coordinate.js\").Coordinate} center\n     * @property {import(\"./proj/Projection.js\").default} projection\n     * @property {number} resolution\n     * @property {number} rotation\n     * @property {number} zoom\n     */\n\n    /**\n     * Default min zoom level for the map view.\n     * @type {number}\n     */\n\n\n    var DEFAULT_MIN_ZOOM = 0;\n    /**\n     * @classdesc\n     * A View object represents a simple 2D view of the map.\n     *\n     * This is the object to act upon to change the center, resolution,\n     * and rotation of the map.\n     *\n     * ### The view states\n     *\n     * An View is determined by three states: `center`, `resolution`,\n     * and `rotation`. Each state has a corresponding getter and setter, e.g.\n     * `getCenter` and `setCenter` for the `center` state.\n     *\n     * An View has a `projection`. The projection determines the\n     * coordinate system of the center, and its units determine the units of the\n     * resolution (projection units per pixel). The default projection is\n     * Spherical Mercator (EPSG:3857).\n     *\n     * ### The constraints\n     *\n     * `setCenter`, `setResolution` and `setRotation` can be used to change the\n     * states of the view. Any value can be passed to the setters. And the value\n     * that is passed to a setter will effectively be the value set in the view,\n     * and returned by the corresponding getter.\n     *\n     * But a View object also has a *resolution constraint*, a\n     * *rotation constraint* and a *center constraint*.\n     *\n     * As said above, no constraints are applied when the setters are used to set\n     * new states for the view. Applying constraints is done explicitly through\n     * the use of the `constrain*` functions (`constrainResolution` and\n     * `constrainRotation` and `constrainCenter`).\n     *\n     * The main users of the constraints are the interactions and the\n     * controls. For example, double-clicking on the map changes the view to\n     * the \"next\" resolution. And releasing the fingers after pinch-zooming\n     * snaps to the closest resolution (with an animation).\n     *\n     * The *resolution constraint* snaps to specific resolutions. It is\n     * determined by the following options: `resolutions`, `maxResolution`,\n     * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three\n     * options are ignored. See documentation for each option for more\n     * information.\n     *\n     * The *rotation constraint* snaps to specific angles. It is determined\n     * by the following options: `enableRotation` and `constrainRotation`.\n     * By default the rotation value is snapped to zero when approaching the\n     * horizontal.\n     *\n     * The *center constraint* is determined by the `extent` option. By\n     * default the center is not constrained at all.\n     *\n      * @api\n     */\n\n    var View =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function View(opt_options) {\n        BaseObject$$1.call(this);\n        var options = assign({}, opt_options);\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.hints_ = [0, 0];\n        /**\n         * @private\n         * @type {Array<Array<Animation>>}\n         */\n\n        this.animations_ = [];\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.updateAnimationKey_;\n        this.updateAnimations_ = this.updateAnimations_.bind(this);\n        /**\n         * @private\n         * @const\n         * @type {import(\"./proj/Projection.js\").default}\n         */\n\n        this.projection_ = createProjection(options.projection, 'EPSG:3857');\n        this.applyOptions_(options);\n      }\n\n      if (BaseObject$$1) View.__proto__ = BaseObject$$1;\n      View.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      View.prototype.constructor = View;\n      /**\n       * Set up the view with the given options.\n       * @param {ViewOptions} options View options.\n       */\n\n      View.prototype.applyOptions_ = function applyOptions_(options) {\n        /**\n         * @type {Object<string, *>}\n         */\n        var properties = {};\n        properties[ViewProperty.CENTER] = options.center !== undefined ? options.center : null;\n        var resolutionConstraintInfo = createResolutionConstraint(options);\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.minResolution_ = resolutionConstraintInfo.minResolution;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n        /**\n         * @private\n         * @type {Array<number>|undefined}\n         */\n\n        this.resolutions_ = options.resolutions;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.minZoom_ = resolutionConstraintInfo.minZoom;\n        var centerConstraint = createCenterConstraint(options);\n        var resolutionConstraint = resolutionConstraintInfo.constraint;\n        var rotationConstraint = createRotationConstraint(options);\n        /**\n         * @private\n         * @type {Constraints}\n         */\n\n        this.constraints_ = {\n          center: centerConstraint,\n          resolution: resolutionConstraint,\n          rotation: rotationConstraint\n        };\n\n        if (options.resolution !== undefined) {\n          properties[ViewProperty.RESOLUTION] = options.resolution;\n        } else if (options.zoom !== undefined) {\n          properties[ViewProperty.RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);\n\n          if (this.resolutions_) {\n            // in case map zoom is out of min/max zoom range\n            properties[ViewProperty.RESOLUTION] = clamp(Number(this.getResolution() || properties[ViewProperty.RESOLUTION]), this.minResolution_, this.maxResolution_);\n          }\n        }\n\n        properties[ViewProperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;\n        this.setProperties(properties);\n        /**\n         * @private\n         * @type {ViewOptions}\n         */\n\n        this.options_ = options;\n      };\n      /**\n       * Get an updated version of the view options used to construct the view.  The\n       * current resolution (or zoom), center, and rotation are applied to any stored\n       * options.  The provided options can be used to apply new min/max zoom or\n       * resolution limits.\n       * @param {ViewOptions} newOptions New options to be applied.\n       * @return {ViewOptions} New options updated with the current view state.\n       */\n\n\n      View.prototype.getUpdatedOptions_ = function getUpdatedOptions_(newOptions) {\n        var options = assign({}, this.options_); // preserve resolution (or zoom)\n\n        if (options.resolution !== undefined) {\n          options.resolution = this.getResolution();\n        } else {\n          options.zoom = this.getZoom();\n        } // preserve center\n\n\n        options.center = this.getCenter(); // preserve rotation\n\n        options.rotation = this.getRotation();\n        return assign({}, options, newOptions);\n      };\n      /**\n       * Animate the view.  The view's center, zoom (or resolution), and rotation\n       * can be animated for smooth transitions between view states.  For example,\n       * to animate the view to a new zoom level:\n       *\n       *     view.animate({zoom: view.getZoom() + 1});\n       *\n       * By default, the animation lasts one second and uses in-and-out easing.  You\n       * can customize this behavior by including `duration` (in milliseconds) and\n       * `easing` options (see {@link module:ol/easing}).\n       *\n       * To chain together multiple animations, call the method with multiple\n       * animation objects.  For example, to first zoom and then pan:\n       *\n       *     view.animate({zoom: 10}, {center: [0, 0]});\n       *\n       * If you provide a function as the last argument to the animate method, it\n       * will get called at the end of an animation series.  The callback will be\n       * called with `true` if the animation series completed on its own or `false`\n       * if it was cancelled.\n       *\n       * Animations are cancelled by user interactions (e.g. dragging the map) or by\n       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n       * (or another method that calls one of these).\n       *\n       * @param {...(AnimationOptions|function(boolean))} var_args Animation\n       *     options.  Multiple animations can be run in series by passing multiple\n       *     options objects.  To run multiple animations in parallel, call the method\n       *     multiple times.  An optional callback can be provided as a final\n       *     argument.  The callback will be called with a boolean indicating whether\n       *     the animation completed without being cancelled.\n       * @api\n       */\n\n\n      View.prototype.animate = function animate(var_args) {\n        var arguments$1 = arguments;\n        var animationCount = arguments.length;\n        var callback;\n\n        if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {\n          callback = arguments[animationCount - 1];\n          --animationCount;\n        }\n\n        if (!this.isDef()) {\n          // if view properties are not yet set, shortcut to the final state\n          var state = arguments[animationCount - 1];\n\n          if (state.center) {\n            this.setCenter(state.center);\n          }\n\n          if (state.zoom !== undefined) {\n            this.setZoom(state.zoom);\n          }\n\n          if (state.rotation !== undefined) {\n            this.setRotation(state.rotation);\n          }\n\n          if (callback) {\n            animationCallback(callback, true);\n          }\n\n          return;\n        }\n\n        var start = Date.now();\n        var center = this.getCenter().slice();\n        var resolution = this.getResolution();\n        var rotation = this.getRotation();\n        var series = [];\n\n        for (var i = 0; i < animationCount; ++i) {\n          var options =\n          /** @type {AnimationOptions} */\n          arguments$1[i];\n          var animation =\n          /** @type {Animation} */\n          {\n            start: start,\n            complete: false,\n            anchor: options.anchor,\n            duration: options.duration !== undefined ? options.duration : 1000,\n            easing: options.easing || inAndOut\n          };\n\n          if (options.center) {\n            animation.sourceCenter = center;\n            animation.targetCenter = options.center;\n            center = animation.targetCenter;\n          }\n\n          if (options.zoom !== undefined) {\n            animation.sourceResolution = resolution;\n            animation.targetResolution = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_, 0);\n            resolution = animation.targetResolution;\n          } else if (options.resolution) {\n            animation.sourceResolution = resolution;\n            animation.targetResolution = options.resolution;\n            resolution = animation.targetResolution;\n          }\n\n          if (options.rotation !== undefined) {\n            animation.sourceRotation = rotation;\n            var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n            animation.targetRotation = rotation + delta;\n            rotation = animation.targetRotation;\n          }\n\n          animation.callback = callback; // check if animation is a no-op\n\n          if (isNoopAnimation(animation)) {\n            animation.complete = true; // we still push it onto the series for callback handling\n          } else {\n            start += animation.duration;\n          }\n\n          series.push(animation);\n        }\n\n        this.animations_.push(series);\n        this.setHint(ViewHint.ANIMATING, 1);\n        this.updateAnimations_();\n      };\n      /**\n       * Determine if the view is being animated.\n       * @return {boolean} The view is being animated.\n       * @api\n       */\n\n\n      View.prototype.getAnimating = function getAnimating() {\n        return this.hints_[ViewHint.ANIMATING] > 0;\n      };\n      /**\n       * Determine if the user is interacting with the view, such as panning or zooming.\n       * @return {boolean} The view is being interacted with.\n       * @api\n       */\n\n\n      View.prototype.getInteracting = function getInteracting() {\n        return this.hints_[ViewHint.INTERACTING] > 0;\n      };\n      /**\n       * Cancel any ongoing animations.\n       * @api\n       */\n\n\n      View.prototype.cancelAnimations = function cancelAnimations() {\n        this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n\n        for (var i = 0, ii = this.animations_.length; i < ii; ++i) {\n          var series = this.animations_[i];\n\n          if (series[0].callback) {\n            animationCallback(series[0].callback, false);\n          }\n        }\n\n        this.animations_.length = 0;\n      };\n      /**\n       * Update all animations.\n       */\n\n\n      View.prototype.updateAnimations_ = function updateAnimations_() {\n        if (this.updateAnimationKey_ !== undefined) {\n          cancelAnimationFrame(this.updateAnimationKey_);\n          this.updateAnimationKey_ = undefined;\n        }\n\n        if (!this.getAnimating()) {\n          return;\n        }\n\n        var now = Date.now();\n        var more = false;\n\n        for (var i = this.animations_.length - 1; i >= 0; --i) {\n          var series = this.animations_[i];\n          var seriesComplete = true;\n\n          for (var j = 0, jj = series.length; j < jj; ++j) {\n            var animation = series[j];\n\n            if (animation.complete) {\n              continue;\n            }\n\n            var elapsed = now - animation.start;\n            var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n\n            if (fraction >= 1) {\n              animation.complete = true;\n              fraction = 1;\n            } else {\n              seriesComplete = false;\n            }\n\n            var progress = animation.easing(fraction);\n\n            if (animation.sourceCenter) {\n              var x0 = animation.sourceCenter[0];\n              var y0 = animation.sourceCenter[1];\n              var x1 = animation.targetCenter[0];\n              var y1 = animation.targetCenter[1];\n              var x = x0 + progress * (x1 - x0);\n              var y = y0 + progress * (y1 - y0);\n              this.set(ViewProperty.CENTER, [x, y]);\n            }\n\n            if (animation.sourceResolution && animation.targetResolution) {\n              var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\n\n              if (animation.anchor) {\n                this.set(ViewProperty.CENTER, this.calculateCenterZoom(resolution, animation.anchor));\n              }\n\n              this.set(ViewProperty.RESOLUTION, resolution);\n            }\n\n            if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\n              var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\n\n              if (animation.anchor) {\n                this.set(ViewProperty.CENTER, this.calculateCenterRotate(rotation, animation.anchor));\n              }\n\n              this.set(ViewProperty.ROTATION, rotation);\n            }\n\n            more = true;\n\n            if (!animation.complete) {\n              break;\n            }\n          }\n\n          if (seriesComplete) {\n            this.animations_[i] = null;\n            this.setHint(ViewHint.ANIMATING, -1);\n            var callback = series[0].callback;\n\n            if (callback) {\n              animationCallback(callback, true);\n            }\n          }\n        } // prune completed series\n\n\n        this.animations_ = this.animations_.filter(Boolean);\n\n        if (more && this.updateAnimationKey_ === undefined) {\n          this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);\n        }\n      };\n      /**\n       * @param {number} rotation Target rotation.\n       * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n       * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n       */\n\n\n      View.prototype.calculateCenterRotate = function calculateCenterRotate(rotation, anchor) {\n        var center;\n        var currentCenter = this.getCenter();\n\n        if (currentCenter !== undefined) {\n          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n          rotate(center, rotation - this.getRotation());\n          add(center, anchor);\n        }\n\n        return center;\n      };\n      /**\n       * @param {number} resolution Target resolution.\n       * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n       * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n       */\n\n\n      View.prototype.calculateCenterZoom = function calculateCenterZoom(resolution, anchor) {\n        var center;\n        var currentCenter = this.getCenter();\n        var currentResolution = this.getResolution();\n\n        if (currentCenter !== undefined && currentResolution !== undefined) {\n          var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;\n          var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;\n          center = [x, y];\n        }\n\n        return center;\n      };\n      /**\n       * @private\n       * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n       */\n\n\n      View.prototype.getSizeFromViewport_ = function getSizeFromViewport_() {\n        var size = [100, 100];\n        var selector = '.ol-viewport[data-view=\"' + getUid(this) + '\"]';\n        var element = document.querySelector(selector);\n\n        if (element) {\n          var metrics = getComputedStyle(element);\n          size[0] = parseInt(metrics.width, 10);\n          size[1] = parseInt(metrics.height, 10);\n        }\n\n        return size;\n      };\n      /**\n       * Get the constrained center of this view.\n       * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\n       * @return {import(\"./coordinate.js\").Coordinate|undefined} Constrained center.\n       * @api\n       */\n\n\n      View.prototype.constrainCenter = function constrainCenter(center) {\n        return this.constraints_.center(center);\n      };\n      /**\n       * Get the constrained resolution of this view.\n       * @param {number|undefined} resolution Resolution.\n       * @param {number=} opt_delta Delta. Default is `0`.\n       * @param {number=} opt_direction Direction. Default is `0`.\n       * @return {number|undefined} Constrained resolution.\n       * @api\n       */\n\n\n      View.prototype.constrainResolution = function constrainResolution(resolution, opt_delta, opt_direction) {\n        var delta = opt_delta || 0;\n        var direction = opt_direction || 0;\n        return this.constraints_.resolution(resolution, delta, direction);\n      };\n      /**\n       * Get the constrained rotation of this view.\n       * @param {number|undefined} rotation Rotation.\n       * @param {number=} opt_delta Delta. Default is `0`.\n       * @return {number|undefined} Constrained rotation.\n       * @api\n       */\n\n\n      View.prototype.constrainRotation = function constrainRotation(rotation, opt_delta) {\n        var delta = opt_delta || 0;\n        return this.constraints_.rotation(rotation, delta);\n      };\n      /**\n       * Get the view center.\n       * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n       * @observable\n       * @api\n       */\n\n\n      View.prototype.getCenter = function getCenter$$1() {\n        return (\n          /** @type {import(\"./coordinate.js\").Coordinate|undefined} */\n          this.get(ViewProperty.CENTER)\n        );\n      };\n      /**\n       * @return {Constraints} Constraints.\n       */\n\n\n      View.prototype.getConstraints = function getConstraints() {\n        return this.constraints_;\n      };\n      /**\n       * @param {Array<number>=} opt_hints Destination array.\n       * @return {Array<number>} Hint.\n       */\n\n\n      View.prototype.getHints = function getHints(opt_hints) {\n        if (opt_hints !== undefined) {\n          opt_hints[0] = this.hints_[0];\n          opt_hints[1] = this.hints_[1];\n          return opt_hints;\n        } else {\n          return this.hints_.slice();\n        }\n      };\n      /**\n       * Calculate the extent for the current view state and the passed size.\n       * The size is the pixel dimensions of the box into which the calculated extent\n       * should fit. In most cases you want to get the extent of the entire map,\n       * that is `map.getSize()`.\n       * @param {import(\"./size.js\").Size=} opt_size Box pixel size. If not provided, the size of the\n       * first map that uses this view will be used.\n       * @return {import(\"./extent.js\").Extent} Extent.\n       * @api\n       */\n\n\n      View.prototype.calculateExtent = function calculateExtent(opt_size) {\n        var size = opt_size || this.getSizeFromViewport_();\n        var center =\n        /** @type {!import(\"./coordinate.js\").Coordinate} */\n        this.getCenter();\n        assert(center, 1); // The view center is not defined\n\n        var resolution =\n        /** @type {!number} */\n        this.getResolution();\n        assert(resolution !== undefined, 2); // The view resolution is not defined\n\n        var rotation =\n        /** @type {!number} */\n        this.getRotation();\n        assert(rotation !== undefined, 3); // The view rotation is not defined\n\n        return getForViewAndSize(center, resolution, rotation, size);\n      };\n      /**\n       * Get the maximum resolution of the view.\n       * @return {number} The maximum resolution of the view.\n       * @api\n       */\n\n\n      View.prototype.getMaxResolution = function getMaxResolution() {\n        return this.maxResolution_;\n      };\n      /**\n       * Get the minimum resolution of the view.\n       * @return {number} The minimum resolution of the view.\n       * @api\n       */\n\n\n      View.prototype.getMinResolution = function getMinResolution() {\n        return this.minResolution_;\n      };\n      /**\n       * Get the maximum zoom level for the view.\n       * @return {number} The maximum zoom level.\n       * @api\n       */\n\n\n      View.prototype.getMaxZoom = function getMaxZoom() {\n        return (\n          /** @type {number} */\n          this.getZoomForResolution(this.minResolution_)\n        );\n      };\n      /**\n       * Set a new maximum zoom level for the view.\n       * @param {number} zoom The maximum zoom level.\n       * @api\n       */\n\n\n      View.prototype.setMaxZoom = function setMaxZoom(zoom) {\n        this.applyOptions_(this.getUpdatedOptions_({\n          maxZoom: zoom\n        }));\n      };\n      /**\n       * Get the minimum zoom level for the view.\n       * @return {number} The minimum zoom level.\n       * @api\n       */\n\n\n      View.prototype.getMinZoom = function getMinZoom() {\n        return (\n          /** @type {number} */\n          this.getZoomForResolution(this.maxResolution_)\n        );\n      };\n      /**\n       * Set a new minimum zoom level for the view.\n       * @param {number} zoom The minimum zoom level.\n       * @api\n       */\n\n\n      View.prototype.setMinZoom = function setMinZoom(zoom) {\n        this.applyOptions_(this.getUpdatedOptions_({\n          minZoom: zoom\n        }));\n      };\n      /**\n       * Get the view projection.\n       * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n       * @api\n       */\n\n\n      View.prototype.getProjection = function getProjection() {\n        return this.projection_;\n      };\n      /**\n       * Get the view resolution.\n       * @return {number|undefined} The resolution of the view.\n       * @observable\n       * @api\n       */\n\n\n      View.prototype.getResolution = function getResolution() {\n        return (\n          /** @type {number|undefined} */\n          this.get(ViewProperty.RESOLUTION)\n        );\n      };\n      /**\n       * Get the resolutions for the view. This returns the array of resolutions\n       * passed to the constructor of the View, or undefined if none were given.\n       * @return {Array<number>|undefined} The resolutions of the view.\n       * @api\n       */\n\n\n      View.prototype.getResolutions = function getResolutions() {\n        return this.resolutions_;\n      };\n      /**\n       * Get the resolution for a provided extent (in map units) and size (in pixels).\n       * @param {import(\"./extent.js\").Extent} extent Extent.\n       * @param {import(\"./size.js\").Size=} opt_size Box pixel size.\n       * @return {number} The resolution at which the provided extent will render at\n       *     the given size.\n       * @api\n       */\n\n\n      View.prototype.getResolutionForExtent = function getResolutionForExtent(extent, opt_size) {\n        var size = opt_size || this.getSizeFromViewport_();\n        var xResolution = getWidth(extent) / size[0];\n        var yResolution = getHeight(extent) / size[1];\n        return Math.max(xResolution, yResolution);\n      };\n      /**\n       * Return a function that returns a value between 0 and 1 for a\n       * resolution. Exponential scaling is assumed.\n       * @param {number=} opt_power Power.\n       * @return {function(number): number} Resolution for value function.\n       */\n\n\n      View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction(opt_power) {\n        var power = opt_power || 2;\n        var maxResolution = this.maxResolution_;\n        var minResolution = this.minResolution_;\n        var max = Math.log(maxResolution / minResolution) / Math.log(power);\n        return (\n          /**\n           * @param {number} value Value.\n           * @return {number} Resolution.\n           */\n          function (value) {\n            var resolution = maxResolution / Math.pow(power, value * max);\n            return resolution;\n          }\n        );\n      };\n      /**\n       * Get the view rotation.\n       * @return {number} The rotation of the view in radians.\n       * @observable\n       * @api\n       */\n\n\n      View.prototype.getRotation = function getRotation() {\n        return (\n          /** @type {number} */\n          this.get(ViewProperty.ROTATION)\n        );\n      };\n      /**\n       * Return a function that returns a resolution for a value between\n       * 0 and 1. Exponential scaling is assumed.\n       * @param {number=} opt_power Power.\n       * @return {function(number): number} Value for resolution function.\n       */\n\n\n      View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction(opt_power) {\n        var power = opt_power || 2;\n        var maxResolution = this.maxResolution_;\n        var minResolution = this.minResolution_;\n        var max = Math.log(maxResolution / minResolution) / Math.log(power);\n        return (\n          /**\n           * @param {number} resolution Resolution.\n           * @return {number} Value.\n           */\n          function (resolution) {\n            var value = Math.log(maxResolution / resolution) / Math.log(power) / max;\n            return value;\n          }\n        );\n      };\n      /**\n       * @param {number} pixelRatio Pixel ratio for center rounding.\n       * @return {State} View state.\n       */\n\n\n      View.prototype.getState = function getState(pixelRatio) {\n        var center =\n        /** @type {import(\"./coordinate.js\").Coordinate} */\n        this.getCenter();\n        var projection = this.getProjection();\n        var resolution =\n        /** @type {number} */\n        this.getResolution();\n        var pixelResolution = resolution / pixelRatio;\n        var rotation = this.getRotation();\n        return (\n          /** @type {State} */\n          {\n            center: [Math.round(center[0] / pixelResolution) * pixelResolution, Math.round(center[1] / pixelResolution) * pixelResolution],\n            projection: projection !== undefined ? projection : null,\n            resolution: resolution,\n            rotation: rotation,\n            zoom: this.getZoom()\n          }\n        );\n      };\n      /**\n       * Get the current zoom level.  If you configured your view with a resolutions\n       * array (this is rare), this method may return non-integer zoom levels (so\n       * the zoom level is not safe to use as an index into a resolutions array).\n       * @return {number|undefined} Zoom.\n       * @api\n       */\n\n\n      View.prototype.getZoom = function getZoom() {\n        var zoom;\n        var resolution = this.getResolution();\n\n        if (resolution !== undefined) {\n          zoom = this.getZoomForResolution(resolution);\n        }\n\n        return zoom;\n      };\n      /**\n       * Get the zoom level for a resolution.\n       * @param {number} resolution The resolution.\n       * @return {number|undefined} The zoom level for the provided resolution.\n       * @api\n       */\n\n\n      View.prototype.getZoomForResolution = function getZoomForResolution(resolution) {\n        var offset = this.minZoom_ || 0;\n        var max, zoomFactor;\n\n        if (this.resolutions_) {\n          var nearest = linearFindNearest(this.resolutions_, resolution, 1);\n          offset = nearest;\n          max = this.resolutions_[nearest];\n\n          if (nearest == this.resolutions_.length - 1) {\n            zoomFactor = 2;\n          } else {\n            zoomFactor = max / this.resolutions_[nearest + 1];\n          }\n        } else {\n          max = this.maxResolution_;\n          zoomFactor = this.zoomFactor_;\n        }\n\n        return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n      };\n      /**\n       * Get the resolution for a zoom level.\n       * @param {number} zoom Zoom level.\n       * @return {number} The view resolution for the provided zoom level.\n       * @api\n       */\n\n\n      View.prototype.getResolutionForZoom = function getResolutionForZoom(zoom) {\n        return (\n          /** @type {number} */\n          this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0)\n        );\n      };\n      /**\n       * Fit the given geometry or extent based on the given map size and border.\n       * The size is pixel dimensions of the box to fit the extent into.\n       * In most cases you will want to use the map size, that is `map.getSize()`.\n       * Takes care of the map angle.\n       * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n       *     extent to fit the view to.\n       * @param {FitOptions=} opt_options Options.\n       * @api\n       */\n\n\n      View.prototype.fit = function fit(geometryOrExtent, opt_options) {\n        var options = opt_options || {};\n        var size = options.size;\n\n        if (!size) {\n          size = this.getSizeFromViewport_();\n        }\n        /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n\n\n        var geometry;\n        assert(Array.isArray(geometryOrExtent) || typeof\n        /** @type {?} */\n        geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`\n\n        if (Array.isArray(geometryOrExtent)) {\n          assert(!isEmpty$1(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`\n\n          geometry = fromExtent(geometryOrExtent);\n        } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {\n          geometryOrExtent = geometryOrExtent.getExtent();\n          geometry = fromExtent(geometryOrExtent);\n          geometry.rotate(this.getRotation(), getCenter(geometryOrExtent));\n        } else {\n          geometry = geometryOrExtent;\n        }\n\n        var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n        var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;\n        var nearest = options.nearest !== undefined ? options.nearest : false;\n        var minResolution;\n\n        if (options.minResolution !== undefined) {\n          minResolution = options.minResolution;\n        } else if (options.maxZoom !== undefined) {\n          minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);\n        } else {\n          minResolution = 0;\n        }\n\n        var coords = geometry.getFlatCoordinates(); // calculate rotated extent\n\n        var rotation = this.getRotation();\n        var cosAngle = Math.cos(-rotation);\n        var sinAngle = Math.sin(-rotation);\n        var minRotX = +Infinity;\n        var minRotY = +Infinity;\n        var maxRotX = -Infinity;\n        var maxRotY = -Infinity;\n        var stride = geometry.getStride();\n\n        for (var i = 0, ii = coords.length; i < ii; i += stride) {\n          var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n          var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n          minRotX = Math.min(minRotX, rotX);\n          minRotY = Math.min(minRotY, rotY);\n          maxRotX = Math.max(maxRotX, rotX);\n          maxRotY = Math.max(maxRotY, rotY);\n        } // calculate resolution\n\n\n        var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);\n        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);\n\n        if (constrainResolution) {\n          var constrainedResolution = this.constrainResolution(resolution, 0, 0);\n\n          if (!nearest && constrainedResolution < resolution) {\n            constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);\n          }\n\n          resolution = constrainedResolution;\n        } // calculate center\n\n\n        sinAngle = -sinAngle; // go back to original rotation\n\n        var centerRotX = (minRotX + maxRotX) / 2;\n        var centerRotY = (minRotY + maxRotY) / 2;\n        centerRotX += (padding[1] - padding[3]) / 2 * resolution;\n        centerRotY += (padding[0] - padding[2]) / 2 * resolution;\n        var centerX = centerRotX * cosAngle - centerRotY * sinAngle;\n        var centerY = centerRotY * cosAngle + centerRotX * sinAngle;\n        var center = [centerX, centerY];\n        var callback = options.callback ? options.callback : VOID;\n\n        if (options.duration !== undefined) {\n          this.animate({\n            resolution: resolution,\n            center: center,\n            duration: options.duration,\n            easing: options.easing\n          }, callback);\n        } else {\n          this.setResolution(resolution);\n          this.setCenter(center);\n          animationCallback(callback, true);\n        }\n      };\n      /**\n       * Center on coordinate and view position.\n       * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"./size.js\").Size} size Box pixel size.\n       * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n       * @api\n       */\n\n\n      View.prototype.centerOn = function centerOn(coordinate, size, position) {\n        // calculate rotated position\n        var rotation = this.getRotation();\n        var cosAngle = Math.cos(-rotation);\n        var sinAngle = Math.sin(-rotation);\n        var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n        var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n        var resolution = this.getResolution();\n        rotX += (size[0] / 2 - position[0]) * resolution;\n        rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle\n\n        sinAngle = -sinAngle; // go back to original rotation\n\n        var centerX = rotX * cosAngle - rotY * sinAngle;\n        var centerY = rotY * cosAngle + rotX * sinAngle;\n        this.setCenter([centerX, centerY]);\n      };\n      /**\n       * @return {boolean} Is defined.\n       */\n\n\n      View.prototype.isDef = function isDef() {\n        return !!this.getCenter() && this.getResolution() !== undefined;\n      };\n      /**\n       * Rotate the view around a given coordinate.\n       * @param {number} rotation New rotation value for the view.\n       * @param {import(\"./coordinate.js\").Coordinate=} opt_anchor The rotation center.\n       * @api\n       */\n\n\n      View.prototype.rotate = function rotate$$1(rotation, opt_anchor) {\n        if (opt_anchor !== undefined) {\n          var center = this.calculateCenterRotate(rotation, opt_anchor);\n          this.setCenter(center);\n        }\n\n        this.setRotation(rotation);\n      };\n      /**\n       * Set the center of the current view.\n       * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n       * @observable\n       * @api\n       */\n\n\n      View.prototype.setCenter = function setCenter(center) {\n        this.set(ViewProperty.CENTER, center);\n\n        if (this.getAnimating()) {\n          this.cancelAnimations();\n        }\n      };\n      /**\n       * @param {ViewHint} hint Hint.\n       * @param {number} delta Delta.\n       * @return {number} New value.\n       */\n\n\n      View.prototype.setHint = function setHint(hint, delta) {\n        this.hints_[hint] += delta;\n        this.changed();\n        return this.hints_[hint];\n      };\n      /**\n       * Set the resolution for this view.\n       * @param {number|undefined} resolution The resolution of the view.\n       * @observable\n       * @api\n       */\n\n\n      View.prototype.setResolution = function setResolution(resolution) {\n        this.set(ViewProperty.RESOLUTION, resolution);\n\n        if (this.getAnimating()) {\n          this.cancelAnimations();\n        }\n      };\n      /**\n       * Set the rotation for this view.\n       * @param {number} rotation The rotation of the view in radians.\n       * @observable\n       * @api\n       */\n\n\n      View.prototype.setRotation = function setRotation(rotation) {\n        this.set(ViewProperty.ROTATION, rotation);\n\n        if (this.getAnimating()) {\n          this.cancelAnimations();\n        }\n      };\n      /**\n       * Zoom to a specific zoom level.\n       * @param {number} zoom Zoom level.\n       * @api\n       */\n\n\n      View.prototype.setZoom = function setZoom(zoom) {\n        this.setResolution(this.getResolutionForZoom(zoom));\n      };\n\n      return View;\n    }(BaseObject);\n    /**\n     * @param {Function} callback Callback.\n     * @param {*} returnValue Return value.\n     */\n\n\n    function animationCallback(callback, returnValue) {\n      setTimeout(function () {\n        callback(returnValue);\n      }, 0);\n    }\n    /**\n     * @param {ViewOptions} options View options.\n     * @return {import(\"./centerconstraint.js\").Type} The constraint.\n     */\n\n\n    function createCenterConstraint(options) {\n      if (options.extent !== undefined) {\n        return createExtent(options.extent);\n      } else {\n        return none;\n      }\n    }\n    /**\n     * @param {ViewOptions} options View options.\n     * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n     *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n     */\n\n\n    function createResolutionConstraint(options) {\n      var resolutionConstraint;\n      var maxResolution;\n      var minResolution; // TODO: move these to be ol constants\n      // see https://github.com/openlayers/openlayers/issues/2076\n\n      var defaultMaxZoom = 28;\n      var defaultZoomFactor = 2;\n      var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n      var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n      var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n      if (options.resolutions !== undefined) {\n        var resolutions = options.resolutions;\n        maxResolution = resolutions[minZoom];\n        minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];\n        resolutionConstraint = createSnapToResolutions(resolutions);\n      } else {\n        // calculate the default min and max resolution\n        var projection = createProjection(options.projection, 'EPSG:3857');\n        var extent = projection.getExtent();\n        var size = !extent ? // use an extent that can fit the whole world if need be\n        360 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit() : Math.max(getWidth(extent), getHeight(extent));\n        var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n        var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence\n\n        maxResolution = options.maxResolution;\n\n        if (maxResolution !== undefined) {\n          minZoom = 0;\n        } else {\n          maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n        } // user provided minResolution takes precedence\n\n\n        minResolution = options.minResolution;\n\n        if (minResolution === undefined) {\n          if (options.maxZoom !== undefined) {\n            if (options.maxResolution !== undefined) {\n              minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n            } else {\n              minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n            }\n          } else {\n            minResolution = defaultMinResolution;\n          }\n        } // given discrete zoom levels, minResolution may be different than provided\n\n\n        maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n        resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);\n      }\n\n      return {\n        constraint: resolutionConstraint,\n        maxResolution: maxResolution,\n        minResolution: minResolution,\n        minZoom: minZoom,\n        zoomFactor: zoomFactor\n      };\n    }\n    /**\n     * @param {ViewOptions} options View options.\n     * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n     */\n\n\n    function createRotationConstraint(options) {\n      var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;\n\n      if (enableRotation) {\n        var constrainRotation = options.constrainRotation;\n\n        if (constrainRotation === undefined || constrainRotation === true) {\n          return createSnapToZero();\n        } else if (constrainRotation === false) {\n          return none$1;\n        } else if (typeof constrainRotation === 'number') {\n          return createSnapToN(constrainRotation);\n        } else {\n          return none$1;\n        }\n      } else {\n        return disable;\n      }\n    }\n    /**\n     * Determine if an animation involves no view change.\n     * @param {Animation} animation The animation.\n     * @return {boolean} The animation involves no view change.\n     */\n\n\n    function isNoopAnimation(animation) {\n      if (animation.sourceCenter && animation.targetCenter) {\n        if (!equals$1(animation.sourceCenter, animation.targetCenter)) {\n          return false;\n        }\n      }\n\n      if (animation.sourceResolution !== animation.targetResolution) {\n        return false;\n      }\n\n      if (animation.sourceRotation !== animation.targetRotation) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * @module ol/dom\n     */\n\n    /**\n     * Create an html canvas element and returns its 2d context.\n     * @param {number=} opt_width Canvas width.\n     * @param {number=} opt_height Canvas height.\n     * @return {CanvasRenderingContext2D} The context.\n     */\n\n\n    function createCanvasContext2D(opt_width, opt_height) {\n      var canvas =\n      /** @type {HTMLCanvasElement} */\n      document.createElement('canvas');\n\n      if (opt_width) {\n        canvas.width = opt_width;\n      }\n\n      if (opt_height) {\n        canvas.height = opt_height;\n      }\n\n      return (\n        /** @type {CanvasRenderingContext2D} */\n        canvas.getContext('2d')\n      );\n    }\n    /**\n     * Get the current computed width for the given element including margin,\n     * padding and border.\n     * Equivalent to jQuery's `$(el).outerWidth(true)`.\n     * @param {!HTMLElement} element Element.\n     * @return {number} The width.\n     */\n\n\n    function outerWidth(element) {\n      var width = element.offsetWidth;\n      var style = getComputedStyle(element);\n      width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n      return width;\n    }\n    /**\n     * Get the current computed height for the given element including margin,\n     * padding and border.\n     * Equivalent to jQuery's `$(el).outerHeight(true)`.\n     * @param {!HTMLElement} element Element.\n     * @return {number} The height.\n     */\n\n\n    function outerHeight(element) {\n      var height = element.offsetHeight;\n      var style = getComputedStyle(element);\n      height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n      return height;\n    }\n    /**\n     * @param {Node} newNode Node to replace old node\n     * @param {Node} oldNode The node to be replaced\n     */\n\n\n    function replaceNode(newNode, oldNode) {\n      var parent = oldNode.parentNode;\n\n      if (parent) {\n        parent.replaceChild(newNode, oldNode);\n      }\n    }\n    /**\n     * @param {Node} node The node to remove.\n     * @returns {Node} The node that was removed or null.\n     */\n\n\n    function removeNode(node) {\n      return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n    }\n    /**\n     * @param {Node} node The node to remove the children from.\n     */\n\n\n    function removeChildren(node) {\n      while (node.lastChild) {\n        node.removeChild(node.lastChild);\n      }\n    }\n    /**\n     * @module ol/layer/Property\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var LayerProperty = {\n      OPACITY: 'opacity',\n      VISIBLE: 'visible',\n      EXTENT: 'extent',\n      Z_INDEX: 'zIndex',\n      MAX_RESOLUTION: 'maxResolution',\n      MIN_RESOLUTION: 'minResolution',\n      SOURCE: 'source'\n    };\n    /**\n     * @module ol/layer/Base\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [opacity=1] Opacity (0, 1).\n     * @property {boolean} [visible=true] Visibility.\n     * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n     * rendered outside of this extent.\n     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n     * method was used.\n     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n     * visible.\n     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n     * be visible.\n     */\n\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in\n     * the options is set as a {@link module:ol/Object} property on the layer object, so\n     * is observable, and has get/set accessors.\n     *\n     * @api\n     */\n\n    var BaseLayer =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function BaseLayer(options) {\n        BaseObject$$1.call(this);\n        /**\n         * @type {Object<string, *>}\n         */\n\n        var properties = assign({}, options);\n        properties[LayerProperty.OPACITY] = options.opacity !== undefined ? options.opacity : 1;\n        properties[LayerProperty.VISIBLE] = options.visible !== undefined ? options.visible : true;\n        properties[LayerProperty.Z_INDEX] = options.zIndex;\n        properties[LayerProperty.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;\n        properties[LayerProperty.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;\n        this.setProperties(properties);\n        /**\n         * @type {import(\"./Layer.js\").State}\n         * @private\n         */\n\n        this.state_ = null;\n        /**\n         * The layer type.\n         * @type {import(\"../LayerType.js\").default}\n         * @protected;\n         */\n\n        this.type;\n      }\n\n      if (BaseObject$$1) BaseLayer.__proto__ = BaseObject$$1;\n      BaseLayer.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      BaseLayer.prototype.constructor = BaseLayer;\n      /**\n       * Get the layer type (used when creating a layer renderer).\n       * @return {import(\"../LayerType.js\").default} The layer type.\n       */\n\n      BaseLayer.prototype.getType = function getType() {\n        return this.type;\n      };\n      /**\n       * @return {import(\"./Layer.js\").State} Layer state.\n       */\n\n\n      BaseLayer.prototype.getLayerState = function getLayerState() {\n        /** @type {import(\"./Layer.js\").State} */\n        var state = this.state_ ||\n        /** @type {?} */\n        {\n          layer: this,\n          managed: true\n        };\n        state.opacity = clamp(this.getOpacity(), 0, 1);\n        state.sourceState = this.getSourceState();\n        state.visible = this.getVisible();\n        state.extent = this.getExtent();\n        state.zIndex = this.getZIndex() || 0;\n        state.maxResolution = this.getMaxResolution();\n        state.minResolution = Math.max(this.getMinResolution(), 0);\n        this.state_ = state;\n        return state;\n      };\n      /**\n       * @abstract\n       * @param {Array<import(\"./Layer.js\").default>=} opt_array Array of layers (to be\n       *     modified in place).\n       * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n       */\n\n\n      BaseLayer.prototype.getLayersArray = function getLayersArray(opt_array) {\n        return _abstract();\n      };\n      /**\n       * @abstract\n       * @param {Array<import(\"./Layer.js\").State>=} opt_states Optional list of layer\n       *     states (to be modified in place).\n       * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n       */\n\n\n      BaseLayer.prototype.getLayerStatesArray = function getLayerStatesArray(opt_states) {\n        return _abstract();\n      };\n      /**\n       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n       * will be visible regardless of extent.\n       * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.getExtent = function getExtent() {\n        return (\n          /** @type {import(\"../extent.js\").Extent|undefined} */\n          this.get(LayerProperty.EXTENT)\n        );\n      };\n      /**\n       * Return the maximum resolution of the layer.\n       * @return {number} The maximum resolution of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.getMaxResolution = function getMaxResolution() {\n        return (\n          /** @type {number} */\n          this.get(LayerProperty.MAX_RESOLUTION)\n        );\n      };\n      /**\n       * Return the minimum resolution of the layer.\n       * @return {number} The minimum resolution of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.getMinResolution = function getMinResolution() {\n        return (\n          /** @type {number} */\n          this.get(LayerProperty.MIN_RESOLUTION)\n        );\n      };\n      /**\n       * Return the opacity of the layer (between 0 and 1).\n       * @return {number} The opacity of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.getOpacity = function getOpacity() {\n        return (\n          /** @type {number} */\n          this.get(LayerProperty.OPACITY)\n        );\n      };\n      /**\n       * @abstract\n       * @return {import(\"../source/State.js\").default} Source state.\n       */\n\n\n      BaseLayer.prototype.getSourceState = function getSourceState() {\n        return _abstract();\n      };\n      /**\n       * Return the visibility of the layer (`true` or `false`).\n       * @return {boolean} The visibility of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.getVisible = function getVisible() {\n        return (\n          /** @type {boolean} */\n          this.get(LayerProperty.VISIBLE)\n        );\n      };\n      /**\n       * Return the Z-index of the layer, which is used to order layers before\n       * rendering. The default Z-index is 0.\n       * @return {number} The Z-index of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.getZIndex = function getZIndex() {\n        return (\n          /** @type {number} */\n          this.get(LayerProperty.Z_INDEX)\n        );\n      };\n      /**\n       * Set the extent at which the layer is visible.  If `undefined`, the layer\n       * will be visible at all extents.\n       * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.setExtent = function setExtent(extent) {\n        this.set(LayerProperty.EXTENT, extent);\n      };\n      /**\n       * Set the maximum resolution at which the layer is visible.\n       * @param {number} maxResolution The maximum resolution of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.setMaxResolution = function setMaxResolution(maxResolution) {\n        this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n      };\n      /**\n       * Set the minimum resolution at which the layer is visible.\n       * @param {number} minResolution The minimum resolution of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.setMinResolution = function setMinResolution(minResolution) {\n        this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n      };\n      /**\n       * Set the opacity of the layer, allowed values range from 0 to 1.\n       * @param {number} opacity The opacity of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.setOpacity = function setOpacity(opacity) {\n        this.set(LayerProperty.OPACITY, opacity);\n      };\n      /**\n       * Set the visibility of the layer (`true` or `false`).\n       * @param {boolean} visible The visibility of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.setVisible = function setVisible(visible) {\n        this.set(LayerProperty.VISIBLE, visible);\n      };\n      /**\n       * Set Z-index of the layer, which is used to order layers before rendering.\n       * The default Z-index is 0.\n       * @param {number} zindex The z-index of the layer.\n       * @observable\n       * @api\n       */\n\n\n      BaseLayer.prototype.setZIndex = function setZIndex(zindex) {\n        this.set(LayerProperty.Z_INDEX, zindex);\n      };\n\n      return BaseLayer;\n    }(BaseObject);\n    /**\n     * @module ol/source/State\n     */\n\n    /**\n     * @enum {string}\n     * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n     */\n\n\n    var SourceState = {\n      UNDEFINED: 'undefined',\n      LOADING: 'loading',\n      READY: 'ready',\n      ERROR: 'error'\n    };\n    /**\n     * @module ol/layer/Group\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [opacity=1] Opacity (0, 1).\n     * @property {boolean} [visible=true] Visibility.\n     * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n     * rendered outside of this extent.\n     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n     * method was used.\n     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n     * visible.\n     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n     * be visible.\n     * @property {Array<import(\"./Base.js\").default>|import(\"../Collection.js\").default<import(\"./Base.js\").default>} [layers] Child layers.\n     */\n\n    /**\n     * @enum {string}\n     * @private\n     */\n\n    var Property$1 = {\n      LAYERS: 'layers'\n    };\n    /**\n     * @classdesc\n     * A {@link module:ol/Collection~Collection} of layers that are handled together.\n     *\n     * A generic `change` event is triggered when the group/Collection changes.\n     *\n     * @api\n     */\n\n    var LayerGroup =\n    /*@__PURE__*/\n    function (BaseLayer$$1) {\n      function LayerGroup(opt_options) {\n        var options = opt_options || {};\n        var baseOptions =\n        /** @type {Options} */\n        assign({}, options);\n        delete baseOptions.layers;\n        var layers = options.layers;\n        BaseLayer$$1.call(this, baseOptions);\n        /**\n         * @private\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         */\n\n        this.layersListenerKeys_ = [];\n        /**\n         * @private\n         * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n         */\n\n        this.listenerKeys_ = {};\n        listen(this, getChangeEventType(Property$1.LAYERS), this.handleLayersChanged_, this);\n\n        if (layers) {\n          if (Array.isArray(layers)) {\n            layers = new Collection(layers.slice(), {\n              unique: true\n            });\n          } else {\n            assert(typeof\n            /** @type {?} */\n            layers.getArray === 'function', 43); // Expected `layers` to be an array or a `Collection`\n          }\n        } else {\n          layers = new Collection(undefined, {\n            unique: true\n          });\n        }\n\n        this.setLayers(layers);\n      }\n\n      if (BaseLayer$$1) LayerGroup.__proto__ = BaseLayer$$1;\n      LayerGroup.prototype = Object.create(BaseLayer$$1 && BaseLayer$$1.prototype);\n      LayerGroup.prototype.constructor = LayerGroup;\n      /**\n       * @private\n       */\n\n      LayerGroup.prototype.handleLayerChange_ = function handleLayerChange_() {\n        this.changed();\n      };\n      /**\n       * @private\n       */\n\n\n      LayerGroup.prototype.handleLayersChanged_ = function handleLayersChanged_() {\n        this.layersListenerKeys_.forEach(unlistenByKey);\n        this.layersListenerKeys_.length = 0;\n        var layers = this.getLayers();\n        this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));\n\n        for (var id in this.listenerKeys_) {\n          this.listenerKeys_[id].forEach(unlistenByKey);\n        }\n\n        clear(this.listenerKeys_);\n        var layersArray = layers.getArray();\n\n        for (var i = 0, ii = layersArray.length; i < ii; i++) {\n          var layer = layersArray[i];\n          this.listenerKeys_[getUid(layer)] = [listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(layer, EventType.CHANGE, this.handleLayerChange_, this)];\n        }\n\n        this.changed();\n      };\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} collectionEvent CollectionEvent.\n       * @private\n       */\n\n\n      LayerGroup.prototype.handleLayersAdd_ = function handleLayersAdd_(collectionEvent) {\n        var layer =\n        /** @type {import(\"./Base.js\").default} */\n        collectionEvent.element;\n        this.listenerKeys_[getUid(layer)] = [listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(layer, EventType.CHANGE, this.handleLayerChange_, this)];\n        this.changed();\n      };\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} collectionEvent CollectionEvent.\n       * @private\n       */\n\n\n      LayerGroup.prototype.handleLayersRemove_ = function handleLayersRemove_(collectionEvent) {\n        var layer =\n        /** @type {import(\"./Base.js\").default} */\n        collectionEvent.element;\n        var key = getUid(layer);\n        this.listenerKeys_[key].forEach(unlistenByKey);\n        delete this.listenerKeys_[key];\n        this.changed();\n      };\n      /**\n       * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n       * in this group.\n       * @return {!import(\"../Collection.js\").default<import(\"./Base.js\").default>} Collection of\n       *   {@link module:ol/layer/Base layers} that are part of this group.\n       * @observable\n       * @api\n       */\n\n\n      LayerGroup.prototype.getLayers = function getLayers() {\n        return (\n          /** @type {!import(\"../Collection.js\").default<import(\"./Base.js\").default>} */\n          this.get(Property$1.LAYERS)\n        );\n      };\n      /**\n       * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n       * in this group.\n       * @param {!import(\"../Collection.js\").default<import(\"./Base.js\").default>} layers Collection of\n       *   {@link module:ol/layer/Base layers} that are part of this group.\n       * @observable\n       * @api\n       */\n\n\n      LayerGroup.prototype.setLayers = function setLayers(layers) {\n        this.set(Property$1.LAYERS, layers);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LayerGroup.prototype.getLayersArray = function getLayersArray(opt_array) {\n        var array = opt_array !== undefined ? opt_array : [];\n        this.getLayers().forEach(function (layer) {\n          layer.getLayersArray(array);\n        });\n        return array;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LayerGroup.prototype.getLayerStatesArray = function getLayerStatesArray(opt_states) {\n        var states = opt_states !== undefined ? opt_states : [];\n        var pos = states.length;\n        this.getLayers().forEach(function (layer) {\n          layer.getLayerStatesArray(states);\n        });\n        var ownLayerState = this.getLayerState();\n\n        for (var i = pos, ii = states.length; i < ii; i++) {\n          var layerState = states[i];\n          layerState.opacity *= ownLayerState.opacity;\n          layerState.visible = layerState.visible && ownLayerState.visible;\n          layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);\n          layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);\n\n          if (ownLayerState.extent !== undefined) {\n            if (layerState.extent !== undefined) {\n              layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);\n            } else {\n              layerState.extent = ownLayerState.extent;\n            }\n          }\n        }\n\n        return states;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LayerGroup.prototype.getSourceState = function getSourceState() {\n        return SourceState.READY;\n      };\n\n      return LayerGroup;\n    }(BaseLayer);\n    /**\n     * @module ol/size\n     */\n\n    /**\n     * Determines if a size has a positive area.\n     * @param {Size} size The size to test.\n     * @return {boolean} The size has a positive area.\n     */\n\n\n    function hasArea(size) {\n      return size[0] > 0 && size[1] > 0;\n    }\n    /**\n     * Returns a size scaled by a ratio. The result will be an array of integers.\n     * @param {Size} size Size.\n     * @param {number} ratio Ratio.\n     * @param {Size=} opt_size Optional reusable size array.\n     * @return {Size} The scaled size.\n     */\n\n\n    function scale$3(size, ratio, opt_size) {\n      if (opt_size === undefined) {\n        opt_size = [0, 0];\n      }\n\n      opt_size[0] = size[0] * ratio + 0.5 | 0;\n      opt_size[1] = size[1] * ratio + 0.5 | 0;\n      return opt_size;\n    }\n    /**\n     * Returns an `Size` array for the passed in number (meaning: square) or\n     * `Size` array.\n     * (meaning: non-square),\n     * @param {number|Size} size Width and height.\n     * @param {Size=} opt_size Optional reusable size array.\n     * @return {Size} Size.\n     * @api\n     */\n\n\n    function toSize(size, opt_size) {\n      if (Array.isArray(size)) {\n        return size;\n      } else {\n        if (opt_size === undefined) {\n          opt_size = [size, size];\n        } else {\n          opt_size[0] = opt_size[1] =\n          /** @type {number} */\n          size;\n        }\n\n        return opt_size;\n      }\n    }\n    /**\n     * @module ol/PluggableMap\n     */\n\n    /**\n     * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n     * be used in applications.\n     * @typedef {Object} FrameState\n     * @property {number} pixelRatio The pixel ratio of the frame.\n     * @property {number} time The time when rendering of the frame was requested.\n     * @property {import(\"./View.js\").State} viewState The state of the current view.\n     * @property {boolean} animate\n     * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform\n     * @property {null|import(\"./extent.js\").Extent} extent\n     * @property {import(\"./coordinate.js\").Coordinate} focus\n     * @property {number} index\n     * @property {Object<string, import(\"./layer/Layer.js\").State>} layerStates\n     * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray\n     * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform\n     * @property {Array<PostRenderFunction>} postRenderFunctions\n     * @property {import(\"./size.js\").Size} size\n     * @property {!Object<string, boolean>} skippedFeatureUids\n     * @property {TileQueue} tileQueue\n     * @property {Object<string, Object<string, import(\"./TileRange.js\").default>>} usedTiles\n     * @property {Array<number>} viewHints\n     * @property {!Object<string, Object<string, boolean>>} wantedTiles\n     */\n\n    /**\n     * @typedef {function(PluggableMap, ?FrameState): boolean} PostRenderFunction\n     */\n\n    /**\n     * @typedef {Object} AtPixelOptions\n     * @property {undefined|function(import(\"./layer/Layer.js\").default): boolean} layerFilter Layer filter\n     * function. The filter function will receive one argument, the\n     * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n     * Only layers which are visible and for which this function returns `true`\n     * will be tested for features. By default, all visible layers will be tested.\n     * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\n     * inside the radius around the given position will be checked for features. This only\n     * works for the canvas renderer and not for WebGL.\n     */\n\n    /**\n     * @typedef {Object} MapOptionsInternal\n     * @property {Collection<import(\"./control/Control.js\").default>} [controls]\n     * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions]\n     * @property {HTMLElement|Document} keyboardEventTarget\n     * @property {Collection<import(\"./Overlay.js\").default>} overlays\n     * @property {Object<string, *>} values\n     */\n\n    /**\n     * Object literal with config options for the map.\n     * @typedef {Object} MapOptions\n     * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n     * Controls initially added to the map. If not specified,\n     * {@link module:ol/control~defaults} is used.\n     * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n     * physical pixels and device-independent pixels (dips) on the device.\n     * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n     * Interactions that are initially added to the map. If not specified,\n     * {@link module:ol/interaction~defaults} is used.\n     * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n     * listen to keyboard events on. This determines when the `KeyboardPan` and\n     * `KeyboardZoom` interactions trigger. For example, if this option is set to\n     * `document` the keyboard interactions will always trigger. If this option is\n     * not specified, the element the library listens to keyboard events on is the\n     * map target (i.e. the user-provided div for the map). If this is not\n     * `document`, the target element needs to be focused for key events to be\n     * emitted, requiring that the target element has a `tabindex` attribute.\n     * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n     * Layers. If this is not defined, a map with no layers will be rendered. Note\n     * that layers are rendered in the order supplied, so if you want, for example,\n     * a vector layer to appear on top of a tile layer, it must come after the tile\n     * layer.\n     * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n     * simultaneously.\n     * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles\n     * will be loaded during animations. This may improve the user experience, but\n     * can also make animations stutter on devices with slow memory.\n     * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,\n     * tiles will be loaded while interacting with the map. This may improve the\n     * user experience, but can also make map panning and zooming choppy on devices\n     * with slow memory.\n     * @property {number} [moveTolerance=1] The minimum distance in pixels the\n     * cursor must move to be detected as a map move event instead of a click.\n     * Increasing this value can make it easier to click on the map.\n     * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n     * Overlays initially added to the map. By default, no overlays are added.\n     * @property {HTMLElement|string} [target] The container for the map, either the\n     * element itself or the `id` of the element. If not specified at construction\n     * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n     * rendered.\n     * @property {View} [view] The map's view.  No layer sources will be\n     * fetched unless this is specified at construction time or through\n     * {@link module:ol/Map~Map#setView}.\n     */\n\n    /**\n     * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n     * @fires import(\"./MapEvent.js\").MapEvent\n     * @fires module:ol/render/Event~RenderEvent#postcompose\n     * @fires module:ol/render/Event~RenderEvent#precompose\n     * @fires module:ol/render/Event~RenderEvent#rendercomplete\n     * @api\n     */\n\n\n    var PluggableMap =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function PluggableMap(options) {\n        BaseObject$$1.call(this);\n        var optionsInternal = createOptionsInternal(options);\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.animationDelayKey_;\n        /**\n         * @private\n         */\n\n        this.animationDelay_ = function () {\n          this.animationDelayKey_ = undefined;\n          this.renderFrame_.call(this, Date.now());\n        }.bind(this);\n        /**\n         * @private\n         * @type {import(\"./transform.js\").Transform}\n         */\n\n\n        this.coordinateToPixelTransform_ = create();\n        /**\n         * @private\n         * @type {import(\"./transform.js\").Transform}\n         */\n\n        this.pixelToCoordinateTransform_ = create();\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.frameIndex_ = 0;\n        /**\n         * @private\n         * @type {?FrameState}\n         */\n\n        this.frameState_ = null;\n        /**\n         * The extent at the previous 'moveend' event.\n         * @private\n         * @type {import(\"./extent.js\").Extent}\n         */\n\n        this.previousExtent_ = null;\n        /**\n         * @private\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n\n        this.viewPropertyListenerKey_ = null;\n        /**\n         * @private\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n\n        this.viewChangeListenerKey_ = null;\n        /**\n         * @private\n         * @type {Array<import(\"./events.js\").EventsKey>}\n         */\n\n        this.layerGroupPropertyListenerKeys_ = null;\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n\n        this.viewport_ = document.createElement('div');\n        this.viewport_.className = 'ol-viewport' + (TOUCH ? ' ol-touch' : '');\n        this.viewport_.style.position = 'relative';\n        this.viewport_.style.overflow = 'hidden';\n        this.viewport_.style.width = '100%';\n        this.viewport_.style.height = '100%'; // prevent page zoom on IE >= 10 browsers\n\n        this.viewport_.style.msTouchAction = 'none';\n        this.viewport_.style.touchAction = 'none';\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n\n        this.overlayContainer_ = document.createElement('div');\n        this.overlayContainer_.className = 'ol-overlaycontainer';\n        this.viewport_.appendChild(this.overlayContainer_);\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n\n        this.overlayContainerStopEvent_ = document.createElement('div');\n        this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n        var overlayEvents = [EventType.CLICK, EventType.DBLCLICK, EventType.MOUSEDOWN, EventType.TOUCHSTART, EventType.MSPOINTERDOWN, MapBrowserEventType.POINTERDOWN, EventType.MOUSEWHEEL, EventType.WHEEL];\n\n        for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {\n          listen(this.overlayContainerStopEvent_, overlayEvents[i], stopPropagation);\n        }\n\n        this.viewport_.appendChild(this.overlayContainerStopEvent_);\n        /**\n         * @private\n         * @type {MapBrowserEventHandler}\n         */\n\n        this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, options.moveTolerance);\n\n        for (var key in MapBrowserEventType) {\n          listen(this.mapBrowserEventHandler_, MapBrowserEventType[key], this.handleMapBrowserEvent, this);\n        }\n        /**\n         * @private\n         * @type {HTMLElement|Document}\n         */\n\n\n        this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n        /**\n         * @private\n         * @type {Array<import(\"./events.js\").EventsKey>}\n         */\n\n        this.keyHandlerKeys_ = null;\n        listen(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n        listen(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n        listen(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n        /**\n         * @type {Collection<import(\"./control/Control.js\").default>}\n         * @protected\n         */\n\n        this.controls = optionsInternal.controls || new Collection();\n        /**\n         * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n         * @protected\n         */\n\n        this.interactions = optionsInternal.interactions || new Collection();\n        /**\n         * @type {Collection<import(\"./Overlay.js\").default>}\n         * @private\n         */\n\n        this.overlays_ = optionsInternal.overlays;\n        /**\n         * A lookup of overlays by id.\n         * @private\n         * @type {Object<string, import(\"./Overlay.js\").default>}\n         */\n\n        this.overlayIdIndex_ = {};\n        /**\n         * @type {import(\"./renderer/Map.js\").default}\n         * @private\n         */\n\n        this.renderer_ = this.createRenderer();\n        /**\n         * @type {function(Event)|undefined}\n         * @private\n         */\n\n        this.handleResize_;\n        /**\n         * @private\n         * @type {import(\"./coordinate.js\").Coordinate}\n         */\n\n        this.focus_ = null;\n        /**\n         * @private\n         * @type {!Array<PostRenderFunction>}\n         */\n\n        this.postRenderFunctions_ = [];\n        /**\n         * @private\n         * @type {TileQueue}\n         */\n\n        this.tileQueue_ = new TileQueue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));\n        /**\n         * Uids of features to skip at rendering time.\n         * @type {Object<string, boolean>}\n         * @private\n         */\n\n        this.skippedFeatureUids_ = {};\n        listen(this, getChangeEventType(MapProperty.LAYERGROUP), this.handleLayerGroupChanged_, this);\n        listen(this, getChangeEventType(MapProperty.VIEW), this.handleViewChanged_, this);\n        listen(this, getChangeEventType(MapProperty.SIZE), this.handleSizeChanged_, this);\n        listen(this, getChangeEventType(MapProperty.TARGET), this.handleTargetChanged_, this); // setProperties will trigger the rendering of the map if the map\n        // is \"defined\" already.\n\n        this.setProperties(optionsInternal.values);\n        this.controls.forEach(\n        /**\n         * @param {import(\"./control/Control.js\").default} control Control.\n         * @this {PluggableMap}\n         */\n        function (control) {\n          control.setMap(this);\n        }.bind(this));\n        listen(this.controls, CollectionEventType.ADD,\n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n          event.element.setMap(this);\n        }, this);\n        listen(this.controls, CollectionEventType.REMOVE,\n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n          event.element.setMap(null);\n        }, this);\n        this.interactions.forEach(\n        /**\n         * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n         * @this {PluggableMap}\n         */\n        function (interaction) {\n          interaction.setMap(this);\n        }.bind(this));\n        listen(this.interactions, CollectionEventType.ADD,\n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n          event.element.setMap(this);\n        }, this);\n        listen(this.interactions, CollectionEventType.REMOVE,\n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n          event.element.setMap(null);\n        }, this);\n        this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n        listen(this.overlays_, CollectionEventType.ADD,\n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n          this.addOverlayInternal_(\n          /** @type {import(\"./Overlay.js\").default} */\n          event.element);\n        }, this);\n        listen(this.overlays_, CollectionEventType.REMOVE,\n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n          var overlay =\n          /** @type {import(\"./Overlay.js\").default} */\n          event.element;\n          var id = overlay.getId();\n\n          if (id !== undefined) {\n            delete this.overlayIdIndex_[id.toString()];\n          }\n\n          event.element.setMap(null);\n        }, this);\n      }\n\n      if (BaseObject$$1) PluggableMap.__proto__ = BaseObject$$1;\n      PluggableMap.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      PluggableMap.prototype.constructor = PluggableMap;\n      /**\n       * @abstract\n       * @return {import(\"./renderer/Map.js\").default} The map renderer\n       */\n\n      PluggableMap.prototype.createRenderer = function createRenderer() {\n        throw new Error('Use a map type that has a createRenderer method');\n      };\n      /**\n       * Add the given control to the map.\n       * @param {import(\"./control/Control.js\").default} control Control.\n       * @api\n       */\n\n\n      PluggableMap.prototype.addControl = function addControl(control) {\n        this.getControls().push(control);\n      };\n      /**\n       * Add the given interaction to the map.\n       * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n       * @api\n       */\n\n\n      PluggableMap.prototype.addInteraction = function addInteraction(interaction) {\n        this.getInteractions().push(interaction);\n      };\n      /**\n       * Adds the given layer to the top of this map. If you want to add a layer\n       * elsewhere in the stack, use `getLayers()` and the methods available on\n       * {@link module:ol/Collection~Collection}.\n       * @param {import(\"./layer/Base.js\").default} layer Layer.\n       * @api\n       */\n\n\n      PluggableMap.prototype.addLayer = function addLayer(layer) {\n        var layers = this.getLayerGroup().getLayers();\n        layers.push(layer);\n      };\n      /**\n       * Add the given overlay to the map.\n       * @param {import(\"./Overlay.js\").default} overlay Overlay.\n       * @api\n       */\n\n\n      PluggableMap.prototype.addOverlay = function addOverlay(overlay) {\n        this.getOverlays().push(overlay);\n      };\n      /**\n       * This deals with map's overlay collection changes.\n       * @param {import(\"./Overlay.js\").default} overlay Overlay.\n       * @private\n       */\n\n\n      PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_(overlay) {\n        var id = overlay.getId();\n\n        if (id !== undefined) {\n          this.overlayIdIndex_[id.toString()] = overlay;\n        }\n\n        overlay.setMap(this);\n      };\n      /**\n       *\n       * @inheritDoc\n       */\n\n\n      PluggableMap.prototype.disposeInternal = function disposeInternal() {\n        this.mapBrowserEventHandler_.dispose();\n        unlisten(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n        unlisten(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n        unlisten(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n\n        if (this.handleResize_ !== undefined) {\n          removeEventListener(EventType.RESIZE, this.handleResize_, false);\n          this.handleResize_ = undefined;\n        }\n\n        if (this.animationDelayKey_) {\n          cancelAnimationFrame(this.animationDelayKey_);\n          this.animationDelayKey_ = undefined;\n        }\n\n        this.setTarget(null);\n        BaseObject$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * Detect features that intersect a pixel on the viewport, and execute a\n       * callback with each intersecting feature. Layers included in the detection can\n       * be configured through the `layerFilter` option in `opt_options`.\n       * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n       * @param {function(this: S, import(\"./Feature.js\").FeatureLike,\n       *     import(\"./layer/Layer.js\").default): T} callback Feature callback. The callback will be\n       *     called with two arguments. The first argument is one\n       *     {@link module:ol/Feature feature} or\n       *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n       *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n       *     unmanaged layers. To stop detection, callback functions can return a\n       *     truthy value.\n       * @param {AtPixelOptions=} opt_options Optional options.\n       * @return {T|undefined} Callback result, i.e. the return value of last\n       * callback execution, or the first truthy callback return value.\n       * @template S,T\n       * @api\n       */\n\n\n      PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel(pixel, callback, opt_options) {\n        if (!this.frameState_) {\n          return;\n        }\n\n        var coordinate = this.getCoordinateFromPixel(pixel);\n        opt_options = opt_options !== undefined ? opt_options :\n        /** @type {AtPixelOptions} */\n        {};\n        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n      };\n      /**\n       * Get all features that intersect a pixel on the viewport.\n       * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n       * @param {AtPixelOptions=} opt_options Optional options.\n       * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n       * `null` if none were found.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel(pixel, opt_options) {\n        var features = null;\n        this.forEachFeatureAtPixel(pixel, function (feature) {\n          if (!features) {\n            features = [];\n          }\n\n          features.push(feature);\n        }, opt_options);\n        return features;\n      };\n      /**\n       * Detect layers that have a color value at a pixel on the viewport, and\n       * execute a callback with each matching layer. Layers included in the\n       * detection can be configured through `opt_layerFilter`.\n       * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n       * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\n       *     Layer callback. This callback will receive two arguments: first is the\n       *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n       *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n       *     that do not currently support this argument. To stop detection, callback\n       *     functions can return a truthy value.\n       * @param {AtPixelOptions=} opt_options Configuration options.\n       * @return {T|undefined} Callback result, i.e. the return value of last\n       * callback execution, or the first truthy callback return value.\n       * @template S,T\n       * @api\n       */\n\n\n      PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, callback, opt_options) {\n        if (!this.frameState_) {\n          return;\n        }\n\n        var options = opt_options ||\n        /** @type {AtPixelOptions} */\n        {};\n        var hitTolerance = options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n        var layerFilter = options.layerFilter || TRUE;\n        return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n      };\n      /**\n       * Detect if features intersect a pixel on the viewport. Layers included in the\n       * detection can be configured through `opt_layerFilter`.\n       * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n       * @param {AtPixelOptions=} opt_options Optional options.\n       * @return {boolean} Is there a feature at the given pixel?\n       * @template U\n       * @api\n       */\n\n\n      PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel(pixel, opt_options) {\n        if (!this.frameState_) {\n          return false;\n        }\n\n        var coordinate = this.getCoordinateFromPixel(pixel);\n        opt_options = opt_options !== undefined ? opt_options :\n        /** @type {AtPixelOptions} */\n        {};\n        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);\n      };\n      /**\n       * Returns the coordinate in view projection for a browser event.\n       * @param {Event} event Event.\n       * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getEventCoordinate = function getEventCoordinate(event) {\n        return this.getCoordinateFromPixel(this.getEventPixel(event));\n      };\n      /**\n       * Returns the map pixel position for a browser event relative to the viewport.\n       * @param {Event|TouchEvent} event Event.\n       * @return {import(\"./pixel.js\").Pixel} Pixel.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getEventPixel = function getEventPixel(event) {\n        var viewportPosition = this.viewport_.getBoundingClientRect();\n        var eventPosition = 'changedTouches' in event ?\n        /** @type {TouchEvent} */\n        event.changedTouches[0] :\n        /** @type {MouseEvent} */\n        event;\n        return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];\n      };\n      /**\n       * Get the target in which this map is rendered.\n       * Note that this returns what is entered as an option or in setTarget:\n       * if that was an element, it returns an element; if a string, it returns that.\n       * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n       *     map is rendered in.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.getTarget = function getTarget() {\n        return (\n          /** @type {HTMLElement|string|undefined} */\n          this.get(MapProperty.TARGET)\n        );\n      };\n      /**\n       * Get the DOM element into which this map is rendered. In contrast to\n       * `getTarget` this method always return an `Element`, or `null` if the\n       * map has no target.\n       * @return {HTMLElement} The element that the map is rendered in.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getTargetElement = function getTargetElement() {\n        var target = this.getTarget();\n\n        if (target !== undefined) {\n          return typeof target === 'string' ? document.getElementById(target) : target;\n        } else {\n          return null;\n        }\n      };\n      /**\n       * Get the coordinate for a given pixel.  This returns a coordinate in the\n       * map view projection.\n       * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n       * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel(pixel) {\n        var frameState = this.frameState_;\n\n        if (!frameState) {\n          return null;\n        } else {\n          return apply(frameState.pixelToCoordinateTransform, pixel.slice());\n        }\n      };\n      /**\n       * Get the map controls. Modifying this collection changes the controls\n       * associated with the map.\n       * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getControls = function getControls() {\n        return this.controls;\n      };\n      /**\n       * Get the map overlays. Modifying this collection changes the overlays\n       * associated with the map.\n       * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getOverlays = function getOverlays() {\n        return this.overlays_;\n      };\n      /**\n       * Get an overlay by its identifier (the value returned by overlay.getId()).\n       * Note that the index treats string and numeric identifiers as the same. So\n       * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n       * @param {string|number} id Overlay identifier.\n       * @return {import(\"./Overlay.js\").default} Overlay.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getOverlayById = function getOverlayById(id) {\n        var overlay = this.overlayIdIndex_[id.toString()];\n        return overlay !== undefined ? overlay : null;\n      };\n      /**\n       * Get the map interactions. Modifying this collection changes the interactions\n       * associated with the map.\n       *\n       * Interactions are used for e.g. pan, zoom and rotate.\n       * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getInteractions = function getInteractions() {\n        return this.interactions;\n      };\n      /**\n       * Get the layergroup associated with this map.\n       * @return {LayerGroup} A layer group containing the layers in this map.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.getLayerGroup = function getLayerGroup() {\n        return (\n          /** @type {LayerGroup} */\n          this.get(MapProperty.LAYERGROUP)\n        );\n      };\n      /**\n       * Get the collection of layers associated with this map.\n       * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getLayers = function getLayers() {\n        var layers = this.getLayerGroup().getLayers();\n        return layers;\n      };\n      /**\n       * Get the pixel for a coordinate.  This takes a coordinate in the map view\n       * projection and returns the corresponding pixel.\n       * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n       * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate(coordinate) {\n        var frameState = this.frameState_;\n\n        if (!frameState) {\n          return null;\n        } else {\n          return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n        }\n      };\n      /**\n       * Get the map renderer.\n       * @return {import(\"./renderer/Map.js\").default} Renderer\n       */\n\n\n      PluggableMap.prototype.getRenderer = function getRenderer() {\n        return this.renderer_;\n      };\n      /**\n       * Get the size of this map.\n       * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.getSize = function getSize$$1() {\n        return (\n          /** @type {import(\"./size.js\").Size|undefined} */\n          this.get(MapProperty.SIZE)\n        );\n      };\n      /**\n       * Get the view associated with this map. A view manages properties such as\n       * center and resolution.\n       * @return {View} The view that controls this map.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.getView = function getView() {\n        return (\n          /** @type {View} */\n          this.get(MapProperty.VIEW)\n        );\n      };\n      /**\n       * Get the element that serves as the map viewport.\n       * @return {HTMLElement} Viewport.\n       * @api\n       */\n\n\n      PluggableMap.prototype.getViewport = function getViewport() {\n        return this.viewport_;\n      };\n      /**\n       * Get the element that serves as the container for overlays.  Elements added to\n       * this container will let mousedown and touchstart events through to the map,\n       * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n       * events.\n       * @return {!HTMLElement} The map's overlay container.\n       */\n\n\n      PluggableMap.prototype.getOverlayContainer = function getOverlayContainer() {\n        return this.overlayContainer_;\n      };\n      /**\n       * Get the element that serves as a container for overlays that don't allow\n       * event propagation. Elements added to this container won't let mousedown and\n       * touchstart events through to the map, so clicks and gestures on an overlay\n       * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n       * @return {!HTMLElement} The map's overlay container that stops events.\n       */\n\n\n      PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent() {\n        return this.overlayContainerStopEvent_;\n      };\n      /**\n       * @param {import(\"./Tile.js\").default} tile Tile.\n       * @param {string} tileSourceKey Tile source key.\n       * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n       * @param {number} tileResolution Tile resolution.\n       * @return {number} Tile priority.\n       */\n\n\n      PluggableMap.prototype.getTilePriority = function getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n        // Filter out tiles at higher zoom levels than the current zoom level, or that\n        // are outside the visible extent.\n        var frameState = this.frameState_;\n\n        if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n          return DROP;\n        }\n\n        if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n          return DROP;\n        } // Prioritize the highest zoom level tiles closest to the focus.\n        // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n        // Within a zoom level, tiles are prioritized by the distance in pixels\n        // between the center of the tile and the focus.  The factor of 65536 means\n        // that the prioritization should behave as desired for tiles up to\n        // 65536 * Math.log(2) = 45426 pixels from the focus.\n\n\n        var deltaX = tileCenter[0] - frameState.focus[0];\n        var deltaY = tileCenter[1] - frameState.focus[1];\n        return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n      };\n      /**\n       * @param {Event} browserEvent Browser event.\n       * @param {string=} opt_type Type.\n       */\n\n\n      PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent(browserEvent, opt_type) {\n        var type = opt_type || browserEvent.type;\n        var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n        this.handleMapBrowserEvent(mapBrowserEvent);\n      };\n      /**\n       * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n       */\n\n\n      PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent(mapBrowserEvent) {\n        if (!this.frameState_) {\n          // With no view defined, we cannot translate pixels into geographical\n          // coordinates so interactions cannot be used.\n          return;\n        }\n\n        this.focus_ = mapBrowserEvent.coordinate;\n        mapBrowserEvent.frameState = this.frameState_;\n        var interactionsArray = this.getInteractions().getArray();\n\n        if (this.dispatchEvent(mapBrowserEvent) !== false) {\n          for (var i = interactionsArray.length - 1; i >= 0; i--) {\n            var interaction = interactionsArray[i];\n\n            if (!interaction.getActive()) {\n              continue;\n            }\n\n            var cont = interaction.handleEvent(mapBrowserEvent);\n\n            if (!cont) {\n              break;\n            }\n          }\n        }\n      };\n      /**\n       * @protected\n       */\n\n\n      PluggableMap.prototype.handlePostRender = function handlePostRender() {\n        var frameState = this.frameState_; // Manage the tile queue\n        // Image loads are expensive and a limited resource, so try to use them\n        // efficiently:\n        // * When the view is static we allow a large number of parallel tile loads\n        //   to complete the frame as quickly as possible.\n        // * When animating or interacting, image loads can cause janks, so we reduce\n        //   the maximum number of loads per frame and limit the number of parallel\n        //   tile loads to remain reactive to view changes and to reduce the chance of\n        //   loading tiles that will quickly disappear from view.\n\n        var tileQueue = this.tileQueue_;\n\n        if (!tileQueue.isEmpty()) {\n          var maxTotalLoading = this.maxTilesLoading_;\n          var maxNewLoads = maxTotalLoading;\n\n          if (frameState) {\n            var hints = frameState.viewHints;\n\n            if (hints[ViewHint.ANIMATING]) {\n              maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\n              maxNewLoads = 2;\n            }\n\n            if (hints[ViewHint.INTERACTING]) {\n              maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\n              maxNewLoads = 2;\n            }\n          }\n\n          if (tileQueue.getTilesLoading() < maxTotalLoading) {\n            tileQueue.reprioritize(); // FIXME only call if view has changed\n\n            tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n          }\n        }\n\n        if (frameState && this.hasListener(RenderEventType.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !getLoading(this.getLayers().getArray())) {\n          this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n        }\n\n        var postRenderFunctions = this.postRenderFunctions_;\n\n        for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n          postRenderFunctions[i](this, frameState);\n        }\n\n        postRenderFunctions.length = 0;\n      };\n      /**\n       * @private\n       */\n\n\n      PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_() {\n        this.render();\n      };\n      /**\n       * @private\n       */\n\n\n      PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_() {\n        // target may be undefined, null, a string or an Element.\n        // If it's a string we convert it to an Element before proceeding.\n        // If it's not now an Element we remove the viewport from the DOM.\n        // If it's an Element we append the viewport element to it.\n        var targetElement;\n\n        if (this.getTarget()) {\n          targetElement = this.getTargetElement();\n        }\n\n        if (this.keyHandlerKeys_) {\n          for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n            unlistenByKey(this.keyHandlerKeys_[i]);\n          }\n\n          this.keyHandlerKeys_ = null;\n        }\n\n        if (!targetElement) {\n          this.renderer_.removeLayerRenderers();\n          removeNode(this.viewport_);\n\n          if (this.handleResize_ !== undefined) {\n            removeEventListener(EventType.RESIZE, this.handleResize_, false);\n            this.handleResize_ = undefined;\n          }\n        } else {\n          targetElement.appendChild(this.viewport_);\n          var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n          this.keyHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n\n          if (!this.handleResize_) {\n            this.handleResize_ = this.updateSize.bind(this);\n            addEventListener(EventType.RESIZE, this.handleResize_, false);\n          }\n        }\n\n        this.updateSize(); // updateSize calls setSize, so no need to call this.render\n        // ourselves here.\n      };\n      /**\n       * @private\n       */\n\n\n      PluggableMap.prototype.handleTileChange_ = function handleTileChange_() {\n        this.render();\n      };\n      /**\n       * @private\n       */\n\n\n      PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_() {\n        this.render();\n      };\n      /**\n       * @private\n       */\n\n\n      PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_() {\n        if (this.viewPropertyListenerKey_) {\n          unlistenByKey(this.viewPropertyListenerKey_);\n          this.viewPropertyListenerKey_ = null;\n        }\n\n        if (this.viewChangeListenerKey_) {\n          unlistenByKey(this.viewChangeListenerKey_);\n          this.viewChangeListenerKey_ = null;\n        }\n\n        var view = this.getView();\n\n        if (view) {\n          this.viewport_.setAttribute('data-view', getUid(view));\n          this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n          this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n        }\n\n        this.render();\n      };\n      /**\n       * @private\n       */\n\n\n      PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_() {\n        if (this.layerGroupPropertyListenerKeys_) {\n          this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n          this.layerGroupPropertyListenerKeys_ = null;\n        }\n\n        var layerGroup = this.getLayerGroup();\n\n        if (layerGroup) {\n          this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this)];\n        }\n\n        this.render();\n      };\n      /**\n       * @return {boolean} Is rendered.\n       */\n\n\n      PluggableMap.prototype.isRendered = function isRendered() {\n        return !!this.frameState_;\n      };\n      /**\n       * Requests an immediate render in a synchronous manner.\n       * @api\n       */\n\n\n      PluggableMap.prototype.renderSync = function renderSync() {\n        if (this.animationDelayKey_) {\n          cancelAnimationFrame(this.animationDelayKey_);\n        }\n\n        this.animationDelay_();\n      };\n      /**\n       * Request a map rendering (at the next animation frame).\n       * @api\n       */\n\n\n      PluggableMap.prototype.render = function render() {\n        if (this.animationDelayKey_ === undefined) {\n          this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n        }\n      };\n      /**\n       * Remove the given control from the map.\n       * @param {import(\"./control/Control.js\").default} control Control.\n       * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n       *     if the control was not found).\n       * @api\n       */\n\n\n      PluggableMap.prototype.removeControl = function removeControl(control) {\n        return this.getControls().remove(control);\n      };\n      /**\n       * Remove the given interaction from the map.\n       * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n       * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n       *     undefined if the interaction was not found).\n       * @api\n       */\n\n\n      PluggableMap.prototype.removeInteraction = function removeInteraction(interaction) {\n        return this.getInteractions().remove(interaction);\n      };\n      /**\n       * Removes the given layer from the map.\n       * @param {import(\"./layer/Base.js\").default} layer Layer.\n       * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n       *     layer was not found).\n       * @api\n       */\n\n\n      PluggableMap.prototype.removeLayer = function removeLayer(layer) {\n        var layers = this.getLayerGroup().getLayers();\n        return layers.remove(layer);\n      };\n      /**\n       * Remove the given overlay from the map.\n       * @param {import(\"./Overlay.js\").default} overlay Overlay.\n       * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n       *     if the overlay was not found).\n       * @api\n       */\n\n\n      PluggableMap.prototype.removeOverlay = function removeOverlay(overlay) {\n        return this.getOverlays().remove(overlay);\n      };\n      /**\n       * @param {number} time Time.\n       * @private\n       */\n\n\n      PluggableMap.prototype.renderFrame_ = function renderFrame_(time) {\n        var viewState;\n        var size = this.getSize();\n        var view = this.getView();\n        var extent = createEmpty();\n        var previousFrameState = this.frameState_;\n        /** @type {?FrameState} */\n\n        var frameState = null;\n\n        if (size !== undefined && hasArea(size) && view && view.isDef()) {\n          var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n          var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n          var layerStates = {};\n\n          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n            layerStates[getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\n          }\n\n          viewState = view.getState(this.pixelRatio_);\n          frameState =\n          /** @type {FrameState} */\n          {\n            animate: false,\n            coordinateToPixelTransform: this.coordinateToPixelTransform_,\n            extent: extent,\n            focus: this.focus_ ? this.focus_ : viewState.center,\n            index: this.frameIndex_++,\n            layerStates: layerStates,\n            layerStatesArray: layerStatesArray,\n            pixelRatio: this.pixelRatio_,\n            pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n            postRenderFunctions: [],\n            size: size,\n            skippedFeatureUids: this.skippedFeatureUids_,\n            tileQueue: this.tileQueue_,\n            time: time,\n            usedTiles: {},\n            viewState: viewState,\n            viewHints: viewHints,\n            wantedTiles: {}\n          };\n        }\n\n        if (frameState) {\n          frameState.extent = getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);\n        }\n\n        this.frameState_ = frameState;\n        this.renderer_.renderFrame(frameState);\n\n        if (frameState) {\n          if (frameState.animate) {\n            this.render();\n          }\n\n          Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n          if (previousFrameState) {\n            var moveStart = !this.previousExtent_ || !isEmpty$1(this.previousExtent_) && !equals$2(frameState.extent, this.previousExtent_);\n\n            if (moveStart) {\n              this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n              this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n            }\n          }\n\n          var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals$2(frameState.extent, this.previousExtent_);\n\n          if (idle) {\n            this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n            clone(frameState.extent, this.previousExtent_);\n          }\n        }\n\n        this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n        setTimeout(this.handlePostRender.bind(this), 0);\n      };\n      /**\n       * Sets the layergroup of this map.\n       * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.setLayerGroup = function setLayerGroup(layerGroup) {\n        this.set(MapProperty.LAYERGROUP, layerGroup);\n      };\n      /**\n       * Set the size of this map.\n       * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.setSize = function setSize(size) {\n        this.set(MapProperty.SIZE, size);\n      };\n      /**\n       * Set the target element to render this map into.\n       * @param {HTMLElement|string|undefined} target The Element or id of the Element\n       *     that the map is rendered in.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.setTarget = function setTarget(target) {\n        this.set(MapProperty.TARGET, target);\n      };\n      /**\n       * Set the view for this map.\n       * @param {View} view The view that controls this map.\n       * @observable\n       * @api\n       */\n\n\n      PluggableMap.prototype.setView = function setView(view) {\n        this.set(MapProperty.VIEW, view);\n      };\n      /**\n       * @param {import(\"./Feature.js\").default} feature Feature.\n       */\n\n\n      PluggableMap.prototype.skipFeature = function skipFeature(feature) {\n        this.skippedFeatureUids_[getUid(feature)] = true;\n        this.render();\n      };\n      /**\n       * Force a recalculation of the map viewport size.  This should be called when\n       * third-party code changes the size of the map viewport.\n       * @api\n       */\n\n\n      PluggableMap.prototype.updateSize = function updateSize() {\n        var targetElement = this.getTargetElement();\n\n        if (!targetElement) {\n          this.setSize(undefined);\n        } else {\n          var computedStyle = getComputedStyle(targetElement);\n          this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);\n        }\n      };\n      /**\n       * @param {import(\"./Feature.js\").default} feature Feature.\n       */\n\n\n      PluggableMap.prototype.unskipFeature = function unskipFeature(feature) {\n        delete this.skippedFeatureUids_[getUid(feature)];\n        this.render();\n      };\n\n      return PluggableMap;\n    }(BaseObject);\n    /**\n     * @param {MapOptions} options Map options.\n     * @return {MapOptionsInternal} Internal map options.\n     */\n\n\n    function createOptionsInternal(options) {\n      /**\n       * @type {HTMLElement|Document}\n       */\n      var keyboardEventTarget = null;\n\n      if (options.keyboardEventTarget !== undefined) {\n        keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n      }\n      /**\n       * @type {Object<string, *>}\n       */\n\n\n      var values = {};\n      var layerGroup = options.layers && typeof\n      /** @type {?} */\n      options.layers.getLayers === 'function' ?\n      /** @type {LayerGroup} */\n      options.layers : new LayerGroup({\n        layers:\n        /** @type {Collection} */\n        options.layers\n      });\n      values[MapProperty.LAYERGROUP] = layerGroup;\n      values[MapProperty.TARGET] = options.target;\n      values[MapProperty.VIEW] = options.view !== undefined ? options.view : new View();\n      var controls;\n\n      if (options.controls !== undefined) {\n        if (Array.isArray(options.controls)) {\n          controls = new Collection(options.controls.slice());\n        } else {\n          assert(typeof\n          /** @type {?} */\n          options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n\n          controls =\n          /** @type {Collection} */\n          options.controls;\n        }\n      }\n\n      var interactions;\n\n      if (options.interactions !== undefined) {\n        if (Array.isArray(options.interactions)) {\n          interactions = new Collection(options.interactions.slice());\n        } else {\n          assert(typeof\n          /** @type {?} */\n          options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n\n          interactions =\n          /** @type {Collection} */\n          options.interactions;\n        }\n      }\n\n      var overlays;\n\n      if (options.overlays !== undefined) {\n        if (Array.isArray(options.overlays)) {\n          overlays = new Collection(options.overlays.slice());\n        } else {\n          assert(typeof\n          /** @type {?} */\n          options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n\n          overlays = options.overlays;\n        }\n      } else {\n        overlays = new Collection();\n      }\n\n      return {\n        controls: controls,\n        interactions: interactions,\n        keyboardEventTarget: keyboardEventTarget,\n        overlays: overlays,\n        values: values\n      };\n    }\n    /**\n     * @param  {Array<import(\"./layer/Base.js\").default>} layers Layers.\n     * @return {boolean} Layers have sources that are still loading.\n     */\n\n\n    function getLoading(layers) {\n      for (var i = 0, ii = layers.length; i < ii; ++i) {\n        var layer = layers[i];\n\n        if (typeof\n        /** @type {?} */\n        layer.getLayers === 'function') {\n          return getLoading(\n          /** @type {LayerGroup} */\n          layer.getLayers().getArray());\n        } else {\n          var source =\n          /** @type {import(\"./layer/Layer.js\").default} */\n          layer.getSource();\n\n          if (source && source.loading) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @module ol/control/Control\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {HTMLElement} [element] The element is the control's\n     * container element. This only needs to be specified if you're developing\n     * a custom control.\n     * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when\n     * the control should be re-rendered. This is called in a `requestAnimationFrame`\n     * callback.\n     * @property {HTMLElement|string} [target] Specify a target if you want\n     * the control to be rendered outside of the map's viewport.\n     */\n\n    /**\n     * @classdesc\n     * A control is a visible widget with a DOM element in a fixed position on the\n     * screen. They can involve user input (buttons), or be informational only;\n     * the position is determined using CSS. By default these are placed in the\n     * container with CSS class name `ol-overlaycontainer-stopevent`, but can use\n     * any outside DOM element.\n     *\n     * This is the base class for controls. You can use it for simple custom\n     * controls by creating the element with listeners, creating an instance:\n     * ```js\n     * var myControl = new Control({element: myElement});\n     * ```\n     * and then adding this to the map.\n     *\n     * The main advantage of having this as a control rather than a simple separate\n     * DOM element is that preventing propagation is handled for you. Controls\n     * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.\n     *\n     * You can also extend this base for your own control class. See\n     * examples/custom-controls for an example of how to do this.\n     *\n     * @api\n     */\n\n\n    var Control =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function Control(options) {\n        BaseObject$$1.call(this);\n        /**\n         * @protected\n         * @type {HTMLElement}\n         */\n\n        this.element = options.element ? options.element : null;\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n\n        this.target_ = null;\n        /**\n         * @private\n         * @type {import(\"../PluggableMap.js\").default}\n         */\n\n        this.map_ = null;\n        /**\n         * @protected\n         * @type {!Array<import(\"../events.js\").EventsKey>}\n         */\n\n        this.listenerKeys = [];\n        /**\n         * @type {function(import(\"../MapEvent.js\").default)}\n         */\n\n        this.render = options.render ? options.render : VOID;\n\n        if (options.target) {\n          this.setTarget(options.target);\n        }\n      }\n\n      if (BaseObject$$1) Control.__proto__ = BaseObject$$1;\n      Control.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      Control.prototype.constructor = Control;\n      /**\n       * @inheritDoc\n       */\n\n      Control.prototype.disposeInternal = function disposeInternal() {\n        removeNode(this.element);\n        BaseObject$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * Get the map associated with this control.\n       * @return {import(\"../PluggableMap.js\").default} Map.\n       * @api\n       */\n\n\n      Control.prototype.getMap = function getMap() {\n        return this.map_;\n      };\n      /**\n       * Remove the control from its current map and attach it to the new map.\n       * Subclasses may set up event handlers to get notified about changes to\n       * the map here.\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @api\n       */\n\n\n      Control.prototype.setMap = function setMap(map) {\n        if (this.map_) {\n          removeNode(this.element);\n        }\n\n        for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {\n          unlistenByKey(this.listenerKeys[i]);\n        }\n\n        this.listenerKeys.length = 0;\n        this.map_ = map;\n\n        if (this.map_) {\n          var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();\n          target.appendChild(this.element);\n\n          if (this.render !== VOID) {\n            this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));\n          }\n\n          map.render();\n        }\n      };\n      /**\n       * This function is used to set a target element for the control. It has no\n       * effect if it is called after the control has been added to the map (i.e.\n       * after `setMap` is called on the control). If no `target` is set in the\n       * options passed to the control constructor and if `setTarget` is not called\n       * then the control is added to the map's overlay container.\n       * @param {HTMLElement|string} target Target.\n       * @api\n       */\n\n\n      Control.prototype.setTarget = function setTarget(target) {\n        this.target_ = typeof target === 'string' ? document.getElementById(target) : target;\n      };\n\n      return Control;\n    }(BaseObject);\n    /**\n     * @module ol/css\n     */\n\n    /**\n     * The CSS class for hidden feature.\n     *\n     * @const\n     * @type {string}\n     */\n\n\n    var CLASS_HIDDEN = 'ol-hidden';\n    /**\n     * The CSS class that we'll give the DOM elements to have them selectable.\n     *\n     * @const\n     * @type {string}\n     */\n\n    var CLASS_SELECTABLE = 'ol-selectable';\n    /**\n     * The CSS class that we'll give the DOM elements to have them unselectable.\n     *\n     * @const\n     * @type {string}\n     */\n\n    var CLASS_UNSELECTABLE = 'ol-unselectable';\n    /**\n     * The CSS class for unsupported feature.\n     *\n     * @const\n     * @type {string}\n     */\n\n    var CLASS_UNSUPPORTED = 'ol-unsupported';\n    /**\n     * The CSS class for controls.\n     *\n     * @const\n     * @type {string}\n     */\n\n    var CLASS_CONTROL = 'ol-control';\n    /**\n     * The CSS class that we'll give the DOM elements that are collapsed, i.e.\n     * to those elements which usually can be expanded.\n     *\n     * @const\n     * @type {string}\n     */\n\n    var CLASS_COLLAPSED = 'ol-collapsed';\n    /**\n     * Get the list of font families from a font spec.  Note that this doesn't work\n     * for font families that have commas in them.\n     * @param {string} The CSS font property.\n     * @return {Object<string>} The font families (or null if the input spec is invalid).\n     */\n\n    var getFontFamilies = function () {\n      var style;\n      var cache = {};\n      return function (font) {\n        if (!style) {\n          style = document.createElement('div').style;\n        }\n\n        if (!(font in cache)) {\n          style.font = font;\n          var family = style.fontFamily;\n          style.font = '';\n\n          if (!family) {\n            return null;\n          }\n\n          cache[font] = family.split(/,\\s?/);\n        }\n\n        return cache[font];\n      };\n    }();\n    /**\n     * @module ol/layer/Layer\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [opacity=1] Opacity (0, 1).\n     * @property {boolean} [visible=true] Visibility.\n     * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n     * rendered outside of this extent.\n     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n     * method was used.\n     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n     * visible.\n     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n     * be visible.\n     * @property {import(\"../source/Source.js\").default} [source] Source for this layer.  If not provided to the constructor,\n     * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after\n     * construction.\n     * @property {import(\"../PluggableMap.js\").default} [map] Map.\n     */\n\n    /**\n     * @typedef {Object} State\n     * @property {import(\"./Base.js\").default} layer\n     * @property {number} opacity\n     * @property {SourceState} sourceState\n     * @property {boolean} visible\n     * @property {boolean} managed\n     * @property {import(\"../extent.js\").Extent} [extent]\n     * @property {number} zIndex\n     * @property {number} maxResolution\n     * @property {number} minResolution\n     */\n\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * A visual representation of raster or vector map data.\n     * Layers group together those properties that pertain to how the data is to be\n     * displayed, irrespective of the source of that data.\n     *\n     * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components\n     * like {@link module:ol/interaction/Select~Select} use unmanaged layers\n     * internally. These unmanaged layers are associated with the map using\n     * {@link module:ol/layer/Layer~Layer#setMap} instead.\n     *\n     * A generic `change` event is fired when the state of the source changes.\n     *\n     * @fires import(\"../render/Event.js\").RenderEvent\n     */\n\n\n    var Layer =\n    /*@__PURE__*/\n    function (BaseLayer$$1) {\n      function Layer(options) {\n        var baseOptions = assign({}, options);\n        delete baseOptions.source;\n        BaseLayer$$1.call(this, baseOptions);\n        /**\n         * @private\n         * @type {?import(\"../events.js\").EventsKey}\n         */\n\n        this.mapPrecomposeKey_ = null;\n        /**\n         * @private\n         * @type {?import(\"../events.js\").EventsKey}\n         */\n\n        this.mapRenderKey_ = null;\n        /**\n         * @private\n         * @type {?import(\"../events.js\").EventsKey}\n         */\n\n        this.sourceChangeKey_ = null;\n\n        if (options.map) {\n          this.setMap(options.map);\n        }\n\n        listen(this, getChangeEventType(LayerProperty.SOURCE), this.handleSourcePropertyChange_, this);\n        var source = options.source ? options.source : null;\n        this.setSource(source);\n      }\n\n      if (BaseLayer$$1) Layer.__proto__ = BaseLayer$$1;\n      Layer.prototype = Object.create(BaseLayer$$1 && BaseLayer$$1.prototype);\n      Layer.prototype.constructor = Layer;\n      /**\n       * @inheritDoc\n       */\n\n      Layer.prototype.getLayersArray = function getLayersArray(opt_array) {\n        var array = opt_array ? opt_array : [];\n        array.push(this);\n        return array;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Layer.prototype.getLayerStatesArray = function getLayerStatesArray(opt_states) {\n        var states = opt_states ? opt_states : [];\n        states.push(this.getLayerState());\n        return states;\n      };\n      /**\n       * Get the layer source.\n       * @return {import(\"../source/Source.js\").default} The layer source (or `null` if not yet set).\n       * @observable\n       * @api\n       */\n\n\n      Layer.prototype.getSource = function getSource() {\n        var source = this.get(LayerProperty.SOURCE);\n        return (\n          /** @type {import(\"../source/Source.js\").default} */\n          source || null\n        );\n      };\n      /**\n        * @inheritDoc\n        */\n\n\n      Layer.prototype.getSourceState = function getSourceState() {\n        var source = this.getSource();\n        return !source ? SourceState.UNDEFINED : source.getState();\n      };\n      /**\n       * @private\n       */\n\n\n      Layer.prototype.handleSourceChange_ = function handleSourceChange_() {\n        this.changed();\n      };\n      /**\n       * @private\n       */\n\n\n      Layer.prototype.handleSourcePropertyChange_ = function handleSourcePropertyChange_() {\n        if (this.sourceChangeKey_) {\n          unlistenByKey(this.sourceChangeKey_);\n          this.sourceChangeKey_ = null;\n        }\n\n        var source = this.getSource();\n\n        if (source) {\n          this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);\n        }\n\n        this.changed();\n      };\n      /**\n       * Sets the layer to be rendered on top of other layers on a map. The map will\n       * not manage this layer in its layers collection, and the callback in\n       * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This\n       * is useful for temporary layers. To remove an unmanaged layer from the map,\n       * use `#setMap(null)`.\n       *\n       * To add the layer to a map and have it managed by the map, use\n       * {@link module:ol/Map#addLayer} instead.\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @api\n       */\n\n\n      Layer.prototype.setMap = function setMap(map) {\n        if (this.mapPrecomposeKey_) {\n          unlistenByKey(this.mapPrecomposeKey_);\n          this.mapPrecomposeKey_ = null;\n        }\n\n        if (!map) {\n          this.changed();\n        }\n\n        if (this.mapRenderKey_) {\n          unlistenByKey(this.mapRenderKey_);\n          this.mapRenderKey_ = null;\n        }\n\n        if (map) {\n          this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function (evt) {\n            var renderEvent =\n            /** @type {import(\"../render/Event.js\").default} */\n            evt;\n            var layerState = this.getLayerState();\n            layerState.managed = false;\n\n            if (this.getZIndex() === undefined) {\n              layerState.zIndex = Infinity;\n            }\n\n            renderEvent.frameState.layerStatesArray.push(layerState);\n            renderEvent.frameState.layerStates[getUid(this)] = layerState;\n          }, this);\n          this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n          this.changed();\n        }\n      };\n      /**\n       * Set the layer source.\n       * @param {import(\"../source/Source.js\").default} source The layer source.\n       * @observable\n       * @api\n       */\n\n\n      Layer.prototype.setSource = function setSource(source) {\n        this.set(LayerProperty.SOURCE, source);\n      };\n\n      return Layer;\n    }(BaseLayer);\n    /**\n     * Return `true` if the layer is visible, and if the passed resolution is\n     * between the layer's minResolution and maxResolution. The comparison is\n     * inclusive for `minResolution` and exclusive for `maxResolution`.\n     * @param {State} layerState Layer state.\n     * @param {number} resolution Resolution.\n     * @return {boolean} The layer is visible at the given resolution.\n     */\n\n\n    function visibleAtResolution(layerState, resolution) {\n      return layerState.visible && resolution >= layerState.minResolution && resolution < layerState.maxResolution;\n    }\n    /**\n     * @module ol/control/Attribution\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-attribution'] CSS class name.\n     * @property {HTMLElement|string} [target] Specify a target if you\n     * want the control to be rendered outside of the map's\n     * viewport.\n     * @property {boolean} [collapsible] Specify if attributions can\n     * be collapsed. If not specified, sources control this behavior with their\n     * `attributionsCollapsible` setting.\n     * @property {boolean} [collapsed=true] Specify if attributions should\n     * be collapsed at startup.\n     * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.\n     * @property {string} [label='i'] Text label to use for the\n     * collapsed attributions button.\n     * Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {string|HTMLElement} [collapseLabel=''] Text label to use\n     * for the expanded attributions button.\n     * Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when\n     * the control should be re-rendered. This is called in a `requestAnimationFrame`\n     * callback.\n     */\n\n    /**\n     * @classdesc\n     * Control to show all the attributions associated with the layer sources\n     * in the map. This control is one of the default controls included in maps.\n     * By default it will show in the bottom right portion of the map, but this can\n     * be changed by using a css selector for `.ol-attribution`.\n     *\n     * @api\n     */\n\n\n    var Attribution =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function Attribution(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          render: options.render || render,\n          target: options.target\n        });\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n\n        this.ulElement_ = document.createElement('ul');\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.overrideCollapsible_ = options.collapsible !== undefined;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;\n\n        if (!this.collapsible_) {\n          this.collapsed_ = false;\n        }\n\n        var className = options.className !== undefined ? options.className : 'ol-attribution';\n        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';\n        var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : \"\\xBB\";\n\n        if (typeof collapseLabel === 'string') {\n          /**\n           * @private\n           * @type {HTMLElement}\n           */\n          this.collapseLabel_ = document.createElement('span');\n          this.collapseLabel_.textContent = collapseLabel;\n        } else {\n          this.collapseLabel_ = collapseLabel;\n        }\n\n        var label = options.label !== undefined ? options.label : 'i';\n\n        if (typeof label === 'string') {\n          /**\n           * @private\n           * @type {HTMLElement}\n           */\n          this.label_ = document.createElement('span');\n          this.label_.textContent = label;\n        } else {\n          this.label_ = label;\n        }\n\n        var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;\n        var button = document.createElement('button');\n        button.setAttribute('type', 'button');\n        button.title = tipLabel;\n        button.appendChild(activeLabel);\n        listen(button, EventType.CLICK, this.handleClick_, this);\n        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');\n        var element = this.element;\n        element.className = cssClasses;\n        element.appendChild(this.ulElement_);\n        element.appendChild(button);\n        /**\n         * A list of currently rendered resolutions.\n         * @type {Array<string>}\n         * @private\n         */\n\n        this.renderedAttributions_ = [];\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.renderedVisible_ = true;\n      }\n\n      if (Control$$1) Attribution.__proto__ = Control$$1;\n      Attribution.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      Attribution.prototype.constructor = Attribution;\n      /**\n       * Collect a list of visible attributions and set the collapsible state.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @return {Array<string>} Attributions.\n       * @private\n       */\n\n      Attribution.prototype.collectSourceAttributions_ = function collectSourceAttributions_(frameState) {\n        /**\n         * Used to determine if an attribution already exists.\n         * @type {!Object<string, boolean>}\n         */\n        var lookup = {};\n        /**\n         * A list of visible attributions.\n         * @type {Array<string>}\n         */\n\n        var visibleAttributions = [];\n        var layerStatesArray = frameState.layerStatesArray;\n        var resolution = frameState.viewState.resolution;\n\n        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n          var layerState = layerStatesArray[i];\n\n          if (!visibleAtResolution(layerState, resolution)) {\n            continue;\n          }\n\n          var source =\n          /** @type {import(\"../layer/Layer.js\").default} */\n          layerState.layer.getSource();\n\n          if (!source) {\n            continue;\n          }\n\n          var attributionGetter = source.getAttributions();\n\n          if (!attributionGetter) {\n            continue;\n          }\n\n          var attributions = attributionGetter(frameState);\n\n          if (!attributions) {\n            continue;\n          }\n\n          if (!this.overrideCollapsible_ && source.getAttributionsCollapsible() === false) {\n            this.setCollapsible(false);\n          }\n\n          if (Array.isArray(attributions)) {\n            for (var j = 0, jj = attributions.length; j < jj; ++j) {\n              if (!(attributions[j] in lookup)) {\n                visibleAttributions.push(attributions[j]);\n                lookup[attributions[j]] = true;\n              }\n            }\n          } else {\n            if (!(attributions in lookup)) {\n              visibleAttributions.push(attributions);\n              lookup[attributions] = true;\n            }\n          }\n        }\n\n        return visibleAttributions;\n      };\n      /**\n       * @private\n       * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n\n\n      Attribution.prototype.updateElement_ = function updateElement_(frameState) {\n        if (!frameState) {\n          if (this.renderedVisible_) {\n            this.element.style.display = 'none';\n            this.renderedVisible_ = false;\n          }\n\n          return;\n        }\n\n        var attributions = this.collectSourceAttributions_(frameState);\n        var visible = attributions.length > 0;\n\n        if (this.renderedVisible_ != visible) {\n          this.element.style.display = visible ? '' : 'none';\n          this.renderedVisible_ = visible;\n        }\n\n        if (equals(attributions, this.renderedAttributions_)) {\n          return;\n        }\n\n        removeChildren(this.ulElement_); // append the attributions\n\n        for (var i = 0, ii = attributions.length; i < ii; ++i) {\n          var element = document.createElement('li');\n          element.innerHTML = attributions[i];\n          this.ulElement_.appendChild(element);\n        }\n\n        this.renderedAttributions_ = attributions;\n      };\n      /**\n       * @param {MouseEvent} event The event to handle\n       * @private\n       */\n\n\n      Attribution.prototype.handleClick_ = function handleClick_(event) {\n        event.preventDefault();\n        this.handleToggle_();\n      };\n      /**\n       * @private\n       */\n\n\n      Attribution.prototype.handleToggle_ = function handleToggle_() {\n        this.element.classList.toggle(CLASS_COLLAPSED);\n\n        if (this.collapsed_) {\n          replaceNode(this.collapseLabel_, this.label_);\n        } else {\n          replaceNode(this.label_, this.collapseLabel_);\n        }\n\n        this.collapsed_ = !this.collapsed_;\n      };\n      /**\n       * Return `true` if the attribution is collapsible, `false` otherwise.\n       * @return {boolean} True if the widget is collapsible.\n       * @api\n       */\n\n\n      Attribution.prototype.getCollapsible = function getCollapsible() {\n        return this.collapsible_;\n      };\n      /**\n       * Set whether the attribution should be collapsible.\n       * @param {boolean} collapsible True if the widget is collapsible.\n       * @api\n       */\n\n\n      Attribution.prototype.setCollapsible = function setCollapsible(collapsible) {\n        if (this.collapsible_ === collapsible) {\n          return;\n        }\n\n        this.collapsible_ = collapsible;\n        this.element.classList.toggle('ol-uncollapsible');\n\n        if (!collapsible && this.collapsed_) {\n          this.handleToggle_();\n        }\n      };\n      /**\n       * Collapse or expand the attribution according to the passed parameter. Will\n       * not do anything if the attribution isn't collapsible or if the current\n       * collapsed state is already the one requested.\n       * @param {boolean} collapsed True if the widget is collapsed.\n       * @api\n       */\n\n\n      Attribution.prototype.setCollapsed = function setCollapsed(collapsed) {\n        if (!this.collapsible_ || this.collapsed_ === collapsed) {\n          return;\n        }\n\n        this.handleToggle_();\n      };\n      /**\n       * Return `true` when the attribution is currently collapsed or `false`\n       * otherwise.\n       * @return {boolean} True if the widget is collapsed.\n       * @api\n       */\n\n\n      Attribution.prototype.getCollapsed = function getCollapsed() {\n        return this.collapsed_;\n      };\n\n      return Attribution;\n    }(Control);\n    /**\n     * Update the attribution element.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @this {Attribution}\n     * @api\n     */\n\n\n    function render(mapEvent) {\n      this.updateElement_(mapEvent.frameState);\n    }\n    /**\n     * @module ol/control/FullScreen\n     */\n\n    /**\n     * @return {string} Change type.\n     */\n\n\n    var getChangeType = function () {\n      var changeType;\n      return function () {\n        if (!changeType) {\n          var body = document.body;\n\n          if (body.webkitRequestFullscreen) {\n            changeType = 'webkitfullscreenchange';\n          } else if (body.mozRequestFullScreen) {\n            changeType = 'mozfullscreenchange';\n          } else if (body.msRequestFullscreen) {\n            changeType = 'MSFullscreenChange';\n          } else if (body.requestFullscreen) {\n            changeType = 'fullscreenchange';\n          }\n        }\n\n        return changeType;\n      };\n    }();\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-full-screen'] CSS class name.\n     * @property {string|Text} [label='\\u2922'] Text label to use for the button.\n     * Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {string|Text} [labelActive='\\u00d7'] Text label to use for the\n     * button when full-screen is active.\n     * Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.\n     * @property {boolean} [keys=false] Full keyboard access.\n     * @property {HTMLElement|string} [target] Specify a target if you want the\n     * control to be rendered outside of the map's viewport.\n     * @property {HTMLElement|string} [source] The element to be displayed\n     * fullscreen. When not provided, the element containing the map viewport will\n     * be displayed fullscreen.\n     */\n\n    /**\n     * @classdesc\n     * Provides a button that when clicked fills up the full screen with the map.\n     * The full screen source element is by default the element containing the map viewport unless\n     * overridden by providing the `source` option. In which case, the dom\n     * element introduced using this parameter will be displayed in full screen.\n     *\n     * When in full screen mode, a close button is shown to exit full screen mode.\n     * The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to\n     * toggle the map in full screen mode.\n     *\n     * @api\n     */\n\n\n    var FullScreen =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function FullScreen(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          target: options.target\n        });\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.cssClassName_ = options.className !== undefined ? options.className : 'ol-full-screen';\n        var label = options.label !== undefined ? options.label : \"\\u2922\";\n        /**\n         * @private\n         * @type {Text}\n         */\n\n        this.labelNode_ = typeof label === 'string' ? document.createTextNode(label) : label;\n        var labelActive = options.labelActive !== undefined ? options.labelActive : \"\\xD7\";\n        /**\n         * @private\n         * @type {Text}\n         */\n\n        this.labelActiveNode_ = typeof labelActive === 'string' ? document.createTextNode(labelActive) : labelActive;\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n\n        this.button_ = document.createElement('button');\n        var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';\n        this.setClassName_(this.button_, isFullScreen());\n        this.button_.setAttribute('type', 'button');\n        this.button_.title = tipLabel;\n        this.button_.appendChild(this.labelNode_);\n        listen(this.button_, EventType.CLICK, this.handleClick_, this);\n        var cssClasses = this.cssClassName_ + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL + ' ' + (!isFullScreenSupported() ? CLASS_UNSUPPORTED : '');\n        var element = this.element;\n        element.className = cssClasses;\n        element.appendChild(this.button_);\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.keys_ = options.keys !== undefined ? options.keys : false;\n        /**\n         * @private\n         * @type {HTMLElement|string|undefined}\n         */\n\n        this.source_ = options.source;\n      }\n\n      if (Control$$1) FullScreen.__proto__ = Control$$1;\n      FullScreen.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      FullScreen.prototype.constructor = FullScreen;\n      /**\n       * @param {MouseEvent} event The event to handle\n       * @private\n       */\n\n      FullScreen.prototype.handleClick_ = function handleClick_(event) {\n        event.preventDefault();\n        this.handleFullScreen_();\n      };\n      /**\n       * @private\n       */\n\n\n      FullScreen.prototype.handleFullScreen_ = function handleFullScreen_() {\n        if (!isFullScreenSupported()) {\n          return;\n        }\n\n        var map = this.getMap();\n\n        if (!map) {\n          return;\n        }\n\n        if (isFullScreen()) {\n          exitFullScreen();\n        } else {\n          var element;\n\n          if (this.source_) {\n            element = typeof this.source_ === 'string' ? document.getElementById(this.source_) : this.source_;\n          } else {\n            element = map.getTargetElement();\n          }\n\n          if (this.keys_) {\n            requestFullScreenWithKeys(element);\n          } else {\n            requestFullScreen(element);\n          }\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      FullScreen.prototype.handleFullScreenChange_ = function handleFullScreenChange_() {\n        var map = this.getMap();\n\n        if (isFullScreen()) {\n          this.setClassName_(this.button_, true);\n          replaceNode(this.labelActiveNode_, this.labelNode_);\n        } else {\n          this.setClassName_(this.button_, false);\n          replaceNode(this.labelNode_, this.labelActiveNode_);\n        }\n\n        if (map) {\n          map.updateSize();\n        }\n      };\n      /**\n       * @param {HTMLElement} element Target element\n       * @param {boolean} fullscreen True if fullscreen class name should be active\n       * @private\n       */\n\n\n      FullScreen.prototype.setClassName_ = function setClassName_(element, fullscreen) {\n        var activeClassName = this.cssClassName_ + '-true';\n        var inactiveClassName = this.cssClassName_ + '-false';\n        var nextClassName = fullscreen ? activeClassName : inactiveClassName;\n        element.classList.remove(activeClassName);\n        element.classList.remove(inactiveClassName);\n        element.classList.add(nextClassName);\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      FullScreen.prototype.setMap = function setMap(map) {\n        Control$$1.prototype.setMap.call(this, map);\n\n        if (map) {\n          this.listenerKeys.push(listen(document, getChangeType(), this.handleFullScreenChange_, this));\n        }\n      };\n\n      return FullScreen;\n    }(Control);\n    /**\n     * @return {boolean} Fullscreen is supported by the current platform.\n     */\n\n\n    function isFullScreenSupported() {\n      var body = document.body;\n      return !!(body.webkitRequestFullscreen || body.mozRequestFullScreen && document.mozFullScreenEnabled || body.msRequestFullscreen && document.msFullscreenEnabled || body.requestFullscreen && document.fullscreenEnabled);\n    }\n    /**\n     * @return {boolean} Element is currently in fullscreen.\n     */\n\n\n    function isFullScreen() {\n      return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);\n    }\n    /**\n     * Request to fullscreen an element.\n     * @param {HTMLElement} element Element to request fullscreen\n     */\n\n\n    function requestFullScreen(element) {\n      if (element.requestFullscreen) {\n        element.requestFullscreen();\n      } else if (element.msRequestFullscreen) {\n        element.msRequestFullscreen();\n      } else if (element.mozRequestFullScreen) {\n        element.mozRequestFullScreen();\n      } else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen();\n      }\n    }\n    /**\n     * Request to fullscreen an element with keyboard input.\n     * @param {HTMLElement} element Element to request fullscreen\n     */\n\n\n    function requestFullScreenWithKeys(element) {\n      if (element.mozRequestFullScreenWithKeys) {\n        element.mozRequestFullScreenWithKeys();\n      } else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen();\n      } else {\n        requestFullScreen(element);\n      }\n    }\n    /**\n     * Exit fullscreen.\n     */\n\n\n    function exitFullScreen() {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.msExitFullscreen) {\n        document.msExitFullscreen();\n      } else if (document.mozCancelFullScreen) {\n        document.mozCancelFullScreen();\n      } else if (document.webkitExitFullscreen) {\n        document.webkitExitFullscreen();\n      }\n    }\n    /**\n     * @module ol/control/MousePosition\n     */\n\n    /**\n     * @type {string}\n     */\n\n\n    var PROJECTION = 'projection';\n    /**\n     * @type {string}\n     */\n\n    var COORDINATE_FORMAT = 'coordinateFormat';\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-mouse-position'] CSS class name.\n     * @property {import(\"../coordinate.js\").CoordinateFormat} [coordinateFormat] Coordinate format.\n     * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n     * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when the\n     * control should be re-rendered. This is called in a `requestAnimationFrame`\n     * callback.\n     * @property {HTMLElement|string} [target] Specify a target if you want the\n     * control to be rendered outside of the map's viewport.\n     * @property {string} [undefinedHTML='&#160;'] Markup to show when coordinates are not\n     * available (e.g. when the pointer leaves the map viewport).  By default, the last position\n     * will be replaced with `'&#160;'` (`&nbsp;`) when the pointer leaves the viewport.  To\n     * retain the last rendered position, set this option to something falsey (like an empty\n     * string `''`).\n     */\n\n    /**\n     * @classdesc\n     * A control to show the 2D coordinates of the mouse cursor. By default, these\n     * are in the view projection, but can be in any supported projection.\n     * By default the control is shown in the top right corner of the map, but this\n     * can be changed by using the css selector `.ol-mouse-position`.\n     *\n     * On touch devices, which usually do not have a mouse cursor, the coordinates\n     * of the currently touched position are shown.\n     *\n     * @api\n     */\n\n    var MousePosition =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function MousePosition(opt_options) {\n        var options = opt_options ? opt_options : {};\n        var element = document.createElement('div');\n        element.className = options.className !== undefined ? options.className : 'ol-mouse-position';\n        Control$$1.call(this, {\n          element: element,\n          render: options.render || render$1,\n          target: options.target\n        });\n        listen(this, getChangeEventType(PROJECTION), this.handleProjectionChanged_, this);\n\n        if (options.coordinateFormat) {\n          this.setCoordinateFormat(options.coordinateFormat);\n        }\n\n        if (options.projection) {\n          this.setProjection(options.projection);\n        }\n        /**\n         * @private\n         * @type {string}\n         */\n\n\n        this.undefinedHTML_ = options.undefinedHTML !== undefined ? options.undefinedHTML : '&#160;';\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.renderOnMouseOut_ = !!this.undefinedHTML_;\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.renderedHTML_ = element.innerHTML;\n        /**\n         * @private\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n\n        this.mapProjection_ = null;\n        /**\n         * @private\n         * @type {?import(\"../proj.js\").TransformFunction}\n         */\n\n        this.transform_ = null;\n        /**\n         * @private\n         * @type {import(\"../pixel.js\").Pixel}\n         */\n\n        this.lastMouseMovePixel_ = null;\n      }\n\n      if (Control$$1) MousePosition.__proto__ = Control$$1;\n      MousePosition.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      MousePosition.prototype.constructor = MousePosition;\n      /**\n       * @private\n       */\n\n      MousePosition.prototype.handleProjectionChanged_ = function handleProjectionChanged_() {\n        this.transform_ = null;\n      };\n      /**\n       * Return the coordinate format type used to render the current position or\n       * undefined.\n       * @return {import(\"../coordinate.js\").CoordinateFormat|undefined} The format to render the current\n       *     position in.\n       * @observable\n       * @api\n       */\n\n\n      MousePosition.prototype.getCoordinateFormat = function getCoordinateFormat() {\n        return (\n          /** @type {import(\"../coordinate.js\").CoordinateFormat|undefined} */\n          this.get(COORDINATE_FORMAT)\n        );\n      };\n      /**\n       * Return the projection that is used to report the mouse position.\n       * @return {import(\"../proj/Projection.js\").default|undefined} The projection to report mouse\n       *     position in.\n       * @observable\n       * @api\n       */\n\n\n      MousePosition.prototype.getProjection = function getProjection() {\n        return (\n          /** @type {import(\"../proj/Projection.js\").default|undefined} */\n          this.get(PROJECTION)\n        );\n      };\n      /**\n       * @param {Event} event Browser event.\n       * @protected\n       */\n\n\n      MousePosition.prototype.handleMouseMove = function handleMouseMove(event) {\n        var map = this.getMap();\n        this.lastMouseMovePixel_ = map.getEventPixel(event);\n        this.updateHTML_(this.lastMouseMovePixel_);\n      };\n      /**\n       * @param {Event} event Browser event.\n       * @protected\n       */\n\n\n      MousePosition.prototype.handleMouseOut = function handleMouseOut(event) {\n        this.updateHTML_(null);\n        this.lastMouseMovePixel_ = null;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      MousePosition.prototype.setMap = function setMap(map) {\n        Control$$1.prototype.setMap.call(this, map);\n\n        if (map) {\n          var viewport = map.getViewport();\n          this.listenerKeys.push(listen(viewport, EventType.MOUSEMOVE, this.handleMouseMove, this), listen(viewport, EventType.TOUCHSTART, this.handleMouseMove, this));\n\n          if (this.renderOnMouseOut_) {\n            this.listenerKeys.push(listen(viewport, EventType.MOUSEOUT, this.handleMouseOut, this), listen(viewport, EventType.TOUCHEND, this.handleMouseOut, this));\n          }\n        }\n      };\n      /**\n       * Set the coordinate format type used to render the current position.\n       * @param {import(\"../coordinate.js\").CoordinateFormat} format The format to render the current\n       *     position in.\n       * @observable\n       * @api\n       */\n\n\n      MousePosition.prototype.setCoordinateFormat = function setCoordinateFormat(format) {\n        this.set(COORDINATE_FORMAT, format);\n      };\n      /**\n       * Set the projection that is used to report the mouse position.\n       * @param {import(\"../proj.js\").ProjectionLike} projection The projection to report mouse\n       *     position in.\n       * @observable\n       * @api\n       */\n\n\n      MousePosition.prototype.setProjection = function setProjection(projection) {\n        this.set(PROJECTION, get$2(projection));\n      };\n      /**\n       * @param {?import(\"../pixel.js\").Pixel} pixel Pixel.\n       * @private\n       */\n\n\n      MousePosition.prototype.updateHTML_ = function updateHTML_(pixel) {\n        var html = this.undefinedHTML_;\n\n        if (pixel && this.mapProjection_) {\n          if (!this.transform_) {\n            var projection = this.getProjection();\n\n            if (projection) {\n              this.transform_ = getTransformFromProjections(this.mapProjection_, projection);\n            } else {\n              this.transform_ = identityTransform;\n            }\n          }\n\n          var map = this.getMap();\n          var coordinate = map.getCoordinateFromPixel(pixel);\n\n          if (coordinate) {\n            this.transform_(coordinate, coordinate);\n            var coordinateFormat = this.getCoordinateFormat();\n\n            if (coordinateFormat) {\n              html = coordinateFormat(coordinate);\n            } else {\n              html = coordinate.toString();\n            }\n          }\n        }\n\n        if (!this.renderedHTML_ || html !== this.renderedHTML_) {\n          this.element.innerHTML = html;\n          this.renderedHTML_ = html;\n        }\n      };\n\n      return MousePosition;\n    }(Control);\n    /**\n     * Update the projection. Rendering of the coordinates is done in\n     * `handleMouseMove` and `handleMouseUp`.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @this {MousePosition}\n     * @api\n     */\n\n\n    function render$1(mapEvent) {\n      var frameState = mapEvent.frameState;\n\n      if (!frameState) {\n        this.mapProjection_ = null;\n      } else {\n        if (this.mapProjection_ != frameState.viewState.projection) {\n          this.mapProjection_ = frameState.viewState.projection;\n          this.transform_ = null;\n        }\n      }\n    }\n    /**\n     * @module ol/control/Rotate\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-rotate'] CSS class name.\n     * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.\n     * Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.\n     * @property {number} [duration=250] Animation duration in milliseconds.\n     * @property {boolean} [autoHide=true] Hide the control when rotation is 0.\n     * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when the control should\n     * be re-rendered. This is called in a `requestAnimationFrame` callback.\n     * @property {function()} [resetNorth] Function called when the control is clicked.\n     * This will override the default `resetNorth`.\n     * @property {HTMLElement|string} [target] Specify a target if you want the control to be\n     * rendered outside of the map's viewport.\n     */\n\n    /**\n     * @classdesc\n     * A button control to reset rotation to 0.\n     * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css\n     * selector is added to the button when the rotation is 0.\n     *\n     * @api\n     */\n\n\n    var Rotate =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function Rotate(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          render: options.render || render$2,\n          target: options.target\n        });\n        var className = options.className !== undefined ? options.className : 'ol-rotate';\n        var label = options.label !== undefined ? options.label : \"\\u21E7\";\n        /**\n         * @type {HTMLElement}\n         * @private\n         */\n\n        this.label_ = null;\n\n        if (typeof label === 'string') {\n          this.label_ = document.createElement('span');\n          this.label_.className = 'ol-compass';\n          this.label_.textContent = label;\n        } else {\n          this.label_ = label;\n          this.label_.classList.add('ol-compass');\n        }\n\n        var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';\n        var button = document.createElement('button');\n        button.className = className + '-reset';\n        button.setAttribute('type', 'button');\n        button.title = tipLabel;\n        button.appendChild(this.label_);\n        listen(button, EventType.CLICK, this.handleClick_, this);\n        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n        var element = this.element;\n        element.className = cssClasses;\n        element.appendChild(button);\n        this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 250;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.rotation_ = undefined;\n\n        if (this.autoHide_) {\n          this.element.classList.add(CLASS_HIDDEN);\n        }\n      }\n\n      if (Control$$1) Rotate.__proto__ = Control$$1;\n      Rotate.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      Rotate.prototype.constructor = Rotate;\n      /**\n       * @param {MouseEvent} event The event to handle\n       * @private\n       */\n\n      Rotate.prototype.handleClick_ = function handleClick_(event) {\n        event.preventDefault();\n\n        if (this.callResetNorth_ !== undefined) {\n          this.callResetNorth_();\n        } else {\n          this.resetNorth_();\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      Rotate.prototype.resetNorth_ = function resetNorth_() {\n        var map = this.getMap();\n        var view = map.getView();\n\n        if (!view) {\n          // the map does not have a view, so we can't act\n          // upon it\n          return;\n        }\n\n        if (view.getRotation() !== undefined) {\n          if (this.duration_ > 0) {\n            view.animate({\n              rotation: 0,\n              duration: this.duration_,\n              easing: easeOut\n            });\n          } else {\n            view.setRotation(0);\n          }\n        }\n      };\n\n      return Rotate;\n    }(Control);\n    /**\n     * Update the rotate control element.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @this {Rotate}\n     * @api\n     */\n\n\n    function render$2(mapEvent) {\n      var frameState = mapEvent.frameState;\n\n      if (!frameState) {\n        return;\n      }\n\n      var rotation = frameState.viewState.rotation;\n\n      if (rotation != this.rotation_) {\n        var transform = 'rotate(' + rotation + 'rad)';\n\n        if (this.autoHide_) {\n          var contains = this.element.classList.contains(CLASS_HIDDEN);\n\n          if (!contains && rotation === 0) {\n            this.element.classList.add(CLASS_HIDDEN);\n          } else if (contains && rotation !== 0) {\n            this.element.classList.remove(CLASS_HIDDEN);\n          }\n        }\n\n        this.label_.style.msTransform = transform;\n        this.label_.style.webkitTransform = transform;\n        this.label_.style.transform = transform;\n      }\n\n      this.rotation_ = rotation;\n    }\n    /**\n     * @module ol/control/Zoom\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [duration=250] Animation duration in milliseconds.\n     * @property {string} [className='ol-zoom'] CSS class name.\n     * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in\n     * button. Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.\n     * Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.\n     * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.\n     * @property {number} [delta=1] The zoom delta applied on each click.\n     * @property {HTMLElement|string} [target] Specify a target if you want the control to be\n     * rendered outside of the map's viewport.\n     */\n\n    /**\n     * @classdesc\n     * A control with 2 buttons, one for zoom in and one for zoom out.\n     * This control is one of the default controls of a map. To style this control\n     * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.\n     *\n     * @api\n     */\n\n\n    var Zoom =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function Zoom(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          target: options.target\n        });\n        var className = options.className !== undefined ? options.className : 'ol-zoom';\n        var delta = options.delta !== undefined ? options.delta : 1;\n        var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';\n        var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : \"\\u2212\";\n        var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';\n        var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';\n        var inElement = document.createElement('button');\n        inElement.className = className + '-in';\n        inElement.setAttribute('type', 'button');\n        inElement.title = zoomInTipLabel;\n        inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);\n        listen(inElement, EventType.CLICK, this.handleClick_.bind(this, delta));\n        var outElement = document.createElement('button');\n        outElement.className = className + '-out';\n        outElement.setAttribute('type', 'button');\n        outElement.title = zoomOutTipLabel;\n        outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);\n        listen(outElement, EventType.CLICK, this.handleClick_.bind(this, -delta));\n        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n        var element = this.element;\n        element.className = cssClasses;\n        element.appendChild(inElement);\n        element.appendChild(outElement);\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 250;\n      }\n\n      if (Control$$1) Zoom.__proto__ = Control$$1;\n      Zoom.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      Zoom.prototype.constructor = Zoom;\n      /**\n       * @param {number} delta Zoom delta.\n       * @param {MouseEvent} event The event to handle\n       * @private\n       */\n\n      Zoom.prototype.handleClick_ = function handleClick_(delta, event) {\n        event.preventDefault();\n        this.zoomByDelta_(delta);\n      };\n      /**\n       * @param {number} delta Zoom delta.\n       * @private\n       */\n\n\n      Zoom.prototype.zoomByDelta_ = function zoomByDelta_(delta) {\n        var map = this.getMap();\n        var view = map.getView();\n\n        if (!view) {\n          // the map does not have a view, so we can't act\n          // upon it\n          return;\n        }\n\n        var currentResolution = view.getResolution();\n\n        if (currentResolution) {\n          var newResolution = view.constrainResolution(currentResolution, delta);\n\n          if (this.duration_ > 0) {\n            if (view.getAnimating()) {\n              view.cancelAnimations();\n            }\n\n            view.animate({\n              resolution: newResolution,\n              duration: this.duration_,\n              easing: easeOut\n            });\n          } else {\n            view.setResolution(newResolution);\n          }\n        }\n      };\n\n      return Zoom;\n    }(Control);\n    /**\n     * @module ol/control/util\n     */\n\n    /**\n     * @typedef {Object} DefaultsOptions\n     * @property {boolean} [attribution=true] Include\n     * {@link module:ol/control/Attribution~Attribution}.\n     * @property {import(\"./Attribution.js\").Options} [attributionOptions]\n     * Options for {@link module:ol/control/Attribution~Attribution}.\n     * @property {boolean} [rotate=true] Include\n     * {@link module:ol/control/Rotate~Rotate}.\n     * @property {import(\"./Rotate.js\").Options} [rotateOptions] Options\n     * for {@link module:ol/control/Rotate~Rotate}.\n     * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.\n     * @property {import(\"./Zoom.js\").Options} [zoomOptions] Options for\n     * {@link module:ol/control/Zoom~Zoom}.\n     * @api\n     */\n\n    /**\n     * Set of controls included in maps by default. Unless configured otherwise,\n     * this returns a collection containing an instance of each of the following\n     * controls:\n     * * {@link module:ol/control/Zoom~Zoom}\n     * * {@link module:ol/control/Rotate~Rotate}\n     * * {@link module:ol/control/Attribution~Attribution}\n     *\n     * @param {DefaultsOptions=} opt_options\n     * Defaults options.\n     * @return {Collection<import(\"./Control.js\").default>}\n     * Controls.\n     * @function module:ol/control.defaults\n     * @api\n     */\n\n\n    function defaults(opt_options) {\n      var options = opt_options ? opt_options : {};\n      var controls = new Collection();\n      var zoomControl = options.zoom !== undefined ? options.zoom : true;\n\n      if (zoomControl) {\n        controls.push(new Zoom(options.zoomOptions));\n      }\n\n      var rotateControl = options.rotate !== undefined ? options.rotate : true;\n\n      if (rotateControl) {\n        controls.push(new Rotate(options.rotateOptions));\n      }\n\n      var attributionControl = options.attribution !== undefined ? options.attribution : true;\n\n      if (attributionControl) {\n        controls.push(new Attribution(options.attributionOptions));\n      }\n\n      return controls;\n    }\n    /**\n     * @module ol/Kinetic\n     */\n\n    /**\n     * @classdesc\n     * Implementation of inertial deceleration for map movement.\n     *\n     * @api\n     */\n\n\n    var Kinetic = function Kinetic(decay, minVelocity, delay) {\n      /**\n       * @private\n       * @type {number}\n       */\n      this.decay_ = decay;\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.minVelocity_ = minVelocity;\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.delay_ = delay;\n      /**\n       * @private\n       * @type {Array<number>}\n       */\n\n      this.points_ = [];\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.angle_ = 0;\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.initialVelocity_ = 0;\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n\n\n    Kinetic.prototype.begin = function begin() {\n      this.points_.length = 0;\n      this.angle_ = 0;\n      this.initialVelocity_ = 0;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     */\n\n\n    Kinetic.prototype.update = function update(x, y) {\n      this.points_.push(x, y, Date.now());\n    };\n    /**\n     * @return {boolean} Whether we should do kinetic animation.\n     */\n\n\n    Kinetic.prototype.end = function end() {\n      if (this.points_.length < 6) {\n        // at least 2 points are required (i.e. there must be at least 6 elements\n        // in the array)\n        return false;\n      }\n\n      var delay = Date.now() - this.delay_;\n      var lastIndex = this.points_.length - 3;\n\n      if (this.points_[lastIndex + 2] < delay) {\n        // the last tracked point is too old, which means that the user stopped\n        // panning before releasing the map\n        return false;\n      } // get the first point which still falls into the delay time\n\n\n      var firstIndex = lastIndex - 3;\n\n      while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {\n        firstIndex -= 3;\n      }\n\n      var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)\n      // we also make sure the user panned for a duration of at least one frame\n      // (1/60s) to compute sane displacement values\n\n      if (duration < 1000 / 60) {\n        return false;\n      }\n\n      var dx = this.points_[lastIndex] - this.points_[firstIndex];\n      var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];\n      this.angle_ = Math.atan2(dy, dx);\n      this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;\n      return this.initialVelocity_ > this.minVelocity_;\n    };\n    /**\n     * @return {number} Total distance travelled (pixels).\n     */\n\n\n    Kinetic.prototype.getDistance = function getDistance() {\n      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;\n    };\n    /**\n     * @return {number} Angle of the kinetic panning animation (radians).\n     */\n\n\n    Kinetic.prototype.getAngle = function getAngle() {\n      return this.angle_;\n    };\n    /**\n     * @module ol/interaction/Property\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var InteractionProperty = {\n      ACTIVE: 'active'\n    };\n    /**\n     * @module ol/interaction/Interaction\n     */\n\n    /**\n     * Object literal with config options for interactions.\n     * @typedef {Object} InteractionOptions\n     * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} handleEvent\n     * Method called by the map to notify the interaction that a browser event was\n     * dispatched to the map. If the function returns a falsy value, propagation of\n     * the event to other interactions in the map's interactions chain will be\n     * prevented (this includes functions with no explicit return).\n     */\n\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * User actions that change the state of the map. Some are similar to controls,\n     * but are not associated with a DOM element.\n     * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\n     * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\n     * by a keyboard event not a button element event.\n     * Although interactions do not have a DOM element, some of them do render\n     * vectors and so are visible on the screen.\n     * @api\n     */\n\n    var Interaction =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function Interaction(options) {\n        BaseObject$$1.call(this);\n\n        if (options.handleEvent) {\n          this.handleEvent = options.handleEvent;\n        }\n        /**\n         * @private\n         * @type {import(\"../PluggableMap.js\").default}\n         */\n\n\n        this.map_ = null;\n        this.setActive(true);\n      }\n\n      if (BaseObject$$1) Interaction.__proto__ = BaseObject$$1;\n      Interaction.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      Interaction.prototype.constructor = Interaction;\n      /**\n       * Return whether the interaction is currently active.\n       * @return {boolean} `true` if the interaction is active, `false` otherwise.\n       * @observable\n       * @api\n       */\n\n      Interaction.prototype.getActive = function getActive() {\n        return (\n          /** @type {boolean} */\n          this.get(InteractionProperty.ACTIVE)\n        );\n      };\n      /**\n       * Get the map associated with this interaction.\n       * @return {import(\"../PluggableMap.js\").default} Map.\n       * @api\n       */\n\n\n      Interaction.prototype.getMap = function getMap() {\n        return this.map_;\n      };\n      /**\n       * Handles the {@link module:ol/MapBrowserEvent map browser event}.\n       * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n       * @return {boolean} `false` to stop event propagation.\n       * @api\n       */\n\n\n      Interaction.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n        return true;\n      };\n      /**\n       * Activate or deactivate the interaction.\n       * @param {boolean} active Active.\n       * @observable\n       * @api\n       */\n\n\n      Interaction.prototype.setActive = function setActive(active) {\n        this.set(InteractionProperty.ACTIVE, active);\n      };\n      /**\n       * Remove the interaction from its current map and attach it to the new map.\n       * Subclasses may set up event handlers to get notified about changes to\n       * the map here.\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       */\n\n\n      Interaction.prototype.setMap = function setMap(map) {\n        this.map_ = map;\n      };\n\n      return Interaction;\n    }(BaseObject);\n    /**\n     * @param {import(\"../View.js\").default} view View.\n     * @param {import(\"../coordinate.js\").Coordinate} delta Delta.\n     * @param {number=} opt_duration Duration.\n     */\n\n\n    function pan(view, delta, opt_duration) {\n      var currentCenter = view.getCenter();\n\n      if (currentCenter) {\n        var center = view.constrainCenter([currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);\n\n        if (opt_duration) {\n          view.animate({\n            duration: opt_duration,\n            easing: linear,\n            center: center\n          });\n        } else {\n          view.setCenter(center);\n        }\n      }\n    }\n    /**\n     * @param {import(\"../View.js\").default} view View.\n     * @param {number|undefined} rotation Rotation.\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor Anchor coordinate.\n     * @param {number=} opt_duration Duration.\n     */\n\n\n    function rotate$3(view, rotation, opt_anchor, opt_duration) {\n      rotation = view.constrainRotation(rotation, 0);\n      rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);\n    }\n    /**\n     * @param {import(\"../View.js\").default} view View.\n     * @param {number|undefined} rotation Rotation.\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor Anchor coordinate.\n     * @param {number=} opt_duration Duration.\n     */\n\n\n    function rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration) {\n      if (rotation !== undefined) {\n        var currentRotation = view.getRotation();\n        var currentCenter = view.getCenter();\n\n        if (currentRotation !== undefined && currentCenter && opt_duration > 0) {\n          view.animate({\n            rotation: rotation,\n            anchor: opt_anchor,\n            duration: opt_duration,\n            easing: easeOut\n          });\n        } else {\n          view.rotate(rotation, opt_anchor);\n        }\n      }\n    }\n    /**\n     * @param {import(\"../View.js\").default} view View.\n     * @param {number|undefined} resolution Resolution to go to.\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor Anchor coordinate.\n     * @param {number=} opt_duration Duration.\n     * @param {number=} opt_direction Zooming direction; > 0 indicates\n     *     zooming out, in which case the constraints system will select\n     *     the largest nearest resolution; < 0 indicates zooming in, in\n     *     which case the constraints system will select the smallest\n     *     nearest resolution; == 0 indicates that the zooming direction\n     *     is unknown/not relevant, in which case the constraints system\n     *     will select the nearest resolution. If not defined 0 is\n     *     assumed.\n     */\n\n\n    function zoom(view, resolution, opt_anchor, opt_duration, opt_direction) {\n      resolution = view.constrainResolution(resolution, 0, opt_direction);\n      zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);\n    }\n    /**\n     * @param {import(\"../View.js\").default} view View.\n     * @param {number} delta Delta from previous zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor Anchor coordinate.\n     * @param {number=} opt_duration Duration.\n     */\n\n\n    function zoomByDelta(view, delta, opt_anchor, opt_duration) {\n      var currentResolution = view.getResolution();\n      var resolution = view.constrainResolution(currentResolution, delta, 0);\n\n      if (resolution !== undefined) {\n        var resolutions = view.getResolutions();\n        resolution = clamp(resolution, view.getMinResolution() || resolutions[resolutions.length - 1], view.getMaxResolution() || resolutions[0]);\n      } // If we have a constraint on center, we need to change the anchor so that the\n      // new center is within the extent. We first calculate the new center, apply\n      // the constraint to it, and then calculate back the anchor\n\n\n      if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {\n        var currentCenter = view.getCenter();\n        var center = view.calculateCenterZoom(resolution, opt_anchor);\n        center = view.constrainCenter(center);\n        opt_anchor = [(resolution * currentCenter[0] - currentResolution * center[0]) / (resolution - currentResolution), (resolution * currentCenter[1] - currentResolution * center[1]) / (resolution - currentResolution)];\n      }\n\n      zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);\n    }\n    /**\n     * @param {import(\"../View.js\").default} view View.\n     * @param {number|undefined} resolution Resolution to go to.\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor Anchor coordinate.\n     * @param {number=} opt_duration Duration.\n     */\n\n\n    function zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration) {\n      if (resolution) {\n        var currentResolution = view.getResolution();\n        var currentCenter = view.getCenter();\n\n        if (currentResolution !== undefined && currentCenter && resolution !== currentResolution && opt_duration) {\n          view.animate({\n            resolution: resolution,\n            anchor: opt_anchor,\n            duration: opt_duration,\n            easing: easeOut\n          });\n        } else {\n          if (opt_anchor) {\n            var center = view.calculateCenterZoom(resolution, opt_anchor);\n            view.setCenter(center);\n          }\n\n          view.setResolution(resolution);\n        }\n      }\n    }\n    /**\n     * @module ol/interaction/DoubleClickZoom\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [duration=250] Animation duration in milliseconds.\n     * @property {number} [delta=1] The zoom delta applied on each double click.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to zoom by double-clicking on the map.\n     * @api\n     */\n\n\n    var DoubleClickZoom =\n    /*@__PURE__*/\n    function (Interaction$$1) {\n      function DoubleClickZoom(opt_options) {\n        Interaction$$1.call(this, {\n          handleEvent: handleEvent\n        });\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.delta_ = options.delta ? options.delta : 1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 250;\n      }\n\n      if (Interaction$$1) DoubleClickZoom.__proto__ = Interaction$$1;\n      DoubleClickZoom.prototype = Object.create(Interaction$$1 && Interaction$$1.prototype);\n      DoubleClickZoom.prototype.constructor = DoubleClickZoom;\n      return DoubleClickZoom;\n    }(Interaction);\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a\n     * doubleclick) and eventually zooms the map.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @this {DoubleClickZoom}\n     */\n\n\n    function handleEvent(mapBrowserEvent) {\n      var stopEvent = false;\n\n      if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\n        var browserEvent =\n        /** @type {MouseEvent} */\n        mapBrowserEvent.originalEvent;\n        var map = mapBrowserEvent.map;\n        var anchor = mapBrowserEvent.coordinate;\n        var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n        var view = map.getView();\n        zoomByDelta(view, delta, anchor, this.duration_);\n        mapBrowserEvent.preventDefault();\n        stopEvent = true;\n      }\n\n      return !stopEvent;\n    }\n    /**\n     * @module ol/events/condition\n     */\n\n    /**\n     * A function that takes an {@link module:ol/MapBrowserEvent} and returns a\n     * `{boolean}`. If the condition is met, true should be returned.\n     *\n     * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default): boolean} Condition\n     */\n\n    /**\n     * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\n     * additionally the shift-key is pressed).\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True if only the alt key is pressed.\n     * @api\n     */\n\n\n    var altKeyOnly = function altKeyOnly(mapBrowserEvent) {\n      var originalEvent =\n      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n      mapBrowserEvent.originalEvent;\n      return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n    };\n    /**\n     * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\n     * (e.g. when additionally the platform-modifier-key is pressed).\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True if only the alt and shift keys are pressed.\n     * @api\n     */\n\n\n    var altShiftKeysOnly = function altShiftKeysOnly(mapBrowserEvent) {\n      var originalEvent =\n      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n      mapBrowserEvent.originalEvent;\n      return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n    };\n    /**\n     * Return `true` if the map has the focus. This condition requires a map target\n     * element with a `tabindex` attribute, e.g. `<div id=\"map\" tabindex=\"1\">`.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n     * @return {boolean} The map has the focus.\n     * @api\n     */\n\n\n    var focus = function focus(event) {\n      return event.target.getTargetElement() === document.activeElement;\n    };\n    /**\n     * Return always true.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True.\n     * @api\n     */\n\n\n    var always = TRUE;\n    /**\n     * Return `true` if the event has an \"action\"-producing mouse button.\n     *\n     * By definition, this includes left-click on windows/linux, and left-click\n     * without the ctrl key on Macs.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} The result.\n     */\n\n    var mouseActionButton = function mouseActionButton(mapBrowserEvent) {\n      var originalEvent =\n      /** @type {MouseEvent} */\n      mapBrowserEvent.originalEvent;\n      return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);\n    };\n    /**\n     * Return always false.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} False.\n     * @api\n     */\n\n\n    var never = FALSE;\n    /**\n     * Return `true` if the browser event is a `pointermove` event, `false`\n     * otherwise.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True if the browser event is a `pointermove` event.\n     * @api\n     */\n\n    var pointerMove$1 = function pointerMove$1(mapBrowserEvent) {\n      return mapBrowserEvent.type == 'pointermove';\n    };\n    /**\n     * Return `true` if the event is a map `singleclick` event, `false` otherwise.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True if the event is a map `singleclick` event.\n     * @api\n     */\n\n\n    var singleClick = function singleClick(mapBrowserEvent) {\n      return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\n    };\n    /**\n     * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\n     * pressed.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True only if there no modifier keys are pressed.\n     * @api\n     */\n\n\n    var noModifierKeys = function noModifierKeys(mapBrowserEvent) {\n      var originalEvent =\n      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n      mapBrowserEvent.originalEvent;\n      return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n    };\n    /**\n     * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\n     * additionally the alt-key is pressed).\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True if only the shift key is pressed.\n     * @api\n     */\n\n\n    var shiftKeyOnly = function shiftKeyOnly(mapBrowserEvent) {\n      var originalEvent =\n      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n      mapBrowserEvent.originalEvent;\n      return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n    };\n    /**\n     * Return `true` if the target element is not editable, i.e. not a `<input>`-,\n     * `<select>`- or `<textarea>`-element, `false` otherwise.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True only if the target element is not editable.\n     * @api\n     */\n\n\n    var targetNotEditable = function targetNotEditable(mapBrowserEvent) {\n      var target = mapBrowserEvent.originalEvent.target;\n      var tagName =\n      /** @type {Element} */\n      target.tagName;\n      return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';\n    };\n    /**\n     * Return `true` if the event originates from a mouse device.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True if the event originates from a mouse device.\n     * @api\n     */\n\n\n    var mouseOnly = function mouseOnly(mapBrowserEvent) {\n      var pointerEvent =\n      /** @type {import(\"../MapBrowserPointerEvent\").default} */\n      mapBrowserEvent.pointerEvent;\n      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n      // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n\n      return pointerEvent.pointerType == 'mouse';\n    };\n    /**\n     * Return `true` if the event originates from a primary pointer in\n     * contact with the surface or if the left mouse button is pressed.\n     * See http://www.w3.org/TR/pointerevents/#button-states.\n     *\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} True if the event originates from a primary pointer.\n     * @api\n     */\n\n\n    var primaryAction = function primaryAction(mapBrowserEvent) {\n      var pointerEvent =\n      /** @type {import(\"../MapBrowserPointerEvent\").default} */\n      mapBrowserEvent.pointerEvent;\n      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n\n      return pointerEvent.isPrimary && pointerEvent.button === 0;\n    };\n    /**\n     * @module ol/interaction/Pointer\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {function(import(\"../MapBrowserPointerEvent.js\").default):boolean} [handleDownEvent]\n     * Function handling \"down\" events. If the function returns `true` then a drag\n     * sequence is started.\n     * @property {function(import(\"../MapBrowserPointerEvent.js\").default)} [handleDragEvent]\n     * Function handling \"drag\" events. This function is called on \"move\" events\n     * during a drag sequence.\n     * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\n     * Method called by the map to notify the interaction that a browser event was\n     * dispatched to the map. The function may return `false` to prevent the\n     * propagation of the event to other interactions in the map's interactions\n     * chain.\n     * @property {function(import(\"../MapBrowserPointerEvent.js\").default)} [handleMoveEvent]\n     * Function handling \"move\" events. This function is called on \"move\" events,\n     * also during a drag sequence (so during a drag sequence both the\n     * `handleDragEvent` function and this function are called).\n     * @property {function(import(\"../MapBrowserPointerEvent.js\").default):boolean} [handleUpEvent]\n     *  Function handling \"up\" events. If the function returns `false` then the\n     * current drag sequence is stopped.\n     * @property {function(boolean):boolean} [stopDown]\n     * Should the down event be propagated to other interactions, or should be\n     * stopped?\n     */\n\n    /**\n     * @classdesc\n     * Base class that calls user-defined functions on `down`, `move` and `up`\n     * events. This class also manages \"drag sequences\".\n     *\n     * When the `handleDownEvent` user function returns `true` a drag sequence is\n     * started. During a drag sequence the `handleDragEvent` user function is\n     * called on `move` events. The drag sequence ends when the `handleUpEvent`\n     * user function is called and returns `false`.\n     * @api\n     */\n\n\n    var PointerInteraction =\n    /*@__PURE__*/\n    function (Interaction$$1) {\n      function PointerInteraction(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Interaction$$1.call(\n        /** @type {import(\"./Interaction.js\").InteractionOptions} */\n        this, options);\n\n        if (options.handleDownEvent) {\n          this.handleDownEvent = options.handleDownEvent;\n        }\n\n        if (options.handleDragEvent) {\n          this.handleDragEvent = options.handleDragEvent;\n        }\n\n        if (options.handleMoveEvent) {\n          this.handleMoveEvent = options.handleMoveEvent;\n        }\n\n        if (options.handleUpEvent) {\n          this.handleUpEvent = options.handleUpEvent;\n        }\n\n        if (options.stopDown) {\n          this.stopDown = options.stopDown;\n        }\n        /**\n         * @type {boolean}\n         * @protected\n         */\n\n\n        this.handlingDownUpSequence = false;\n        /**\n         * @type {!Object<string, import(\"../pointer/PointerEvent.js\").default>}\n         * @private\n         */\n\n        this.trackedPointers_ = {};\n        /**\n         * @type {Array<import(\"../pointer/PointerEvent.js\").default>}\n         * @protected\n         */\n\n        this.targetPointers = [];\n      }\n\n      if (Interaction$$1) PointerInteraction.__proto__ = Interaction$$1;\n      PointerInteraction.prototype = Object.create(Interaction$$1 && Interaction$$1.prototype);\n      PointerInteraction.prototype.constructor = PointerInteraction;\n      /**\n       * Handle pointer down events.\n       * @param {import(\"../MapBrowserPointerEvent.js\").default} mapBrowserEvent Event.\n       * @return {boolean} If the event was consumed.\n       * @protected\n       */\n\n      PointerInteraction.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        return false;\n      };\n      /**\n       * Handle pointer drag events.\n       * @param {import(\"../MapBrowserPointerEvent.js\").default} mapBrowserEvent Event.\n       * @protected\n       */\n\n\n      PointerInteraction.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {};\n      /**\n       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into\n       * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\n       * detected.\n       * @override\n       * @api\n       */\n\n\n      PointerInteraction.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n        if (!\n        /** @type {import(\"../MapBrowserPointerEvent.js\").default} */\n        mapBrowserEvent.pointerEvent) {\n          return true;\n        }\n\n        var stopEvent = false;\n        this.updateTrackedPointers_(mapBrowserEvent);\n\n        if (this.handlingDownUpSequence) {\n          if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\n            this.handleDragEvent(mapBrowserEvent);\n          } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n            var handledUp = this.handleUpEvent(mapBrowserEvent);\n            this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;\n          }\n        } else {\n          if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n            var handled = this.handleDownEvent(mapBrowserEvent);\n\n            if (handled) {\n              mapBrowserEvent.preventDefault();\n            }\n\n            this.handlingDownUpSequence = handled;\n            stopEvent = this.stopDown(handled);\n          } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\n            this.handleMoveEvent(mapBrowserEvent);\n          }\n        }\n\n        return !stopEvent;\n      };\n      /**\n       * Handle pointer move events.\n       * @param {import(\"../MapBrowserPointerEvent.js\").default} mapBrowserEvent Event.\n       * @protected\n       */\n\n\n      PointerInteraction.prototype.handleMoveEvent = function handleMoveEvent(mapBrowserEvent) {};\n      /**\n       * Handle pointer up events.\n       * @param {import(\"../MapBrowserPointerEvent.js\").default} mapBrowserEvent Event.\n       * @return {boolean} If the event was consumed.\n       * @protected\n       */\n\n\n      PointerInteraction.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        return false;\n      };\n      /**\n       * This function is used to determine if \"down\" events should be propagated\n       * to other interactions or should be stopped.\n       * @param {boolean} handled Was the event handled by the interaction?\n       * @return {boolean} Should the `down` event be stopped?\n       */\n\n\n      PointerInteraction.prototype.stopDown = function stopDown(handled) {\n        return handled;\n      };\n      /**\n       * @param {import(\"../MapBrowserPointerEvent.js\").default} mapBrowserEvent Event.\n       * @private\n       */\n\n\n      PointerInteraction.prototype.updateTrackedPointers_ = function updateTrackedPointers_(mapBrowserEvent) {\n        if (isPointerDraggingEvent(mapBrowserEvent)) {\n          var event = mapBrowserEvent.pointerEvent;\n          var id = event.pointerId.toString();\n\n          if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n            delete this.trackedPointers_[id];\n          } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n            this.trackedPointers_[id] = event;\n          } else if (id in this.trackedPointers_) {\n            // update only when there was a pointerdown event for this pointer\n            this.trackedPointers_[id] = event;\n          }\n\n          this.targetPointers = getValues(this.trackedPointers_);\n        }\n      };\n\n      return PointerInteraction;\n    }(Interaction);\n    /**\n     * @param {Array<import(\"../pointer/PointerEvent.js\").default>} pointerEvents List of events.\n     * @return {import(\"../pixel.js\").Pixel} Centroid pixel.\n     */\n\n\n    function centroid(pointerEvents) {\n      var length = pointerEvents.length;\n      var clientX = 0;\n      var clientY = 0;\n\n      for (var i = 0; i < length; i++) {\n        clientX += pointerEvents[i].clientX;\n        clientY += pointerEvents[i].clientY;\n      }\n\n      return [clientX / length, clientY / length];\n    }\n    /**\n     * @param {import(\"../MapBrowserPointerEvent.js\").default} mapBrowserEvent Event.\n     * @return {boolean} Whether the event is a pointerdown, pointerdrag\n     *     or pointerup event.\n     */\n\n\n    function isPointerDraggingEvent(mapBrowserEvent) {\n      var type = mapBrowserEvent.type;\n      return type === MapBrowserEventType.POINTERDOWN || type === MapBrowserEventType.POINTERDRAG || type === MapBrowserEventType.POINTERUP;\n    }\n    /**\n     * @module ol/interaction/DragPan\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n     * to indicate whether that event should be handled.\n     * Default is {@link module:ol/events/condition~noModifierKeys}.\n     * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to pan the map by dragging the map.\n     * @api\n     */\n\n\n    var DragPan =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function DragPan(opt_options) {\n        PointerInteraction$$1.call(this, {\n          stopDown: FALSE\n        });\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {import(\"../Kinetic.js\").default|undefined}\n         */\n\n        this.kinetic_ = options.kinetic;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         */\n\n        this.lastCentroid = null;\n        /**\n         * @type {number}\n         */\n\n        this.lastPointersCount_;\n        /**\n         * @type {boolean}\n         */\n\n        this.panning_ = false;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : noModifierKeys;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.noKinetic_ = false;\n      }\n\n      if (PointerInteraction$$1) DragPan.__proto__ = PointerInteraction$$1;\n      DragPan.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      DragPan.prototype.constructor = DragPan;\n      /**\n       * @inheritDoc\n       */\n\n      DragPan.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n        if (!this.panning_) {\n          this.panning_ = true;\n          this.getMap().getView().setHint(ViewHint.INTERACTING, 1);\n        }\n\n        var targetPointers = this.targetPointers;\n        var centroid$$1 = centroid(targetPointers);\n\n        if (targetPointers.length == this.lastPointersCount_) {\n          if (this.kinetic_) {\n            this.kinetic_.update(centroid$$1[0], centroid$$1[1]);\n          }\n\n          if (this.lastCentroid) {\n            var deltaX = this.lastCentroid[0] - centroid$$1[0];\n            var deltaY = centroid$$1[1] - this.lastCentroid[1];\n            var map = mapBrowserEvent.map;\n            var view = map.getView();\n            var center = [deltaX, deltaY];\n            scale(center, view.getResolution());\n            rotate(center, view.getRotation());\n            add(center, view.getCenter());\n            center = view.constrainCenter(center);\n            view.setCenter(center);\n          }\n        } else if (this.kinetic_) {\n          // reset so we don't overestimate the kinetic energy after\n          // after one finger down, tiny drag, second finger down\n          this.kinetic_.begin();\n        }\n\n        this.lastCentroid = centroid$$1;\n        this.lastPointersCount_ = targetPointers.length;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragPan.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n\n        if (this.targetPointers.length === 0) {\n          if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n            var distance$$1 = this.kinetic_.getDistance();\n            var angle = this.kinetic_.getAngle();\n            var center =\n            /** @type {!import(\"../coordinate.js\").Coordinate} */\n            view.getCenter();\n            var centerpx = map.getPixelFromCoordinate(center);\n            var dest = map.getCoordinateFromPixel([centerpx[0] - distance$$1 * Math.cos(angle), centerpx[1] - distance$$1 * Math.sin(angle)]);\n            view.animate({\n              center: view.constrainCenter(dest),\n              duration: 500,\n              easing: easeOut\n            });\n          }\n\n          if (this.panning_) {\n            this.panning_ = false;\n            view.setHint(ViewHint.INTERACTING, -1);\n          }\n\n          return false;\n        } else {\n          if (this.kinetic_) {\n            // reset so we don't overestimate the kinetic energy after\n            // after one finger up, tiny drag, second finger up\n            this.kinetic_.begin();\n          }\n\n          this.lastCentroid = null;\n          return true;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragPan.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n          var map = mapBrowserEvent.map;\n          var view = map.getView();\n          this.lastCentroid = null; // stop any current animation\n\n          if (view.getAnimating()) {\n            view.setCenter(mapBrowserEvent.frameState.viewState.center);\n          }\n\n          if (this.kinetic_) {\n            this.kinetic_.begin();\n          } // No kinetic as soon as more than one pointer on the screen is\n          // detected. This is to prevent nasty pans after pinch.\n\n\n          this.noKinetic_ = this.targetPointers.length > 1;\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      return DragPan;\n    }(PointerInteraction);\n    /**\n     * @module ol/interaction/DragRotate\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an\n     * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n     * to indicate whether that event should be handled.\n     * Default is {@link module:ol/events/condition~altShiftKeysOnly}.\n     * @property {number} [duration=250] Animation duration in milliseconds.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to rotate the map by clicking and dragging on the map,\n     * normally combined with an {@link module:ol/events/condition} that limits\n     * it to when the alt and shift keys are held down.\n     *\n     * This interaction is only supported for mouse devices.\n     * @api\n     */\n\n\n    var DragRotate =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function DragRotate(opt_options) {\n        var options = opt_options ? opt_options : {};\n        PointerInteraction$$1.call(this, {\n          stopDown: FALSE\n        });\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.lastAngle_ = undefined;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 250;\n      }\n\n      if (PointerInteraction$$1) DragRotate.__proto__ = PointerInteraction$$1;\n      DragRotate.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      DragRotate.prototype.constructor = DragRotate;\n      /**\n       * @inheritDoc\n       */\n\n      DragRotate.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return;\n        }\n\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n\n        if (view.getConstraints().rotation === disable) {\n          return;\n        }\n\n        var size = map.getSize();\n        var offset = mapBrowserEvent.pixel;\n        var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\n\n        if (this.lastAngle_ !== undefined) {\n          var delta = theta - this.lastAngle_;\n          var rotation = view.getRotation();\n          rotateWithoutConstraints(view, rotation - delta);\n        }\n\n        this.lastAngle_ = theta;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragRotate.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return true;\n        }\n\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        view.setHint(ViewHint.INTERACTING, -1);\n        var rotation = view.getRotation();\n        rotate$3(view, rotation, undefined, this.duration_);\n        return false;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragRotate.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return false;\n        }\n\n        if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\n          var map = mapBrowserEvent.map;\n          map.getView().setHint(ViewHint.INTERACTING, 1);\n          this.lastAngle_ = undefined;\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      return DragRotate;\n    }(PointerInteraction);\n    /**\n     * @module ol/render/Box\n     */\n\n\n    var RenderBox =\n    /*@__PURE__*/\n    function (Disposable$$1) {\n      function RenderBox(className) {\n        Disposable$$1.call(this);\n        /**\n         * @type {import(\"../geom/Polygon.js\").default}\n         * @private\n         */\n\n        this.geometry_ = null;\n        /**\n         * @type {HTMLDivElement}\n         * @private\n         */\n\n        this.element_ =\n        /** @type {HTMLDivElement} */\n        document.createElement('div');\n        this.element_.style.position = 'absolute';\n        this.element_.className = 'ol-box ' + className;\n        /**\n         * @private\n         * @type {import(\"../PluggableMap.js\").default}\n         */\n\n        this.map_ = null;\n        /**\n         * @private\n         * @type {import(\"../pixel.js\").Pixel}\n         */\n\n        this.startPixel_ = null;\n        /**\n         * @private\n         * @type {import(\"../pixel.js\").Pixel}\n         */\n\n        this.endPixel_ = null;\n      }\n\n      if (Disposable$$1) RenderBox.__proto__ = Disposable$$1;\n      RenderBox.prototype = Object.create(Disposable$$1 && Disposable$$1.prototype);\n      RenderBox.prototype.constructor = RenderBox;\n      /**\n       * @inheritDoc\n       */\n\n      RenderBox.prototype.disposeInternal = function disposeInternal() {\n        this.setMap(null);\n      };\n      /**\n       * @private\n       */\n\n\n      RenderBox.prototype.render_ = function render_() {\n        var startPixel = this.startPixel_;\n        var endPixel = this.endPixel_;\n        var px = 'px';\n        var style = this.element_.style;\n        style.left = Math.min(startPixel[0], endPixel[0]) + px;\n        style.top = Math.min(startPixel[1], endPixel[1]) + px;\n        style.width = Math.abs(endPixel[0] - startPixel[0]) + px;\n        style.height = Math.abs(endPixel[1] - startPixel[1]) + px;\n      };\n      /**\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       */\n\n\n      RenderBox.prototype.setMap = function setMap(map) {\n        if (this.map_) {\n          this.map_.getOverlayContainer().removeChild(this.element_);\n          var style = this.element_.style;\n          style.left = style.top = style.width = style.height = 'inherit';\n        }\n\n        this.map_ = map;\n\n        if (this.map_) {\n          this.map_.getOverlayContainer().appendChild(this.element_);\n        }\n      };\n      /**\n       * @param {import(\"../pixel.js\").Pixel} startPixel Start pixel.\n       * @param {import(\"../pixel.js\").Pixel} endPixel End pixel.\n       */\n\n\n      RenderBox.prototype.setPixels = function setPixels(startPixel, endPixel) {\n        this.startPixel_ = startPixel;\n        this.endPixel_ = endPixel;\n        this.createOrUpdateGeometry();\n        this.render_();\n      };\n      /**\n       * Creates or updates the cached geometry.\n       */\n\n\n      RenderBox.prototype.createOrUpdateGeometry = function createOrUpdateGeometry() {\n        var startPixel = this.startPixel_;\n        var endPixel = this.endPixel_;\n        var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];\n        var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_); // close the polygon\n\n        coordinates[4] = coordinates[0].slice();\n\n        if (!this.geometry_) {\n          this.geometry_ = new Polygon([coordinates]);\n        } else {\n          this.geometry_.setCoordinates([coordinates]);\n        }\n      };\n      /**\n       * @return {import(\"../geom/Polygon.js\").default} Geometry.\n       */\n\n\n      RenderBox.prototype.getGeometry = function getGeometry() {\n        return this.geometry_;\n      };\n\n      return RenderBox;\n    }(Disposable);\n    /**\n     * @module ol/interaction/DragBox\n     */\n\n    /**\n     * A function that takes a {@link module:ol/MapBrowserEvent} and two\n     * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n     * true should be returned.\n     * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default, import(\"../pixel.js\").Pixel, import(\"../pixel.js\").Pixel):boolean} EndCondition\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n     * to indicate whether that event should be handled.\n     * Default is {@link ol/events/condition~always}.\n     * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n     * `boxEndCondition` function.\n     * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n     * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n     * Default is `true` if the area of the box is bigger than the `minArea` option.\n     * @property {function(this:DragBox, import(\"../MapBrowserEvent.js\").default)} onBoxEnd Code to execute just\n     * before `boxend` is fired.\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var DragBoxEventType = {\n      /**\n       * Triggered upon drag box start.\n       * @event DragBoxEvent#boxstart\n       * @api\n       */\n      BOXSTART: 'boxstart',\n\n      /**\n       * Triggered on drag when box is active.\n       * @event DragBoxEvent#boxdrag\n       * @api\n       */\n      BOXDRAG: 'boxdrag',\n\n      /**\n       * Triggered upon drag box end.\n       * @event DragBoxEvent#boxend\n       * @api\n       */\n      BOXEND: 'boxend'\n    };\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n     * this type.\n     */\n\n    var DragBoxEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function DragBoxEvent(type, coordinate, mapBrowserEvent) {\n        Event$$1.call(this, type);\n        /**\n         * The coordinate of the drag event.\n         * @const\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @api\n         */\n\n        this.coordinate = coordinate;\n        /**\n         * @const\n         * @type {import(\"../MapBrowserEvent.js\").default}\n         * @api\n         */\n\n        this.mapBrowserEvent = mapBrowserEvent;\n      }\n\n      if (Event$$1) DragBoxEvent.__proto__ = Event$$1;\n      DragBoxEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      DragBoxEvent.prototype.constructor = DragBoxEvent;\n      return DragBoxEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Allows the user to draw a vector box by clicking and dragging on the map,\n     * normally combined with an {@link module:ol/events/condition} that limits\n     * it to when the shift or other key is held down. This is used, for example,\n     * for zooming to a specific area of the map\n     * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n     * {@link module:ol/interaction/DragRotateAndZoom}).\n     *\n     * This interaction is only supported for mouse devices.\n     *\n     * @fires DragBoxEvent\n     * @api\n     */\n\n\n    var DragBox =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function DragBox(opt_options) {\n        PointerInteraction$$1.call(this);\n        var options = opt_options ? opt_options : {};\n        /**\n        * @type {import(\"../render/Box.js\").default}\n        * @private\n        */\n\n        this.box_ = new RenderBox(options.className || 'ol-dragbox');\n        /**\n        * @type {number}\n        * @private\n        */\n\n        this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n        /**\n         * Function to execute just before `onboxend` is fired\n         * @type {function(this:DragBox, import(\"../MapBrowserEvent.js\").default)}\n         * @private\n         */\n\n        this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : VOID;\n        /**\n        * @type {import(\"../pixel.js\").Pixel}\n        * @private\n        */\n\n        this.startPixel_ = null;\n        /**\n        * @private\n        * @type {import(\"../events/condition.js\").Condition}\n        */\n\n        this.condition_ = options.condition ? options.condition : always;\n        /**\n        * @private\n        * @type {EndCondition}\n        */\n\n        this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;\n      }\n\n      if (PointerInteraction$$1) DragBox.__proto__ = PointerInteraction$$1;\n      DragBox.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      DragBox.prototype.constructor = DragBox;\n      /**\n       * The default condition for determining whether the boxend event\n       * should fire.\n       * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent The originating MapBrowserEvent\n       *     leading to the box end.\n       * @param {import(\"../pixel.js\").Pixel} startPixel The starting pixel of the box.\n       * @param {import(\"../pixel.js\").Pixel} endPixel The end pixel of the box.\n       * @return {boolean} Whether or not the boxend condition should be fired.\n       */\n\n      DragBox.prototype.defaultBoxEndCondition = function defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n        var width = endPixel[0] - startPixel[0];\n        var height = endPixel[1] - startPixel[1];\n        return width * width + height * height >= this.minArea_;\n      };\n      /**\n      * Returns geometry of last drawn box.\n      * @return {import(\"../geom/Polygon.js\").default} Geometry.\n      * @api\n      */\n\n\n      DragBox.prototype.getGeometry = function getGeometry() {\n        return this.box_.getGeometry();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragBox.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return;\n        }\n\n        this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragBox.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return true;\n        }\n\n        this.box_.setMap(null);\n\n        if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {\n          this.onBoxEnd_(mapBrowserEvent);\n          this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));\n        }\n\n        return false;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragBox.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return false;\n        }\n\n        if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\n          this.startPixel_ = mapBrowserEvent.pixel;\n          this.box_.setMap(mapBrowserEvent.map);\n          this.box_.setPixels(this.startPixel_, this.startPixel_);\n          this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      return DragBox;\n    }(PointerInteraction);\n    /**\n     * @module ol/interaction/DragZoom\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-dragzoom'] CSS class name for styling the\n     * box.\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled.\n     * Default is {@link module:ol/events/condition~shiftKeyOnly}.\n     * @property {number} [duration=200] Animation duration in milliseconds.\n     * @property {boolean} [out=false] Use interaction for zooming out.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to zoom the map by clicking and dragging on the map,\n     * normally combined with an {@link module:ol/events/condition} that limits\n     * it to when a key, shift by default, is held down.\n     *\n     * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\n     * your custom one configured with `className`.\n     * @api\n     */\n\n\n    var DragZoom =\n    /*@__PURE__*/\n    function (DragBox$$1) {\n      function DragZoom(opt_options) {\n        var options = opt_options ? opt_options : {};\n        var condition = options.condition ? options.condition : shiftKeyOnly;\n        DragBox$$1.call(this, {\n          condition: condition,\n          className: options.className || 'ol-dragzoom',\n          onBoxEnd: onBoxEnd\n        });\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 200;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.out_ = options.out !== undefined ? options.out : false;\n      }\n\n      if (DragBox$$1) DragZoom.__proto__ = DragBox$$1;\n      DragZoom.prototype = Object.create(DragBox$$1 && DragBox$$1.prototype);\n      DragZoom.prototype.constructor = DragZoom;\n      return DragZoom;\n    }(DragBox);\n    /**\n     * @this {DragZoom}\n     */\n\n\n    function onBoxEnd() {\n      var map = this.getMap();\n      var view =\n      /** @type {!import(\"../View.js\").default} */\n      map.getView();\n      var size =\n      /** @type {!import(\"../size.js\").Size} */\n      map.getSize();\n      var extent = this.getGeometry().getExtent();\n\n      if (this.out_) {\n        var mapExtent = view.calculateExtent(size);\n        var boxPixelExtent = createOrUpdateFromCoordinates([map.getPixelFromCoordinate(getBottomLeft(extent)), map.getPixelFromCoordinate(getTopRight(extent))]);\n        var factor = view.getResolutionForExtent(boxPixelExtent, size);\n        scaleFromCenter(mapExtent, 1 / factor);\n        extent = mapExtent;\n      }\n\n      var resolution = view.constrainResolution(view.getResolutionForExtent(extent, size));\n      var center = getCenter(extent);\n      center = view.constrainCenter(center);\n      view.animate({\n        resolution: resolution,\n        center: center,\n        duration: this.duration_,\n        easing: easeOut\n      });\n    }\n    /**\n     * @module ol/events/KeyCode\n     */\n\n    /**\n     * @enum {number}\n     * @const\n     */\n\n\n    var KeyCode = {\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      DOWN: 40\n    };\n    /**\n     * @module ol/interaction/KeyboardPan\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled. Default is\n     * {@link module:ol/events/condition~noModifierKeys} and\n     * {@link module:ol/events/condition~targetNotEditable}.\n     * @property {number} [duration=100] Animation duration in milliseconds.\n     * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\n     * press.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to pan the map using keyboard arrows.\n     * Note that, although this interaction is by default included in maps,\n     * the keys can only be used when browser focus is on the element to which\n     * the keyboard events are attached. By default, this is the map div,\n     * though you can change this with the `keyboardEventTarget` in\n     * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n     * element, focus will have to be on, and returned to, this element if the keys\n     * are to function.\n     * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\n     * @api\n     */\n\n    var KeyboardPan =\n    /*@__PURE__*/\n    function (Interaction$$1) {\n      function KeyboardPan(opt_options) {\n        Interaction$$1.call(this, {\n          handleEvent: handleEvent$1\n        });\n        var options = opt_options || {};\n        /**\n         * @private\n         * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n         * @return {boolean} Combined condition result.\n         */\n\n        this.defaultCondition_ = function (mapBrowserEvent) {\n          return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);\n        };\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n\n        this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 100;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;\n      }\n\n      if (Interaction$$1) KeyboardPan.__proto__ = Interaction$$1;\n      KeyboardPan.prototype = Object.create(Interaction$$1 && Interaction$$1.prototype);\n      KeyboardPan.prototype.constructor = KeyboardPan;\n      return KeyboardPan;\n    }(Interaction);\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a\n     * `KeyEvent`, and decides the direction to pan to (if an arrow key was\n     * pressed).\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @this {KeyboardPan}\n     */\n\n\n    function handleEvent$1(mapBrowserEvent) {\n      var stopEvent = false;\n\n      if (mapBrowserEvent.type == EventType.KEYDOWN) {\n        var keyEvent =\n        /** @type {KeyboardEvent} */\n        mapBrowserEvent.originalEvent;\n        var keyCode = keyEvent.keyCode;\n\n        if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {\n          var map = mapBrowserEvent.map;\n          var view = map.getView();\n          var mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n          var deltaX = 0,\n              deltaY = 0;\n\n          if (keyCode == KeyCode.DOWN) {\n            deltaY = -mapUnitsDelta;\n          } else if (keyCode == KeyCode.LEFT) {\n            deltaX = -mapUnitsDelta;\n          } else if (keyCode == KeyCode.RIGHT) {\n            deltaX = mapUnitsDelta;\n          } else {\n            deltaY = mapUnitsDelta;\n          }\n\n          var delta = [deltaX, deltaY];\n          rotate(delta, view.getRotation());\n          pan(view, delta, this.duration_);\n          mapBrowserEvent.preventDefault();\n          stopEvent = true;\n        }\n      }\n\n      return !stopEvent;\n    }\n    /**\n     * @module ol/interaction/KeyboardZoom\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [duration=100] Animation duration in milliseconds.\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled. Default is\n     * {@link module:ol/events/condition~targetNotEditable}.\n     * @property {number} [delta=1] The zoom level delta on each key press.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to zoom the map using keyboard + and -.\n     * Note that, although this interaction is by default included in maps,\n     * the keys can only be used when browser focus is on the element to which\n     * the keyboard events are attached. By default, this is the map div,\n     * though you can change this with the `keyboardEventTarget` in\n     * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n     * element, focus will have to be on, and returned to, this element if the keys\n     * are to function.\n     * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.\n     * @api\n     */\n\n\n    var KeyboardZoom =\n    /*@__PURE__*/\n    function (Interaction$$1) {\n      function KeyboardZoom(opt_options) {\n        Interaction$$1.call(this, {\n          handleEvent: handleEvent$2\n        });\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : targetNotEditable;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.delta_ = options.delta ? options.delta : 1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 100;\n      }\n\n      if (Interaction$$1) KeyboardZoom.__proto__ = Interaction$$1;\n      KeyboardZoom.prototype = Object.create(Interaction$$1 && Interaction$$1.prototype);\n      KeyboardZoom.prototype.constructor = KeyboardZoom;\n      return KeyboardZoom;\n    }(Interaction);\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a\n     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\n     * key pressed was '+' or '-').\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @this {KeyboardZoom}\n     */\n\n\n    function handleEvent$2(mapBrowserEvent) {\n      var stopEvent = false;\n\n      if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {\n        var keyEvent =\n        /** @type {KeyboardEvent} */\n        mapBrowserEvent.originalEvent;\n        var charCode = keyEvent.charCode;\n\n        if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {\n          var map = mapBrowserEvent.map;\n          var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;\n          var view = map.getView();\n          zoomByDelta(view, delta, undefined, this.duration_);\n          mapBrowserEvent.preventDefault();\n          stopEvent = true;\n        }\n      }\n\n      return !stopEvent;\n    }\n    /**\n     * @module ol/interaction/MouseWheelZoom\n     */\n\n    /**\n     * Maximum mouse wheel delta.\n     * @type {number}\n     */\n\n\n    var MAX_DELTA = 1;\n    /**\n     * @enum {string}\n     */\n\n    var Mode = {\n      TRACKPAD: 'trackpad',\n      WHEEL: 'wheel'\n    };\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled. Default is\n     * {@link module:ol/events/condition~always}.\n     * @property {number} [duration=250] Animation duration in milliseconds.\n     * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\n     * @property {boolean} [constrainResolution=false] When using a trackpad or\n     * magic mouse, zoom to the closest integer zoom level after the scroll gesture\n     * ends.\n     * @property {boolean} [useAnchor=true] Enable zooming using the mouse's\n     * location as the anchor. When set to `false`, zooming in and out will zoom to\n     * the center of the screen instead of zooming on the mouse's location.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to zoom the map by scrolling the mouse wheel.\n     * @api\n     */\n\n    var MouseWheelZoom =\n    /*@__PURE__*/\n    function (Interaction$$1) {\n      function MouseWheelZoom(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Interaction$$1.call(\n        /** @type {import(\"./Interaction.js\").InteractionOptions} */\n        this, options);\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.delta_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 250;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.constrainResolution_ = options.constrainResolution || false;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : always;\n        /**\n         * @private\n         * @type {?import(\"../coordinate.js\").Coordinate}\n         */\n\n        this.lastAnchor_ = null;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.startTime_ = undefined;\n        /**\n         * @private\n         * @type {?}\n         */\n\n        this.timeoutId_;\n        /**\n         * @private\n         * @type {Mode|undefined}\n         */\n\n        this.mode_ = undefined;\n        /**\n         * Trackpad events separated by this delay will be considered separate\n         * interactions.\n         * @type {number}\n         */\n\n        this.trackpadEventGap_ = 400;\n        /**\n         * @type {?}\n         */\n\n        this.trackpadTimeoutId_;\n        /**\n         * The number of delta values per zoom level\n         * @private\n         * @type {number}\n         */\n\n        this.trackpadDeltaPerZoom_ = 300;\n        /**\n         * The zoom factor by which scroll zooming is allowed to exceed the limits.\n         * @private\n         * @type {number}\n         */\n\n        this.trackpadZoomBuffer_ = 1.5;\n      }\n\n      if (Interaction$$1) MouseWheelZoom.__proto__ = Interaction$$1;\n      MouseWheelZoom.prototype = Object.create(Interaction$$1 && Interaction$$1.prototype);\n      MouseWheelZoom.prototype.constructor = MouseWheelZoom;\n      /**\n       * @private\n       */\n\n      MouseWheelZoom.prototype.decrementInteractingHint_ = function decrementInteractingHint_() {\n        this.trackpadTimeoutId_ = undefined;\n        var view = this.getMap().getView();\n        view.setHint(ViewHint.INTERACTING, -1);\n      };\n      /**\n       * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually\n       * zooms the map.\n       * @override\n       */\n\n\n      MouseWheelZoom.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n        if (!this.condition_(mapBrowserEvent)) {\n          return true;\n        }\n\n        var type = mapBrowserEvent.type;\n\n        if (type !== EventType.WHEEL && type !== EventType.MOUSEWHEEL) {\n          return true;\n        }\n\n        mapBrowserEvent.preventDefault();\n        var map = mapBrowserEvent.map;\n        var wheelEvent =\n        /** @type {WheelEvent} */\n        mapBrowserEvent.originalEvent;\n\n        if (this.useAnchor_) {\n          this.lastAnchor_ = mapBrowserEvent.coordinate;\n        } // Delta normalisation inspired by\n        // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n\n\n        var delta;\n\n        if (mapBrowserEvent.type == EventType.WHEEL) {\n          delta = wheelEvent.deltaY;\n\n          if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n            delta /= DEVICE_PIXEL_RATIO;\n          }\n\n          if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n            delta *= 40;\n          }\n        } else if (mapBrowserEvent.type == EventType.MOUSEWHEEL) {\n          delta = -wheelEvent.wheelDeltaY;\n\n          if (SAFARI) {\n            delta /= 3;\n          }\n        }\n\n        if (delta === 0) {\n          return false;\n        }\n\n        var now = Date.now();\n\n        if (this.startTime_ === undefined) {\n          this.startTime_ = now;\n        }\n\n        if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n          this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;\n        }\n\n        if (this.mode_ === Mode.TRACKPAD) {\n          var view = map.getView();\n\n          if (this.trackpadTimeoutId_) {\n            clearTimeout(this.trackpadTimeoutId_);\n          } else {\n            view.setHint(ViewHint.INTERACTING, 1);\n          }\n\n          this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);\n          var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);\n          var minResolution = view.getMinResolution();\n          var maxResolution = view.getMaxResolution();\n          var rebound = 0;\n\n          if (resolution < minResolution) {\n            resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);\n            rebound = 1;\n          } else if (resolution > maxResolution) {\n            resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);\n            rebound = -1;\n          }\n\n          if (this.lastAnchor_) {\n            var center = view.calculateCenterZoom(resolution, this.lastAnchor_);\n            view.setCenter(view.constrainCenter(center));\n          }\n\n          view.setResolution(resolution);\n\n          if (rebound === 0 && this.constrainResolution_) {\n            view.animate({\n              resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),\n              easing: easeOut,\n              anchor: this.lastAnchor_,\n              duration: this.duration_\n            });\n          }\n\n          if (rebound > 0) {\n            view.animate({\n              resolution: minResolution,\n              easing: easeOut,\n              anchor: this.lastAnchor_,\n              duration: 500\n            });\n          } else if (rebound < 0) {\n            view.animate({\n              resolution: maxResolution,\n              easing: easeOut,\n              anchor: this.lastAnchor_,\n              duration: 500\n            });\n          }\n\n          this.startTime_ = now;\n          return false;\n        }\n\n        this.delta_ += delta;\n        var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n        clearTimeout(this.timeoutId_);\n        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);\n        return false;\n      };\n      /**\n       * @private\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       */\n\n\n      MouseWheelZoom.prototype.handleWheelZoom_ = function handleWheelZoom_(map) {\n        var view = map.getView();\n\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n\n        var maxDelta = MAX_DELTA;\n        var delta = clamp(this.delta_, -maxDelta, maxDelta);\n        zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);\n        this.mode_ = undefined;\n        this.delta_ = 0;\n        this.lastAnchor_ = null;\n        this.startTime_ = undefined;\n        this.timeoutId_ = undefined;\n      };\n      /**\n       * Enable or disable using the mouse's location as an anchor when zooming\n       * @param {boolean} useAnchor true to zoom to the mouse's location, false\n       * to zoom to the center of the map\n       * @api\n       */\n\n\n      MouseWheelZoom.prototype.setMouseAnchor = function setMouseAnchor(useAnchor) {\n        this.useAnchor_ = useAnchor;\n\n        if (!useAnchor) {\n          this.lastAnchor_ = null;\n        }\n      };\n\n      return MouseWheelZoom;\n    }(Interaction);\n    /**\n     * @module ol/interaction/PinchRotate\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [duration=250] The duration of the animation in\n     * milliseconds.\n     * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to rotate the map by twisting with two fingers\n     * on a touch screen.\n     * @api\n     */\n\n\n    var PinchRotate =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function PinchRotate(opt_options) {\n        var options = opt_options ? opt_options : {};\n        var pointerOptions =\n        /** @type {import(\"./Pointer.js\").Options} */\n        options;\n\n        if (!pointerOptions.stopDown) {\n          pointerOptions.stopDown = FALSE;\n        }\n\n        PointerInteraction$$1.call(this, pointerOptions);\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n\n        this.anchor_ = null;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.lastAngle_ = undefined;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.rotating_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.rotationDelta_ = 0.0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 250;\n      }\n\n      if (PointerInteraction$$1) PinchRotate.__proto__ = PointerInteraction$$1;\n      PinchRotate.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      PinchRotate.prototype.constructor = PinchRotate;\n      /**\n       * @inheritDoc\n       */\n\n      PinchRotate.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n        var rotationDelta = 0.0;\n        var touch0 = this.targetPointers[0];\n        var touch1 = this.targetPointers[1]; // angle between touches\n\n        var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);\n\n        if (this.lastAngle_ !== undefined) {\n          var delta = angle - this.lastAngle_;\n          this.rotationDelta_ += delta;\n\n          if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n            this.rotating_ = true;\n          }\n\n          rotationDelta = delta;\n        }\n\n        this.lastAngle_ = angle;\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n\n        if (view.getConstraints().rotation === disable) {\n          return;\n        } // rotate anchor point.\n        // FIXME: should be the intersection point between the lines:\n        //     touch0,touch1 and previousTouch0,previousTouch1\n\n\n        var viewportPosition = map.getViewport().getBoundingClientRect();\n        var centroid$$1 = centroid(this.targetPointers);\n        centroid$$1[0] -= viewportPosition.left;\n        centroid$$1[1] -= viewportPosition.top;\n        this.anchor_ = map.getCoordinateFromPixel(centroid$$1); // rotate\n\n        if (this.rotating_) {\n          var rotation = view.getRotation();\n          map.render();\n          rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      PinchRotate.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        if (this.targetPointers.length < 2) {\n          var map = mapBrowserEvent.map;\n          var view = map.getView();\n          view.setHint(ViewHint.INTERACTING, -1);\n\n          if (this.rotating_) {\n            var rotation = view.getRotation();\n            rotate$3(view, rotation, this.anchor_, this.duration_);\n          }\n\n          return false;\n        } else {\n          return true;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      PinchRotate.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        if (this.targetPointers.length >= 2) {\n          var map = mapBrowserEvent.map;\n          this.anchor_ = null;\n          this.lastAngle_ = undefined;\n          this.rotating_ = false;\n          this.rotationDelta_ = 0.0;\n\n          if (!this.handlingDownUpSequence) {\n            map.getView().setHint(ViewHint.INTERACTING, 1);\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      return PinchRotate;\n    }(PointerInteraction);\n    /**\n     * @module ol/interaction/PinchZoom\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [duration=400] Animation duration in milliseconds.\n     * @property {boolean} [constrainResolution=false] Zoom to the closest integer\n     * zoom level after the pinch gesture ends.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to zoom the map by pinching with two fingers\n     * on a touch screen.\n     * @api\n     */\n\n\n    var PinchZoom =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function PinchZoom(opt_options) {\n        var options = opt_options ? opt_options : {};\n        var pointerOptions =\n        /** @type {import(\"./Pointer.js\").Options} */\n        options;\n\n        if (!pointerOptions.stopDown) {\n          pointerOptions.stopDown = FALSE;\n        }\n\n        PointerInteraction$$1.call(this, pointerOptions);\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.constrainResolution_ = options.constrainResolution || false;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n\n        this.anchor_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 400;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.lastDistance_ = undefined;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.lastScaleDelta_ = 1;\n      }\n\n      if (PointerInteraction$$1) PinchZoom.__proto__ = PointerInteraction$$1;\n      PinchZoom.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      PinchZoom.prototype.constructor = PinchZoom;\n      /**\n       * @inheritDoc\n       */\n\n      PinchZoom.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n        var scaleDelta = 1.0;\n        var touch0 = this.targetPointers[0];\n        var touch1 = this.targetPointers[1];\n        var dx = touch0.clientX - touch1.clientX;\n        var dy = touch0.clientY - touch1.clientY; // distance between touches\n\n        var distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (this.lastDistance_ !== undefined) {\n          scaleDelta = this.lastDistance_ / distance;\n        }\n\n        this.lastDistance_ = distance;\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        var resolution = view.getResolution();\n        var maxResolution = view.getMaxResolution();\n        var minResolution = view.getMinResolution();\n        var newResolution = resolution * scaleDelta;\n\n        if (newResolution > maxResolution) {\n          scaleDelta = maxResolution / resolution;\n          newResolution = maxResolution;\n        } else if (newResolution < minResolution) {\n          scaleDelta = minResolution / resolution;\n          newResolution = minResolution;\n        }\n\n        if (scaleDelta != 1.0) {\n          this.lastScaleDelta_ = scaleDelta;\n        } // scale anchor point.\n\n\n        var viewportPosition = map.getViewport().getBoundingClientRect();\n        var centroid$$1 = centroid(this.targetPointers);\n        centroid$$1[0] -= viewportPosition.left;\n        centroid$$1[1] -= viewportPosition.top;\n        this.anchor_ = map.getCoordinateFromPixel(centroid$$1); // scale, bypass the resolution constraint\n\n        map.render();\n        zoomWithoutConstraints(view, newResolution, this.anchor_);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      PinchZoom.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        if (this.targetPointers.length < 2) {\n          var map = mapBrowserEvent.map;\n          var view = map.getView();\n          view.setHint(ViewHint.INTERACTING, -1);\n          var resolution = view.getResolution();\n\n          if (this.constrainResolution_ || resolution < view.getMinResolution() || resolution > view.getMaxResolution()) {\n            // Zoom to final resolution, with an animation, and provide a\n            // direction not to zoom out/in if user was pinching in/out.\n            // Direction is > 0 if pinching out, and < 0 if pinching in.\n            var direction = this.lastScaleDelta_ - 1;\n            zoom(view, resolution, this.anchor_, this.duration_, direction);\n          }\n\n          return false;\n        } else {\n          return true;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      PinchZoom.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        if (this.targetPointers.length >= 2) {\n          var map = mapBrowserEvent.map;\n          this.anchor_ = null;\n          this.lastDistance_ = undefined;\n          this.lastScaleDelta_ = 1;\n\n          if (!this.handlingDownUpSequence) {\n            map.getView().setHint(ViewHint.INTERACTING, 1);\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      return PinchZoom;\n    }(PointerInteraction);\n    /**\n     * @module ol/interaction/DragAndDrop\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {Array<typeof import(\"../format/Feature.js\").default>} [formatConstructors] Format constructors.\n     * @property {import(\"../source/Vector.js\").default} [source] Optional vector source where features will be added.  If a source is provided\n     * all existing features will be removed and new features will be added when\n     * they are dropped on the target.  If you want to add features to a vector\n     * source without removing the existing features (append only), instead of\n     * providing the source option listen for the \"addfeatures\" event.\n     * @property {import(\"../proj.js\").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\n     * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var DragAndDropEventType = {\n      /**\n       * Triggered when features are added\n       * @event DragAndDropEvent#addfeatures\n       * @api\n       */\n      ADD_FEATURES: 'addfeatures'\n    };\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\n     * of this type.\n     */\n\n    var DragAndDropEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function DragAndDropEvent(type, file, opt_features, opt_projection) {\n        Event$$1.call(this, type);\n        /**\n         * The features parsed from dropped data.\n         * @type {Array<import(\"../Feature.js\").FeatureLike>|undefined}\n         * @api\n         */\n\n        this.features = opt_features;\n        /**\n         * The dropped file.\n         * @type {File}\n         * @api\n         */\n\n        this.file = file;\n        /**\n         * The feature projection.\n         * @type {import(\"../proj/Projection.js\").default|undefined}\n         * @api\n         */\n\n        this.projection = opt_projection;\n      }\n\n      if (Event$$1) DragAndDropEvent.__proto__ = Event$$1;\n      DragAndDropEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      DragAndDropEvent.prototype.constructor = DragAndDropEvent;\n      return DragAndDropEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Handles input of vector data by drag and drop.\n     * @api\n     *\n     * @fires DragAndDropEvent\n     */\n\n\n    var DragAndDrop =\n    /*@__PURE__*/\n    function (Interaction$$1) {\n      function DragAndDrop(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Interaction$$1.call(this, {\n          handleEvent: TRUE\n        });\n        /**\n         * @private\n         * @type {Array<typeof import(\"../format/Feature.js\").default>}\n         */\n\n        this.formatConstructors_ = options.formatConstructors ? options.formatConstructors : [];\n        /**\n         * @private\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n\n        this.projection_ = options.projection ? get$2(options.projection) : null;\n        /**\n         * @private\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         */\n\n        this.dropListenKeys_ = null;\n        /**\n         * @private\n         * @type {import(\"../source/Vector.js\").default}\n         */\n\n        this.source_ = options.source || null;\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n\n        this.target = options.target ? options.target : null;\n      }\n\n      if (Interaction$$1) DragAndDrop.__proto__ = Interaction$$1;\n      DragAndDrop.prototype = Object.create(Interaction$$1 && Interaction$$1.prototype);\n      DragAndDrop.prototype.constructor = DragAndDrop;\n      /**\n       * @param {File} file File.\n       * @param {Event} event Load event.\n       * @private\n       */\n\n      DragAndDrop.prototype.handleResult_ = function handleResult_(file, event) {\n        var result = event.target.result;\n        var map = this.getMap();\n        var projection = this.projection_;\n\n        if (!projection) {\n          var view = map.getView();\n          projection = view.getProjection();\n        }\n\n        var formatConstructors = this.formatConstructors_;\n        var features = [];\n\n        for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {\n          var format = new formatConstructors[i]();\n          features = this.tryReadFeatures_(format, result, {\n            featureProjection: projection\n          });\n\n          if (features && features.length > 0) {\n            break;\n          }\n        }\n\n        if (this.source_) {\n          this.source_.clear();\n          this.source_.addFeatures(features);\n        }\n\n        this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));\n      };\n      /**\n       * @private\n       */\n\n\n      DragAndDrop.prototype.registerListeners_ = function registerListeners_() {\n        var map = this.getMap();\n\n        if (map) {\n          var dropArea = this.target ? this.target : map.getViewport();\n          this.dropListenKeys_ = [listen(dropArea, EventType.DROP, handleDrop, this), listen(dropArea, EventType.DRAGENTER, handleStop, this), listen(dropArea, EventType.DRAGOVER, handleStop, this), listen(dropArea, EventType.DROP, handleStop, this)];\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragAndDrop.prototype.setActive = function setActive(active) {\n        Interaction$$1.prototype.setActive.call(this, active);\n\n        if (active) {\n          this.registerListeners_();\n        } else {\n          this.unregisterListeners_();\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragAndDrop.prototype.setMap = function setMap(map) {\n        this.unregisterListeners_();\n        Interaction$$1.prototype.setMap.call(this, map);\n\n        if (this.getActive()) {\n          this.registerListeners_();\n        }\n      };\n      /**\n       * @param {import(\"../format/Feature.js\").default} format Format.\n       * @param {string} text Text.\n       * @param {import(\"../format/Feature.js\").ReadOptions} options Read options.\n       * @private\n       * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n       */\n\n\n      DragAndDrop.prototype.tryReadFeatures_ = function tryReadFeatures_(format, text, options) {\n        try {\n          return format.readFeatures(text, options);\n        } catch (e) {\n          return null;\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      DragAndDrop.prototype.unregisterListeners_ = function unregisterListeners_() {\n        if (this.dropListenKeys_) {\n          this.dropListenKeys_.forEach(unlistenByKey);\n          this.dropListenKeys_ = null;\n        }\n      };\n\n      return DragAndDrop;\n    }(Interaction);\n    /**\n     * @param {DragEvent} event Event.\n     * @this {DragAndDrop}\n     */\n\n\n    function handleDrop(event) {\n      var files = event.dataTransfer.files;\n\n      for (var i = 0, ii = files.length; i < ii; ++i) {\n        var file = files.item(i);\n        var reader = new FileReader();\n        reader.addEventListener(EventType.LOAD, this.handleResult_.bind(this, file));\n        reader.readAsText(file);\n      }\n    }\n    /**\n     * @param {DragEvent} event Event.\n     */\n\n\n    function handleStop(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      event.dataTransfer.dropEffect = 'copy';\n    }\n    /**\n     * @module ol/interaction/DragRotateAndZoom\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled.\n     * Default is {@link module:ol/events/condition~shiftKeyOnly}.\n     * @property {number} [duration=400] Animation duration in milliseconds.\n     */\n\n    /**\n     * @classdesc\n     * Allows the user to zoom and rotate the map by clicking and dragging\n     * on the map.  By default, this interaction is limited to when the shift\n     * key is held down.\n     *\n     * This interaction is only supported for mouse devices.\n     *\n     * And this interaction is not included in the default interactions.\n     * @api\n     */\n\n\n    var DragRotateAndZoom =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function DragRotateAndZoom(opt_options) {\n        var options = opt_options ? opt_options : {};\n        PointerInteraction$$1.call(\n        /** @type {import(\"./Pointer.js\").Options} */\n        this, options);\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : shiftKeyOnly;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.lastAngle_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.lastMagnitude_ = undefined;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.lastScaleDelta_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 400;\n      }\n\n      if (PointerInteraction$$1) DragRotateAndZoom.__proto__ = PointerInteraction$$1;\n      DragRotateAndZoom.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      DragRotateAndZoom.prototype.constructor = DragRotateAndZoom;\n      /**\n       * @inheritDoc\n       */\n\n      DragRotateAndZoom.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return;\n        }\n\n        var map = mapBrowserEvent.map;\n        var size = map.getSize();\n        var offset = mapBrowserEvent.pixel;\n        var deltaX = offset[0] - size[0] / 2;\n        var deltaY = size[1] / 2 - offset[1];\n        var theta = Math.atan2(deltaY, deltaX);\n        var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        var view = map.getView();\n\n        if (view.getConstraints().rotation !== disable && this.lastAngle_ !== undefined) {\n          var angleDelta = theta - this.lastAngle_;\n          rotateWithoutConstraints(view, view.getRotation() - angleDelta);\n        }\n\n        this.lastAngle_ = theta;\n\n        if (this.lastMagnitude_ !== undefined) {\n          var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);\n          zoomWithoutConstraints(view, resolution);\n        }\n\n        if (this.lastMagnitude_ !== undefined) {\n          this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;\n        }\n\n        this.lastMagnitude_ = magnitude;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragRotateAndZoom.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return true;\n        }\n\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        view.setHint(ViewHint.INTERACTING, -1);\n        var direction = this.lastScaleDelta_ - 1;\n        rotate$3(view, view.getRotation());\n        zoom(view, view.getResolution(), undefined, this.duration_, direction);\n        this.lastScaleDelta_ = 0;\n        return false;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      DragRotateAndZoom.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        if (!mouseOnly(mapBrowserEvent)) {\n          return false;\n        }\n\n        if (this.condition_(mapBrowserEvent)) {\n          mapBrowserEvent.map.getView().setHint(ViewHint.INTERACTING, 1);\n          this.lastAngle_ = undefined;\n          this.lastMagnitude_ = undefined;\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      return DragRotateAndZoom;\n    }(PointerInteraction);\n    /**\n     * @module ol/Feature\n     */\n\n    /**\n     * @typedef {typeof Feature|typeof import(\"./render/Feature.js\").default} FeatureClass\n     */\n\n    /**\n     * @typedef {Feature|import(\"./render/Feature.js\").default} FeatureLike\n     */\n\n    /**\n     * @classdesc\n     * A vector object for geographic features with a geometry and other\n     * attribute properties, similar to the features in vector file formats like\n     * GeoJSON.\n     *\n     * Features can be styled individually with `setStyle`; otherwise they use the\n     * style of their vector layer.\n     *\n     * Note that attribute properties are set as {@link module:ol/Object} properties on\n     * the feature object, so they are observable, and have get/set accessors.\n     *\n     * Typically, a feature has a single geometry property. You can set the\n     * geometry using the `setGeometry` method and get it with `getGeometry`.\n     * It is possible to store more than one geometry on a feature using attribute\n     * properties. By default, the geometry used for rendering is identified by\n     * the property name `geometry`. If you want to use another geometry property\n     * for rendering, use the `setGeometryName` method to change the attribute\n     * property associated with the geometry for the feature.  For example:\n     *\n     * ```js\n     *\n     * import Feature from 'ol/Feature';\n     * import Polygon from 'ol/geom/Polygon';\n     * import Point from 'ol/geom/Point';\n     *\n     * var feature = new Feature({\n     *   geometry: new Polygon(polyCoords),\n     *   labelPoint: new Point(labelCoords),\n     *   name: 'My Polygon'\n     * });\n     *\n     * // get the polygon geometry\n     * var poly = feature.getGeometry();\n     *\n     * // Render the feature as a point using the coordinates from labelPoint\n     * feature.setGeometryName('labelPoint');\n     *\n     * // get the point geometry\n     * var point = feature.getGeometry();\n     * ```\n     *\n     * @api\n     */\n\n\n    var Feature =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function Feature(opt_geometryOrProperties) {\n        BaseObject$$1.call(this);\n        /**\n         * @private\n         * @type {number|string|undefined}\n         */\n\n        this.id_ = undefined;\n        /**\n         * @type {string}\n         * @private\n         */\n\n        this.geometryName_ = 'geometry';\n        /**\n         * User provided style.\n         * @private\n         * @type {import(\"./style/Style.js\").StyleLike}\n         */\n\n        this.style_ = null;\n        /**\n         * @private\n         * @type {import(\"./style/Style.js\").StyleFunction|undefined}\n         */\n\n        this.styleFunction_ = undefined;\n        /**\n         * @private\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n\n        this.geometryChangeKey_ = null;\n        listen(this, getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);\n\n        if (opt_geometryOrProperties) {\n          if (typeof\n          /** @type {?} */\n          opt_geometryOrProperties.getSimplifiedGeometry === 'function') {\n            var geometry =\n            /** @type {import(\"./geom/Geometry.js\").default} */\n            opt_geometryOrProperties;\n            this.setGeometry(geometry);\n          } else {\n            /** @type {Object<string, *>} */\n            var properties = opt_geometryOrProperties;\n            this.setProperties(properties);\n          }\n        }\n      }\n\n      if (BaseObject$$1) Feature.__proto__ = BaseObject$$1;\n      Feature.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      Feature.prototype.constructor = Feature;\n      /**\n       * Clone this feature. If the original feature has a geometry it\n       * is also cloned. The feature id is not set in the clone.\n       * @return {Feature} The clone.\n       * @api\n       */\n\n      Feature.prototype.clone = function clone() {\n        var clone = new Feature(this.getProperties());\n        clone.setGeometryName(this.getGeometryName());\n        var geometry = this.getGeometry();\n\n        if (geometry) {\n          clone.setGeometry(geometry.clone());\n        }\n\n        var style = this.getStyle();\n\n        if (style) {\n          clone.setStyle(style);\n        }\n\n        return clone;\n      };\n      /**\n       * Get the feature's default geometry.  A feature may have any number of named\n       * geometries.  The \"default\" geometry (the one that is rendered by default) is\n       * set when calling {@link module:ol/Feature~Feature#setGeometry}.\n       * @return {import(\"./geom/Geometry.js\").default|undefined} The default geometry for the feature.\n       * @api\n       * @observable\n       */\n\n\n      Feature.prototype.getGeometry = function getGeometry() {\n        return (\n          /** @type {import(\"./geom/Geometry.js\").default|undefined} */\n          this.get(this.geometryName_)\n        );\n      };\n      /**\n       * Get the feature identifier.  This is a stable identifier for the feature and\n       * is either set when reading data from a remote source or set explicitly by\n       * calling {@link module:ol/Feature~Feature#setId}.\n       * @return {number|string|undefined} Id.\n       * @api\n       */\n\n\n      Feature.prototype.getId = function getId() {\n        return this.id_;\n      };\n      /**\n       * Get the name of the feature's default geometry.  By default, the default\n       * geometry is named `geometry`.\n       * @return {string} Get the property name associated with the default geometry\n       *     for this feature.\n       * @api\n       */\n\n\n      Feature.prototype.getGeometryName = function getGeometryName() {\n        return this.geometryName_;\n      };\n      /**\n       * Get the feature's style. Will return what was provided to the\n       * {@link module:ol/Feature~Feature#setStyle} method.\n       * @return {import(\"./style/Style.js\").StyleLike} The feature style.\n       * @api\n       */\n\n\n      Feature.prototype.getStyle = function getStyle() {\n        return this.style_;\n      };\n      /**\n       * Get the feature's style function.\n       * @return {import(\"./style/Style.js\").StyleFunction|undefined} Return a function\n       * representing the current style of this feature.\n       * @api\n       */\n\n\n      Feature.prototype.getStyleFunction = function getStyleFunction() {\n        return this.styleFunction_;\n      };\n      /**\n       * @private\n       */\n\n\n      Feature.prototype.handleGeometryChange_ = function handleGeometryChange_() {\n        this.changed();\n      };\n      /**\n       * @private\n       */\n\n\n      Feature.prototype.handleGeometryChanged_ = function handleGeometryChanged_() {\n        if (this.geometryChangeKey_) {\n          unlistenByKey(this.geometryChangeKey_);\n          this.geometryChangeKey_ = null;\n        }\n\n        var geometry = this.getGeometry();\n\n        if (geometry) {\n          this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);\n        }\n\n        this.changed();\n      };\n      /**\n       * Set the default geometry for the feature.  This will update the property\n       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.\n       * @param {import(\"./geom/Geometry.js\").default|undefined} geometry The new geometry.\n       * @api\n       * @observable\n       */\n\n\n      Feature.prototype.setGeometry = function setGeometry(geometry) {\n        this.set(this.geometryName_, geometry);\n      };\n      /**\n       * Set the style for the feature.  This can be a single style object, an array\n       * of styles, or a function that takes a resolution and returns an array of\n       * styles. If it is `null` the feature has no style (a `null` style).\n       * @param {import(\"./style/Style.js\").StyleLike} style Style for this feature.\n       * @api\n       * @fires module:ol/events/Event~Event#event:change\n       */\n\n\n      Feature.prototype.setStyle = function setStyle(style) {\n        this.style_ = style;\n        this.styleFunction_ = !style ? undefined : createStyleFunction(style);\n        this.changed();\n      };\n      /**\n       * Set the feature id.  The feature id is considered stable and may be used when\n       * requesting features or comparing identifiers returned from a remote source.\n       * The feature id can be used with the\n       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.\n       * @param {number|string|undefined} id The feature id.\n       * @api\n       * @fires module:ol/events/Event~Event#event:change\n       */\n\n\n      Feature.prototype.setId = function setId(id) {\n        this.id_ = id;\n        this.changed();\n      };\n      /**\n       * Set the property name to be used when getting the feature's default geometry.\n       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with\n       * this name will be returned.\n       * @param {string} name The property name of the default geometry.\n       * @api\n       */\n\n\n      Feature.prototype.setGeometryName = function setGeometryName(name) {\n        unlisten(this, getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);\n        this.geometryName_ = name;\n        listen(this, getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);\n        this.handleGeometryChanged_();\n      };\n\n      return Feature;\n    }(BaseObject);\n    /**\n     * Convert the provided object into a feature style function.  Functions passed\n     * through unchanged.  Arrays of Style or single style objects wrapped\n     * in a new feature style function.\n     * @param {!import(\"./style/Style.js\").StyleFunction|!Array<import(\"./style/Style.js\").default>|!import(\"./style/Style.js\").default} obj\n     *     A feature style function, a single style, or an array of styles.\n     * @return {import(\"./style/Style.js\").StyleFunction} A style function.\n     */\n\n\n    function createStyleFunction(obj) {\n      if (typeof obj === 'function') {\n        return obj;\n      } else {\n        /**\n         * @type {Array<import(\"./style/Style.js\").default>}\n         */\n        var styles;\n\n        if (Array.isArray(obj)) {\n          styles = obj;\n        } else {\n          assert(typeof\n          /** @type {?} */\n          obj.getZIndex === 'function', 41); // Expected an `import(\"./style/Style.js\").Style` or an array of `import(\"./style/Style.js\").Style`\n\n          var style =\n          /** @type {import(\"./style/Style.js\").default} */\n          obj;\n          styles = [style];\n        }\n\n        return function () {\n          return styles;\n        };\n      }\n    }\n    /**\n     * @module ol/geom/Circle\n     */\n\n    /**\n     * @classdesc\n     * Circle geometry.\n     *\n     * @api\n     */\n\n\n    var Circle =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function Circle(center, opt_radius, opt_layout) {\n        SimpleGeometry$$1.call(this);\n\n        if (opt_layout !== undefined && opt_radius === undefined) {\n          this.setFlatCoordinates(opt_layout, center);\n        } else {\n          var radius = opt_radius ? opt_radius : 0;\n          this.setCenterAndRadius(center, radius, opt_layout);\n        }\n      }\n\n      if (SimpleGeometry$$1) Circle.__proto__ = SimpleGeometry$$1;\n      Circle.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      Circle.prototype.constructor = Circle;\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!Circle} Clone.\n       * @override\n       * @api\n       */\n\n      Circle.prototype.clone = function clone$$1() {\n        return new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Circle.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        var squaredDistance = dx * dx + dy * dy;\n\n        if (squaredDistance < minSquaredDistance) {\n          if (squaredDistance === 0) {\n            for (var i = 0; i < this.stride; ++i) {\n              closestPoint[i] = flatCoordinates[i];\n            }\n          } else {\n            var delta = this.getRadius() / Math.sqrt(squaredDistance);\n            closestPoint[0] = flatCoordinates[0] + delta * dx;\n            closestPoint[1] = flatCoordinates[1] + delta * dy;\n\n            for (var i$1 = 2; i$1 < this.stride; ++i$1) {\n              closestPoint[i$1] = flatCoordinates[i$1];\n            }\n          }\n\n          closestPoint.length = this.stride;\n          return squaredDistance;\n        } else {\n          return minSquaredDistance;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Circle.prototype.containsXY = function containsXY$$1(x, y) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        return dx * dx + dy * dy <= this.getRadiusSquared_();\n      };\n      /**\n       * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n       * @return {import(\"../coordinate.js\").Coordinate} Center.\n       * @api\n       */\n\n\n      Circle.prototype.getCenter = function getCenter$$1() {\n        return this.flatCoordinates.slice(0, this.stride);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Circle.prototype.computeExtent = function computeExtent(extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n        return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n      };\n      /**\n       * Return the radius of the circle.\n       * @return {number} Radius.\n       * @api\n       */\n\n\n      Circle.prototype.getRadius = function getRadius() {\n        return Math.sqrt(this.getRadiusSquared_());\n      };\n      /**\n       * @private\n       * @return {number} Radius squared.\n       */\n\n\n      Circle.prototype.getRadiusSquared_ = function getRadiusSquared_() {\n        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n        return dx * dx + dy * dy;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      Circle.prototype.getType = function getType() {\n        return GeometryType.CIRCLE;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      Circle.prototype.intersectsExtent = function intersectsExtent(extent) {\n        var circleExtent = this.getExtent();\n\n        if (intersects(extent, circleExtent)) {\n          var center = this.getCenter();\n\n          if (extent[0] <= center[0] && extent[2] >= center[0]) {\n            return true;\n          }\n\n          if (extent[1] <= center[1] && extent[3] >= center[1]) {\n            return true;\n          }\n\n          return forEachCorner(extent, this.intersectsCoordinate, this);\n        }\n\n        return false;\n      };\n      /**\n       * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n       * @param {import(\"../coordinate.js\").Coordinate} center Center.\n       * @api\n       */\n\n\n      Circle.prototype.setCenter = function setCenter(center) {\n        var stride = this.stride;\n        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n        var flatCoordinates = center.slice();\n        flatCoordinates[stride] = flatCoordinates[0] + radius;\n\n        for (var i = 1; i < stride; ++i) {\n          flatCoordinates[stride + i] = center[i];\n        }\n\n        this.setFlatCoordinates(this.layout, flatCoordinates);\n        this.changed();\n      };\n      /**\n       * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n       * number) of the circle.\n       * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n       * @param {number} radius Radius.\n       * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n       * @api\n       */\n\n\n      Circle.prototype.setCenterAndRadius = function setCenterAndRadius(center, radius, opt_layout) {\n        this.setLayout(opt_layout, center, 0);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n        /** @type {Array<number>} */\n\n\n        var flatCoordinates = this.flatCoordinates;\n        var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n        flatCoordinates[offset++] = flatCoordinates[0] + radius;\n\n        for (var i = 1, ii = this.stride; i < ii; ++i) {\n          flatCoordinates[offset++] = flatCoordinates[i];\n        }\n\n        flatCoordinates.length = offset;\n        this.changed();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Circle.prototype.getCoordinates = function getCoordinates() {\n        return null;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Circle.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {};\n      /**\n       * Set the radius of the circle. The radius is in the units of the projection.\n       * @param {number} radius Radius.\n       * @api\n       */\n\n\n      Circle.prototype.setRadius = function setRadius(radius) {\n        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n        this.changed();\n      };\n\n      return Circle;\n    }(SimpleGeometry);\n    /**\n     * Transform each coordinate of the circle from one coordinate reference system\n     * to another. The geometry is modified in place.\n     * If you do not want the geometry modified in place, first clone() it and\n     * then use this function on the clone.\n     *\n     * Internally a circle is currently represented by two points: the center of\n     * the circle `[cx, cy]`, and the point to the right of the circle\n     * `[cx + r, cy]`. This `transform` function just transforms these two points.\n     * So the resulting geometry is also a circle, and that circle does not\n     * correspond to the shape that would be obtained by transforming every point\n     * of the original circle.\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @return {Circle} This geometry.  Note that original geometry is\n     *     modified in place.\n     * @function\n     * @api\n     */\n\n\n    Circle.prototype.transform;\n    /**\n     * @module ol/geom/flat/interpolate\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} fraction Fraction.\n     * @param {Array<number>=} opt_dest Destination.\n     * @return {Array<number>} Destination.\n     */\n\n    function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n      var pointX = NaN;\n      var pointY = NaN;\n      var n = (end - offset) / stride;\n\n      if (n === 1) {\n        pointX = flatCoordinates[offset];\n        pointY = flatCoordinates[offset + 1];\n      } else if (n == 2) {\n        pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];\n        pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];\n      } else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length = 0;\n        var cumulativeLengths = [0];\n\n        for (var i = offset + stride; i < end; i += stride) {\n          var x2 = flatCoordinates[i];\n          var y2 = flatCoordinates[i + 1];\n          length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n          cumulativeLengths.push(length);\n          x1 = x2;\n          y1 = y2;\n        }\n\n        var target = fraction * length;\n        var index = binarySearch(cumulativeLengths, target);\n\n        if (index < 0) {\n          var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n          var o = offset + (-index - 2) * stride;\n          pointX = lerp(flatCoordinates[o], flatCoordinates[o + stride], t);\n          pointY = lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n        } else {\n          pointX = flatCoordinates[offset + index * stride];\n          pointY = flatCoordinates[offset + index * stride + 1];\n        }\n      }\n\n      if (opt_dest) {\n        opt_dest[0] = pointX;\n        opt_dest[1] = pointY;\n        return opt_dest;\n      } else {\n        return [pointX, pointY];\n      }\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {number} m M.\n     * @param {boolean} extrapolate Extrapolate.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n\n\n    function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n      if (end == offset) {\n        return null;\n      }\n\n      var coordinate;\n\n      if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n          coordinate = flatCoordinates.slice(offset, offset + stride);\n          coordinate[stride - 1] = m;\n          return coordinate;\n        } else {\n          return null;\n        }\n      } else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n          coordinate = flatCoordinates.slice(end - stride, end);\n          coordinate[stride - 1] = m;\n          return coordinate;\n        } else {\n          return null;\n        }\n      } // FIXME use O(1) search\n\n\n      if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n      }\n\n      var lo = offset / stride;\n      var hi = end / stride;\n\n      while (lo < hi) {\n        var mid = lo + hi >> 1;\n\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n          hi = mid;\n        } else {\n          lo = mid + 1;\n        }\n      }\n\n      var m0 = flatCoordinates[lo * stride - 1];\n\n      if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n      }\n\n      var m1 = flatCoordinates[(lo + 1) * stride - 1];\n      var t = (m - m0) / (m1 - m0);\n      coordinate = [];\n\n      for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n      }\n\n      coordinate.push(m);\n      return coordinate;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {number} m M.\n     * @param {boolean} extrapolate Extrapolate.\n     * @param {boolean} interpolate Interpolate.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n\n\n    function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n      if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n      }\n\n      var coordinate;\n\n      if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n          coordinate = flatCoordinates.slice(0, stride);\n          coordinate[stride - 1] = m;\n          return coordinate;\n        } else {\n          return null;\n        }\n      }\n\n      if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n          coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n          coordinate[stride - 1] = m;\n          return coordinate;\n        } else {\n          return null;\n        }\n      }\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n\n        if (offset == end) {\n          continue;\n        }\n\n        if (m < flatCoordinates[offset + stride - 1]) {\n          return null;\n        } else if (m <= flatCoordinates[end - 1]) {\n          return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n\n        offset = end;\n      }\n\n      return null;\n    }\n    /**\n     * @module ol/geom/flat/length\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @return {number} Length.\n     */\n\n\n    function lineStringLength(flatCoordinates, offset, end, stride) {\n      var x1 = flatCoordinates[offset];\n      var y1 = flatCoordinates[offset + 1];\n      var length = 0;\n\n      for (var i = offset + stride; i < end; i += stride) {\n        var x2 = flatCoordinates[i];\n        var y2 = flatCoordinates[i + 1];\n        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n        x1 = x2;\n        y1 = y2;\n      }\n\n      return length;\n    }\n    /**\n     * @module ol/geom/LineString\n     */\n\n    /**\n     * @classdesc\n     * Linestring geometry.\n     *\n     * @api\n     */\n\n\n    var LineString =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function LineString(coordinates, opt_layout) {\n        SimpleGeometry$$1.call(this);\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n\n        this.flatMidpoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.flatMidpointRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDeltaRevision_ = -1;\n\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n          this.setFlatCoordinates(opt_layout,\n          /** @type {Array<number>} */\n          coordinates);\n        } else {\n          this.setCoordinates(\n          /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n          coordinates, opt_layout);\n        }\n      }\n\n      if (SimpleGeometry$$1) LineString.__proto__ = SimpleGeometry$$1;\n      LineString.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      LineString.prototype.constructor = LineString;\n      /**\n       * Append the passed coordinate to the coordinates of the linestring.\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @api\n       */\n\n      LineString.prototype.appendCoordinate = function appendCoordinate(coordinate) {\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = coordinate.slice();\n        } else {\n          extend(this.flatCoordinates, coordinate);\n        }\n\n        this.changed();\n      };\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!LineString} Clone.\n       * @override\n       * @api\n       */\n\n\n      LineString.prototype.clone = function clone$$1() {\n        return new LineString(this.flatCoordinates.slice(), this.layout);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LineString.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n          return minSquaredDistance;\n        }\n\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n          this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n          this.maxDeltaRevision_ = this.getRevision();\n        }\n\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n      };\n      /**\n       * Iterate over each segment, calling the provided callback.\n       * If the callback returns a truthy value the function returns that\n       * value immediately. Otherwise the function returns `false`.\n       *\n       * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n       *     called for each segment.\n       * @return {T|boolean} Value.\n       * @template T,S\n       * @api\n       */\n\n\n      LineString.prototype.forEachSegment = function forEachSegment$1(callback) {\n        return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n      };\n      /**\n       * Returns the coordinate at `m` using linear interpolation, or `null` if no\n       * such coordinate exists.\n       *\n       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n       * M will return the first coordinate and Ms greater than the last M will\n       * return the last coordinate.\n       *\n       * @param {number} m M.\n       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n       * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n       * @api\n       */\n\n\n      LineString.prototype.getCoordinateAtM = function getCoordinateAtM(m, opt_extrapolate) {\n        if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM) {\n          return null;\n        }\n\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n      };\n      /**\n       * Return the coordinates of the linestring.\n       * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n       * @override\n       * @api\n       */\n\n\n      LineString.prototype.getCoordinates = function getCoordinates() {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n      };\n      /**\n       * Return the coordinate at the provided fraction along the linestring.\n       * The `fraction` is a number between 0 and 1, where 0 is the start of the\n       * linestring and 1 is the end.\n       * @param {number} fraction Fraction.\n       * @param {import(\"../coordinate.js\").Coordinate=} opt_dest Optional coordinate whose values will\n       *     be modified. If not provided, a new coordinate will be returned.\n       * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n       * @api\n       */\n\n\n      LineString.prototype.getCoordinateAt = function getCoordinateAt(fraction, opt_dest) {\n        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);\n      };\n      /**\n       * Return the length of the linestring on projected plane.\n       * @return {number} Length (on projected plane).\n       * @api\n       */\n\n\n      LineString.prototype.getLength = function getLength() {\n        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n      };\n      /**\n       * @return {Array<number>} Flat midpoint.\n       */\n\n\n      LineString.prototype.getFlatMidpoint = function getFlatMidpoint() {\n        if (this.flatMidpointRevision_ != this.getRevision()) {\n          this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n          this.flatMidpointRevision_ = this.getRevision();\n        }\n\n        return this.flatMidpoint_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      LineString.prototype.getType = function getType() {\n        return GeometryType.LINE_STRING;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      LineString.prototype.intersectsExtent = function intersectsExtent(extent) {\n        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n      };\n      /**\n       * Set the coordinates of the linestring.\n       * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n       * @param {GeometryLayout=} opt_layout Layout.\n       * @override\n       * @api\n       */\n\n\n      LineString.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n      };\n\n      return LineString;\n    }(SimpleGeometry);\n    /**\n     * @module ol/geom/MultiLineString\n     */\n\n    /**\n     * @classdesc\n     * Multi-linestring geometry.\n     *\n     * @api\n     */\n\n\n    var MultiLineString =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function MultiLineString(coordinates, opt_layout, opt_ends) {\n        SimpleGeometry$$1.call(this);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n\n        this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDeltaRevision_ = -1;\n\n        if (Array.isArray(coordinates[0])) {\n          this.setCoordinates(\n          /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */\n          coordinates, opt_layout);\n        } else if (opt_layout !== undefined && opt_ends) {\n          this.setFlatCoordinates(opt_layout,\n          /** @type {Array<number>} */\n          coordinates);\n          this.ends_ = opt_ends;\n        } else {\n          var layout = this.getLayout();\n          var lineStrings =\n          /** @type {Array<LineString>} */\n          coordinates;\n          var flatCoordinates = [];\n          var ends = [];\n\n          for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n            var lineString = lineStrings[i];\n\n            if (i === 0) {\n              layout = lineString.getLayout();\n            }\n\n            extend(flatCoordinates, lineString.getFlatCoordinates());\n            ends.push(flatCoordinates.length);\n          }\n\n          this.setFlatCoordinates(layout, flatCoordinates);\n          this.ends_ = ends;\n        }\n      }\n\n      if (SimpleGeometry$$1) MultiLineString.__proto__ = SimpleGeometry$$1;\n      MultiLineString.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      MultiLineString.prototype.constructor = MultiLineString;\n      /**\n       * Append the passed linestring to the multilinestring.\n       * @param {LineString} lineString LineString.\n       * @api\n       */\n\n      MultiLineString.prototype.appendLineString = function appendLineString(lineString) {\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = lineString.getFlatCoordinates().slice();\n        } else {\n          extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n        }\n\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n      };\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!MultiLineString} Clone.\n       * @override\n       * @api\n       */\n\n\n      MultiLineString.prototype.clone = function clone$$1() {\n        return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      MultiLineString.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n          return minSquaredDistance;\n        }\n\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n          this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n          this.maxDeltaRevision_ = this.getRevision();\n        }\n\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n      };\n      /**\n       * Returns the coordinate at `m` using linear interpolation, or `null` if no\n       * such coordinate exists.\n       *\n       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n       * M will return the first coordinate and Ms greater than the last M will\n       * return the last coordinate.\n       *\n       * `opt_interpolate` controls interpolation between consecutive LineStrings\n       * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n       * will be linearly interpolated between the last coordinate of one LineString\n       * and the first coordinate of the next LineString.  If `opt_interpolate` is\n       * `false` then the function will return `null` for Ms falling between\n       * LineStrings.\n       *\n       * @param {number} m M.\n       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n       * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n       * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n       * @api\n       */\n\n\n      MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM(m, opt_extrapolate, opt_interpolate) {\n        if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM || this.flatCoordinates.length === 0) {\n          return null;\n        }\n\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n      };\n      /**\n       * Return the coordinates of the multilinestring.\n       * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n       * @override\n       * @api\n       */\n\n\n      MultiLineString.prototype.getCoordinates = function getCoordinates() {\n        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n      };\n      /**\n       * @return {Array<number>} Ends.\n       */\n\n\n      MultiLineString.prototype.getEnds = function getEnds() {\n        return this.ends_;\n      };\n      /**\n       * Return the linestring at the specified index.\n       * @param {number} index Index.\n       * @return {LineString} LineString.\n       * @api\n       */\n\n\n      MultiLineString.prototype.getLineString = function getLineString(index) {\n        if (index < 0 || this.ends_.length <= index) {\n          return null;\n        }\n\n        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n      };\n      /**\n       * Return the linestrings of this multilinestring.\n       * @return {Array<LineString>} LineStrings.\n       * @api\n       */\n\n\n      MultiLineString.prototype.getLineStrings = function getLineStrings() {\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var layout = this.layout;\n        /** @type {Array<LineString>} */\n\n        var lineStrings = [];\n        var offset = 0;\n\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n          var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n          lineStrings.push(lineString);\n          offset = end;\n        }\n\n        return lineStrings;\n      };\n      /**\n       * @return {Array<number>} Flat midpoints.\n       */\n\n\n      MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints() {\n        var midpoints = [];\n        var flatCoordinates = this.flatCoordinates;\n        var offset = 0;\n        var ends = this.ends_;\n        var stride = this.stride;\n\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n          var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n          extend(midpoints, midpoint);\n          offset = end;\n        }\n\n        return midpoints;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      MultiLineString.prototype.getType = function getType() {\n        return GeometryType.MULTI_LINE_STRING;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      MultiLineString.prototype.intersectsExtent = function intersectsExtent(extent) {\n        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n      };\n      /**\n       * Set the coordinates of the multilinestring.\n       * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n       * @param {GeometryLayout=} opt_layout Layout.\n       * @override\n       * @api\n       */\n\n\n      MultiLineString.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n      };\n\n      return MultiLineString;\n    }(SimpleGeometry);\n    /**\n     * @module ol/geom/MultiPoint\n     */\n\n    /**\n     * @classdesc\n     * Multi-point geometry.\n     *\n     * @api\n     */\n\n\n    var MultiPoint =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function MultiPoint(coordinates, opt_layout) {\n        SimpleGeometry$$1.call(this);\n\n        if (opt_layout && !Array.isArray(coordinates[0])) {\n          this.setFlatCoordinates(opt_layout,\n          /** @type {Array<number>} */\n          coordinates);\n        } else {\n          this.setCoordinates(\n          /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n          coordinates, opt_layout);\n        }\n      }\n\n      if (SimpleGeometry$$1) MultiPoint.__proto__ = SimpleGeometry$$1;\n      MultiPoint.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      MultiPoint.prototype.constructor = MultiPoint;\n      /**\n       * Append the passed point to this multipoint.\n       * @param {Point} point Point.\n       * @api\n       */\n\n      MultiPoint.prototype.appendPoint = function appendPoint(point) {\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = point.getFlatCoordinates().slice();\n        } else {\n          extend(this.flatCoordinates, point.getFlatCoordinates());\n        }\n\n        this.changed();\n      };\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!MultiPoint} Clone.\n       * @override\n       * @api\n       */\n\n\n      MultiPoint.prototype.clone = function clone$$1() {\n        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n        return multiPoint;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      MultiPoint.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n          return minSquaredDistance;\n        }\n\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n          var squaredDistance$$1 = squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n\n          if (squaredDistance$$1 < minSquaredDistance) {\n            minSquaredDistance = squaredDistance$$1;\n\n            for (var j = 0; j < stride; ++j) {\n              closestPoint[j] = flatCoordinates[i + j];\n            }\n\n            closestPoint.length = stride;\n          }\n        }\n\n        return minSquaredDistance;\n      };\n      /**\n       * Return the coordinates of the multipoint.\n       * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n       * @override\n       * @api\n       */\n\n\n      MultiPoint.prototype.getCoordinates = function getCoordinates() {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n      };\n      /**\n       * Return the point at the specified index.\n       * @param {number} index Index.\n       * @return {Point} Point.\n       * @api\n       */\n\n\n      MultiPoint.prototype.getPoint = function getPoint(index) {\n        var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n\n        if (index < 0 || n <= index) {\n          return null;\n        }\n\n        return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);\n      };\n      /**\n       * Return the points of this multipoint.\n       * @return {Array<Point>} Points.\n       * @api\n       */\n\n\n      MultiPoint.prototype.getPoints = function getPoints() {\n        var flatCoordinates = this.flatCoordinates;\n        var layout = this.layout;\n        var stride = this.stride;\n        /** @type {Array<Point>} */\n\n        var points = [];\n\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n          var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n          points.push(point);\n        }\n\n        return points;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      MultiPoint.prototype.getType = function getType() {\n        return GeometryType.MULTI_POINT;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      MultiPoint.prototype.intersectsExtent = function intersectsExtent(extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n          var x = flatCoordinates[i];\n          var y = flatCoordinates[i + 1];\n\n          if (containsXY(extent, x, y)) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n      /**\n       * Set the coordinates of the multipoint.\n       * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n       * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n       * @override\n       * @api\n       */\n\n\n      MultiPoint.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n      };\n\n      return MultiPoint;\n    }(SimpleGeometry);\n    /**\n     * @module ol/geom/flat/center\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<Array<number>>} endss Endss.\n     * @param {number} stride Stride.\n     * @return {Array<number>} Flat centers.\n     */\n\n\n    function linearRingss$1(flatCoordinates, offset, endss, stride) {\n      var flatCenters = [];\n      var extent = createEmpty();\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n        offset = ends[ends.length - 1];\n      }\n\n      return flatCenters;\n    }\n    /**\n     * @module ol/geom/MultiPolygon\n     */\n\n    /**\n     * @classdesc\n     * Multi-polygon geometry.\n     *\n     * @api\n     */\n\n\n    var MultiPolygon =\n    /*@__PURE__*/\n    function (SimpleGeometry$$1) {\n      function MultiPolygon(coordinates, opt_layout, opt_endss) {\n        SimpleGeometry$$1.call(this);\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n\n        this.endss_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.flatInteriorPointsRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.flatInteriorPoints_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.orientedFlatCoordinates_ = null;\n\n        if (!opt_endss && !Array.isArray(coordinates[0])) {\n          var layout = this.getLayout();\n          var polygons =\n          /** @type {Array<Polygon>} */\n          coordinates;\n          var flatCoordinates = [];\n          var endss = [];\n\n          for (var i = 0, ii = polygons.length; i < ii; ++i) {\n            var polygon = polygons[i];\n\n            if (i === 0) {\n              layout = polygon.getLayout();\n            }\n\n            var offset = flatCoordinates.length;\n            var ends = polygon.getEnds();\n\n            for (var j = 0, jj = ends.length; j < jj; ++j) {\n              ends[j] += offset;\n            }\n\n            extend(flatCoordinates, polygon.getFlatCoordinates());\n            endss.push(ends);\n          }\n\n          opt_layout = layout;\n          coordinates = flatCoordinates;\n          opt_endss = endss;\n        }\n\n        if (opt_layout !== undefined && opt_endss) {\n          this.setFlatCoordinates(opt_layout,\n          /** @type {Array<number>} */\n          coordinates);\n          this.endss_ = opt_endss;\n        } else {\n          this.setCoordinates(\n          /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */\n          coordinates, opt_layout);\n        }\n      }\n\n      if (SimpleGeometry$$1) MultiPolygon.__proto__ = SimpleGeometry$$1;\n      MultiPolygon.prototype = Object.create(SimpleGeometry$$1 && SimpleGeometry$$1.prototype);\n      MultiPolygon.prototype.constructor = MultiPolygon;\n      /**\n       * Append the passed polygon to this multipolygon.\n       * @param {Polygon} polygon Polygon.\n       * @api\n       */\n\n      MultiPolygon.prototype.appendPolygon = function appendPolygon(polygon) {\n        /** @type {Array<number>} */\n        var ends;\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = polygon.getFlatCoordinates().slice();\n          ends = polygon.getEnds().slice();\n          this.endss_.push();\n        } else {\n          var offset = this.flatCoordinates.length;\n          extend(this.flatCoordinates, polygon.getFlatCoordinates());\n          ends = polygon.getEnds().slice();\n\n          for (var i = 0, ii = ends.length; i < ii; ++i) {\n            ends[i] += offset;\n          }\n        }\n\n        this.endss_.push(ends);\n        this.changed();\n      };\n      /**\n       * Make a complete copy of the geometry.\n       * @return {!MultiPolygon} Clone.\n       * @override\n       * @api\n       */\n\n\n      MultiPolygon.prototype.clone = function clone$$1() {\n        var len = this.endss_.length;\n        var newEndss = new Array(len);\n\n        for (var i = 0; i < len; ++i) {\n          newEndss[i] = this.endss_[i].slice();\n        }\n\n        return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      MultiPolygon.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n          return minSquaredDistance;\n        }\n\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n          this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n          this.maxDeltaRevision_ = this.getRevision();\n        }\n\n        return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      MultiPolygon.prototype.containsXY = function containsXY$$1(x, y) {\n        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n      };\n      /**\n       * Return the area of the multipolygon on projected plane.\n       * @return {number} Area (on projected plane).\n       * @api\n       */\n\n\n      MultiPolygon.prototype.getArea = function getArea$$1() {\n        return linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n      };\n      /**\n       * Get the coordinate array for this geometry.  This array has the structure\n       * of a GeoJSON coordinate array for multi-polygons.\n       *\n       * @param {boolean=} opt_right Orient coordinates according to the right-hand\n       *     rule (counter-clockwise for exterior and clockwise for interior rings).\n       *     If `false`, coordinates will be oriented according to the left-hand rule\n       *     (clockwise for exterior and counter-clockwise for interior rings).\n       *     By default, coordinate orientation will depend on how the geometry was\n       *     constructed.\n       * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n       * @override\n       * @api\n       */\n\n\n      MultiPolygon.prototype.getCoordinates = function getCoordinates(opt_right) {\n        var flatCoordinates;\n\n        if (opt_right !== undefined) {\n          flatCoordinates = this.getOrientedFlatCoordinates().slice();\n          orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n        } else {\n          flatCoordinates = this.flatCoordinates;\n        }\n\n        return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n      };\n      /**\n       * @return {Array<Array<number>>} Endss.\n       */\n\n\n      MultiPolygon.prototype.getEndss = function getEndss() {\n        return this.endss_;\n      };\n      /**\n       * @return {Array<number>} Flat interior points.\n       */\n\n\n      MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints() {\n        if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n          var flatCenters = linearRingss$1(this.flatCoordinates, 0, this.endss_, this.stride);\n          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n          this.flatInteriorPointsRevision_ = this.getRevision();\n        }\n\n        return this.flatInteriorPoints_;\n      };\n      /**\n       * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n       * @return {MultiPoint} Interior points as XYM coordinates, where M is\n       * the length of the horizontal intersection that the point belongs to.\n       * @api\n       */\n\n\n      MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints() {\n        return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n      };\n      /**\n       * @return {Array<number>} Oriented flat coordinates.\n       */\n\n\n      MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates() {\n        if (this.orientedRevision_ != this.getRevision()) {\n          var flatCoordinates = this.flatCoordinates;\n\n          if (linearRingsAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n            this.orientedFlatCoordinates_ = flatCoordinates;\n          } else {\n            this.orientedFlatCoordinates_ = flatCoordinates.slice();\n            this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n          }\n\n          this.orientedRevision_ = this.getRevision();\n        }\n\n        return this.orientedFlatCoordinates_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEndss = [];\n        simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n      };\n      /**\n       * Return the polygon at the specified index.\n       * @param {number} index Index.\n       * @return {Polygon} Polygon.\n       * @api\n       */\n\n\n      MultiPolygon.prototype.getPolygon = function getPolygon(index) {\n        if (index < 0 || this.endss_.length <= index) {\n          return null;\n        }\n\n        var offset;\n\n        if (index === 0) {\n          offset = 0;\n        } else {\n          var prevEnds = this.endss_[index - 1];\n          offset = prevEnds[prevEnds.length - 1];\n        }\n\n        var ends = this.endss_[index].slice();\n        var end = ends[ends.length - 1];\n\n        if (offset !== 0) {\n          for (var i = 0, ii = ends.length; i < ii; ++i) {\n            ends[i] -= offset;\n          }\n        }\n\n        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n      };\n      /**\n       * Return the polygons of this multipolygon.\n       * @return {Array<Polygon>} Polygons.\n       * @api\n       */\n\n\n      MultiPolygon.prototype.getPolygons = function getPolygons() {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var endss = this.endss_;\n        var polygons = [];\n        var offset = 0;\n\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n          var ends = endss[i].slice();\n          var end = ends[ends.length - 1];\n\n          if (offset !== 0) {\n            for (var j = 0, jj = ends.length; j < jj; ++j) {\n              ends[j] -= offset;\n            }\n          }\n\n          var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n          polygons.push(polygon);\n          offset = end;\n        }\n\n        return polygons;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      MultiPolygon.prototype.getType = function getType() {\n        return GeometryType.MULTI_POLYGON;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      MultiPolygon.prototype.intersectsExtent = function intersectsExtent(extent) {\n        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n      };\n      /**\n       * Set the coordinates of the multipolygon.\n       * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n       * @param {GeometryLayout=} opt_layout Layout.\n       * @override\n       * @api\n       */\n\n\n      MultiPolygon.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 3);\n\n        if (!this.flatCoordinates) {\n          this.flatCoordinates = [];\n        }\n\n        var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n\n        if (endss.length === 0) {\n          this.flatCoordinates.length = 0;\n        } else {\n          var lastEnds = endss[endss.length - 1];\n          this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n        }\n\n        this.changed();\n      };\n\n      return MultiPolygon;\n    }(SimpleGeometry);\n    /**\n     * @module ol/LayerType\n     */\n\n    /**\n     * A layer type used when creating layer renderers.\n     * @enum {string}\n     */\n\n\n    var LayerType = {\n      IMAGE: 'IMAGE',\n      TILE: 'TILE',\n      VECTOR_TILE: 'VECTOR_TILE',\n      VECTOR: 'VECTOR'\n    };\n    /**\n     * @module ol/layer/VectorRenderType\n     */\n\n    /**\n     * @enum {string}\n     * Render mode for vector layers:\n     *  * `'image'`: Vector layers are rendered as images. Great performance, but\n     *    point symbols and texts are always rotated with the view and pixels are\n     *    scaled during zoom animations.\n     *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering\n     *    even during animations, but slower performance.\n     * @api\n     */\n\n    var VectorRenderType = {\n      IMAGE: 'image',\n      VECTOR: 'vector'\n    };\n    /**\n     * @module ol/color\n     */\n\n    /**\n     * A color represented as a short array [red, green, blue, alpha].\n     * red, green, and blue should be integers in the range 0..255 inclusive.\n     * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n     * given then `1` will be used.\n     * @typedef {Array<number>} Color\n     * @api\n     */\n\n    /**\n     * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n     * @const\n     * @type {RegExp}\n     * @private\n     */\n\n    var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n    /**\n     * Regular expression for matching potential named color style strings.\n     * @const\n     * @type {RegExp}\n     * @private\n     */\n\n    var NAMED_COLOR_RE_ = /^([a-z]*)$/i;\n    /**\n     * Return the color as an rgba string.\n     * @param {Color|string} color Color.\n     * @return {string} Rgba string.\n     * @api\n     */\n\n    function asString(color) {\n      if (typeof color === 'string') {\n        return color;\n      } else {\n        return toString(color);\n      }\n    }\n    /**\n     * Return named color as an rgba string.\n     * @param {string} color Named color.\n     * @return {string} Rgb string.\n     */\n\n\n    function fromNamed(color) {\n      var el = document.createElement('div');\n      el.style.color = color;\n\n      if (el.style.color !== '') {\n        document.body.appendChild(el);\n        var rgb = getComputedStyle(el).color;\n        document.body.removeChild(el);\n        return rgb;\n      } else {\n        return '';\n      }\n    }\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n\n\n    var fromString = function () {\n      // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n      // semantics, whenever the cache grows too large we simply delete an\n      // arbitrary 25% of the entries.\n\n      /**\n       * @const\n       * @type {number}\n       */\n      var MAX_CACHE_SIZE = 1024;\n      /**\n       * @type {Object<string, Color>}\n       */\n\n      var cache = {};\n      /**\n       * @type {number}\n       */\n\n      var cacheSize = 0;\n      return (\n        /**\n         * @param {string} s String.\n         * @return {Color} Color.\n         */\n        function (s) {\n          var color;\n\n          if (cache.hasOwnProperty(s)) {\n            color = cache[s];\n          } else {\n            if (cacheSize >= MAX_CACHE_SIZE) {\n              var i = 0;\n\n              for (var key in cache) {\n                if ((i++ & 3) === 0) {\n                  delete cache[key];\n                  --cacheSize;\n                }\n              }\n            }\n\n            color = fromStringInternal_(s);\n            cache[s] = color;\n            ++cacheSize;\n          }\n\n          return color;\n        }\n      );\n    }();\n    /**\n     * Return the color as an array. This function maintains a cache of calculated\n     * arrays which means the result should not be modified.\n     * @param {Color|string} color Color.\n     * @return {Color} Color.\n     * @api\n     */\n\n\n    function asArray(color) {\n      if (Array.isArray(color)) {\n        return color;\n      } else {\n        return fromString(color);\n      }\n    }\n    /**\n     * @param {string} s String.\n     * @private\n     * @return {Color} Color.\n     */\n\n\n    function fromStringInternal_(s) {\n      var r, g, b, a, color;\n\n      if (NAMED_COLOR_RE_.exec(s)) {\n        s = fromNamed(s);\n      }\n\n      if (HEX_COLOR_RE_.exec(s)) {\n        // hex\n        var n = s.length - 1; // number of hex digits\n\n        var d; // number of digits per channel\n\n        if (n <= 4) {\n          d = 1;\n        } else {\n          d = 2;\n        }\n\n        var hasAlpha = n === 4 || n === 8;\n        r = parseInt(s.substr(1 + 0 * d, d), 16);\n        g = parseInt(s.substr(1 + 1 * d, d), 16);\n        b = parseInt(s.substr(1 + 2 * d, d), 16);\n\n        if (hasAlpha) {\n          a = parseInt(s.substr(1 + 3 * d, d), 16);\n        } else {\n          a = 255;\n        }\n\n        if (d == 1) {\n          r = (r << 4) + r;\n          g = (g << 4) + g;\n          b = (b << 4) + b;\n\n          if (hasAlpha) {\n            a = (a << 4) + a;\n          }\n        }\n\n        color = [r, g, b, a / 255];\n      } else if (s.indexOf('rgba(') == 0) {\n        // rgba()\n        color = s.slice(5, -1).split(',').map(Number);\n        normalize(color);\n      } else if (s.indexOf('rgb(') == 0) {\n        // rgb()\n        color = s.slice(4, -1).split(',').map(Number);\n        color.push(1);\n        normalize(color);\n      } else {\n        assert(false, 14); // Invalid color\n      }\n\n      return color;\n    }\n    /**\n     * TODO this function is only used in the test, we probably shouldn't export it\n     * @param {Color} color Color.\n     * @return {Color} Clamped color.\n     */\n\n\n    function normalize(color) {\n      color[0] = clamp(color[0] + 0.5 | 0, 0, 255);\n      color[1] = clamp(color[1] + 0.5 | 0, 0, 255);\n      color[2] = clamp(color[2] + 0.5 | 0, 0, 255);\n      color[3] = clamp(color[3], 0, 1);\n      return color;\n    }\n    /**\n     * @param {Color} color Color.\n     * @return {string} String.\n     */\n\n\n    function toString(color) {\n      var r = color[0];\n\n      if (r != (r | 0)) {\n        r = r + 0.5 | 0;\n      }\n\n      var g = color[1];\n\n      if (g != (g | 0)) {\n        g = g + 0.5 | 0;\n      }\n\n      var b = color[2];\n\n      if (b != (b | 0)) {\n        b = b + 0.5 | 0;\n      }\n\n      var a = color[3] === undefined ? 1 : color[3];\n      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    }\n    /**\n     * @module ol/colorlike\n     */\n\n    /**\n     * A type accepted by CanvasRenderingContext2D.fillStyle\n     * or CanvasRenderingContext2D.strokeStyle.\n     * Represents a color, pattern, or gradient. The origin for patterns and\n     * gradients as fill style is an increment of 512 css pixels from map coordinate\n     * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image\n     * must be a factor of two (2, 4, 8, ..., 512).\n     *\n     * @typedef {string|CanvasPattern|CanvasGradient} ColorLike\n     * @api\n     */\n\n    /**\n     * @param {import(\"./color.js\").Color|ColorLike} color Color.\n     * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.\n     * @api\n     */\n\n\n    function asColorLike(color) {\n      if (Array.isArray(color)) {\n        return toString(color);\n      } else {\n        return color;\n      }\n    }\n    /**\n     * @module ol/ImageState\n     */\n\n    /**\n     * @enum {number}\n     */\n\n\n    var ImageState = {\n      IDLE: 0,\n      LOADING: 1,\n      LOADED: 2,\n      ERROR: 3\n    };\n    /**\n     * @module ol/structs/LRUCache\n     */\n\n    /**\n     * @typedef {Object} Entry\n     * @property {string} key_\n     * @property {Object} newer\n     * @property {Object} older\n     * @property {*} value_\n     */\n\n    /**\n     * @classdesc\n     * Implements a Least-Recently-Used cache where the keys do not conflict with\n     * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n     * items from the cache is the responsibility of the user.\n     *\n     * @fires import(\"../events/Event.js\").Event\n     * @template T\n     */\n\n    var LRUCache =\n    /*@__PURE__*/\n    function (EventTarget) {\n      function LRUCache(opt_highWaterMark) {\n        EventTarget.call(this);\n        /**\n         * @type {number}\n         */\n\n        this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.count_ = 0;\n        /**\n         * @private\n         * @type {!Object<string, Entry>}\n         */\n\n        this.entries_ = {};\n        /**\n         * @private\n         * @type {?Entry}\n         */\n\n        this.oldest_ = null;\n        /**\n         * @private\n         * @type {?Entry}\n         */\n\n        this.newest_ = null;\n      }\n\n      if (EventTarget) LRUCache.__proto__ = EventTarget;\n      LRUCache.prototype = Object.create(EventTarget && EventTarget.prototype);\n      LRUCache.prototype.constructor = LRUCache;\n      /**\n       * @return {boolean} Can expire cache.\n       */\n\n      LRUCache.prototype.canExpireCache = function canExpireCache() {\n        return this.getCount() > this.highWaterMark;\n      };\n      /**\n       * FIXME empty description for jsdoc\n       */\n\n\n      LRUCache.prototype.clear = function clear() {\n        this.count_ = 0;\n        this.entries_ = {};\n        this.oldest_ = null;\n        this.newest_ = null;\n        this.dispatchEvent(EventType.CLEAR);\n      };\n      /**\n       * @param {string} key Key.\n       * @return {boolean} Contains key.\n       */\n\n\n      LRUCache.prototype.containsKey = function containsKey(key) {\n        return this.entries_.hasOwnProperty(key);\n      };\n      /**\n       * @param {function(this: S, T, string, LRUCache): ?} f The function\n       *     to call for every entry from the oldest to the newer. This function takes\n       *     3 arguments (the entry value, the entry key and the LRUCache object).\n       *     The return value is ignored.\n       * @param {S=} opt_this The object to use as `this` in `f`.\n       * @template S\n       */\n\n\n      LRUCache.prototype.forEach = function forEach(f, opt_this) {\n        var entry = this.oldest_;\n\n        while (entry) {\n          f.call(opt_this, entry.value_, entry.key_, this);\n          entry = entry.newer;\n        }\n      };\n      /**\n       * @param {string} key Key.\n       * @return {T} Value.\n       */\n\n\n      LRUCache.prototype.get = function get(key) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n        if (entry === this.newest_) {\n          return entry.value_;\n        } else if (entry === this.oldest_) {\n          this.oldest_ =\n          /** @type {Entry} */\n          this.oldest_.newer;\n          this.oldest_.older = null;\n        } else {\n          entry.newer.older = entry.older;\n          entry.older.newer = entry.newer;\n        }\n\n        entry.newer = null;\n        entry.older = this.newest_;\n        this.newest_.newer = entry;\n        this.newest_ = entry;\n        return entry.value_;\n      };\n      /**\n       * Remove an entry from the cache.\n       * @param {string} key The entry key.\n       * @return {T} The removed entry.\n       */\n\n\n      LRUCache.prototype.remove = function remove(key) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n        if (entry === this.newest_) {\n          this.newest_ =\n          /** @type {Entry} */\n          entry.older;\n\n          if (this.newest_) {\n            this.newest_.newer = null;\n          }\n        } else if (entry === this.oldest_) {\n          this.oldest_ =\n          /** @type {Entry} */\n          entry.newer;\n\n          if (this.oldest_) {\n            this.oldest_.older = null;\n          }\n        } else {\n          entry.newer.older = entry.older;\n          entry.older.newer = entry.newer;\n        }\n\n        delete this.entries_[key];\n        --this.count_;\n        return entry.value_;\n      };\n      /**\n       * @return {number} Count.\n       */\n\n\n      LRUCache.prototype.getCount = function getCount() {\n        return this.count_;\n      };\n      /**\n       * @return {Array<string>} Keys.\n       */\n\n\n      LRUCache.prototype.getKeys = function getKeys() {\n        var keys = new Array(this.count_);\n        var i = 0;\n        var entry;\n\n        for (entry = this.newest_; entry; entry = entry.older) {\n          keys[i++] = entry.key_;\n        }\n\n        return keys;\n      };\n      /**\n       * @return {Array<T>} Values.\n       */\n\n\n      LRUCache.prototype.getValues = function getValues() {\n        var values = new Array(this.count_);\n        var i = 0;\n        var entry;\n\n        for (entry = this.newest_; entry; entry = entry.older) {\n          values[i++] = entry.value_;\n        }\n\n        return values;\n      };\n      /**\n       * @return {T} Last value.\n       */\n\n\n      LRUCache.prototype.peekLast = function peekLast() {\n        return this.oldest_.value_;\n      };\n      /**\n       * @return {string} Last key.\n       */\n\n\n      LRUCache.prototype.peekLastKey = function peekLastKey() {\n        return this.oldest_.key_;\n      };\n      /**\n       * Get the key of the newest item in the cache.  Throws if the cache is empty.\n       * @return {string} The newest key.\n       */\n\n\n      LRUCache.prototype.peekFirstKey = function peekFirstKey() {\n        return this.newest_.key_;\n      };\n      /**\n       * @return {T} value Value.\n       */\n\n\n      LRUCache.prototype.pop = function pop() {\n        var entry = this.oldest_;\n        delete this.entries_[entry.key_];\n\n        if (entry.newer) {\n          entry.newer.older = null;\n        }\n\n        this.oldest_ =\n        /** @type {Entry} */\n        entry.newer;\n\n        if (!this.oldest_) {\n          this.newest_ = null;\n        }\n\n        --this.count_;\n        return entry.value_;\n      };\n      /**\n       * @param {string} key Key.\n       * @param {T} value Value.\n       */\n\n\n      LRUCache.prototype.replace = function replace(key, value) {\n        this.get(key); // update `newest_`\n\n        this.entries_[key].value_ = value;\n      };\n      /**\n       * @param {string} key Key.\n       * @param {T} value Value.\n       */\n\n\n      LRUCache.prototype.set = function set(key, value) {\n        assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n\n        var entry =\n        /** @type {Entry} */\n        {\n          key_: key,\n          newer: null,\n          older: this.newest_,\n          value_: value\n        };\n\n        if (!this.newest_) {\n          this.oldest_ = entry;\n        } else {\n          this.newest_.newer = entry;\n        }\n\n        this.newest_ = entry;\n        this.entries_[key] = entry;\n        ++this.count_;\n      };\n      /**\n       * Set a maximum number of entries for the cache.\n       * @param {number} size Cache size.\n       * @api\n       */\n\n\n      LRUCache.prototype.setSize = function setSize(size) {\n        this.highWaterMark = size;\n      };\n      /**\n       * Prune the cache.\n       */\n\n\n      LRUCache.prototype.prune = function prune() {\n        while (this.canExpireCache()) {\n          this.pop();\n        }\n      };\n\n      return LRUCache;\n    }(Target);\n    /**\n     * @module ol/render/canvas\n     */\n\n    /**\n     * @typedef {Object} FillState\n     * @property {import(\"../colorlike.js\").ColorLike} fillStyle\n     */\n\n    /**\n     * @typedef {Object} FillStrokeState\n     * @property {import(\"../colorlike.js\").ColorLike} [currentFillStyle]\n     * @property {import(\"../colorlike.js\").ColorLike} [currentStrokeStyle]\n     * @property {string} [currentLineCap]\n     * @property {Array<number>} currentLineDash\n     * @property {number} [currentLineDashOffset]\n     * @property {string} [currentLineJoin]\n     * @property {number} [currentLineWidth]\n     * @property {number} [currentMiterLimit]\n     * @property {number} [lastStroke]\n     * @property {import(\"../colorlike.js\").ColorLike} [fillStyle]\n     * @property {import(\"../colorlike.js\").ColorLike} [strokeStyle]\n     * @property {string} [lineCap]\n     * @property {Array<number>} lineDash\n     * @property {number} [lineDashOffset]\n     * @property {string} [lineJoin]\n     * @property {number} [lineWidth]\n     * @property {number} [miterLimit]\n     */\n\n    /**\n     * @typedef {Object} StrokeState\n     * @property {string} lineCap\n     * @property {Array<number>} lineDash\n     * @property {number} lineDashOffset\n     * @property {string} lineJoin\n     * @property {number} lineWidth\n     * @property {number} miterLimit\n     * @property {import(\"../colorlike.js\").ColorLike} strokeStyle\n     */\n\n    /**\n     * @typedef {Object} TextState\n     * @property {string} font\n     * @property {string} [textAlign]\n     * @property {string} textBaseline\n     * @property {string} [placement]\n     * @property {number} [maxAngle]\n     * @property {boolean} [overflow]\n     * @property {import(\"../style/Fill.js\").default} [backgroundFill]\n     * @property {import(\"../style/Stroke.js\").default} [backgroundStroke]\n     * @property {number} [scale]\n     * @property {Array<number>} [padding]\n     */\n\n    /**\n     * Container for decluttered replay instructions that need to be rendered or\n     * omitted together, i.e. when styles render both an image and text, or for the\n     * characters that form text along lines. The basic elements of this array are\n     * `[minX, minY, maxX, maxY, count]`, where the first four entries are the\n     * rendered extent of the group in pixel space. `count` is the number of styles\n     * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.\n     * In addition to these four elements, declutter instruction arrays (i.e. the\n     * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.\n     * @typedef {Array<*>} DeclutterGroup\n     */\n\n    /**\n     * @const\n     * @type {string}\n     */\n\n\n    var defaultFont = '10px sans-serif';\n    /**\n     * @const\n     * @type {import(\"../color.js\").Color}\n     */\n\n    var defaultFillStyle = [0, 0, 0, 1];\n    /**\n     * @const\n     * @type {string}\n     */\n\n    var defaultLineCap = 'round';\n    /**\n     * @const\n     * @type {Array<number>}\n     */\n\n    var defaultLineDash = [];\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var defaultLineDashOffset = 0;\n    /**\n     * @const\n     * @type {string}\n     */\n\n    var defaultLineJoin = 'round';\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var defaultMiterLimit = 10;\n    /**\n     * @const\n     * @type {import(\"../color.js\").Color}\n     */\n\n    var defaultStrokeStyle = [0, 0, 0, 1];\n    /**\n     * @const\n     * @type {string}\n     */\n\n    var defaultTextAlign = 'center';\n    /**\n     * @const\n     * @type {string}\n     */\n\n    var defaultTextBaseline = 'middle';\n    /**\n     * @const\n     * @type {Array<number>}\n     */\n\n    var defaultPadding = [0, 0, 0, 0];\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var defaultLineWidth = 1;\n    /**\n     * The label cache for text rendering. To change the default cache size of 2048\n     * entries, use {@link module:ol/structs/LRUCache#setSize}.\n     * @type {LRUCache<HTMLCanvasElement>}\n     * @api\n     */\n\n    var labelCache = new LRUCache();\n    /**\n     * @type {!Object<string, number>}\n     */\n\n    var checkedFonts = {};\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n\n    var measureContext = null;\n    /**\n     * @type {!Object<string, number>}\n     */\n\n    var textHeights = {};\n    /**\n     * Clears the label cache when a font becomes available.\n     * @param {string} fontSpec CSS font spec.\n     */\n\n    var checkFont = function () {\n      var retries = 60;\n      var checked = checkedFonts;\n      var size = '32px ';\n      var referenceFonts = ['monospace', 'serif'];\n      var len = referenceFonts.length;\n      var text = \"wmytzilWMYTZIL@#/&?$%10\\uF013\";\n      var interval, referenceWidth;\n\n      function isAvailable(font) {\n        var context = getMeasureContext(); // Check weight ranges according to\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n\n        for (var weight = 100; weight <= 700; weight += 300) {\n          var fontWeight = weight + ' ';\n          var available = true;\n\n          for (var i = 0; i < len; ++i) {\n            var referenceFont = referenceFonts[i];\n            context.font = fontWeight + size + referenceFont;\n            referenceWidth = context.measureText(text).width;\n\n            if (font != referenceFont) {\n              context.font = fontWeight + size + font + ',' + referenceFont;\n              var width = context.measureText(text).width; // If width and referenceWidth are the same, then the fallback was used\n              // instead of the font we wanted, so the font is not available.\n\n              available = available && width != referenceWidth;\n            }\n          }\n\n          if (available) {\n            // Consider font available when it is available in one weight range.\n            //FIXME With this we miss rare corner cases, so we should consider\n            //FIXME checking availability for each requested weight range.\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function check() {\n        var done = true;\n\n        for (var font in checked) {\n          if (checked[font] < retries) {\n            if (isAvailable(font)) {\n              checked[font] = retries;\n              clear(textHeights); // Make sure that loaded fonts are picked up by Safari\n\n              measureContext = null;\n              labelCache.clear();\n            } else {\n              ++checked[font];\n              done = false;\n            }\n          }\n        }\n\n        if (done) {\n          clearInterval(interval);\n          interval = undefined;\n        }\n      }\n\n      return function (fontSpec) {\n        var fontFamilies = getFontFamilies(fontSpec);\n\n        if (!fontFamilies) {\n          return;\n        }\n\n        for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {\n          var fontFamily = fontFamilies[i];\n\n          if (!(fontFamily in checked)) {\n            checked[fontFamily] = retries;\n\n            if (!isAvailable(fontFamily)) {\n              checked[fontFamily] = 0;\n\n              if (interval === undefined) {\n                interval = setInterval(check, 32);\n              }\n            }\n          }\n        }\n      };\n    }();\n    /**\n     * @return {CanvasRenderingContext2D} Measure context.\n     */\n\n\n    function getMeasureContext() {\n      if (!measureContext) {\n        measureContext = createCanvasContext2D(1, 1);\n      }\n\n      return measureContext;\n    }\n    /**\n     * @param {string} font Font to use for measuring.\n     * @return {import(\"../size.js\").Size} Measurement.\n     */\n\n\n    var measureTextHeight = function () {\n      var span;\n      var heights = textHeights;\n      return function (font) {\n        var height = heights[font];\n\n        if (height == undefined) {\n          if (!span) {\n            span = document.createElement('span');\n            span.textContent = 'M';\n            span.style.margin = span.style.padding = '0 !important';\n            span.style.position = 'absolute !important';\n            span.style.left = '-99999px !important';\n          }\n\n          span.style.font = font;\n          document.body.appendChild(span);\n          height = heights[font] = span.offsetHeight;\n          document.body.removeChild(span);\n        }\n\n        return height;\n      };\n    }();\n    /**\n     * @param {string} font Font.\n     * @param {string} text Text.\n     * @return {number} Width.\n     */\n\n\n    function measureTextWidth(font, text) {\n      var measureContext = getMeasureContext();\n\n      if (font != measureContext.font) {\n        measureContext.font = font;\n      }\n\n      return measureContext.measureText(text).width;\n    }\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} rotation Rotation.\n     * @param {number} offsetX X offset.\n     * @param {number} offsetY Y offset.\n     */\n\n\n    function rotateAtOffset(context, rotation, offsetX, offsetY) {\n      if (rotation !== 0) {\n        context.translate(offsetX, offsetY);\n        context.rotate(rotation);\n        context.translate(-offsetX, -offsetY);\n      }\n    }\n\n    var resetTransform = create();\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../transform.js\").Transform|null} transform Transform.\n     * @param {number} opacity Opacity.\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n     * @param {number} originX Origin X.\n     * @param {number} originY Origin Y.\n     * @param {number} w Width.\n     * @param {number} h Height.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} scale Scale.\n     */\n\n    function drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale) {\n      var alpha;\n\n      if (opacity != 1) {\n        alpha = context.globalAlpha;\n        context.globalAlpha = alpha * opacity;\n      }\n\n      if (transform) {\n        context.setTransform.apply(context, transform);\n      }\n\n      context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);\n\n      if (alpha) {\n        context.globalAlpha = alpha;\n      }\n\n      if (transform) {\n        context.setTransform.apply(context, resetTransform);\n      }\n    }\n    /**\n     * @module ol/style/Image\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} opacity\n     * @property {boolean} rotateWithView\n     * @property {number} rotation\n     * @property {number} scale\n     */\n\n    /**\n     * @classdesc\n     * A base class used for creating subclasses and not instantiated in\n     * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and\n     * {@link module:ol/style/RegularShape~RegularShape}.\n     * @abstract\n     * @api\n     */\n\n\n    var ImageStyle = function ImageStyle(options) {\n      /**\n       * @private\n       * @type {number}\n       */\n      this.opacity_ = options.opacity;\n      /**\n       * @private\n       * @type {boolean}\n       */\n\n      this.rotateWithView_ = options.rotateWithView;\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.rotation_ = options.rotation;\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.scale_ = options.scale;\n    };\n    /**\n     * Clones the style.\n     * @return {ImageStyle} The cloned style.\n     * @api\n     */\n\n\n    ImageStyle.prototype.clone = function clone() {\n      return new ImageStyle({\n        opacity: this.getOpacity(),\n        scale: this.getScale(),\n        rotation: this.getRotation(),\n        rotateWithView: this.getRotateWithView()\n      });\n    };\n    /**\n     * Get the symbolizer opacity.\n     * @return {number} Opacity.\n     * @api\n     */\n\n\n    ImageStyle.prototype.getOpacity = function getOpacity() {\n      return this.opacity_;\n    };\n    /**\n     * Determine whether the symbolizer rotates with the map.\n     * @return {boolean} Rotate with map.\n     * @api\n     */\n\n\n    ImageStyle.prototype.getRotateWithView = function getRotateWithView() {\n      return this.rotateWithView_;\n    };\n    /**\n     * Get the symoblizer rotation.\n     * @return {number} Rotation.\n     * @api\n     */\n\n\n    ImageStyle.prototype.getRotation = function getRotation() {\n      return this.rotation_;\n    };\n    /**\n     * Get the symbolizer scale.\n     * @return {number} Scale.\n     * @api\n     */\n\n\n    ImageStyle.prototype.getScale = function getScale() {\n      return this.scale_;\n    };\n    /**\n     * This method is deprecated and always returns false.\n     * @return {boolean} false.\n     * @deprecated\n     * @api\n     */\n\n\n    ImageStyle.prototype.getSnapToPixel = function getSnapToPixel() {\n      return false;\n    };\n    /**\n     * Get the anchor point in pixels. The anchor determines the center point for the\n     * symbolizer.\n     * @abstract\n     * @return {Array<number>} Anchor.\n     */\n\n\n    ImageStyle.prototype.getAnchor = function getAnchor() {\n      return _abstract();\n    };\n    /**\n     * Get the image element for the symbolizer.\n     * @abstract\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.\n     */\n\n\n    ImageStyle.prototype.getImage = function getImage(pixelRatio) {\n      return _abstract();\n    };\n    /**\n     * @abstract\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.\n     */\n\n\n    ImageStyle.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n      return _abstract();\n    };\n    /**\n     * @abstract\n     * @return {import(\"../ImageState.js\").default} Image state.\n     */\n\n\n    ImageStyle.prototype.getImageState = function getImageState() {\n      return _abstract();\n    };\n    /**\n     * @abstract\n     * @return {import(\"../size.js\").Size} Image size.\n     */\n\n\n    ImageStyle.prototype.getImageSize = function getImageSize() {\n      return _abstract();\n    };\n    /**\n     * @abstract\n     * @return {import(\"../size.js\").Size} Size of the hit-detection image.\n     */\n\n\n    ImageStyle.prototype.getHitDetectionImageSize = function getHitDetectionImageSize() {\n      return _abstract();\n    };\n    /**\n     * Get the origin of the symbolizer.\n     * @abstract\n     * @return {Array<number>} Origin.\n     */\n\n\n    ImageStyle.prototype.getOrigin = function getOrigin() {\n      return _abstract();\n    };\n    /**\n     * Get the size of the symbolizer (in pixels).\n     * @abstract\n     * @return {import(\"../size.js\").Size} Size.\n     */\n\n\n    ImageStyle.prototype.getSize = function getSize() {\n      return _abstract();\n    };\n    /**\n     * Set the opacity.\n     *\n     * @param {number} opacity Opacity.\n     * @api\n     */\n\n\n    ImageStyle.prototype.setOpacity = function setOpacity(opacity) {\n      this.opacity_ = opacity;\n    };\n    /**\n     * Set whether to rotate the style with the view.\n     *\n     * @param {boolean} rotateWithView Rotate with map.\n     * @api\n     */\n\n\n    ImageStyle.prototype.setRotateWithView = function setRotateWithView(rotateWithView) {\n      this.rotateWithView_ = rotateWithView;\n    };\n    /**\n     * Set the rotation.\n     *\n     * @param {number} rotation Rotation.\n     * @api\n     */\n\n\n    ImageStyle.prototype.setRotation = function setRotation(rotation) {\n      this.rotation_ = rotation;\n    };\n    /**\n     * Set the scale.\n     *\n     * @param {number} scale Scale.\n     * @api\n     */\n\n\n    ImageStyle.prototype.setScale = function setScale(scale) {\n      this.scale_ = scale;\n    };\n    /**\n     * This method is deprecated and does nothing.\n     * @param {boolean} snapToPixel Snap to pixel?\n     * @deprecated\n     * @api\n     */\n\n\n    ImageStyle.prototype.setSnapToPixel = function setSnapToPixel(snapToPixel) {};\n    /**\n     * @abstract\n     * @param {function(this: T, import(\"../events/Event.js\").default)} listener Listener function.\n     * @param {T} thisArg Value to use as `this` when executing `listener`.\n     * @return {import(\"../events.js\").EventsKey|undefined} Listener key.\n     * @template T\n     */\n\n\n    ImageStyle.prototype.listenImageChange = function listenImageChange(listener, thisArg) {\n      return _abstract();\n    };\n    /**\n     * Load not yet loaded URI.\n     * @abstract\n     */\n\n\n    ImageStyle.prototype.load = function load() {\n      _abstract();\n    };\n    /**\n     * @abstract\n     * @param {function(this: T, import(\"../events/Event.js\").default)} listener Listener function.\n     * @param {T} thisArg Value to use as `this` when executing `listener`.\n     * @template T\n     */\n\n\n    ImageStyle.prototype.unlistenImageChange = function unlistenImageChange(listener, thisArg) {\n      _abstract();\n    };\n    /**\n     * @module ol/style/RegularShape\n     */\n\n    /**\n     * Specify radius for regular polygons, or radius1 and radius2 for stars.\n     * @typedef {Object} Options\n     * @property {import(\"./Fill.js\").default} [fill] Fill style.\n     * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n     * is the number of sides.\n     * @property {number} [radius] Radius of a regular polygon.\n     * @property {number} [radius1] Outer radius of a star.\n     * @property {number} [radius2] Inner radius of a star.\n     * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\n     * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n     * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n     * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n     * @property {import(\"./AtlasManager.js\").default} [atlasManager] The atlas manager to use for this symbol. When\n     * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\n     * symbol is added to an atlas. By default no atlas manager is used.\n     */\n\n    /**\n     * @typedef {Object} RenderOptions\n     * @property {import(\"../colorlike.js\").ColorLike} [strokeStyle]\n     * @property {number} strokeWidth\n     * @property {number} size\n     * @property {string} lineCap\n     * @property {Array<number>} lineDash\n     * @property {number} lineDashOffset\n     * @property {string} lineJoin\n     * @property {number} miterLimit\n     */\n\n    /**\n     * @classdesc\n     * Set regular shape style for vector features. The resulting shape will be\n     * a regular polygon when `radius` is provided, or a star when `radius1` and\n     * `radius2` are provided.\n     * @api\n     */\n\n\n    var RegularShape =\n    /*@__PURE__*/\n    function (ImageStyle$$1) {\n      function RegularShape(options) {\n        /**\n         * @type {boolean}\n         */\n        var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;\n        ImageStyle$$1.call(this, {\n          opacity: 1,\n          rotateWithView: rotateWithView,\n          rotation: options.rotation !== undefined ? options.rotation : 0,\n          scale: 1\n        });\n        /**\n         * @private\n         * @type {Array<string|number>}\n         */\n\n        this.checksums_ = null;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.canvas_ = null;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.hitDetectionCanvas_ = null;\n        /**\n         * @private\n         * @type {import(\"./Fill.js\").default}\n         */\n\n        this.fill_ = options.fill !== undefined ? options.fill : null;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.origin_ = [0, 0];\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.points_ = options.points;\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.radius_ =\n        /** @type {number} */\n        options.radius !== undefined ? options.radius : options.radius1;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.radius2_ = options.radius2;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.angle_ = options.angle !== undefined ? options.angle : 0;\n        /**\n         * @private\n         * @type {import(\"./Stroke.js\").default}\n         */\n\n        this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.anchor_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n\n        this.size_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n\n        this.imageSize_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n\n        this.hitDetectionImageSize_ = null;\n        /**\n         * @protected\n         * @type {import(\"./AtlasManager.js\").default|undefined}\n         */\n\n        this.atlasManager_ = options.atlasManager;\n        this.render_(this.atlasManager_);\n      }\n\n      if (ImageStyle$$1) RegularShape.__proto__ = ImageStyle$$1;\n      RegularShape.prototype = Object.create(ImageStyle$$1 && ImageStyle$$1.prototype);\n      RegularShape.prototype.constructor = RegularShape;\n      /**\n       * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n       * @return {RegularShape} The cloned style.\n       * @api\n       */\n\n      RegularShape.prototype.clone = function clone() {\n        var style = new RegularShape({\n          fill: this.getFill() ? this.getFill().clone() : undefined,\n          points: this.getPoints(),\n          radius: this.getRadius(),\n          radius2: this.getRadius2(),\n          angle: this.getAngle(),\n          stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n          rotation: this.getRotation(),\n          rotateWithView: this.getRotateWithView(),\n          atlasManager: this.atlasManager_\n        });\n        style.setOpacity(this.getOpacity());\n        style.setScale(this.getScale());\n        return style;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      RegularShape.prototype.getAnchor = function getAnchor() {\n        return this.anchor_;\n      };\n      /**\n       * Get the angle used in generating the shape.\n       * @return {number} Shape's rotation in radians.\n       * @api\n       */\n\n\n      RegularShape.prototype.getAngle = function getAngle() {\n        return this.angle_;\n      };\n      /**\n       * Get the fill style for the shape.\n       * @return {import(\"./Fill.js\").default} Fill style.\n       * @api\n       */\n\n\n      RegularShape.prototype.getFill = function getFill() {\n        return this.fill_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n        return this.hitDetectionCanvas_;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      RegularShape.prototype.getImage = function getImage(pixelRatio) {\n        return this.canvas_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      RegularShape.prototype.getImageSize = function getImageSize() {\n        return this.imageSize_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize() {\n        return this.hitDetectionImageSize_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      RegularShape.prototype.getImageState = function getImageState() {\n        return ImageState.LOADED;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      RegularShape.prototype.getOrigin = function getOrigin() {\n        return this.origin_;\n      };\n      /**\n       * Get the number of points for generating the shape.\n       * @return {number} Number of points for stars and regular polygons.\n       * @api\n       */\n\n\n      RegularShape.prototype.getPoints = function getPoints() {\n        return this.points_;\n      };\n      /**\n       * Get the (primary) radius for the shape.\n       * @return {number} Radius.\n       * @api\n       */\n\n\n      RegularShape.prototype.getRadius = function getRadius() {\n        return this.radius_;\n      };\n      /**\n       * Get the secondary radius for the shape.\n       * @return {number|undefined} Radius2.\n       * @api\n       */\n\n\n      RegularShape.prototype.getRadius2 = function getRadius2() {\n        return this.radius2_;\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      RegularShape.prototype.getSize = function getSize() {\n        return this.size_;\n      };\n      /**\n       * Get the stroke style for the shape.\n       * @return {import(\"./Stroke.js\").default} Stroke style.\n       * @api\n       */\n\n\n      RegularShape.prototype.getStroke = function getStroke() {\n        return this.stroke_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      RegularShape.prototype.listenImageChange = function listenImageChange(listener, thisArg) {\n        return undefined;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      RegularShape.prototype.load = function load() {};\n      /**\n       * @inheritDoc\n       */\n\n\n      RegularShape.prototype.unlistenImageChange = function unlistenImageChange(listener, thisArg) {};\n      /**\n       * @protected\n       * @param {import(\"./AtlasManager.js\").default|undefined} atlasManager An atlas manager.\n       */\n\n\n      RegularShape.prototype.render_ = function render_(atlasManager) {\n        var imageSize;\n        var lineCap = '';\n        var lineJoin = '';\n        var miterLimit = 0;\n        var lineDash = null;\n        var lineDashOffset = 0;\n        var strokeStyle;\n        var strokeWidth = 0;\n\n        if (this.stroke_) {\n          strokeStyle = this.stroke_.getColor();\n\n          if (strokeStyle === null) {\n            strokeStyle = defaultStrokeStyle;\n          }\n\n          strokeStyle = asColorLike(strokeStyle);\n          strokeWidth = this.stroke_.getWidth();\n\n          if (strokeWidth === undefined) {\n            strokeWidth = defaultLineWidth;\n          }\n\n          lineDash = this.stroke_.getLineDash();\n          lineDashOffset = this.stroke_.getLineDashOffset();\n\n          if (!CANVAS_LINE_DASH) {\n            lineDash = null;\n            lineDashOffset = 0;\n          }\n\n          lineJoin = this.stroke_.getLineJoin();\n\n          if (lineJoin === undefined) {\n            lineJoin = defaultLineJoin;\n          }\n\n          lineCap = this.stroke_.getLineCap();\n\n          if (lineCap === undefined) {\n            lineCap = defaultLineCap;\n          }\n\n          miterLimit = this.stroke_.getMiterLimit();\n\n          if (miterLimit === undefined) {\n            miterLimit = defaultMiterLimit;\n          }\n        }\n\n        var size = 2 * (this.radius_ + strokeWidth) + 1;\n        /** @type {RenderOptions} */\n\n        var renderOptions = {\n          strokeStyle: strokeStyle,\n          strokeWidth: strokeWidth,\n          size: size,\n          lineCap: lineCap,\n          lineDash: lineDash,\n          lineDashOffset: lineDashOffset,\n          lineJoin: lineJoin,\n          miterLimit: miterLimit\n        };\n\n        if (atlasManager === undefined) {\n          // no atlas manager is used, create a new canvas\n          var context = createCanvasContext2D(size, size);\n          this.canvas_ = context.canvas; // canvas.width and height are rounded to the closest integer\n\n          size = this.canvas_.width;\n          imageSize = size;\n          this.draw_(renderOptions, context, 0, 0);\n          this.createHitDetectionCanvas_(renderOptions);\n        } else {\n          // an atlas manager is used, add the symbol to an atlas\n          size = Math.round(size);\n          var hasCustomHitDetectionImage = !this.fill_;\n          var renderHitDetectionCallback;\n\n          if (hasCustomHitDetectionImage) {\n            // render the hit-detection image into a separate atlas image\n            renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);\n          }\n\n          var id = this.getChecksum();\n          var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);\n          this.canvas_ = info.image;\n          this.origin_ = [info.offsetX, info.offsetY];\n          imageSize = info.image.width;\n\n          if (hasCustomHitDetectionImage) {\n            this.hitDetectionCanvas_ = info.hitImage;\n            this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];\n          } else {\n            this.hitDetectionCanvas_ = this.canvas_;\n            this.hitDetectionImageSize_ = [imageSize, imageSize];\n          }\n        }\n\n        this.anchor_ = [size / 2, size / 2];\n        this.size_ = [size, size];\n        this.imageSize_ = [imageSize, imageSize];\n      };\n      /**\n       * @private\n       * @param {RenderOptions} renderOptions Render options.\n       * @param {CanvasRenderingContext2D} context The rendering context.\n       * @param {number} x The origin for the symbol (x).\n       * @param {number} y The origin for the symbol (y).\n       */\n\n\n      RegularShape.prototype.draw_ = function draw_(renderOptions, context, x, y) {\n        var i, angle0, radiusC; // reset transform\n\n        context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)\n\n        context.translate(x, y);\n        context.beginPath();\n        var points = this.points_;\n\n        if (points === Infinity) {\n          context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n        } else {\n          var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n\n          if (radius2 !== this.radius_) {\n            points = 2 * points;\n          }\n\n          for (i = 0; i <= points; i++) {\n            angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n            radiusC = i % 2 === 0 ? this.radius_ : radius2;\n            context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n          }\n        }\n\n        if (this.fill_) {\n          var color = this.fill_.getColor();\n\n          if (color === null) {\n            color = defaultFillStyle;\n          }\n\n          context.fillStyle = asColorLike(color);\n          context.fill();\n        }\n\n        if (this.stroke_) {\n          context.strokeStyle = renderOptions.strokeStyle;\n          context.lineWidth = renderOptions.strokeWidth;\n\n          if (renderOptions.lineDash) {\n            context.setLineDash(renderOptions.lineDash);\n            context.lineDashOffset = renderOptions.lineDashOffset;\n          }\n\n          context.lineCap =\n          /** @type {CanvasLineCap} */\n          renderOptions.lineCap;\n          context.lineJoin =\n          /** @type {CanvasLineJoin} */\n          renderOptions.lineJoin;\n          context.miterLimit = renderOptions.miterLimit;\n          context.stroke();\n        }\n\n        context.closePath();\n      };\n      /**\n       * @private\n       * @param {RenderOptions} renderOptions Render options.\n       */\n\n\n      RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_(renderOptions) {\n        this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n\n        if (this.fill_) {\n          this.hitDetectionCanvas_ = this.canvas_;\n          return;\n        } // if no fill style is set, create an extra hit-detection image with a\n        // default fill style\n\n\n        var context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n        this.hitDetectionCanvas_ = context.canvas;\n        this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n      };\n      /**\n       * @private\n       * @param {RenderOptions} renderOptions Render options.\n       * @param {CanvasRenderingContext2D} context The context.\n       * @param {number} x The origin for the symbol (x).\n       * @param {number} y The origin for the symbol (y).\n       */\n\n\n      RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_(renderOptions, context, x, y) {\n        // reset transform\n        context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)\n\n        context.translate(x, y);\n        context.beginPath();\n        var points = this.points_;\n\n        if (points === Infinity) {\n          context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n        } else {\n          var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n\n          if (radius2 !== this.radius_) {\n            points = 2 * points;\n          }\n\n          var i, radiusC, angle0;\n\n          for (i = 0; i <= points; i++) {\n            angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n            radiusC = i % 2 === 0 ? this.radius_ : radius2;\n            context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n          }\n        }\n\n        context.fillStyle = asString(defaultFillStyle);\n        context.fill();\n\n        if (this.stroke_) {\n          context.strokeStyle = renderOptions.strokeStyle;\n          context.lineWidth = renderOptions.strokeWidth;\n\n          if (renderOptions.lineDash) {\n            context.setLineDash(renderOptions.lineDash);\n            context.lineDashOffset = renderOptions.lineDashOffset;\n          }\n\n          context.stroke();\n        }\n\n        context.closePath();\n      };\n      /**\n       * @return {string} The checksum.\n       */\n\n\n      RegularShape.prototype.getChecksum = function getChecksum() {\n        var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';\n        var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';\n        var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];\n\n        if (recalculate) {\n          var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');\n          this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];\n        }\n\n        return (\n          /** @type {string} */\n          this.checksums_[0]\n        );\n      };\n\n      return RegularShape;\n    }(ImageStyle);\n    /**\n     * @module ol/style/Circle\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"./Fill.js\").default} [fill] Fill style.\n     * @property {number} radius Circle radius.\n     * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n     * @property {import(\"./AtlasManager.js\").default} [atlasManager] The atlas manager to use for this circle.\n     * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,\n     * the circle is added to an atlas. By default no atlas manager is used.\n     */\n\n    /**\n     * @classdesc\n     * Set circle style for vector features.\n     * @api\n     */\n\n\n    var CircleStyle =\n    /*@__PURE__*/\n    function (RegularShape$$1) {\n      function CircleStyle(opt_options) {\n        var options = opt_options ||\n        /** @type {Options} */\n        {};\n        RegularShape$$1.call(this, {\n          points: Infinity,\n          fill: options.fill,\n          radius: options.radius,\n          stroke: options.stroke,\n          atlasManager: options.atlasManager\n        });\n      }\n\n      if (RegularShape$$1) CircleStyle.__proto__ = RegularShape$$1;\n      CircleStyle.prototype = Object.create(RegularShape$$1 && RegularShape$$1.prototype);\n      CircleStyle.prototype.constructor = CircleStyle;\n      /**\n      * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n      * @return {CircleStyle} The cloned style.\n      * @override\n      * @api\n      */\n\n      CircleStyle.prototype.clone = function clone() {\n        var style = new CircleStyle({\n          fill: this.getFill() ? this.getFill().clone() : undefined,\n          stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n          radius: this.getRadius(),\n          atlasManager: this.atlasManager_\n        });\n        style.setOpacity(this.getOpacity());\n        style.setScale(this.getScale());\n        return style;\n      };\n      /**\n      * Set the circle radius.\n      *\n      * @param {number} radius Circle radius.\n      * @api\n      */\n\n\n      CircleStyle.prototype.setRadius = function setRadius(radius) {\n        this.radius_ = radius;\n        this.render_(this.atlasManager_);\n      };\n\n      return CircleStyle;\n    }(RegularShape);\n    /**\n     * @module ol/style/Fill\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [color] A color, gradient or pattern.\n     * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\n     * Default null; if null, the Canvas/renderer default black will be used.\n     */\n\n    /**\n     * @classdesc\n     * Set fill style for vector features.\n     * @api\n     */\n\n\n    var Fill = function Fill(opt_options) {\n      var options = opt_options || {};\n      /**\n       * @private\n       * @type {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike}\n       */\n\n      this.color_ = options.color !== undefined ? options.color : null;\n      /**\n       * @private\n       * @type {string|undefined}\n       */\n\n      this.checksum_ = undefined;\n    };\n    /**\n     * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.\n     * @return {Fill} The cloned style.\n     * @api\n     */\n\n\n    Fill.prototype.clone = function clone() {\n      var color = this.getColor();\n      return new Fill({\n        color: Array.isArray(color) ? color.slice() : color || undefined\n      });\n    };\n    /**\n     * Get the fill color.\n     * @return {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} Color.\n     * @api\n     */\n\n\n    Fill.prototype.getColor = function getColor() {\n      return this.color_;\n    };\n    /**\n     * Set the color.\n     *\n     * @param {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} color Color.\n     * @api\n     */\n\n\n    Fill.prototype.setColor = function setColor(color) {\n      this.color_ = color;\n      this.checksum_ = undefined;\n    };\n    /**\n     * @return {string} The checksum.\n     */\n\n\n    Fill.prototype.getChecksum = function getChecksum() {\n      if (this.checksum_ === undefined) {\n        var color = this.color_;\n\n        if (color) {\n          if (Array.isArray(color) || typeof color == 'string') {\n            this.checksum_ = 'f' + asString(\n            /** @type {import(\"../color.js\").Color|string} */\n            color);\n          } else {\n            this.checksum_ = getUid(this.color_);\n          }\n        } else {\n          this.checksum_ = 'f-';\n        }\n      }\n\n      return this.checksum_;\n    };\n    /**\n     * @module ol/style/Stroke\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [color] A color, gradient or pattern.\n     * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\n     * Default null; if null, the Canvas/renderer default black will be used.\n     * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.\n     * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.\n     * @property {Array<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).\n     * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on\n     * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.\n     * @property {number} [lineDashOffset=0] Line dash offset.\n     * @property {number} [miterLimit=10] Miter limit.\n     * @property {number} [width] Width.\n     */\n\n    /**\n     * @classdesc\n     * Set stroke style for vector features.\n     * Note that the defaults given are the Canvas defaults, which will be used if\n     * option is not defined. The `get` functions return whatever was entered in\n     * the options; they will not return the default.\n     * @api\n     */\n\n\n    var Stroke = function Stroke(opt_options) {\n      var options = opt_options || {};\n      /**\n       * @private\n       * @type {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike}\n       */\n\n      this.color_ = options.color !== undefined ? options.color : null;\n      /**\n       * @private\n       * @type {string|undefined}\n       */\n\n      this.lineCap_ = options.lineCap;\n      /**\n       * @private\n       * @type {Array<number>}\n       */\n\n      this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n\n      this.lineDashOffset_ = options.lineDashOffset;\n      /**\n       * @private\n       * @type {string|undefined}\n       */\n\n      this.lineJoin_ = options.lineJoin;\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n\n      this.miterLimit_ = options.miterLimit;\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n\n      this.width_ = options.width;\n      /**\n       * @private\n       * @type {string|undefined}\n       */\n\n      this.checksum_ = undefined;\n    };\n    /**\n     * Clones the style.\n     * @return {Stroke} The cloned style.\n     * @api\n     */\n\n\n    Stroke.prototype.clone = function clone() {\n      var color = this.getColor();\n      return new Stroke({\n        color: Array.isArray(color) ? color.slice() : color || undefined,\n        lineCap: this.getLineCap(),\n        lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,\n        lineDashOffset: this.getLineDashOffset(),\n        lineJoin: this.getLineJoin(),\n        miterLimit: this.getMiterLimit(),\n        width: this.getWidth()\n      });\n    };\n    /**\n     * Get the stroke color.\n     * @return {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} Color.\n     * @api\n     */\n\n\n    Stroke.prototype.getColor = function getColor() {\n      return this.color_;\n    };\n    /**\n     * Get the line cap type for the stroke.\n     * @return {string|undefined} Line cap.\n     * @api\n     */\n\n\n    Stroke.prototype.getLineCap = function getLineCap() {\n      return this.lineCap_;\n    };\n    /**\n     * Get the line dash style for the stroke.\n     * @return {Array<number>} Line dash.\n     * @api\n     */\n\n\n    Stroke.prototype.getLineDash = function getLineDash() {\n      return this.lineDash_;\n    };\n    /**\n     * Get the line dash offset for the stroke.\n     * @return {number|undefined} Line dash offset.\n     * @api\n     */\n\n\n    Stroke.prototype.getLineDashOffset = function getLineDashOffset() {\n      return this.lineDashOffset_;\n    };\n    /**\n     * Get the line join type for the stroke.\n     * @return {string|undefined} Line join.\n     * @api\n     */\n\n\n    Stroke.prototype.getLineJoin = function getLineJoin() {\n      return this.lineJoin_;\n    };\n    /**\n     * Get the miter limit for the stroke.\n     * @return {number|undefined} Miter limit.\n     * @api\n     */\n\n\n    Stroke.prototype.getMiterLimit = function getMiterLimit() {\n      return this.miterLimit_;\n    };\n    /**\n     * Get the stroke width.\n     * @return {number|undefined} Width.\n     * @api\n     */\n\n\n    Stroke.prototype.getWidth = function getWidth() {\n      return this.width_;\n    };\n    /**\n     * Set the color.\n     *\n     * @param {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} color Color.\n     * @api\n     */\n\n\n    Stroke.prototype.setColor = function setColor(color) {\n      this.color_ = color;\n      this.checksum_ = undefined;\n    };\n    /**\n     * Set the line cap.\n     *\n     * @param {string|undefined} lineCap Line cap.\n     * @api\n     */\n\n\n    Stroke.prototype.setLineCap = function setLineCap(lineCap) {\n      this.lineCap_ = lineCap;\n      this.checksum_ = undefined;\n    };\n    /**\n     * Set the line dash.\n     *\n     * Please note that Internet Explorer 10 and lower [do not support][mdn] the\n     * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this\n     * property will have no visual effect in these browsers.\n     *\n     * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility\n     *\n     * @param {Array<number>} lineDash Line dash.\n     * @api\n     */\n\n\n    Stroke.prototype.setLineDash = function setLineDash(lineDash) {\n      this.lineDash_ = lineDash;\n      this.checksum_ = undefined;\n    };\n    /**\n     * Set the line dash offset.\n     *\n     * @param {number|undefined} lineDashOffset Line dash offset.\n     * @api\n     */\n\n\n    Stroke.prototype.setLineDashOffset = function setLineDashOffset(lineDashOffset) {\n      this.lineDashOffset_ = lineDashOffset;\n      this.checksum_ = undefined;\n    };\n    /**\n     * Set the line join.\n     *\n     * @param {string|undefined} lineJoin Line join.\n     * @api\n     */\n\n\n    Stroke.prototype.setLineJoin = function setLineJoin(lineJoin) {\n      this.lineJoin_ = lineJoin;\n      this.checksum_ = undefined;\n    };\n    /**\n     * Set the miter limit.\n     *\n     * @param {number|undefined} miterLimit Miter limit.\n     * @api\n     */\n\n\n    Stroke.prototype.setMiterLimit = function setMiterLimit(miterLimit) {\n      this.miterLimit_ = miterLimit;\n      this.checksum_ = undefined;\n    };\n    /**\n     * Set the width.\n     *\n     * @param {number|undefined} width Width.\n     * @api\n     */\n\n\n    Stroke.prototype.setWidth = function setWidth(width) {\n      this.width_ = width;\n      this.checksum_ = undefined;\n    };\n    /**\n     * @return {string} The checksum.\n     */\n\n\n    Stroke.prototype.getChecksum = function getChecksum() {\n      if (this.checksum_ === undefined) {\n        this.checksum_ = 's';\n\n        if (this.color_) {\n          if (typeof this.color_ === 'string') {\n            this.checksum_ += this.color_;\n          } else {\n            this.checksum_ += getUid(this.color_);\n          }\n        } else {\n          this.checksum_ += '-';\n        }\n\n        this.checksum_ += ',' + (this.lineCap_ !== undefined ? this.lineCap_.toString() : '-') + ',' + (this.lineDash_ ? this.lineDash_.toString() : '-') + ',' + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : '-') + ',' + (this.lineJoin_ !== undefined ? this.lineJoin_ : '-') + ',' + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : '-') + ',' + (this.width_ !== undefined ? this.width_.toString() : '-');\n      }\n\n      return this.checksum_;\n    };\n    /**\n     * @module ol/style/Style\n     */\n\n    /**\n     * A function that takes an {@link module:ol/Feature} and a `{number}`\n     * representing the view's resolution. The function should return a\n     * {@link module:ol/style/Style} or an array of them. This way e.g. a\n     * vector layer can be styled.\n     *\n     * @typedef {function(import(\"../Feature.js\").FeatureLike, number):(Style|Array<Style>)} StyleFunction\n     */\n\n    /**\n     * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.\n     * @typedef {Style|Array<Style>|StyleFunction} StyleLike\n     */\n\n    /**\n     * A function that takes an {@link module:ol/Feature} as argument and returns an\n     * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.\n     *\n     * @typedef {function(import(\"../Feature.js\").FeatureLike):\n     *     (import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default|undefined)} GeometryFunction\n     */\n\n    /**\n     * Custom renderer function. Takes two arguments:\n     *\n     * 1. The pixel coordinates of the geometry in GeoJSON notation.\n     * 2. The {@link module:ol/render~State} of the layer renderer.\n     *\n     * @typedef {function((import(\"../coordinate.js\").Coordinate|Array<import(\"../coordinate.js\").Coordinate>|Array<Array<import(\"../coordinate.js\").Coordinate>>),import(\"../render.js\").State)}\n     * RenderFunction\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {string|import(\"../geom/Geometry.js\").default|GeometryFunction} [geometry] Feature property or geometry\n     * or function returning a geometry to render for this style.\n     * @property {import(\"./Fill.js\").default} [fill] Fill style.\n     * @property {import(\"./Image.js\").default} [image] Image style.\n     * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be\n     * ignored, and the provided function will be called with each render frame for each geometry.\n     * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n     * @property {import(\"./Text.js\").default} [text] Text style.\n     * @property {number} [zIndex] Z index.\n     */\n\n    /**\n     * @classdesc\n     * Container for vector feature rendering styles. Any changes made to the style\n     * or its children through `set*()` methods will not take effect until the\n     * feature or layer that uses the style is re-rendered.\n     * @api\n     */\n\n\n    var Style = function Style(opt_options) {\n      var options = opt_options || {};\n      /**\n       * @private\n       * @type {string|import(\"../geom/Geometry.js\").default|GeometryFunction}\n       */\n\n      this.geometry_ = null;\n      /**\n       * @private\n       * @type {!GeometryFunction}\n       */\n\n      this.geometryFunction_ = defaultGeometryFunction;\n\n      if (options.geometry !== undefined) {\n        this.setGeometry(options.geometry);\n      }\n      /**\n       * @private\n       * @type {import(\"./Fill.js\").default}\n       */\n\n\n      this.fill_ = options.fill !== undefined ? options.fill : null;\n      /**\n         * @private\n         * @type {import(\"./Image.js\").default}\n         */\n\n      this.image_ = options.image !== undefined ? options.image : null;\n      /**\n       * @private\n       * @type {RenderFunction|null}\n       */\n\n      this.renderer_ = options.renderer !== undefined ? options.renderer : null;\n      /**\n       * @private\n       * @type {import(\"./Stroke.js\").default}\n       */\n\n      this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n      /**\n       * @private\n       * @type {import(\"./Text.js\").default}\n       */\n\n      this.text_ = options.text !== undefined ? options.text : null;\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n\n      this.zIndex_ = options.zIndex;\n    };\n    /**\n     * Clones the style.\n     * @return {Style} The cloned style.\n     * @api\n     */\n\n\n    Style.prototype.clone = function clone() {\n      var geometry = this.getGeometry();\n\n      if (geometry && typeof geometry === 'object') {\n        geometry =\n        /** @type {import(\"../geom/Geometry.js\").default} */\n        geometry.clone();\n      }\n\n      return new Style({\n        geometry: geometry,\n        fill: this.getFill() ? this.getFill().clone() : undefined,\n        image: this.getImage() ? this.getImage().clone() : undefined,\n        stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n        text: this.getText() ? this.getText().clone() : undefined,\n        zIndex: this.getZIndex()\n      });\n    };\n    /**\n     * Get the custom renderer function that was configured with\n     * {@link #setRenderer} or the `renderer` constructor option.\n     * @return {RenderFunction|null} Custom renderer function.\n     * @api\n     */\n\n\n    Style.prototype.getRenderer = function getRenderer() {\n      return this.renderer_;\n    };\n    /**\n     * Sets a custom renderer function for this style. When set, `fill`, `stroke`\n     * and `image` options of the style will be ignored.\n     * @param {RenderFunction|null} renderer Custom renderer function.\n     * @api\n     */\n\n\n    Style.prototype.setRenderer = function setRenderer(renderer) {\n      this.renderer_ = renderer;\n    };\n    /**\n     * Get the geometry to be rendered.\n     * @return {string|import(\"../geom/Geometry.js\").default|GeometryFunction}\n     * Feature property or geometry or function that returns the geometry that will\n     * be rendered with this style.\n     * @api\n     */\n\n\n    Style.prototype.getGeometry = function getGeometry() {\n      return this.geometry_;\n    };\n    /**\n     * Get the function used to generate a geometry for rendering.\n     * @return {!GeometryFunction} Function that is called with a feature\n     * and returns the geometry to render instead of the feature's geometry.\n     * @api\n     */\n\n\n    Style.prototype.getGeometryFunction = function getGeometryFunction() {\n      return this.geometryFunction_;\n    };\n    /**\n     * Get the fill style.\n     * @return {import(\"./Fill.js\").default} Fill style.\n     * @api\n     */\n\n\n    Style.prototype.getFill = function getFill() {\n      return this.fill_;\n    };\n    /**\n     * Set the fill style.\n     * @param {import(\"./Fill.js\").default} fill Fill style.\n     * @api\n     */\n\n\n    Style.prototype.setFill = function setFill(fill) {\n      this.fill_ = fill;\n    };\n    /**\n     * Get the image style.\n     * @return {import(\"./Image.js\").default} Image style.\n     * @api\n     */\n\n\n    Style.prototype.getImage = function getImage() {\n      return this.image_;\n    };\n    /**\n     * Set the image style.\n     * @param {import(\"./Image.js\").default} image Image style.\n     * @api\n     */\n\n\n    Style.prototype.setImage = function setImage(image) {\n      this.image_ = image;\n    };\n    /**\n     * Get the stroke style.\n     * @return {import(\"./Stroke.js\").default} Stroke style.\n     * @api\n     */\n\n\n    Style.prototype.getStroke = function getStroke() {\n      return this.stroke_;\n    };\n    /**\n     * Set the stroke style.\n     * @param {import(\"./Stroke.js\").default} stroke Stroke style.\n     * @api\n     */\n\n\n    Style.prototype.setStroke = function setStroke(stroke) {\n      this.stroke_ = stroke;\n    };\n    /**\n     * Get the text style.\n     * @return {import(\"./Text.js\").default} Text style.\n     * @api\n     */\n\n\n    Style.prototype.getText = function getText() {\n      return this.text_;\n    };\n    /**\n     * Set the text style.\n     * @param {import(\"./Text.js\").default} text Text style.\n     * @api\n     */\n\n\n    Style.prototype.setText = function setText(text) {\n      this.text_ = text;\n    };\n    /**\n     * Get the z-index for the style.\n     * @return {number|undefined} ZIndex.\n     * @api\n     */\n\n\n    Style.prototype.getZIndex = function getZIndex() {\n      return this.zIndex_;\n    };\n    /**\n     * Set a geometry that is rendered instead of the feature's geometry.\n     *\n     * @param {string|import(\"../geom/Geometry.js\").default|GeometryFunction} geometry\n     *   Feature property or geometry or function returning a geometry to render\n     *   for this style.\n     * @api\n     */\n\n\n    Style.prototype.setGeometry = function setGeometry(geometry) {\n      if (typeof geometry === 'function') {\n        this.geometryFunction_ = geometry;\n      } else if (typeof geometry === 'string') {\n        this.geometryFunction_ = function (feature) {\n          return (\n            /** @type {import(\"../geom/Geometry.js\").default} */\n            feature.get(geometry)\n          );\n        };\n      } else if (!geometry) {\n        this.geometryFunction_ = defaultGeometryFunction;\n      } else if (geometry !== undefined) {\n        this.geometryFunction_ = function () {\n          return (\n            /** @type {import(\"../geom/Geometry.js\").default} */\n            geometry\n          );\n        };\n      }\n\n      this.geometry_ = geometry;\n    };\n    /**\n     * Set the z-index.\n     *\n     * @param {number|undefined} zIndex ZIndex.\n     * @api\n     */\n\n\n    Style.prototype.setZIndex = function setZIndex(zIndex) {\n      this.zIndex_ = zIndex;\n    };\n    /**\n     * Convert the provided object into a style function.  Functions passed through\n     * unchanged.  Arrays of Style or single style objects wrapped in a\n     * new style function.\n     * @param {StyleFunction|Array<Style>|Style} obj\n     *     A style function, a single style, or an array of styles.\n     * @return {StyleFunction} A style function.\n     */\n\n\n    function toFunction(obj) {\n      var styleFunction;\n\n      if (typeof obj === 'function') {\n        styleFunction = obj;\n      } else {\n        /**\n         * @type {Array<Style>}\n         */\n        var styles;\n\n        if (Array.isArray(obj)) {\n          styles = obj;\n        } else {\n          assert(typeof\n          /** @type {?} */\n          obj.getZIndex === 'function', 41); // Expected an `Style` or an array of `Style`\n\n          var style =\n          /** @type {Style} */\n          obj;\n          styles = [style];\n        }\n\n        styleFunction = function styleFunction() {\n          return styles;\n        };\n      }\n\n      return styleFunction;\n    }\n    /**\n     * @type {Array<Style>}\n     */\n\n\n    var defaultStyles = null;\n    /**\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {number} resolution Resolution.\n     * @return {Array<Style>} Style.\n     */\n\n    function createDefaultStyle(feature, resolution) {\n      // We don't use an immediately-invoked function\n      // and a closure so we don't get an error at script evaluation time in\n      // browsers that do not support Canvas. (import(\"./Circle.js\").CircleStyle does\n      // canvas.getContext('2d') at construction time, which will cause an.error\n      // in such browsers.)\n      if (!defaultStyles) {\n        var fill = new Fill({\n          color: 'rgba(255,255,255,0.4)'\n        });\n        var stroke = new Stroke({\n          color: '#3399CC',\n          width: 1.25\n        });\n        defaultStyles = [new Style({\n          image: new CircleStyle({\n            fill: fill,\n            stroke: stroke,\n            radius: 5\n          }),\n          fill: fill,\n          stroke: stroke\n        })];\n      }\n\n      return defaultStyles;\n    }\n    /**\n     * Default styles for editing features.\n     * @return {Object<import(\"../geom/GeometryType.js\").default, Array<Style>>} Styles\n     */\n\n\n    function createEditingStyle() {\n      /** @type {Object<import(\"../geom/GeometryType.js\").default, Array<Style>>} */\n      var styles = {};\n      var white = [255, 255, 255, 1];\n      var blue = [0, 153, 255, 1];\n      var width = 3;\n      styles[GeometryType.POLYGON] = [new Style({\n        fill: new Fill({\n          color: [255, 255, 255, 0.5]\n        })\n      })];\n      styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];\n      styles[GeometryType.LINE_STRING] = [new Style({\n        stroke: new Stroke({\n          color: white,\n          width: width + 2\n        })\n      }), new Style({\n        stroke: new Stroke({\n          color: blue,\n          width: width\n        })\n      })];\n      styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];\n      styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);\n      styles[GeometryType.POINT] = [new Style({\n        image: new CircleStyle({\n          radius: width * 2,\n          fill: new Fill({\n            color: blue\n          }),\n          stroke: new Stroke({\n            color: white,\n            width: width / 2\n          })\n        }),\n        zIndex: Infinity\n      })];\n      styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];\n      styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);\n      return styles;\n    }\n    /**\n     * Function that is called with a feature and returns its default geometry.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature to get the geometry for.\n     * @return {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default|undefined} Geometry to render.\n     */\n\n\n    function defaultGeometryFunction(feature) {\n      return feature.getGeometry();\n    }\n    /**\n     * @module ol/layer/Vector\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [opacity=1] Opacity (0, 1).\n     * @property {boolean} [visible=true] Visibility.\n     * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n     * rendered outside of this extent.\n     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n     * method was used.\n     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n     * visible.\n     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n     * be visible.\n     * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n     * features before rendering. By default features are drawn in the order that they are created. Use\n     * `null` to avoid the sort, but get an undefined draw order.\n     * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n     * renderer when getting features from the vector source for the rendering or hit-detection.\n     * Recommended value: the size of the largest symbol, line width or label.\n     * @property {import(\"./VectorRenderType.js\").default|string} [renderMode='vector'] Render mode for vector layers:\n     *  * `'image'`: Vector layers are rendered as images. Great performance, but point symbols and\n     *    texts are always rotated with the view and pixels are scaled during zoom animations.\n     *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering even during\n     *    animations, but slower performance.\n     * @property {import(\"../source/Vector.js\").default} [source] Source.\n     * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n     * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n     * use {@link module:ol/Map#addLayer}.\n     * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all\n     * image and text styles, and the priority is defined by the z-index of the style. Lower z-index\n     * means higher priority.\n     * @property {import(\"../style/Style.js\").StyleLike} [style] Layer style. See\n     * {@link module:ol/style} for default style which will be used if this is not defined.\n     * @property {boolean} [updateWhileAnimating=false] When set to `true` and `renderMode`\n     * is `vector`, feature batches will be recreated during animations. This means that no\n     * vectors will be shown clipped, but the setting will have a performance impact for large\n     * amounts of vector data. When set to `false`, batches will be recreated when no animation\n     * is active.\n     * @property {boolean} [updateWhileInteracting=false] When set to `true` and `renderMode`\n     * is `vector`, feature batches will be recreated during interactions. See also\n     * `updateWhileAnimating`.\n     */\n\n    /**\n     * @enum {string}\n     * @private\n     */\n\n\n    var Property$2 = {\n      RENDER_ORDER: 'renderOrder'\n    };\n    /**\n     * @classdesc\n     * Vector data that is rendered client-side.\n     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n     * property on the layer object; for example, setting `title: 'My Title'` in the\n     * options means that `title` is observable, and has get/set accessors.\n     *\n     * @api\n     */\n\n    var VectorLayer =\n    /*@__PURE__*/\n    function (Layer$$1) {\n      function VectorLayer(opt_options) {\n        var options = opt_options ? opt_options :\n        /** @type {Options} */\n        {};\n        var baseOptions = assign({}, options);\n        delete baseOptions.style;\n        delete baseOptions.renderBuffer;\n        delete baseOptions.updateWhileAnimating;\n        delete baseOptions.updateWhileInteracting;\n        Layer$$1.call(this, baseOptions);\n        /**\n        * @private\n        * @type {boolean}\n        */\n\n        this.declutter_ = options.declutter !== undefined ? options.declutter : false;\n        /**\n        * @type {number}\n        * @private\n        */\n\n        this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;\n        /**\n        * User provided style.\n        * @type {import(\"../style/Style.js\").StyleLike}\n        * @private\n        */\n\n        this.style_ = null;\n        /**\n        * Style function for use within the library.\n        * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n        * @private\n        */\n\n        this.styleFunction_ = undefined;\n        this.setStyle(options.style);\n        /**\n        * @type {boolean}\n        * @private\n        */\n\n        this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;\n        /**\n        * @type {boolean}\n        * @private\n        */\n\n        this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;\n        /**\n        * @private\n        * @type {import(\"./VectorTileRenderType.js\").default|string}\n        */\n\n        this.renderMode_ = options.renderMode || VectorRenderType.VECTOR;\n        /**\n        * The layer type.\n        * @protected\n        * @type {import(\"../LayerType.js\").default}\n        */\n\n        this.type = LayerType.VECTOR;\n      }\n\n      if (Layer$$1) VectorLayer.__proto__ = Layer$$1;\n      VectorLayer.prototype = Object.create(Layer$$1 && Layer$$1.prototype);\n      VectorLayer.prototype.constructor = VectorLayer;\n      /**\n      * @return {boolean} Declutter.\n      */\n\n      VectorLayer.prototype.getDeclutter = function getDeclutter() {\n        return this.declutter_;\n      };\n      /**\n      * @param {boolean} declutter Declutter.\n      */\n\n\n      VectorLayer.prototype.setDeclutter = function setDeclutter(declutter) {\n        this.declutter_ = declutter;\n      };\n      /**\n      * @return {number|undefined} Render buffer.\n      */\n\n\n      VectorLayer.prototype.getRenderBuffer = function getRenderBuffer() {\n        return this.renderBuffer_;\n      };\n      /**\n      * @return {function(import(\"../Feature.js\").default, import(\"../Feature.js\").default): number|null|undefined} Render\n      *     order.\n      */\n\n\n      VectorLayer.prototype.getRenderOrder = function getRenderOrder() {\n        return (\n          /** @type {import(\"../render.js\").OrderFunction|null|undefined} */\n          this.get(Property$2.RENDER_ORDER)\n        );\n      };\n      /**\n      * Get the style for features.  This returns whatever was passed to the `style`\n      * option at construction or to the `setStyle` method.\n      * @return {import(\"../style/Style.js\").StyleLike}\n      *     Layer style.\n      * @api\n      */\n\n\n      VectorLayer.prototype.getStyle = function getStyle() {\n        return this.style_;\n      };\n      /**\n      * Get the style function.\n      * @return {import(\"../style/Style.js\").StyleFunction|undefined} Layer style function.\n      * @api\n      */\n\n\n      VectorLayer.prototype.getStyleFunction = function getStyleFunction() {\n        return this.styleFunction_;\n      };\n      /**\n      * @return {boolean} Whether the rendered layer should be updated while\n      *     animating.\n      */\n\n\n      VectorLayer.prototype.getUpdateWhileAnimating = function getUpdateWhileAnimating() {\n        return this.updateWhileAnimating_;\n      };\n      /**\n      * @return {boolean} Whether the rendered layer should be updated while\n      *     interacting.\n      */\n\n\n      VectorLayer.prototype.getUpdateWhileInteracting = function getUpdateWhileInteracting() {\n        return this.updateWhileInteracting_;\n      };\n      /**\n      * @param {import(\"../render.js\").OrderFunction|null|undefined} renderOrder\n      *     Render order.\n      */\n\n\n      VectorLayer.prototype.setRenderOrder = function setRenderOrder(renderOrder) {\n        this.set(Property$2.RENDER_ORDER, renderOrder);\n      };\n      /**\n      * Set the style for features.  This can be a single style object, an array\n      * of styles, or a function that takes a feature and resolution and returns\n      * an array of styles. If it is `undefined` the default style is used. If\n      * it is `null` the layer has no style (a `null` style), so only features\n      * that have their own styles will be rendered in the layer. See\n      * {@link module:ol/style} for information on the default style.\n      * @param {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null|undefined} style Layer style.\n      * @api\n      */\n\n\n      VectorLayer.prototype.setStyle = function setStyle(style) {\n        this.style_ = style !== undefined ? style : createDefaultStyle;\n        this.styleFunction_ = style === null ? undefined : toFunction(this.style_);\n        this.changed();\n      };\n      /**\n      * @return {import(\"./VectorRenderType.js\").default|string} The render mode.\n      */\n\n\n      VectorLayer.prototype.getRenderMode = function getRenderMode() {\n        return this.renderMode_;\n      };\n\n      return VectorLayer;\n    }(Layer);\n    /**\n     * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.\n     * @function\n     * @return {import(\"../source/Vector.js\").default} Source.\n     * @api\n     */\n\n\n    VectorLayer.prototype.getSource;\n    /**\n     * @module ol/format/FormatType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n    var FormatType = {\n      ARRAY_BUFFER: 'arraybuffer',\n      JSON: 'json',\n      TEXT: 'text',\n      XML: 'xml'\n    };\n    /**\n     * @module ol/featureloader\n     */\n\n    /**\n     * {@link module:ol/source/Vector} sources use a function of this type to\n     * load features.\n     *\n     * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,\n     * a `{number}` representing the resolution (map units per pixel) and an\n     * {@link module:ol/proj/Projection} for the projection  as\n     * arguments. `this` within the function is bound to the\n     * {@link module:ol/source/Vector} it's called from.\n     *\n     * The function is responsible for loading the features and adding them to the\n     * source.\n     * @typedef {function(this:(import(\"./source/Vector\").default|import(\"./VectorTile.js\").default), import(\"./extent.js\").Extent, number,\n     *                    import(\"./proj/Projection.js\").default)} FeatureLoader\n     * @api\n     */\n\n    /**\n     * {@link module:ol/source/Vector} sources use a function of this type to\n     * get the url to load features from.\n     *\n     * This function takes an {@link module:ol/extent~Extent} representing the area\n     * to be loaded, a `{number}` representing the resolution (map units per pixel)\n     * and an {@link module:ol/proj/Projection} for the projection  as\n     * arguments and returns a `{string}` representing the URL.\n     * @typedef {function(import(\"./extent.js\").Extent, number, import(\"./proj/Projection.js\").default): string} FeatureUrlFunction\n     * @api\n     */\n\n    /**\n     * @param {string|FeatureUrlFunction} url Feature URL service.\n     * @param {import(\"./format/Feature.js\").default} format Feature format.\n     * @param {function(this:import(\"./VectorTile.js\").default, Array<import(\"./Feature.js\").default>, import(\"./proj/Projection.js\").default, import(\"./extent.js\").Extent)|function(this:import(\"./source/Vector\").default, Array<import(\"./Feature.js\").default>)} success\n     *     Function called with the loaded features and optionally with the data\n     *     projection. Called with the vector tile or source as `this`.\n     * @param {function(this:import(\"./VectorTile.js\").default)|function(this:import(\"./source/Vector\").default)} failure\n     *     Function called when loading failed. Called with the vector tile or\n     *     source as `this`.\n     * @return {FeatureLoader} The feature loader.\n     */\n\n    function loadFeaturesXhr(url, format, success, failure) {\n      return (\n        /**\n         * @param {import(\"./extent.js\").Extent} extent Extent.\n         * @param {number} resolution Resolution.\n         * @param {import(\"./proj/Projection.js\").default} projection Projection.\n         * @this {import(\"./source/Vector\").default|import(\"./VectorTile.js\").default}\n         */\n        function (extent, resolution, projection) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);\n\n          if (format.getType() == FormatType.ARRAY_BUFFER) {\n            xhr.responseType = 'arraybuffer';\n          }\n          /**\n           * @param {Event} event Event.\n           * @private\n           */\n\n\n          xhr.onload = function (event) {\n            // status will be 0 for file:// urls\n            if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {\n              var type = format.getType();\n              /** @type {Document|Node|Object|string|undefined} */\n\n              var source;\n\n              if (type == FormatType.JSON || type == FormatType.TEXT) {\n                source = xhr.responseText;\n              } else if (type == FormatType.XML) {\n                source = xhr.responseXML;\n\n                if (!source) {\n                  source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');\n                }\n              } else if (type == FormatType.ARRAY_BUFFER) {\n                source =\n                /** @type {ArrayBuffer} */\n                xhr.response;\n              }\n\n              if (source) {\n                success.call(this, format.readFeatures(source, {\n                  featureProjection: projection\n                }), format.readProjection(source), format.getLastExtent());\n              } else {\n                failure.call(this);\n              }\n            } else {\n              failure.call(this);\n            }\n          }.bind(this);\n          /**\n           * @private\n           */\n\n\n          xhr.onerror = function () {\n            failure.call(this);\n          }.bind(this);\n\n          xhr.send();\n        }\n      );\n    }\n    /**\n     * Create an XHR feature loader for a `url` and `format`. The feature loader\n     * loads features (with XHR), parses the features, and adds them to the\n     * vector source.\n     * @param {string|FeatureUrlFunction} url Feature URL service.\n     * @param {import(\"./format/Feature.js\").default} format Feature format.\n     * @return {FeatureLoader} The feature loader.\n     * @api\n     */\n\n\n    function xhr(url, format) {\n      return loadFeaturesXhr(url, format,\n      /**\n       * @param {Array<import(\"./Feature.js\").default>} features The loaded features.\n       * @param {import(\"./proj/Projection.js\").default} dataProjection Data\n       * projection.\n       * @this {import(\"./source/Vector\").default|import(\"./VectorTile.js\").default}\n       */\n      function (features, dataProjection) {\n        var sourceOrTile =\n        /** @type {?} */\n        this;\n\n        if (typeof sourceOrTile.addFeatures === 'function') {\n          /** @type {import(\"./source/Vector\").default} */\n          sourceOrTile.addFeatures(features);\n        }\n      },\n      /* FIXME handle error */\n      VOID);\n    }\n    /**\n     * @module ol/loadingstrategy\n     */\n\n    /**\n     * Strategy function for loading all features with a single request.\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     * @api\n     */\n\n\n    function all(extent, resolution) {\n      return [[-Infinity, -Infinity, Infinity, Infinity]];\n    }\n    /**\n     * @module ol/source/Source\n     */\n\n    /**\n     * A function that returns a string or an array of strings representing source\n     * attributions.\n     *\n     * @typedef {function(import(\"../PluggableMap.js\").FrameState): (string|Array<string>)} Attribution\n     */\n\n    /**\n     * A type that can be used to provide attribution information for data sources.\n     *\n     * It represents either\n     * * a simple string (e.g. `' Acme Inc.'`)\n     * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)\n     * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)\n     *\n     * @typedef {string|Array<string>|Attribution} AttributionLike\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {AttributionLike} [attributions]\n     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n     * @property {import(\"../proj.js\").ProjectionLike} projection\n     * @property {SourceState} [state='ready']\n     * @property {boolean} [wrapX=false]\n     */\n\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * Base class for {@link module:ol/layer/Layer~Layer} sources.\n     *\n     * A generic `change` event is triggered when the state of the source changes.\n     * @abstract\n     * @api\n     */\n\n\n    var Source =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function Source(options) {\n        BaseObject$$1.call(this);\n        /**\n         * @private\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n\n        this.projection_ = get$2(options.projection);\n        /**\n         * @private\n         * @type {?Attribution}\n         */\n\n        this.attributions_ = adaptAttributions(options.attributions);\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;\n        /**\n         * This source is currently loading data. Sources that defer loading to the\n         * map's tile queue never set this to `true`.\n         * @type {boolean}\n         */\n\n        this.loading = false;\n        /**\n         * @private\n         * @type {SourceState}\n         */\n\n        this.state_ = options.state !== undefined ? options.state : SourceState.READY;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n      }\n\n      if (BaseObject$$1) Source.__proto__ = BaseObject$$1;\n      Source.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      Source.prototype.constructor = Source;\n      /**\n       * Get the attribution function for the source.\n       * @return {?Attribution} Attribution function.\n       */\n\n      Source.prototype.getAttributions = function getAttributions() {\n        return this.attributions_;\n      };\n      /**\n       * @return {boolean} Aattributions are collapsible.\n       */\n\n\n      Source.prototype.getAttributionsCollapsible = function getAttributionsCollapsible() {\n        return this.attributionsCollapsible_;\n      };\n      /**\n       * Get the projection of the source.\n       * @return {import(\"../proj/Projection.js\").default} Projection.\n       * @api\n       */\n\n\n      Source.prototype.getProjection = function getProjection() {\n        return this.projection_;\n      };\n      /**\n       * @abstract\n       * @return {Array<number>|undefined} Resolutions.\n       */\n\n\n      Source.prototype.getResolutions = function getResolutions() {\n        return _abstract();\n      };\n      /**\n       * Get the state of the source, see {@link module:ol/source/State~State} for possible states.\n       * @return {SourceState} State.\n       * @api\n       */\n\n\n      Source.prototype.getState = function getState() {\n        return this.state_;\n      };\n      /**\n       * @return {boolean|undefined} Wrap X.\n       */\n\n\n      Source.prototype.getWrapX = function getWrapX() {\n        return this.wrapX_;\n      };\n      /**\n       * Refreshes the source and finally dispatches a 'change' event.\n       * @api\n       */\n\n\n      Source.prototype.refresh = function refresh() {\n        this.changed();\n      };\n      /**\n       * Set the attributions of the source.\n       * @param {AttributionLike|undefined} attributions Attributions.\n       *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,\n       *     or `undefined`.\n       * @api\n       */\n\n\n      Source.prototype.setAttributions = function setAttributions(attributions) {\n        this.attributions_ = adaptAttributions(attributions);\n        this.changed();\n      };\n      /**\n       * Set the state of the source.\n       * @param {SourceState} state State.\n       * @protected\n       */\n\n\n      Source.prototype.setState = function setState(state) {\n        this.state_ = state;\n        this.changed();\n      };\n\n      return Source;\n    }(BaseObject);\n    /**\n     * Turns the attributions option into an attributions function.\n     * @param {AttributionLike|undefined} attributionLike The attribution option.\n     * @return {?Attribution} An attribution function (or null).\n     */\n\n\n    function adaptAttributions(attributionLike) {\n      if (!attributionLike) {\n        return null;\n      }\n\n      if (Array.isArray(attributionLike)) {\n        return function (frameState) {\n          return attributionLike;\n        };\n      }\n\n      if (typeof attributionLike === 'function') {\n        return attributionLike;\n      }\n\n      return function (frameState) {\n        return [attributionLike];\n      };\n    }\n    /**\n     * @module ol/source/VectorEventType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var VectorEventType = {\n      /**\n       * Triggered when a feature is added to the source.\n       * @event ol/source/Vector.VectorSourceEvent#addfeature\n       * @api\n       */\n      ADDFEATURE: 'addfeature',\n\n      /**\n       * Triggered when a feature is updated.\n       * @event ol/source/Vector.VectorSourceEvent#changefeature\n       * @api\n       */\n      CHANGEFEATURE: 'changefeature',\n\n      /**\n       * Triggered when the clear method is called on the source.\n       * @event ol/source/Vector.VectorSourceEvent#clear\n       * @api\n       */\n      CLEAR: 'clear',\n\n      /**\n       * Triggered when a feature is removed from the source.\n       * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.\n       * @event ol/source/Vector.VectorSourceEvent#removefeature\n       * @api\n       */\n      REMOVEFEATURE: 'removefeature'\n    };\n    var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};\n\n    function unwrapExports$$1(x) {\n      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n    }\n\n    function createCommonjsModule$$1(fn, module) {\n      return module = {\n        exports: {}\n      }, fn(module, module.exports), module.exports;\n    }\n\n    var quickselect = createCommonjsModule$$1(function (module, exports) {\n      (function (global, factory) {\n        module.exports = factory();\n      })(commonjsGlobal$$1, function () {\n        function quickselect(arr, k, left, right, compare) {\n          quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);\n        }\n\n        function quickselectStep(arr, k, left, right, compare) {\n          while (right > left) {\n            if (right - left > 600) {\n              var n = right - left + 1;\n              var m = k - left + 1;\n              var z = Math.log(n);\n              var s = 0.5 * Math.exp(2 * z / 3);\n              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n              quickselectStep(arr, k, newLeft, newRight, compare);\n            }\n\n            var t = arr[k];\n            var i = left;\n            var j = right;\n            swap(arr, left, k);\n            if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n            while (i < j) {\n              swap(arr, i, j);\n              i++;\n              j--;\n\n              while (compare(arr[i], t) < 0) {\n                i++;\n              }\n\n              while (compare(arr[j], t) > 0) {\n                j--;\n              }\n            }\n\n            if (compare(arr[left], t) === 0) swap(arr, left, j);else {\n              j++;\n              swap(arr, j, right);\n            }\n            if (j <= k) left = j + 1;\n            if (k <= j) right = j - 1;\n          }\n        }\n\n        function swap(arr, i, j) {\n          var tmp = arr[i];\n          arr[i] = arr[j];\n          arr[j] = tmp;\n        }\n\n        function defaultCompare(a, b) {\n          return a < b ? -1 : a > b ? 1 : 0;\n        }\n\n        return quickselect;\n      });\n    });\n    var quickselect$1 =\n    /*#__PURE__*/\n    Object.freeze({\n      default: quickselect,\n      __moduleExports: quickselect\n    });\n    var quickselect$2 = quickselect$1 && quickselect || quickselect$1;\n    var rbush_1 = rbush;\n    var default_1 = rbush;\n\n    function rbush(maxEntries, format) {\n      if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n      this._maxEntries = Math.max(4, maxEntries || 9);\n      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n      if (format) {\n        this._initFormat(format);\n      }\n\n      this.clear();\n    }\n\n    rbush.prototype = {\n      all: function all() {\n        return this._all(this.data, []);\n      },\n      search: function search(bbox) {\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n        if (!intersects$1(bbox, node)) return result;\n        var nodesToSearch = [],\n            i,\n            len,\n            child,\n            childBBox;\n\n        while (node) {\n          for (i = 0, len = node.children.length; i < len; i++) {\n            child = node.children[i];\n            childBBox = node.leaf ? toBBox(child) : child;\n\n            if (intersects$1(bbox, childBBox)) {\n              if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n            }\n          }\n\n          node = nodesToSearch.pop();\n        }\n\n        return result;\n      },\n      collides: function collides(bbox) {\n        var node = this.data,\n            toBBox = this.toBBox;\n        if (!intersects$1(bbox, node)) return false;\n        var nodesToSearch = [],\n            i,\n            len,\n            child,\n            childBBox;\n\n        while (node) {\n          for (i = 0, len = node.children.length; i < len; i++) {\n            child = node.children[i];\n            childBBox = node.leaf ? toBBox(child) : child;\n\n            if (intersects$1(bbox, childBBox)) {\n              if (node.leaf || contains(bbox, childBBox)) return true;\n              nodesToSearch.push(child);\n            }\n          }\n\n          node = nodesToSearch.pop();\n        }\n\n        return false;\n      },\n      load: function load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n          for (var i = 0, len = data.length; i < len; i++) {\n            this.insert(data[i]);\n          }\n\n          return this;\n        } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n          // save as is if tree is empty\n          this.data = node;\n        } else if (this.data.height === node.height) {\n          // split root if trees have the same height\n          this._splitRoot(this.data, node);\n        } else {\n          if (this.data.height < node.height) {\n            // swap trees if inserted one is bigger\n            var tmpNode = this.data;\n            this.data = node;\n            node = tmpNode;\n          } // insert the small tree into the large tree at appropriate level\n\n\n          this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n      },\n      insert: function insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n      },\n      clear: function clear() {\n        this.data = createNode([]);\n        return this;\n      },\n      remove: function remove(item, equalsFn) {\n        if (!item) return this;\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i,\n            parent,\n            index,\n            goingUp; // depth-first iterative tree traversal\n\n        while (node || path.length) {\n          if (!node) {\n            // go up\n            node = path.pop();\n            parent = path[path.length - 1];\n            i = indexes.pop();\n            goingUp = true;\n          }\n\n          if (node.leaf) {\n            // check current node\n            index = findItem(item, node.children, equalsFn);\n\n            if (index !== -1) {\n              // item found, remove the item and condense tree upwards\n              node.children.splice(index, 1);\n              path.push(node);\n\n              this._condense(path);\n\n              return this;\n            }\n          }\n\n          if (!goingUp && !node.leaf && contains(node, bbox)) {\n            // go down\n            path.push(node);\n            indexes.push(i);\n            i = 0;\n            parent = node;\n            node = node.children[0];\n          } else if (parent) {\n            // go right\n            i++;\n            node = parent.children[i];\n            goingUp = false;\n          } else node = null; // nothing found\n\n        }\n\n        return this;\n      },\n      toBBox: function toBBox(item) {\n        return item;\n      },\n      compareMinX: compareNodeMinX,\n      compareMinY: compareNodeMinY,\n      toJSON: function toJSON() {\n        return this.data;\n      },\n      fromJSON: function fromJSON(data) {\n        this.data = data;\n        return this;\n      },\n      _all: function _all(node, result) {\n        var nodesToSearch = [];\n\n        while (node) {\n          if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n          node = nodesToSearch.pop();\n        }\n\n        return result;\n      },\n      _build: function _build(items, left, right, height) {\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n          // reached leaf level; return leaf\n          node = createNode(items.slice(left, right + 1));\n          calcBBox(node, this.toBBox);\n          return node;\n        }\n\n        if (!height) {\n          // target height of the bulk-loaded tree\n          height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n          M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height; // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i,\n            j,\n            right2,\n            right3;\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n          right2 = Math.min(i + N1 - 1, right);\n          multiSelect(items, i, right2, N2, this.compareMinY);\n\n          for (j = i; j <= right2; j += N2) {\n            right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n            node.children.push(this._build(items, j, right3, height - 1));\n          }\n        }\n\n        calcBBox(node, this.toBBox);\n        return node;\n      },\n      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n          path.push(node);\n          if (node.leaf || path.length - 1 === level) break;\n          minArea = minEnlargement = Infinity;\n\n          for (i = 0, len = node.children.length; i < len; i++) {\n            child = node.children[i];\n            area = bboxArea(child);\n            enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n            if (enlargement < minEnlargement) {\n              minEnlargement = enlargement;\n              minArea = area < minArea ? area : minArea;\n              targetNode = child;\n            } else if (enlargement === minEnlargement) {\n              // otherwise choose one with the smallest area\n              if (area < minArea) {\n                minArea = area;\n                targetNode = child;\n              }\n            }\n          }\n\n          node = targetNode || node.children[0];\n        }\n\n        return node;\n      },\n      _insert: function _insert(item, level, isNode) {\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n        node.children.push(item);\n        extend$2(node, bbox); // split on node overflow; propagate upwards if necessary\n\n        while (level >= 0) {\n          if (insertPath[level].children.length > this._maxEntries) {\n            this._split(insertPath, level);\n\n            level--;\n          } else break;\n        } // adjust bboxes along the insertion path\n\n\n        this._adjustParentBBoxes(bbox, insertPath, level);\n      },\n      // split overflowed node into two\n      _split: function _split(insertPath, level) {\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n      },\n      _splitRoot: function _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n      },\n      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n          bbox1 = distBBox(node, 0, i, this.toBBox);\n          bbox2 = distBBox(node, i, M, this.toBBox);\n          overlap = intersectionArea(bbox1, bbox2);\n          area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n          if (overlap < minOverlap) {\n            minOverlap = overlap;\n            index = i;\n            minArea = area < minArea ? area : minArea;\n          } else if (overlap === minOverlap) {\n            // otherwise choose distribution with minimum area\n            if (area < minArea) {\n              minArea = area;\n              index = i;\n            }\n          }\n        }\n\n        return index;\n      },\n      // sorts node children by the best axis for split\n      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n\n\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n      },\n      // total margin of all possible split distributions where each node is at least m full\n      _allDistMargin: function _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i,\n            child;\n\n        for (i = m; i < M - m; i++) {\n          child = node.children[i];\n          extend$2(leftBBox, node.leaf ? toBBox(child) : child);\n          margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n          child = node.children[i];\n          extend$2(rightBBox, node.leaf ? toBBox(child) : child);\n          margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n      },\n      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n          extend$2(path[i], bbox);\n        }\n      },\n      _condense: function _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n          if (path[i].children.length === 0) {\n            if (i > 0) {\n              siblings = path[i - 1].children;\n              siblings.splice(siblings.indexOf(path[i]), 1);\n            } else this.clear();\n          } else calcBBox(path[i], this.toBBox);\n        }\n      },\n      _initFormat: function _initFormat(format) {\n        // data format (minX, minY, maxX, maxY accessors)\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n        var compareArr = ['return a', ' - b', ';'];\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n      }\n    };\n\n    function findItem(item, items, equalsFn) {\n      if (!equalsFn) return items.indexOf(item);\n\n      for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n      }\n\n      return -1;\n    } // calculate node's bbox from bboxes of its children\n\n\n    function calcBBox(node, toBBox) {\n      distBBox(node, 0, node.children.length, toBBox, node);\n    } // min bounding rectangle of node children from k to p-1\n\n\n    function distBBox(node, k, p, toBBox, destNode) {\n      if (!destNode) destNode = createNode(null);\n      destNode.minX = Infinity;\n      destNode.minY = Infinity;\n      destNode.maxX = -Infinity;\n      destNode.maxY = -Infinity;\n\n      for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend$2(destNode, node.leaf ? toBBox(child) : child);\n      }\n\n      return destNode;\n    }\n\n    function extend$2(a, b) {\n      a.minX = Math.min(a.minX, b.minX);\n      a.minY = Math.min(a.minY, b.minY);\n      a.maxX = Math.max(a.maxX, b.maxX);\n      a.maxY = Math.max(a.maxY, b.maxY);\n      return a;\n    }\n\n    function compareNodeMinX(a, b) {\n      return a.minX - b.minX;\n    }\n\n    function compareNodeMinY(a, b) {\n      return a.minY - b.minY;\n    }\n\n    function bboxArea(a) {\n      return (a.maxX - a.minX) * (a.maxY - a.minY);\n    }\n\n    function bboxMargin(a) {\n      return a.maxX - a.minX + (a.maxY - a.minY);\n    }\n\n    function enlargedArea(a, b) {\n      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n    }\n\n    function intersectionArea(a, b) {\n      var minX = Math.max(a.minX, b.minX),\n          minY = Math.max(a.minY, b.minY),\n          maxX = Math.min(a.maxX, b.maxX),\n          maxY = Math.min(a.maxY, b.maxY);\n      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n    }\n\n    function contains(a, b) {\n      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n    }\n\n    function intersects$1(a, b) {\n      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n    }\n\n    function createNode(children) {\n      return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n      };\n    } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n    // combines selection algorithm with binary divide & conquer approach\n\n\n    function multiSelect(arr, left, right, n, compare) {\n      var stack = [left, right],\n          mid;\n\n      while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n        if (right - left <= n) continue;\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect$2(arr, mid, left, right, compare);\n        stack.push(left, mid, mid, right);\n      }\n    }\n\n    rbush_1.default = default_1;\n    /**\n     * @module ol/structs/RBush\n     */\n\n    /**\n     * @typedef {Object} Entry\n     * @property {number} minX\n     * @property {number} minY\n     * @property {number} maxX\n     * @property {number} maxY\n     * @property {Object} [value]\n     */\n\n    /**\n     * @classdesc\n     * Wrapper around the RBush by Vladimir Agafonkin.\n     * See https://github.com/mourner/rbush.\n     *\n     * @template T\n     */\n\n    var RBush = function RBush(opt_maxEntries) {\n      /**\n       * @private\n       */\n      this.rbush_ = rbush_1(opt_maxEntries, undefined);\n      /**\n       * A mapping between the objects added to this rbush wrapper\n       * and the objects that are actually added to the internal rbush.\n       * @private\n       * @type {Object<string, Entry>}\n       */\n\n      this.items_ = {};\n    };\n    /**\n     * Insert a value into the RBush.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {T} value Value.\n     */\n\n\n    RBush.prototype.insert = function insert(extent, value) {\n      /** @type {Entry} */\n      var item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value\n      };\n      this.rbush_.insert(item);\n      this.items_[getUid(value)] = item;\n    };\n    /**\n     * Bulk-insert values into the RBush.\n     * @param {Array<import(\"../extent.js\").Extent>} extents Extents.\n     * @param {Array<T>} values Values.\n     */\n\n\n    RBush.prototype.load = function load(extents, values) {\n      var items = new Array(values.length);\n\n      for (var i = 0, l = values.length; i < l; i++) {\n        var extent = extents[i];\n        var value = values[i];\n        /** @type {Entry} */\n\n        var item = {\n          minX: extent[0],\n          minY: extent[1],\n          maxX: extent[2],\n          maxY: extent[3],\n          value: value\n        };\n        items[i] = item;\n        this.items_[getUid(value)] = item;\n      }\n\n      this.rbush_.load(items);\n    };\n    /**\n     * Remove a value from the RBush.\n     * @param {T} value Value.\n     * @return {boolean} Removed.\n     */\n\n\n    RBush.prototype.remove = function remove(value) {\n      var uid = getUid(value); // get the object in which the value was wrapped when adding to the\n      // internal rbush. then use that object to do the removal.\n\n      var item = this.items_[uid];\n      delete this.items_[uid];\n      return this.rbush_.remove(item) !== null;\n    };\n    /**\n     * Update the extent of a value in the RBush.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {T} value Value.\n     */\n\n\n    RBush.prototype.update = function update(extent, value) {\n      var item = this.items_[getUid(value)];\n      var bbox = [item.minX, item.minY, item.maxX, item.maxY];\n\n      if (!equals$2(bbox, extent)) {\n        this.remove(value);\n        this.insert(extent, value);\n      }\n    };\n    /**\n     * Return all values in the RBush.\n     * @return {Array<T>} All.\n     */\n\n\n    RBush.prototype.getAll = function getAll() {\n      var items = this.rbush_.all();\n      return items.map(function (item) {\n        return item.value;\n      });\n    };\n    /**\n     * Return all values in the given extent.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {Array<T>} All in extent.\n     */\n\n\n    RBush.prototype.getInExtent = function getInExtent(extent) {\n      /** @type {Entry} */\n      var bbox = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3]\n      };\n      var items = this.rbush_.search(bbox);\n      return items.map(function (item) {\n        return item.value;\n      });\n    };\n    /**\n     * Calls a callback function with each value in the tree.\n     * If the callback returns a truthy value, this value is returned without\n     * checking the rest of the tree.\n     * @param {function(this: S, T): *} callback Callback.\n     * @param {S=} opt_this The object to use as `this` in `callback`.\n     * @return {*} Callback return value.\n     * @template S\n     */\n\n\n    RBush.prototype.forEach = function forEach(callback, opt_this) {\n      return this.forEach_(this.getAll(), callback, opt_this);\n    };\n    /**\n     * Calls a callback function with each value in the provided extent.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {function(this: S, T): *} callback Callback.\n     * @param {S=} opt_this The object to use as `this` in `callback`.\n     * @return {*} Callback return value.\n     * @template S\n     */\n\n\n    RBush.prototype.forEachInExtent = function forEachInExtent(extent, callback, opt_this) {\n      return this.forEach_(this.getInExtent(extent), callback, opt_this);\n    };\n    /**\n     * @param {Array<T>} values Values.\n     * @param {function(this: S, T): *} callback Callback.\n     * @param {S=} opt_this The object to use as `this` in `callback`.\n     * @private\n     * @return {*} Callback return value.\n     * @template S\n     */\n\n\n    RBush.prototype.forEach_ = function forEach_(values, callback, opt_this) {\n      var result;\n\n      for (var i = 0, l = values.length; i < l; i++) {\n        result = callback.call(opt_this, values[i]);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return result;\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n\n\n    RBush.prototype.isEmpty = function isEmpty$1$$1() {\n      return isEmpty(this.items_);\n    };\n    /**\n     * Remove all values from the RBush.\n     */\n\n\n    RBush.prototype.clear = function clear$$1() {\n      this.rbush_.clear();\n      this.items_ = {};\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent=} opt_extent Extent.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n\n\n    RBush.prototype.getExtent = function getExtent(opt_extent) {\n      var data = this.rbush_.toJSON();\n      return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);\n    };\n    /**\n     * @param {RBush} rbush R-Tree.\n     */\n\n\n    RBush.prototype.concat = function concat(rbush) {\n      this.rbush_.load(rbush.rbush_.all());\n\n      for (var i in rbush.items_) {\n        this.items_[i] = rbush.items_[i];\n      }\n    };\n    /**\n     * @module ol/source/Vector\n     */\n\n    /**\n     * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\n     * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\n     * is one of the standard {@link module:ol/loadingstrategy} strategies.\n     *\n     * @typedef {function(import(\"../extent.js\").Extent, number): Array<import(\"../extent.js\").Extent>} LoadingStrategy\n     * @api\n     */\n\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/source/Vector} instances are instances of this\n     * type.\n     */\n\n\n    var VectorSourceEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function VectorSourceEvent(type, opt_feature) {\n        Event$$1.call(this, type);\n        /**\n         * The feature being added or removed.\n         * @type {import(\"../Feature.js\").default|undefined}\n         * @api\n         */\n\n        this.feature = opt_feature;\n      }\n\n      if (Event$$1) VectorSourceEvent.__proto__ = Event$$1;\n      VectorSourceEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      VectorSourceEvent.prototype.constructor = VectorSourceEvent;\n      return VectorSourceEvent;\n    }(Event);\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n     * @property {Array<import(\"../Feature.js\").default>|Collection<import(\"../Feature.js\").default>} [features]\n     * Features. If provided as {@link module:ol/Collection}, the features in the source\n     * and the collection will stay in sync.\n     * @property {import(\"../format/Feature.js\").default} [format] The feature format used by the XHR\n     * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\n     * @property {import(\"../featureloader.js\").FeatureLoader} [loader]\n     * The loader function used to load features, from a remote source for example.\n     * If this is not set and `url` is set, the source will create and use an XHR\n     * feature loader.\n     *\n     * Example:\n     *\n     * ```js\n     * import {Vector} from 'ol/source';\n     * import {GeoJSON} from 'ol/format';\n     * import {bbox} from 'ol/loadingstrategy';\n     *\n     * var vectorSource = new Vector({\n     *   format: new GeoJSON(),\n     *   loader: function(extent, resolution, projection) {\n     *      var proj = projection.getCode();\n     *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +\n     *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +\n     *          'outputFormat=application/json&srsname=' + proj + '&' +\n     *          'bbox=' + extent.join(',') + ',' + proj;\n     *      var xhr = new XMLHttpRequest();\n     *      xhr.open('GET', url);\n     *      var onError = function() {\n     *        vectorSource.removeLoadedExtent(extent);\n     *      }\n     *      xhr.onerror = onError;\n     *      xhr.onload = function() {\n     *        if (xhr.status == 200) {\n     *          vectorSource.addFeatures(\n     *              vectorSource.getFormat().readFeatures(xhr.responseText));\n     *        } else {\n     *          onError();\n     *        }\n     *      }\n     *      xhr.send();\n     *    },\n     *    strategy: bbox\n     *  });\n     * ```\n     * @property {boolean} [overlaps=true] This source may have overlapping geometries.\n     * Setting this to `false` (e.g. for sources with polygons that represent administrative\n     * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n     * stroke operations.\n     * @property {LoadingStrategy} [strategy] The loading strategy to use.\n     * By default an {@link module:ol/loadingstrategy~all}\n     * strategy is used, a one-off strategy which loads all features at once.\n     * @property {string|import(\"../featureloader.js\").FeatureUrlFunction} [url]\n     * Setting this option instructs the source to load features using an XHR loader\n     * (see {@link module:ol/featureloader~xhr}). Use a `string` and an\n     * {@link module:ol/loadingstrategy~all} for a one-off download of all features from\n     * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with\n     * other loading strategies.\n     * Requires `format` to be set as well.\n     * When default XHR feature loader is provided, the features will\n     * be transformed from the data projection to the view projection\n     * during parsing. If your remote data source does not advertise its projection\n     * properly, this transformation will be incorrect. For some formats, the\n     * default projection (usually EPSG:4326) can be overridden by setting the\n     * dataProjection constructor option on the format.\n     * Note that if a source contains non-feature data, such as a GeoJSON geometry\n     * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\n     * @property {boolean} [useSpatialIndex=true]\n     * By default, an RTree is used as spatial index. When features are removed and\n     * added frequently, and the total number of features is low, setting this to\n     * `false` may improve performance.\n     *\n     * Note that\n     * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\n     * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\n     * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\n     * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\n     * through all features.\n     *\n     * When set to `false`, the features will be maintained in an\n     * {@link module:ol/Collection}, which can be retrieved through\n     * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\n     * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\n     * -180 and 180 meridians to work properly, this should be set to `false`. The\n     * resulting geometry coordinates will then exceed the world bounds.\n     */\n\n    /**\n     * @classdesc\n     * Provides a source of features for vector layers. Vector features provided\n     * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\n     * vector data that is optimized for rendering.\n     *\n     * @fires ol/source/Vector.VectorSourceEvent\n     * @api\n     */\n\n\n    var VectorSource =\n    /*@__PURE__*/\n    function (Source$$1) {\n      function VectorSource(opt_options) {\n        var options = opt_options || {};\n        Source$$1.call(this, {\n          attributions: options.attributions,\n          projection: undefined,\n          state: SourceState.READY,\n          wrapX: options.wrapX !== undefined ? options.wrapX : true\n        });\n        /**\n         * @private\n         * @type {import(\"../featureloader.js\").FeatureLoader}\n         */\n\n        this.loader_ = VOID;\n        /**\n         * @private\n         * @type {import(\"../format/Feature.js\").default|undefined}\n         */\n\n        this.format_ = options.format;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n        /**\n         * @private\n         * @type {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined}\n         */\n\n        this.url_ = options.url;\n\n        if (options.loader !== undefined) {\n          this.loader_ = options.loader;\n        } else if (this.url_ !== undefined) {\n          assert(this.format_, 7); // `format` must be set when `url` is set\n          // create a XHR feature loader for \"url\" and \"format\"\n\n          this.loader_ = xhr(this.url_,\n          /** @type {import(\"../format/Feature.js\").default} */\n          this.format_);\n        }\n        /**\n         * @private\n         * @type {LoadingStrategy}\n         */\n\n\n        this.strategy_ = options.strategy !== undefined ? options.strategy : all;\n        var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n        /**\n         * @private\n         * @type {RBush<import(\"../Feature.js\").default>}\n         */\n\n        this.featuresRtree_ = useSpatialIndex ? new RBush() : null;\n        /**\n         * @private\n         * @type {RBush<{extent: import(\"../extent.js\").Extent}>}\n         */\n\n        this.loadedExtentsRtree_ = new RBush();\n        /**\n         * @private\n         * @type {!Object<string, import(\"../Feature.js\").default>}\n         */\n\n        this.nullGeometryFeatures_ = {};\n        /**\n         * A lookup of features by id (the return from feature.getId()).\n         * @private\n         * @type {!Object<string, import(\"../Feature.js\").default>}\n         */\n\n        this.idIndex_ = {};\n        /**\n         * A lookup of features without id (keyed by getUid(feature)).\n         * @private\n         * @type {!Object<string, import(\"../Feature.js\").default>}\n         */\n\n        this.undefIdIndex_ = {};\n        /**\n         * @private\n         * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n         */\n\n        this.featureChangeKeys_ = {};\n        /**\n         * @private\n         * @type {Collection<import(\"../Feature.js\").default>}\n         */\n\n        this.featuresCollection_ = null;\n        var collection, features;\n\n        if (Array.isArray(options.features)) {\n          features = options.features;\n        } else if (options.features) {\n          collection = options.features;\n          features = collection.getArray();\n        }\n\n        if (!useSpatialIndex && collection === undefined) {\n          collection = new Collection(features);\n        }\n\n        if (features !== undefined) {\n          this.addFeaturesInternal(features);\n        }\n\n        if (collection !== undefined) {\n          this.bindFeaturesCollection_(collection);\n        }\n      }\n\n      if (Source$$1) VectorSource.__proto__ = Source$$1;\n      VectorSource.prototype = Object.create(Source$$1 && Source$$1.prototype);\n      VectorSource.prototype.constructor = VectorSource;\n      /**\n       * Add a single feature to the source.  If you want to add a batch of features\n       * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\n       * instead. A feature will not be added to the source if feature with\n       * the same id is already there. The reason for this behavior is to avoid\n       * feature duplication when using bbox or tile loading strategies.\n       * @param {import(\"../Feature.js\").default} feature Feature to add.\n       * @api\n       */\n\n      VectorSource.prototype.addFeature = function addFeature(feature) {\n        this.addFeatureInternal(feature);\n        this.changed();\n      };\n      /**\n       * Add a feature without firing a `change` event.\n       * @param {import(\"../Feature.js\").default} feature Feature.\n       * @protected\n       */\n\n\n      VectorSource.prototype.addFeatureInternal = function addFeatureInternal(feature) {\n        var featureKey = getUid(feature);\n\n        if (!this.addToIndex_(featureKey, feature)) {\n          return;\n        }\n\n        this.setupChangeEvents_(featureKey, feature);\n        var geometry = feature.getGeometry();\n\n        if (geometry) {\n          var extent = geometry.getExtent();\n\n          if (this.featuresRtree_) {\n            this.featuresRtree_.insert(extent, feature);\n          }\n        } else {\n          this.nullGeometryFeatures_[featureKey] = feature;\n        }\n\n        this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));\n      };\n      /**\n       * @param {string} featureKey Unique identifier for the feature.\n       * @param {import(\"../Feature.js\").default} feature The feature.\n       * @private\n       */\n\n\n      VectorSource.prototype.setupChangeEvents_ = function setupChangeEvents_(featureKey, feature) {\n        this.featureChangeKeys_[featureKey] = [listen(feature, EventType.CHANGE, this.handleFeatureChange_, this), listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)];\n      };\n      /**\n       * @param {string} featureKey Unique identifier for the feature.\n       * @param {import(\"../Feature.js\").default} feature The feature.\n       * @return {boolean} The feature is \"valid\", in the sense that it is also a\n       *     candidate for insertion into the Rtree.\n       * @private\n       */\n\n\n      VectorSource.prototype.addToIndex_ = function addToIndex_(featureKey, feature) {\n        var valid = true;\n        var id = feature.getId();\n\n        if (id !== undefined) {\n          if (!(id.toString() in this.idIndex_)) {\n            this.idIndex_[id.toString()] = feature;\n          } else {\n            valid = false;\n          }\n        } else {\n          assert(!(featureKey in this.undefIdIndex_), 30); // The passed `feature` was already added to the source\n\n          this.undefIdIndex_[featureKey] = feature;\n        }\n\n        return valid;\n      };\n      /**\n       * Add a batch of features to the source.\n       * @param {Array<import(\"../Feature.js\").default>} features Features to add.\n       * @api\n       */\n\n\n      VectorSource.prototype.addFeatures = function addFeatures(features) {\n        this.addFeaturesInternal(features);\n        this.changed();\n      };\n      /**\n       * Add features without firing a `change` event.\n       * @param {Array<import(\"../Feature.js\").default>} features Features.\n       * @protected\n       */\n\n\n      VectorSource.prototype.addFeaturesInternal = function addFeaturesInternal(features) {\n        var extents = [];\n        var newFeatures = [];\n        var geometryFeatures = [];\n\n        for (var i = 0, length = features.length; i < length; i++) {\n          var feature = features[i];\n          var featureKey = getUid(feature);\n\n          if (this.addToIndex_(featureKey, feature)) {\n            newFeatures.push(feature);\n          }\n        }\n\n        for (var i$1 = 0, length$1 = newFeatures.length; i$1 < length$1; i$1++) {\n          var feature$1 = newFeatures[i$1];\n          var featureKey$1 = getUid(feature$1);\n          this.setupChangeEvents_(featureKey$1, feature$1);\n          var geometry = feature$1.getGeometry();\n\n          if (geometry) {\n            var extent = geometry.getExtent();\n            extents.push(extent);\n            geometryFeatures.push(feature$1);\n          } else {\n            this.nullGeometryFeatures_[featureKey$1] = feature$1;\n          }\n        }\n\n        if (this.featuresRtree_) {\n          this.featuresRtree_.load(extents, geometryFeatures);\n        }\n\n        for (var i$2 = 0, length$2 = newFeatures.length; i$2 < length$2; i$2++) {\n          this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i$2]));\n        }\n      };\n      /**\n       * @param {!Collection<import(\"../Feature.js\").default>} collection Collection.\n       * @private\n       */\n\n\n      VectorSource.prototype.bindFeaturesCollection_ = function bindFeaturesCollection_(collection) {\n        var modifyingCollection = false;\n        listen(this, VectorEventType.ADDFEATURE,\n        /**\n         * @param {VectorSourceEvent} evt The vector source event\n         */\n        function (evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            collection.push(evt.feature);\n            modifyingCollection = false;\n          }\n        });\n        listen(this, VectorEventType.REMOVEFEATURE,\n        /**\n         * @param {VectorSourceEvent} evt The vector source event\n         */\n        function (evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            collection.remove(evt.feature);\n            modifyingCollection = false;\n          }\n        });\n        listen(collection, CollectionEventType.ADD,\n        /**\n         * @param {import(\"../Collection.js\").CollectionEvent} evt The collection event\n         */\n        function (evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            this.addFeature(\n            /** @type {import(\"../Feature.js\").default} */\n            evt.element);\n            modifyingCollection = false;\n          }\n        }, this);\n        listen(collection, CollectionEventType.REMOVE,\n        /**\n         * @param {import(\"../Collection.js\").CollectionEvent} evt The collection event\n         */\n        function (evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            this.removeFeature(\n            /** @type {import(\"../Feature.js\").default} */\n            evt.element);\n            modifyingCollection = false;\n          }\n        }, this);\n        this.featuresCollection_ = collection;\n      };\n      /**\n       * Remove all features from the source.\n       * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n       * @api\n       */\n\n\n      VectorSource.prototype.clear = function clear$$1(opt_fast) {\n        if (opt_fast) {\n          for (var featureId in this.featureChangeKeys_) {\n            var keys = this.featureChangeKeys_[featureId];\n            keys.forEach(unlistenByKey);\n          }\n\n          if (!this.featuresCollection_) {\n            this.featureChangeKeys_ = {};\n            this.idIndex_ = {};\n            this.undefIdIndex_ = {};\n          }\n        } else {\n          if (this.featuresRtree_) {\n            this.featuresRtree_.forEach(this.removeFeatureInternal, this);\n\n            for (var id in this.nullGeometryFeatures_) {\n              this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n            }\n          }\n        }\n\n        if (this.featuresCollection_) {\n          this.featuresCollection_.clear();\n        }\n\n        if (this.featuresRtree_) {\n          this.featuresRtree_.clear();\n        }\n\n        this.loadedExtentsRtree_.clear();\n        this.nullGeometryFeatures_ = {};\n        var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n        this.dispatchEvent(clearEvent);\n        this.changed();\n      };\n      /**\n       * Iterate through all features on the source, calling the provided callback\n       * with each one.  If the callback returns any \"truthy\" value, iteration will\n       * stop and the function will return the same value.\n       * Note: this function only iterate through the feature that have a defined geometry.\n       *\n       * @param {function(import(\"../Feature.js\").default): T} callback Called with each feature\n       *     on the source.  Return a truthy value to stop iteration.\n       * @return {T|undefined} The return value from the last call to the callback.\n       * @template T\n       * @api\n       */\n\n\n      VectorSource.prototype.forEachFeature = function forEachFeature(callback) {\n        if (this.featuresRtree_) {\n          return this.featuresRtree_.forEach(callback);\n        } else if (this.featuresCollection_) {\n          this.featuresCollection_.forEach(callback);\n        }\n      };\n      /**\n       * Iterate through all features whose geometries contain the provided\n       * coordinate, calling the callback with each feature.  If the callback returns\n       * a \"truthy\" value, iteration will stop and the function will return the same\n       * value.\n       *\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {function(import(\"../Feature.js\").default): T} callback Called with each feature\n       *     whose goemetry contains the provided coordinate.\n       * @return {T|undefined} The return value from the last call to the callback.\n       * @template T\n       */\n\n\n      VectorSource.prototype.forEachFeatureAtCoordinateDirect = function forEachFeatureAtCoordinateDirect(coordinate, callback) {\n        var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n        return this.forEachFeatureInExtent(extent, function (feature) {\n          var geometry = feature.getGeometry();\n\n          if (geometry.intersectsCoordinate(coordinate)) {\n            return callback(feature);\n          } else {\n            return undefined;\n          }\n        });\n      };\n      /**\n       * Iterate through all features whose bounding box intersects the provided\n       * extent (note that the feature's geometry may not intersect the extent),\n       * calling the callback with each feature.  If the callback returns a \"truthy\"\n       * value, iteration will stop and the function will return the same value.\n       *\n       * If you are interested in features whose geometry intersects an extent, call\n       * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\n       *\n       * When `useSpatialIndex` is set to false, this method will loop through all\n       * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\n       *\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @param {function(import(\"../Feature.js\").default): T} callback Called with each feature\n       *     whose bounding box intersects the provided extent.\n       * @return {T|undefined} The return value from the last call to the callback.\n       * @template T\n       * @api\n       */\n\n\n      VectorSource.prototype.forEachFeatureInExtent = function forEachFeatureInExtent(extent, callback) {\n        if (this.featuresRtree_) {\n          return this.featuresRtree_.forEachInExtent(extent, callback);\n        } else if (this.featuresCollection_) {\n          this.featuresCollection_.forEach(callback);\n        }\n      };\n      /**\n       * Iterate through all features whose geometry intersects the provided extent,\n       * calling the callback with each feature.  If the callback returns a \"truthy\"\n       * value, iteration will stop and the function will return the same value.\n       *\n       * If you only want to test for bounding box intersection, call the\n       * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\n       *\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @param {function(import(\"../Feature.js\").default): T} callback Called with each feature\n       *     whose geometry intersects the provided extent.\n       * @return {T|undefined} The return value from the last call to the callback.\n       * @template T\n       * @api\n       */\n\n\n      VectorSource.prototype.forEachFeatureIntersectingExtent = function forEachFeatureIntersectingExtent(extent, callback) {\n        return this.forEachFeatureInExtent(extent,\n        /**\n         * @param {import(\"../Feature.js\").default} feature Feature.\n         * @return {T|undefined} The return value from the last call to the callback.\n         */\n        function (feature) {\n          var geometry = feature.getGeometry();\n\n          if (geometry.intersectsExtent(extent)) {\n            var result = callback(feature);\n\n            if (result) {\n              return result;\n            }\n          }\n        });\n      };\n      /**\n       * Get the features collection associated with this source. Will be `null`\n       * unless the source was configured with `useSpatialIndex` set to `false`, or\n       * with an {@link module:ol/Collection} as `features`.\n       * @return {Collection<import(\"../Feature.js\").default>} The collection of features.\n       * @api\n       */\n\n\n      VectorSource.prototype.getFeaturesCollection = function getFeaturesCollection() {\n        return this.featuresCollection_;\n      };\n      /**\n       * Get all features on the source in random order.\n       * @return {Array<import(\"../Feature.js\").default>} Features.\n       * @api\n       */\n\n\n      VectorSource.prototype.getFeatures = function getFeatures() {\n        var features;\n\n        if (this.featuresCollection_) {\n          features = this.featuresCollection_.getArray();\n        } else if (this.featuresRtree_) {\n          features = this.featuresRtree_.getAll();\n\n          if (!isEmpty(this.nullGeometryFeatures_)) {\n            extend(features, getValues(this.nullGeometryFeatures_));\n          }\n        }\n\n        return (\n          /** @type {Array<import(\"../Feature.js\").default>} */\n          features\n        );\n      };\n      /**\n       * Get all features whose geometry intersects the provided coordinate.\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @return {Array<import(\"../Feature.js\").default>} Features.\n       * @api\n       */\n\n\n      VectorSource.prototype.getFeaturesAtCoordinate = function getFeaturesAtCoordinate(coordinate) {\n        var features = [];\n        this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {\n          features.push(feature);\n        });\n        return features;\n      };\n      /**\n       * Get all features in the provided extent.  Note that this returns an array of\n       * all features intersecting the given extent in random order (so it may include\n       * features whose geometries do not intersect the extent).\n       *\n       * This method is not available when the source is configured with\n       * `useSpatialIndex` set to `false`.\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @return {Array<import(\"../Feature.js\").default>} Features.\n       * @api\n       */\n\n\n      VectorSource.prototype.getFeaturesInExtent = function getFeaturesInExtent(extent) {\n        return this.featuresRtree_.getInExtent(extent);\n      };\n      /**\n       * Get the closest feature to the provided coordinate.\n       *\n       * This method is not available when the source is configured with\n       * `useSpatialIndex` set to `false`.\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {function(import(\"../Feature.js\").default):boolean=} opt_filter Feature filter function.\n       *     The filter function will receive one argument, the {@link module:ol/Feature feature}\n       *     and it should return a boolean value. By default, no filtering is made.\n       * @return {import(\"../Feature.js\").default} Closest feature.\n       * @api\n       */\n\n\n      VectorSource.prototype.getClosestFeatureToCoordinate = function getClosestFeatureToCoordinate(coordinate, opt_filter) {\n        // Find the closest feature using branch and bound.  We start searching an\n        // infinite extent, and find the distance from the first feature found.  This\n        // becomes the closest feature.  We then compute a smaller extent which any\n        // closer feature must intersect.  We continue searching with this smaller\n        // extent, trying to find a closer feature.  Every time we find a closer\n        // feature, we update the extent being searched so that any even closer\n        // feature must intersect it.  We continue until we run out of features.\n        var x = coordinate[0];\n        var y = coordinate[1];\n        var closestFeature = null;\n        var closestPoint = [NaN, NaN];\n        var minSquaredDistance = Infinity;\n        var extent = [-Infinity, -Infinity, Infinity, Infinity];\n        var filter = opt_filter ? opt_filter : TRUE;\n        this.featuresRtree_.forEachInExtent(extent,\n        /**\n         * @param {import(\"../Feature.js\").default} feature Feature.\n         */\n        function (feature) {\n          if (filter(feature)) {\n            var geometry = feature.getGeometry();\n            var previousMinSquaredDistance = minSquaredDistance;\n            minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);\n\n            if (minSquaredDistance < previousMinSquaredDistance) {\n              closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being\n              // searched while the R-Tree traversal using this same extent object\n              // is still in progress.  This is safe because the new extent is\n              // strictly contained by the old extent.\n\n              var minDistance = Math.sqrt(minSquaredDistance);\n              extent[0] = x - minDistance;\n              extent[1] = y - minDistance;\n              extent[2] = x + minDistance;\n              extent[3] = y + minDistance;\n            }\n          }\n        });\n        return closestFeature;\n      };\n      /**\n       * Get the extent of the features currently in the source.\n       *\n       * This method is not available when the source is configured with\n       * `useSpatialIndex` set to `false`.\n       * @param {import(\"../extent.js\").Extent=} opt_extent Destination extent. If provided, no new extent\n       *     will be created. Instead, that extent's coordinates will be overwritten.\n       * @return {import(\"../extent.js\").Extent} Extent.\n       * @api\n       */\n\n\n      VectorSource.prototype.getExtent = function getExtent(opt_extent) {\n        return this.featuresRtree_.getExtent(opt_extent);\n      };\n      /**\n       * Get a feature by its identifier (the value returned by feature.getId()).\n       * Note that the index treats string and numeric identifiers as the same.  So\n       * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n       *\n       * @param {string|number} id Feature identifier.\n       * @return {import(\"../Feature.js\").default} The feature (or `null` if not found).\n       * @api\n       */\n\n\n      VectorSource.prototype.getFeatureById = function getFeatureById(id) {\n        var feature = this.idIndex_[id.toString()];\n        return feature !== undefined ? feature : null;\n      };\n      /**\n       * Get the format associated with this source.\n       *\n       * @return {import(\"../format/Feature.js\").default|undefined} The feature format.\n       * @api\n       */\n\n\n      VectorSource.prototype.getFormat = function getFormat() {\n        return this.format_;\n      };\n      /**\n       * @return {boolean} The source can have overlapping geometries.\n       */\n\n\n      VectorSource.prototype.getOverlaps = function getOverlaps() {\n        return this.overlaps_;\n      };\n      /**\n       * Get the url associated with this source.\n       *\n       * @return {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined} The url.\n       * @api\n       */\n\n\n      VectorSource.prototype.getUrl = function getUrl() {\n        return this.url_;\n      };\n      /**\n       * @param {Event} event Event.\n       * @private\n       */\n\n\n      VectorSource.prototype.handleFeatureChange_ = function handleFeatureChange_(event) {\n        var feature =\n        /** @type {import(\"../Feature.js\").default} */\n        event.target;\n        var featureKey = getUid(feature);\n        var geometry = feature.getGeometry();\n\n        if (!geometry) {\n          if (!(featureKey in this.nullGeometryFeatures_)) {\n            if (this.featuresRtree_) {\n              this.featuresRtree_.remove(feature);\n            }\n\n            this.nullGeometryFeatures_[featureKey] = feature;\n          }\n        } else {\n          var extent = geometry.getExtent();\n\n          if (featureKey in this.nullGeometryFeatures_) {\n            delete this.nullGeometryFeatures_[featureKey];\n\n            if (this.featuresRtree_) {\n              this.featuresRtree_.insert(extent, feature);\n            }\n          } else {\n            if (this.featuresRtree_) {\n              this.featuresRtree_.update(extent, feature);\n            }\n          }\n        }\n\n        var id = feature.getId();\n\n        if (id !== undefined) {\n          var sid = id.toString();\n\n          if (featureKey in this.undefIdIndex_) {\n            delete this.undefIdIndex_[featureKey];\n            this.idIndex_[sid] = feature;\n          } else {\n            if (this.idIndex_[sid] !== feature) {\n              this.removeFromIdIndex_(feature);\n              this.idIndex_[sid] = feature;\n            }\n          }\n        } else {\n          if (!(featureKey in this.undefIdIndex_)) {\n            this.removeFromIdIndex_(feature);\n            this.undefIdIndex_[featureKey] = feature;\n          }\n        }\n\n        this.changed();\n        this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));\n      };\n      /**\n       * Returns true if the feature is contained within the source.\n       * @param {import(\"../Feature.js\").default} feature Feature.\n       * @return {boolean} Has feature.\n       * @api\n       */\n\n\n      VectorSource.prototype.hasFeature = function hasFeature(feature) {\n        var id = feature.getId();\n\n        if (id !== undefined) {\n          return id in this.idIndex_;\n        } else {\n          return getUid(feature) in this.undefIdIndex_;\n        }\n      };\n      /**\n       * @return {boolean} Is empty.\n       */\n\n\n      VectorSource.prototype.isEmpty = function isEmpty$1$$1() {\n        return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);\n      };\n      /**\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @param {number} resolution Resolution.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       */\n\n\n      VectorSource.prototype.loadFeatures = function loadFeatures(extent, resolution, projection) {\n        var this$1 = this;\n        var loadedExtentsRtree = this.loadedExtentsRtree_;\n        var extentsToLoad = this.strategy_(extent, resolution);\n        this.loading = false;\n\n        var loop = function loop(i, ii) {\n          var extentToLoad = extentsToLoad[i];\n          var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,\n          /**\n           * @param {{extent: import(\"../extent.js\").Extent}} object Object.\n           * @return {boolean} Contains.\n           */\n          function (object) {\n            return containsExtent(object.extent, extentToLoad);\n          });\n\n          if (!alreadyLoaded) {\n            this$1.loader_.call(this$1, extentToLoad, resolution, projection);\n            loadedExtentsRtree.insert(extentToLoad, {\n              extent: extentToLoad.slice()\n            });\n            this$1.loading = this$1.loader_ !== VOID;\n          }\n        };\n\n        for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n          loop(i, ii);\n        }\n      };\n      /**\n       * Remove an extent from the list of loaded extents.\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @api\n       */\n\n\n      VectorSource.prototype.removeLoadedExtent = function removeLoadedExtent(extent) {\n        var loadedExtentsRtree = this.loadedExtentsRtree_;\n        var obj;\n        loadedExtentsRtree.forEachInExtent(extent, function (object) {\n          if (equals$2(object.extent, extent)) {\n            obj = object;\n            return true;\n          }\n        });\n\n        if (obj) {\n          loadedExtentsRtree.remove(obj);\n        }\n      };\n      /**\n       * Remove a single feature from the source.  If you want to remove all features\n       * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\n       * instead.\n       * @param {import(\"../Feature.js\").default} feature Feature to remove.\n       * @api\n       */\n\n\n      VectorSource.prototype.removeFeature = function removeFeature(feature) {\n        var featureKey = getUid(feature);\n\n        if (featureKey in this.nullGeometryFeatures_) {\n          delete this.nullGeometryFeatures_[featureKey];\n        } else {\n          if (this.featuresRtree_) {\n            this.featuresRtree_.remove(feature);\n          }\n        }\n\n        this.removeFeatureInternal(feature);\n        this.changed();\n      };\n      /**\n       * Remove feature without firing a `change` event.\n       * @param {import(\"../Feature.js\").default} feature Feature.\n       * @protected\n       */\n\n\n      VectorSource.prototype.removeFeatureInternal = function removeFeatureInternal(feature) {\n        var featureKey = getUid(feature);\n        this.featureChangeKeys_[featureKey].forEach(unlistenByKey);\n        delete this.featureChangeKeys_[featureKey];\n        var id = feature.getId();\n\n        if (id !== undefined) {\n          delete this.idIndex_[id.toString()];\n        } else {\n          delete this.undefIdIndex_[featureKey];\n        }\n\n        this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));\n      };\n      /**\n       * Remove a feature from the id index.  Called internally when the feature id\n       * may have changed.\n       * @param {import(\"../Feature.js\").default} feature The feature.\n       * @return {boolean} Removed the feature from the index.\n       * @private\n       */\n\n\n      VectorSource.prototype.removeFromIdIndex_ = function removeFromIdIndex_(feature) {\n        var removed = false;\n\n        for (var id in this.idIndex_) {\n          if (this.idIndex_[id] === feature) {\n            delete this.idIndex_[id];\n            removed = true;\n            break;\n          }\n        }\n\n        return removed;\n      };\n      /**\n       * Set the new loader of the source. The next loadFeatures call will use the\n       * new loader.\n       * @param {import(\"../featureloader.js\").FeatureLoader} loader The loader to set.\n       * @api\n       */\n\n\n      VectorSource.prototype.setLoader = function setLoader(loader) {\n        this.loader_ = loader;\n      };\n\n      return VectorSource;\n    }(Source);\n    /**\n     * @module ol/interaction/Draw\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {GeometryType} type Geometry type of\n     * the geometries being drawn with this instance.\n     * @property {number} [clickTolerance=6] The maximum distance in pixels between\n     * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n     * actually add a point/vertex to the geometry being drawn.  The default of `6`\n     * was chosen for the draw interaction to behave correctly on mouse as well as\n     * on touch devices.\n     * @property {import(\"../Collection.js\").default<Feature>} [features]\n     * Destination collection for the drawn features.\n     * @property {VectorSource} [source] Destination source for\n     * the drawn features.\n     * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n     * before the current vertex can be dragged to its exact position.\n     * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n     * drawing finish.\n     * @property {boolean} [stopClick=false] Stop click, singleclick, and\n     * doubleclick events from firing during drawing.\n     * @property {number} [maxPoints] The number of points that can be drawn before\n     * a polygon ring or line string is finished. By default there is no\n     * restriction.\n     * @property {number} [minPoints] The number of points that must be drawn\n     * before a polygon ring or line string can be finished. Default is `3` for\n     * polygon rings and `2` for line strings.\n     * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether the drawing can be finished.\n     * @property {import(\"../style/Style.js\").StyleLike} [style]\n     * Style for sketch features.\n     * @property {GeometryFunction} [geometryFunction]\n     * Function that is called when a geometry's coordinates are updated.\n     * @property {string} [geometryName] Geometry name to use for features created\n     * by the draw interaction.\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled.\n     * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,\n     * adds a vertex or deactivates freehand drawing.\n     * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n     * polygons, and circles.  This makes the interaction always operate in freehand\n     * mode and takes precedence over any `freehandCondition` option.\n     * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n     * Condition that activates freehand drawing for lines and polygons. This\n     * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n     * returns a boolean to indicate whether that event should be handled. The\n     * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the\n     * Shift key activates freehand drawing.\n     * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n     * overlay.\n     */\n\n    /**\n     * Coordinate type when drawing points.\n     * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n     */\n\n    /**\n     * Coordinate type when drawing lines.\n     * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n     */\n\n    /**\n     * Coordinate type when drawing polygons.\n     * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n     */\n\n    /**\n     * Types used for drawing coordinates.\n     * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n     */\n\n    /**\n     * Function that takes an array of coordinates and an optional existing geometry as\n     * arguments, and returns a geometry. The optional existing geometry is the\n     * geometry that is returned when the function is called without a second\n     * argument.\n     * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default=):\n     *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n     */\n\n    /**\n     * Draw mode.  This collapses multi-part geometry types with their single-part\n     * cousins.\n     * @enum {string}\n     */\n\n\n    var Mode$1 = {\n      POINT: 'Point',\n      LINE_STRING: 'LineString',\n      POLYGON: 'Polygon',\n      CIRCLE: 'Circle'\n    };\n    /**\n     * @enum {string}\n     */\n\n    var DrawEventType = {\n      /**\n       * Triggered upon feature draw start\n       * @event DrawEvent#drawstart\n       * @api\n       */\n      DRAWSTART: 'drawstart',\n\n      /**\n       * Triggered upon feature draw end\n       * @event DrawEvent#drawend\n       * @api\n       */\n      DRAWEND: 'drawend'\n    };\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n     * instances of this type.\n     */\n\n    var DrawEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function DrawEvent(type, feature) {\n        Event$$1.call(this, type);\n        /**\n         * The feature being drawn.\n         * @type {Feature}\n         * @api\n         */\n\n        this.feature = feature;\n      }\n\n      if (Event$$1) DrawEvent.__proto__ = Event$$1;\n      DrawEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      DrawEvent.prototype.constructor = DrawEvent;\n      return DrawEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Interaction for drawing feature geometries.\n     *\n     * @fires DrawEvent\n     * @api\n     */\n\n\n    var Draw =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function Draw(options) {\n        var pointerOptions =\n        /** @type {import(\"./Pointer.js\").Options} */\n        options;\n\n        if (!pointerOptions.stopDown) {\n          pointerOptions.stopDown = FALSE;\n        }\n\n        PointerInteraction$$1.call(this, pointerOptions);\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.shouldHandle_ = false;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         * @private\n         */\n\n        this.downPx_ = null;\n        /**\n         * @type {?}\n         * @private\n         */\n\n        this.downTimeout_;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n\n        this.lastDragTime_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.freehand_ = false;\n        /**\n         * Target source for drawn features.\n         * @type {VectorSource}\n         * @private\n         */\n\n        this.source_ = options.source ? options.source : null;\n        /**\n         * Target collection for drawn features.\n         * @type {import(\"../Collection.js\").default<Feature>}\n         * @private\n         */\n\n        this.features_ = options.features ? options.features : null;\n        /**\n         * Pixel distance for snapping.\n         * @type {number}\n         * @private\n         */\n\n        this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n        /**\n         * Geometry type.\n         * @type {GeometryType}\n         * @private\n         */\n\n        this.type_ =\n        /** @type {GeometryType} */\n        options.type;\n        /**\n         * Drawing mode (derived from geometry type.\n         * @type {Mode}\n         * @private\n         */\n\n        this.mode_ = getMode(this.type_);\n        /**\n         * Stop click, singleclick, and doubleclick events from firing during drawing.\n         * Default is `false`.\n         * @type {boolean}\n         * @private\n         */\n\n        this.stopClick_ = !!options.stopClick;\n        /**\n         * The number of points that must be drawn before a polygon ring or line\n         * string can be finished.  The default is 3 for polygon rings and 2 for\n         * line strings.\n         * @type {number}\n         * @private\n         */\n\n        this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === Mode$1.POLYGON ? 3 : 2;\n        /**\n         * The number of points that can be drawn before a polygon ring or line string\n         * is finished. The default is no restriction.\n         * @type {number}\n         * @private\n         */\n\n        this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\n        /**\n         * A function to decide if a potential finish coordinate is permissible\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\n        var geometryFunction = options.geometryFunction;\n\n        if (!geometryFunction) {\n          if (this.type_ === GeometryType.CIRCLE) {\n            /**\n             * @param {!LineCoordType} coordinates The coordinates.\n             * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n             * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n             */\n            geometryFunction = function geometryFunction(coordinates, opt_geometry) {\n              var circle = opt_geometry ?\n              /** @type {Circle} */\n              opt_geometry : new Circle([NaN, NaN]);\n              var squaredLength = squaredDistance$1(coordinates[0], coordinates[1]);\n              circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\n              return circle;\n            };\n          } else {\n            var Constructor;\n            var mode = this.mode_;\n\n            if (mode === Mode$1.POINT) {\n              Constructor = Point;\n            } else if (mode === Mode$1.LINE_STRING) {\n              Constructor = LineString;\n            } else if (mode === Mode$1.POLYGON) {\n              Constructor = Polygon;\n            }\n            /**\n             * @param {!LineCoordType} coordinates The coordinates.\n             * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n             * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n             */\n\n\n            geometryFunction = function geometryFunction(coordinates, opt_geometry) {\n              var geometry = opt_geometry;\n\n              if (geometry) {\n                if (mode === Mode$1.POLYGON) {\n                  if (coordinates[0].length) {\n                    // Add a closing coordinate to match the first\n                    geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n                  } else {\n                    geometry.setCoordinates([]);\n                  }\n                } else {\n                  geometry.setCoordinates(coordinates);\n                }\n              } else {\n                geometry = new Constructor(coordinates);\n              }\n\n              return geometry;\n            };\n          }\n        }\n        /**\n         * @type {GeometryFunction}\n         * @private\n         */\n\n\n        this.geometryFunction_ = geometryFunction;\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n        /**\n         * Finish coordinate for the feature (first point for polygons, last point for\n         * linestrings).\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n\n        this.finishCoordinate_ = null;\n        /**\n         * Sketch feature.\n         * @type {Feature}\n         * @private\n         */\n\n        this.sketchFeature_ = null;\n        /**\n         * Sketch point.\n         * @type {Feature}\n         * @private\n         */\n\n        this.sketchPoint_ = null;\n        /**\n         * Sketch coordinates. Used when drawing a line or polygon.\n         * @type {SketchCoordType}\n         * @private\n         */\n\n        this.sketchCoords_ = null;\n        /**\n         * Sketch line. Used when drawing polygon.\n         * @type {Feature}\n         * @private\n         */\n\n        this.sketchLine_ = null;\n        /**\n         * Sketch line coordinates. Used when drawing a polygon or circle.\n         * @type {LineCoordType}\n         * @private\n         */\n\n        this.sketchLineCoords_ = null;\n        /**\n         * Squared tolerance for handling up events.  If the squared distance\n         * between a down and up event is greater than this tolerance, up events\n         * will not be handled.\n         * @type {number}\n         * @private\n         */\n\n        this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n        /**\n         * Draw overlay where our sketch features are drawn.\n         * @type {VectorLayer}\n         * @private\n         */\n\n        this.overlay_ = new VectorLayer({\n          source: new VectorSource({\n            useSpatialIndex: false,\n            wrapX: options.wrapX ? options.wrapX : false\n          }),\n          style: options.style ? options.style : getDefaultStyleFunction(),\n          updateWhileInteracting: true\n        });\n        /**\n         * Name of the geometry attribute for newly created features.\n         * @type {string|undefined}\n         * @private\n         */\n\n        this.geometryName_ = options.geometryName;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : noModifierKeys;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.freehandCondition_;\n\n        if (options.freehand) {\n          this.freehandCondition_ = always;\n        } else {\n          this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;\n        }\n\n        listen(this, getChangeEventType(InteractionProperty.ACTIVE), this.updateState_, this);\n      }\n\n      if (PointerInteraction$$1) Draw.__proto__ = PointerInteraction$$1;\n      Draw.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      Draw.prototype.constructor = Draw;\n      /**\n       * @inheritDoc\n       */\n\n      Draw.prototype.setMap = function setMap(map) {\n        PointerInteraction$$1.prototype.setMap.call(this, map);\n        this.updateState_();\n      };\n      /**\n       * Get the overlay layer that this interaction renders sketch features to.\n       * @return {VectorLayer} Overlay layer.\n       * @api\n       */\n\n\n      Draw.prototype.getOverlay = function getOverlay() {\n        return this.overlay_;\n      };\n      /**\n       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n       * @override\n       * @api\n       */\n\n\n      Draw.prototype.handleEvent = function handleEvent(event) {\n        if (event.originalEvent.type === EventType.CONTEXTMENU) {\n          // Avoid context menu for long taps when drawing on mobile\n          event.preventDefault();\n        }\n\n        this.freehand_ = this.mode_ !== Mode$1.POINT && this.freehandCondition_(event);\n        var move = event.type === MapBrowserEventType.POINTERMOVE;\n        var pass = true;\n\n        if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\n          var now = Date.now();\n\n          if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n            this.downPx_ = event.pixel;\n            this.shouldHandle_ = !this.freehand_;\n            move = true;\n          } else {\n            this.lastDragTime_ = undefined;\n          }\n\n          if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n            clearTimeout(this.downTimeout_);\n            this.downTimeout_ = undefined;\n          }\n        }\n\n        if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {\n          this.addToDrawing_(event);\n          pass = false;\n        } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {\n          pass = false;\n        } else if (move) {\n          pass = event.type === MapBrowserEventType.POINTERMOVE;\n\n          if (pass && this.freehand_) {\n            pass = this.handlePointerMove_(event);\n          } else if (\n          /** @type {MapBrowserPointerEvent} */\n          event.pointerEvent.pointerType == POINTER_TYPE || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === undefined) {\n            this.handlePointerMove_(event);\n          }\n        } else if (event.type === MapBrowserEventType.DBLCLICK) {\n          pass = false;\n        }\n\n        return PointerInteraction$$1.prototype.handleEvent.call(this, event) && pass;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Draw.prototype.handleDownEvent = function handleDownEvent(event) {\n        this.shouldHandle_ = !this.freehand_;\n\n        if (this.freehand_) {\n          this.downPx_ = event.pixel;\n\n          if (!this.finishCoordinate_) {\n            this.startDrawing_(event);\n          }\n\n          return true;\n        } else if (this.condition_(event)) {\n          this.lastDragTime_ = Date.now();\n          this.downTimeout_ = setTimeout(function () {\n            this.handlePointerMove_(new MapBrowserPointerEvent(MapBrowserEventType.POINTERMOVE, event.map, event.pointerEvent, false, event.frameState));\n          }.bind(this), this.dragVertexDelay_);\n          this.downPx_ = event.pixel;\n          return true;\n        } else {\n          return false;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Draw.prototype.handleUpEvent = function handleUpEvent(event) {\n        var pass = true;\n\n        if (this.downTimeout_) {\n          clearTimeout(this.downTimeout_);\n          this.downTimeout_ = undefined;\n        }\n\n        this.handlePointerMove_(event);\n        var circleMode = this.mode_ === Mode$1.CIRCLE;\n\n        if (this.shouldHandle_) {\n          if (!this.finishCoordinate_) {\n            this.startDrawing_(event);\n\n            if (this.mode_ === Mode$1.POINT) {\n              this.finishDrawing();\n            }\n          } else if (this.freehand_ || circleMode) {\n            this.finishDrawing();\n          } else if (this.atFinish_(event)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event);\n          }\n\n          pass = false;\n        } else if (this.freehand_) {\n          this.finishCoordinate_ = null;\n          this.abortDrawing_();\n        }\n\n        if (!pass && this.stopClick_) {\n          event.stopPropagation();\n        }\n\n        return pass;\n      };\n      /**\n       * Handle move events.\n       * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n       * @return {boolean} Pass the event to other interactions.\n       * @private\n       */\n\n\n      Draw.prototype.handlePointerMove_ = function handlePointerMove_(event) {\n        if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n          var downPx = this.downPx_;\n          var clickPx = event.pixel;\n          var dx = downPx[0] - clickPx[0];\n          var dy = downPx[1] - clickPx[1];\n          var squaredDistance$$1 = dx * dx + dy * dy;\n          this.shouldHandle_ = this.freehand_ ? squaredDistance$$1 > this.squaredClickTolerance_ : squaredDistance$$1 <= this.squaredClickTolerance_;\n\n          if (!this.shouldHandle_) {\n            return true;\n          }\n        }\n\n        if (this.finishCoordinate_) {\n          this.modifyDrawing_(event);\n        } else {\n          this.createOrUpdateSketchPoint_(event);\n        }\n\n        return true;\n      };\n      /**\n       * Determine if an event is within the snapping tolerance of the start coord.\n       * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n       * @return {boolean} The event is within the snapping tolerance of the start.\n       * @private\n       */\n\n\n      Draw.prototype.atFinish_ = function atFinish_(event) {\n        var at = false;\n\n        if (this.sketchFeature_) {\n          var potentiallyDone = false;\n          var potentiallyFinishCoordinates = [this.finishCoordinate_];\n\n          if (this.mode_ === Mode$1.LINE_STRING) {\n            potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n          } else if (this.mode_ === Mode$1.POLYGON) {\n            var sketchCoords =\n            /** @type {PolyCoordType} */\n            this.sketchCoords_;\n            potentiallyDone = sketchCoords[0].length > this.minPoints_;\n            potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n          }\n\n          if (potentiallyDone) {\n            var map = event.map;\n\n            for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n              var finishCoordinate = potentiallyFinishCoordinates[i];\n              var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n              var pixel = event.pixel;\n              var dx = pixel[0] - finishPixel[0];\n              var dy = pixel[1] - finishPixel[1];\n              var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n              at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n\n              if (at) {\n                this.finishCoordinate_ = finishCoordinate;\n                break;\n              }\n            }\n          }\n        }\n\n        return at;\n      };\n      /**\n       * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n       * @private\n       */\n\n\n      Draw.prototype.createOrUpdateSketchPoint_ = function createOrUpdateSketchPoint_(event) {\n        var coordinates = event.coordinate.slice();\n\n        if (!this.sketchPoint_) {\n          this.sketchPoint_ = new Feature(new Point(coordinates));\n          this.updateSketchFeatures_();\n        } else {\n          var sketchPointGeom =\n          /** @type {Point} */\n          this.sketchPoint_.getGeometry();\n          sketchPointGeom.setCoordinates(coordinates);\n        }\n      };\n      /**\n       * Start the drawing.\n       * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n       * @private\n       */\n\n\n      Draw.prototype.startDrawing_ = function startDrawing_(event) {\n        var start = event.coordinate;\n        this.finishCoordinate_ = start;\n\n        if (this.mode_ === Mode$1.POINT) {\n          this.sketchCoords_ = start.slice();\n        } else if (this.mode_ === Mode$1.POLYGON) {\n          this.sketchCoords_ = [[start.slice(), start.slice()]];\n          this.sketchLineCoords_ = this.sketchCoords_[0];\n        } else {\n          this.sketchCoords_ = [start.slice(), start.slice()];\n        }\n\n        if (this.sketchLineCoords_) {\n          this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n        }\n\n        var geometry = this.geometryFunction_(this.sketchCoords_);\n        this.sketchFeature_ = new Feature();\n\n        if (this.geometryName_) {\n          this.sketchFeature_.setGeometryName(this.geometryName_);\n        }\n\n        this.sketchFeature_.setGeometry(geometry);\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n      };\n      /**\n       * Modify the drawing.\n       * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n       * @private\n       */\n\n\n      Draw.prototype.modifyDrawing_ = function modifyDrawing_(event) {\n        var coordinate = event.coordinate;\n        var geometry =\n        /** @type {import(\"../geom/SimpleGeometry.js\").default} */\n        this.sketchFeature_.getGeometry();\n        var coordinates, last;\n\n        if (this.mode_ === Mode$1.POINT) {\n          last = this.sketchCoords_;\n        } else if (this.mode_ === Mode$1.POLYGON) {\n          coordinates =\n          /** @type {PolyCoordType} */\n          this.sketchCoords_[0];\n          last = coordinates[coordinates.length - 1];\n\n          if (this.atFinish_(event)) {\n            // snap to finish\n            coordinate = this.finishCoordinate_.slice();\n          }\n        } else {\n          coordinates = this.sketchCoords_;\n          last = coordinates[coordinates.length - 1];\n        }\n\n        last[0] = coordinate[0];\n        last[1] = coordinate[1];\n        this.geometryFunction_(\n        /** @type {!LineCoordType} */\n        this.sketchCoords_, geometry);\n\n        if (this.sketchPoint_) {\n          var sketchPointGeom =\n          /** @type {Point} */\n          this.sketchPoint_.getGeometry();\n          sketchPointGeom.setCoordinates(coordinate);\n        }\n        /** @type {LineString} */\n\n\n        var sketchLineGeom;\n\n        if (geometry.getType() == GeometryType.POLYGON && this.mode_ !== Mode$1.POLYGON) {\n          if (!this.sketchLine_) {\n            this.sketchLine_ = new Feature();\n          }\n\n          var ring =\n          /** @type {Polygon} */\n          geometry.getLinearRing(0);\n          sketchLineGeom =\n          /** @type {LineString} */\n          this.sketchLine_.getGeometry();\n\n          if (!sketchLineGeom) {\n            sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n            this.sketchLine_.setGeometry(sketchLineGeom);\n          } else {\n            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n            sketchLineGeom.changed();\n          }\n        } else if (this.sketchLineCoords_) {\n          sketchLineGeom =\n          /** @type {LineString} */\n          this.sketchLine_.getGeometry();\n          sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n        }\n\n        this.updateSketchFeatures_();\n      };\n      /**\n       * Add a new coordinate to the drawing.\n       * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n       * @private\n       */\n\n\n      Draw.prototype.addToDrawing_ = function addToDrawing_(event) {\n        var coordinate = event.coordinate;\n        var geometry =\n        /** @type {import(\"../geom/SimpleGeometry.js\").default} */\n        this.sketchFeature_.getGeometry();\n        var done;\n        var coordinates;\n\n        if (this.mode_ === Mode$1.LINE_STRING) {\n          this.finishCoordinate_ = coordinate.slice();\n          coordinates =\n          /** @type {LineCoordType} */\n          this.sketchCoords_;\n\n          if (coordinates.length >= this.maxPoints_) {\n            if (this.freehand_) {\n              coordinates.pop();\n            } else {\n              done = true;\n            }\n          }\n\n          coordinates.push(coordinate.slice());\n          this.geometryFunction_(coordinates, geometry);\n        } else if (this.mode_ === Mode$1.POLYGON) {\n          coordinates =\n          /** @type {PolyCoordType} */\n          this.sketchCoords_[0];\n\n          if (coordinates.length >= this.maxPoints_) {\n            if (this.freehand_) {\n              coordinates.pop();\n            } else {\n              done = true;\n            }\n          }\n\n          coordinates.push(coordinate.slice());\n\n          if (done) {\n            this.finishCoordinate_ = coordinates[0];\n          }\n\n          this.geometryFunction_(this.sketchCoords_, geometry);\n        }\n\n        this.updateSketchFeatures_();\n\n        if (done) {\n          this.finishDrawing();\n        }\n      };\n      /**\n       * Remove last point of the feature currently being drawn.\n       * @api\n       */\n\n\n      Draw.prototype.removeLastPoint = function removeLastPoint() {\n        if (!this.sketchFeature_) {\n          return;\n        }\n\n        var geometry =\n        /** @type {import(\"../geom/SimpleGeometry.js\").default} */\n        this.sketchFeature_.getGeometry();\n        var coordinates;\n        /** @type {LineString} */\n\n        var sketchLineGeom;\n\n        if (this.mode_ === Mode$1.LINE_STRING) {\n          coordinates =\n          /** @type {LineCoordType} */\n          this.sketchCoords_;\n          coordinates.splice(-2, 1);\n          this.geometryFunction_(coordinates, geometry);\n\n          if (coordinates.length >= 2) {\n            this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          }\n        } else if (this.mode_ === Mode$1.POLYGON) {\n          coordinates =\n          /** @type {PolyCoordType} */\n          this.sketchCoords_[0];\n          coordinates.splice(-2, 1);\n          sketchLineGeom =\n          /** @type {LineString} */\n          this.sketchLine_.getGeometry();\n          sketchLineGeom.setCoordinates(coordinates);\n          this.geometryFunction_(this.sketchCoords_, geometry);\n        }\n\n        if (coordinates.length === 0) {\n          this.finishCoordinate_ = null;\n        }\n\n        this.updateSketchFeatures_();\n      };\n      /**\n       * Stop drawing and add the sketch feature to the target layer.\n       * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n       * dispatched before inserting the feature.\n       * @api\n       */\n\n\n      Draw.prototype.finishDrawing = function finishDrawing() {\n        var sketchFeature = this.abortDrawing_();\n\n        if (!sketchFeature) {\n          return;\n        }\n\n        var coordinates = this.sketchCoords_;\n        var geometry =\n        /** @type {import(\"../geom/SimpleGeometry.js\").default} */\n        sketchFeature.getGeometry();\n\n        if (this.mode_ === Mode$1.LINE_STRING) {\n          // remove the redundant last point\n          coordinates.pop();\n          this.geometryFunction_(coordinates, geometry);\n        } else if (this.mode_ === Mode$1.POLYGON) {\n          // remove the redundant last point in ring\n\n          /** @type {PolyCoordType} */\n          coordinates[0].pop();\n          this.geometryFunction_(coordinates, geometry);\n          coordinates = geometry.getCoordinates();\n        } // cast multi-part geometries\n\n\n        if (this.type_ === GeometryType.MULTI_POINT) {\n          sketchFeature.setGeometry(new MultiPoint([\n          /** @type {PointCoordType} */\n          coordinates]));\n        } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {\n          sketchFeature.setGeometry(new MultiLineString([\n          /** @type {LineCoordType} */\n          coordinates]));\n        } else if (this.type_ === GeometryType.MULTI_POLYGON) {\n          sketchFeature.setGeometry(new MultiPolygon([\n          /** @type {PolyCoordType} */\n          coordinates]));\n        } // First dispatch event to allow full set up of feature\n\n\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature\n\n        if (this.features_) {\n          this.features_.push(sketchFeature);\n        }\n\n        if (this.source_) {\n          this.source_.addFeature(sketchFeature);\n        }\n      };\n      /**\n       * Stop drawing without adding the sketch feature to the target layer.\n       * @return {Feature} The sketch feature (or null if none).\n       * @private\n       */\n\n\n      Draw.prototype.abortDrawing_ = function abortDrawing_() {\n        this.finishCoordinate_ = null;\n        var sketchFeature = this.sketchFeature_;\n\n        if (sketchFeature) {\n          this.sketchFeature_ = null;\n          this.sketchPoint_ = null;\n          this.sketchLine_ = null;\n          /** @type {VectorSource} */\n\n          this.overlay_.getSource().clear(true);\n        }\n\n        return sketchFeature;\n      };\n      /**\n       * Extend an existing geometry by adding additional points. This only works\n       * on features with `LineString` geometries, where the interaction will\n       * extend lines by adding points to the end of the coordinates array.\n       * @param {!Feature} feature Feature to be extended.\n       * @api\n       */\n\n\n      Draw.prototype.extend = function extend(feature) {\n        var geometry = feature.getGeometry();\n        var lineString =\n        /** @type {LineString} */\n        geometry;\n        this.sketchFeature_ = feature;\n        this.sketchCoords_ = lineString.getCoordinates();\n        var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n        this.finishCoordinate_ = last.slice();\n        this.sketchCoords_.push(last.slice());\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n      };\n      /**\n       * Redraw the sketch features.\n       * @private\n       */\n\n\n      Draw.prototype.updateSketchFeatures_ = function updateSketchFeatures_() {\n        var sketchFeatures = [];\n\n        if (this.sketchFeature_) {\n          sketchFeatures.push(this.sketchFeature_);\n        }\n\n        if (this.sketchLine_) {\n          sketchFeatures.push(this.sketchLine_);\n        }\n\n        if (this.sketchPoint_) {\n          sketchFeatures.push(this.sketchPoint_);\n        }\n\n        var overlaySource =\n        /** @type {VectorSource} */\n        this.overlay_.getSource();\n        overlaySource.clear(true);\n        overlaySource.addFeatures(sketchFeatures);\n      };\n      /**\n       * @private\n       */\n\n\n      Draw.prototype.updateState_ = function updateState_() {\n        var map = this.getMap();\n        var active = this.getActive();\n\n        if (!map || !active) {\n          this.abortDrawing_();\n        }\n\n        this.overlay_.setMap(active ? map : null);\n      };\n\n      return Draw;\n    }(PointerInteraction);\n    /**\n     * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n     */\n\n\n    function getDefaultStyleFunction() {\n      var styles = createEditingStyle();\n      return function (feature, resolution) {\n        return styles[feature.getGeometry().getType()];\n      };\n    }\n    /**\n     * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n     * polygon with a user specified number of sides and start angle instead of an\n     * `import(\"../geom/Circle.js\").Circle` geometry.\n     * @param {number=} opt_sides Number of sides of the regular polygon. Default is\n     *     32.\n     * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\n     *     Default is the angle defined by the heading from the center of the\n     *     regular polygon to the current pointer position.\n     * @return {GeometryFunction} Function that draws a\n     *     polygon.\n     * @api\n     */\n\n\n    function createRegularPolygon(opt_sides, opt_angle) {\n      return function (coordinates, opt_geometry) {\n        var center =\n        /** @type {LineCoordType} */\n        coordinates[0];\n        var end =\n        /** @type {LineCoordType} */\n        coordinates[1];\n        var radius = Math.sqrt(squaredDistance$1(center, end));\n        var geometry = opt_geometry ?\n        /** @type {Polygon} */\n        opt_geometry : fromCircle(new Circle(center), opt_sides);\n        var angle = opt_angle;\n\n        if (!opt_angle) {\n          var x = end[0] - center[0];\n          var y = end[1] - center[1];\n          angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);\n        }\n\n        makeRegular(geometry, center, radius, angle);\n        return geometry;\n      };\n    }\n    /**\n     * Get the drawing mode.  The mode for mult-part geometries is the same as for\n     * their single-part cousins.\n     * @param {GeometryType} type Geometry type.\n     * @return {Mode} Drawing mode.\n     */\n\n\n    function getMode(type) {\n      var mode;\n\n      if (type === GeometryType.POINT || type === GeometryType.MULTI_POINT) {\n        mode = Mode$1.POINT;\n      } else if (type === GeometryType.LINE_STRING || type === GeometryType.MULTI_LINE_STRING) {\n        mode = Mode$1.LINE_STRING;\n      } else if (type === GeometryType.POLYGON || type === GeometryType.MULTI_POLYGON) {\n        mode = Mode$1.POLYGON;\n      } else if (type === GeometryType.CIRCLE) {\n        mode = Mode$1.CIRCLE;\n      }\n\n      return (\n        /** @type {!Mode} */\n        mode\n      );\n    }\n    /**\n     * @module ol/interaction/Extent\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../extent.js\").Extent} [extent] Initial extent. Defaults to no\n     * initial extent.\n     * @property {import(\"../style/Style.js\").StyleLike} [boxStyle]\n     * Style for the drawn extent box. Defaults to\n     * {@link module:ol/style/Style~createEditing()['Polygon']}\n     * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n     * pointer close enough to a segment or vertex for editing.\n     * @property {import(\"../style/Style.js\").StyleLike} [pointerStyle]\n     * Style for the cursor used to draw the extent. Defaults to\n     * {@link module:ol/style/Style~createEditing()['Point']}\n     * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\n     * in the X direction? Only affects visuals, not functionality.\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var ExtentEventType = {\n      /**\n       * Triggered after the extent is changed\n       * @event ExtentEventType#extentchanged\n       * @api\n       */\n      EXTENTCHANGED: 'extentchanged'\n    };\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/interaction/Extent~ExtentInteraction} instances are\n     * instances of this type.\n     */\n\n    var ExtentInteractionEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function ExtentInteractionEvent(extent) {\n        Event$$1.call(this, ExtentEventType.EXTENTCHANGED);\n        /**\n         * The current extent.\n         * @type {import(\"../extent.js\").Extent}\n         * @api\n         */\n\n        this.extent = extent;\n      }\n\n      if (Event$$1) ExtentInteractionEvent.__proto__ = Event$$1;\n      ExtentInteractionEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      ExtentInteractionEvent.prototype.constructor = ExtentInteractionEvent;\n      return ExtentInteractionEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Allows the user to draw a vector box by clicking and dragging on the map.\n     * Once drawn, the vector box can be modified by dragging its vertices or edges.\n     * This interaction is only supported for mouse devices.\n     *\n     * @fires Event\n     * @api\n     */\n\n\n    var ExtentInteraction =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function ExtentInteraction(opt_options) {\n        var options = opt_options || {};\n        PointerInteraction$$1.call(\n        /** @type {import(\"./Pointer.js\").Options} */\n        this, options);\n        /**\n         * Extent of the drawn box\n         * @type {import(\"../extent.js\").Extent}\n         * @private\n         */\n\n        this.extent_ = null;\n        /**\n         * Handler for pointer move events\n         * @type {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null}\n         * @private\n         */\n\n        this.pointerHandler_ = null;\n        /**\n         * Pixel threshold to snap to extent\n         * @type {number}\n         * @private\n         */\n\n        this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n        /**\n         * Is the pointer snapped to an extent vertex\n         * @type {boolean}\n         * @private\n         */\n\n        this.snappedToVertex_ = false;\n        /**\n         * Feature for displaying the visible extent\n         * @type {Feature}\n         * @private\n         */\n\n        this.extentFeature_ = null;\n        /**\n         * Feature for displaying the visible pointer\n         * @type {Feature}\n         * @private\n         */\n\n        this.vertexFeature_ = null;\n\n        if (!opt_options) {\n          opt_options = {};\n        }\n        /**\n         * Layer for the extentFeature\n         * @type {VectorLayer}\n         * @private\n         */\n\n\n        this.extentOverlay_ = new VectorLayer({\n          source: new VectorSource({\n            useSpatialIndex: false,\n            wrapX: !!opt_options.wrapX\n          }),\n          style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),\n          updateWhileAnimating: true,\n          updateWhileInteracting: true\n        });\n        /**\n         * Layer for the vertexFeature\n         * @type {VectorLayer}\n         * @private\n         */\n\n        this.vertexOverlay_ = new VectorLayer({\n          source: new VectorSource({\n            useSpatialIndex: false,\n            wrapX: !!opt_options.wrapX\n          }),\n          style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),\n          updateWhileAnimating: true,\n          updateWhileInteracting: true\n        });\n\n        if (opt_options.extent) {\n          this.setExtent(opt_options.extent);\n        }\n      }\n\n      if (PointerInteraction$$1) ExtentInteraction.__proto__ = PointerInteraction$$1;\n      ExtentInteraction.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      ExtentInteraction.prototype.constructor = ExtentInteraction;\n      /**\n       * @param {import(\"../pixel.js\").Pixel} pixel cursor location\n       * @param {import(\"../PluggableMap.js\").default} map map\n       * @returns {import(\"../coordinate.js\").Coordinate|null} snapped vertex on extent\n       * @private\n       */\n\n      ExtentInteraction.prototype.snapToVertex_ = function snapToVertex_(pixel, map) {\n        var pixelCoordinate = map.getCoordinateFromPixel(pixel);\n\n        var sortByDistance = function sortByDistance(a, b) {\n          return squaredDistanceToSegment(pixelCoordinate, a) - squaredDistanceToSegment(pixelCoordinate, b);\n        };\n\n        var extent = this.getExtent();\n\n        if (extent) {\n          //convert extents to line segments and find the segment closest to pixelCoordinate\n          var segments = getSegments(extent);\n          segments.sort(sortByDistance);\n          var closestSegment = segments[0];\n          var vertex = closestOnSegment(pixelCoordinate, closestSegment);\n          var vertexPixel = map.getPixelFromCoordinate(vertex); //if the distance is within tolerance, snap to the segment\n\n          if (distance(pixel, vertexPixel) <= this.pixelTolerance_) {\n            //test if we should further snap to a vertex\n            var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            var squaredDist1 = squaredDistance$1(vertexPixel, pixel1);\n            var squaredDist2 = squaredDistance$1(vertexPixel, pixel2);\n            var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            this.snappedToVertex_ = dist <= this.pixelTolerance_;\n\n            if (this.snappedToVertex_) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n            }\n\n            return vertex;\n          }\n        }\n\n        return null;\n      };\n      /**\n       * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent pointer move event\n       * @private\n       */\n\n\n      ExtentInteraction.prototype.handlePointerMove_ = function handlePointerMove_(mapBrowserEvent) {\n        var pixel = mapBrowserEvent.pixel;\n        var map = mapBrowserEvent.map;\n        var vertex = this.snapToVertex_(pixel, map);\n\n        if (!vertex) {\n          vertex = map.getCoordinateFromPixel(pixel);\n        }\n\n        this.createOrUpdatePointerFeature_(vertex);\n      };\n      /**\n       * @param {import(\"../extent.js\").Extent} extent extent\n       * @returns {Feature} extent as featrue\n       * @private\n       */\n\n\n      ExtentInteraction.prototype.createOrUpdateExtentFeature_ = function createOrUpdateExtentFeature_(extent) {\n        var extentFeature = this.extentFeature_;\n\n        if (!extentFeature) {\n          if (!extent) {\n            extentFeature = new Feature({});\n          } else {\n            extentFeature = new Feature(fromExtent(extent));\n          }\n\n          this.extentFeature_ = extentFeature;\n          /** @type {VectorSource} */\n\n          this.extentOverlay_.getSource().addFeature(extentFeature);\n        } else {\n          if (!extent) {\n            extentFeature.setGeometry(undefined);\n          } else {\n            extentFeature.setGeometry(fromExtent(extent));\n          }\n        }\n\n        return extentFeature;\n      };\n      /**\n       * @param {import(\"../coordinate.js\").Coordinate} vertex location of feature\n       * @returns {Feature} vertex as feature\n       * @private\n       */\n\n\n      ExtentInteraction.prototype.createOrUpdatePointerFeature_ = function createOrUpdatePointerFeature_(vertex) {\n        var vertexFeature = this.vertexFeature_;\n\n        if (!vertexFeature) {\n          vertexFeature = new Feature(new Point(vertex));\n          this.vertexFeature_ = vertexFeature;\n          /** @type {VectorSource} */\n\n          this.vertexOverlay_.getSource().addFeature(vertexFeature);\n        } else {\n          var geometry =\n          /** @type {Point} */\n          vertexFeature.getGeometry();\n          geometry.setCoordinates(vertex);\n        }\n\n        return vertexFeature;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ExtentInteraction.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n        if (!\n        /** @type {import(\"../MapBrowserPointerEvent.js\").default} */\n        mapBrowserEvent.pointerEvent) {\n          return true;\n        } //display pointer (if not dragging)\n\n\n        if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {\n          this.handlePointerMove_(mapBrowserEvent);\n        } //call pointer to determine up/down/drag\n\n\n        PointerInteraction$$1.prototype.handleEvent.call(this, mapBrowserEvent); //return false to stop propagation\n\n        return false;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ExtentInteraction.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n        var pixel = mapBrowserEvent.pixel;\n        var map = mapBrowserEvent.map;\n        var extent = this.getExtent();\n        var vertex = this.snapToVertex_(pixel, map); //find the extent corner opposite the passed corner\n\n        var getOpposingPoint = function getOpposingPoint(point) {\n          var x_ = null;\n          var y_ = null;\n\n          if (point[0] == extent[0]) {\n            x_ = extent[2];\n          } else if (point[0] == extent[2]) {\n            x_ = extent[0];\n          }\n\n          if (point[1] == extent[1]) {\n            y_ = extent[3];\n          } else if (point[1] == extent[3]) {\n            y_ = extent[1];\n          }\n\n          if (x_ !== null && y_ !== null) {\n            return [x_, y_];\n          }\n\n          return null;\n        };\n\n        if (vertex && extent) {\n          var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;\n          var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null; //snap to point\n\n          if (x !== null && y !== null) {\n            this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex)); //snap to edge\n          } else if (x !== null) {\n            this.pointerHandler_ = getEdgeHandler(getOpposingPoint([x, extent[1]]), getOpposingPoint([x, extent[3]]));\n          } else if (y !== null) {\n            this.pointerHandler_ = getEdgeHandler(getOpposingPoint([extent[0], y]), getOpposingPoint([extent[2], y]));\n          } //no snap - new bbox\n\n        } else {\n          vertex = map.getCoordinateFromPixel(pixel);\n          this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\n          this.pointerHandler_ = getPointHandler(vertex);\n        }\n\n        return true; //event handled; start downup sequence\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ExtentInteraction.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n        if (this.pointerHandler_) {\n          var pixelCoordinate = mapBrowserEvent.coordinate;\n          this.setExtent(this.pointerHandler_(pixelCoordinate));\n          this.createOrUpdatePointerFeature_(pixelCoordinate);\n        }\n\n        return true;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ExtentInteraction.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n        this.pointerHandler_ = null; //If bbox is zero area, set to null;\n\n        var extent = this.getExtent();\n\n        if (!extent || getArea(extent) === 0) {\n          this.setExtent(null);\n        }\n\n        return false; //Stop handling downup sequence\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ExtentInteraction.prototype.setMap = function setMap(map) {\n        this.extentOverlay_.setMap(map);\n        this.vertexOverlay_.setMap(map);\n        PointerInteraction$$1.prototype.setMap.call(this, map);\n      };\n      /**\n       * Returns the current drawn extent in the view projection\n       *\n       * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n       * @api\n       */\n\n\n      ExtentInteraction.prototype.getExtent = function getExtent() {\n        return this.extent_;\n      };\n      /**\n       * Manually sets the drawn extent, using the view projection.\n       *\n       * @param {import(\"../extent.js\").Extent} extent Extent\n       * @api\n       */\n\n\n      ExtentInteraction.prototype.setExtent = function setExtent(extent) {\n        //Null extent means no bbox\n        this.extent_ = extent ? extent : null;\n        this.createOrUpdateExtentFeature_(extent);\n        this.dispatchEvent(new ExtentInteractionEvent(this.extent_));\n      };\n\n      return ExtentInteraction;\n    }(PointerInteraction);\n    /**\n     * Returns the default style for the drawn bbox\n     *\n     * @return {import(\"../style/Style.js\").StyleFunction} Default Extent style\n     */\n\n\n    function getDefaultExtentStyleFunction() {\n      var style = createEditingStyle();\n      return function (feature, resolution) {\n        return style[GeometryType.POLYGON];\n      };\n    }\n    /**\n     * Returns the default style for the pointer\n     *\n     * @return {import(\"../style/Style.js\").StyleFunction} Default pointer style\n     */\n\n\n    function getDefaultPointerStyleFunction() {\n      var style = createEditingStyle();\n      return function (feature, resolution) {\n        return style[GeometryType.POINT];\n      };\n    }\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} fixedPoint corner that will be unchanged in the new extent\n     * @returns {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent} event handler\n     */\n\n\n    function getPointHandler(fixedPoint) {\n      return function (point) {\n        return boundingExtent([fixedPoint, point]);\n      };\n    }\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} fixedP1 first corner that will be unchanged in the new extent\n     * @param {import(\"../coordinate.js\").Coordinate} fixedP2 second corner that will be unchanged in the new extent\n     * @returns {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null} event handler\n     */\n\n\n    function getEdgeHandler(fixedP1, fixedP2) {\n      if (fixedP1[0] == fixedP2[0]) {\n        return function (point) {\n          return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\n        };\n      } else if (fixedP1[1] == fixedP2[1]) {\n        return function (point) {\n          return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\n        };\n      } else {\n        return null;\n      }\n    }\n    /**\n     * @param {import(\"../extent.js\").Extent} extent extent\n     * @returns {Array<Array<import(\"../coordinate.js\").Coordinate>>} extent line segments\n     */\n\n\n    function getSegments(extent) {\n      return [[[extent[0], extent[1]], [extent[0], extent[3]]], [[extent[0], extent[3]], [extent[2], extent[3]]], [[extent[2], extent[3]], [extent[2], extent[1]]], [[extent[2], extent[1]], [extent[0], extent[1]]]];\n    }\n    /**\n     * @module ol/interaction/Modify\n     */\n\n    /**\n     * The segment index assigned to a circle's center when\n     * breaking up a circle into ModifySegmentDataType segments.\n     * @type {number}\n     */\n\n\n    var CIRCLE_CENTER_INDEX = 0;\n    /**\n     * The segment index assigned to a circle's circumference when\n     * breaking up a circle into ModifySegmentDataType segments.\n     * @type {number}\n     */\n\n    var CIRCLE_CIRCUMFERENCE_INDEX = 1;\n    /**\n     * @enum {string}\n     */\n\n    var ModifyEventType = {\n      /**\n       * Triggered upon feature modification start\n       * @event ModifyEvent#modifystart\n       * @api\n       */\n      MODIFYSTART: 'modifystart',\n\n      /**\n       * Triggered upon feature modification end\n       * @event ModifyEvent#modifyend\n       * @api\n       */\n      MODIFYEND: 'modifyend'\n    };\n    /**\n     * @typedef {Object} SegmentData\n     * @property {Array<number>} [depth]\n     * @property {Feature} feature\n     * @property {import(\"../geom/SimpleGeometry.js\").default} geometry\n     * @property {number} [index]\n     * @property {Array<import(\"../extent.js\").Extent>} segment\n     * @property {Array<SegmentData>} [featureSegments]\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event will be considered to add or move a\n     * vertex to the sketch. Default is\n     * {@link module:ol/events/condition~primaryAction}.\n     * @property {import(\"../events/condition.js\").Condition} [deleteCondition] A function\n     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled. By default,\n     * {@link module:ol/events/condition~singleClick} with\n     * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.\n     * @property {import(\"../events/condition.js\").Condition} [insertVertexCondition] A\n     * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n     * returns a boolean to indicate whether a new vertex can be added to the sketch\n     * features. Default is {@link module:ol/events/condition~always}.\n     * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n     * pointer close enough to a segment or vertex for editing.\n     * @property {import(\"../style/Style.js\").StyleLike} [style]\n     * Style used for the features being modified. By default the default edit\n     * style is used (see {@link module:ol/style}).\n     * @property {VectorSource} [source] The vector source with\n     * features to modify.  If a vector source is not provided, a feature collection\n     * must be provided with the features option.\n     * @property {Collection<Feature>} [features]\n     * The features the interaction works on.  If a feature collection is not\n     * provided, a vector source must be provided with the source option.\n     * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n     * overlay.\n     */\n\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\n     * instances of this type.\n     */\n\n    var ModifyEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function ModifyEvent(type, features, mapBrowserPointerEvent) {\n        Event$$1.call(this, type);\n        /**\n         * The features being modified.\n         * @type {Collection<Feature>}\n         * @api\n         */\n\n        this.features = features;\n        /**\n         * Associated {@link module:ol/MapBrowserEvent}.\n         * @type {import(\"../MapBrowserEvent.js\").default}\n         * @api\n         */\n\n        this.mapBrowserEvent = mapBrowserPointerEvent;\n      }\n\n      if (Event$$1) ModifyEvent.__proto__ = Event$$1;\n      ModifyEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      ModifyEvent.prototype.constructor = ModifyEvent;\n      return ModifyEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Interaction for modifying feature geometries.  To modify features that have\n     * been added to an existing source, construct the modify interaction with the\n     * `source` option.  If you want to modify features in a collection (for example,\n     * the collection used by a select interaction), construct the interaction with\n     * the `features` option.  The interaction must be constructed with either a\n     * `source` or `features` option.\n     *\n     * By default, the interaction will allow deletion of vertices when the `alt`\n     * key is pressed.  To configure the interaction with a different condition\n     * for deletion, use the `deleteCondition` option.\n     * @fires ModifyEvent\n     * @api\n     */\n\n\n    var Modify =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function Modify(options) {\n        PointerInteraction$$1.call(\n        /** @type {import(\"./Pointer.js\").Options} */\n        this, options);\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : primaryAction;\n        /**\n         * @private\n         * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n         * @return {boolean} Combined condition result.\n         */\n\n        this.defaultDeleteCondition_ = function (mapBrowserEvent) {\n          return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n        };\n        /**\n         * @type {import(\"../events/condition.js\").Condition}\n         * @private\n         */\n\n\n        this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : this.defaultDeleteCondition_;\n        /**\n         * @type {import(\"../events/condition.js\").Condition}\n         * @private\n         */\n\n        this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : always;\n        /**\n         * Editing vertex.\n         * @type {Feature}\n         * @private\n         */\n\n        this.vertexFeature_ = null;\n        /**\n         * Segments intersecting {@link this.vertexFeature_} by segment uid.\n         * @type {Object<string, boolean>}\n         * @private\n         */\n\n        this.vertexSegments_ = null;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         * @private\n         */\n\n        this.lastPixel_ = [0, 0];\n        /**\n         * Tracks if the next `singleclick` event should be ignored to prevent\n         * accidental deletion right after vertex creation.\n         * @type {boolean}\n         * @private\n         */\n\n        this.ignoreNextSingleClick_ = false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.modified_ = false;\n        /**\n         * Segment RTree for each layer\n         * @type {RBush<SegmentData>}\n         * @private\n         */\n\n        this.rBush_ = new RBush();\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.snappedToVertex_ = false;\n        /**\n         * Indicate whether the interaction is currently changing a feature's\n         * coordinates.\n         * @type {boolean}\n         * @private\n         */\n\n        this.changingFeature_ = false;\n        /**\n         * @type {Array}\n         * @private\n         */\n\n        this.dragSegments_ = [];\n        /**\n         * Draw overlay where sketch features are drawn.\n         * @type {VectorLayer}\n         * @private\n         */\n\n        this.overlay_ = new VectorLayer({\n          source: new VectorSource({\n            useSpatialIndex: false,\n            wrapX: !!options.wrapX\n          }),\n          style: options.style ? options.style : getDefaultStyleFunction$1(),\n          updateWhileAnimating: true,\n          updateWhileInteracting: true\n        });\n        /**\n         * @const\n         * @private\n         * @type {!Object<string, function(Feature, import(\"../geom/Geometry.js\").default)>}\n         */\n\n        this.SEGMENT_WRITERS_ = {\n          'Point': this.writePointGeometry_,\n          'LineString': this.writeLineStringGeometry_,\n          'LinearRing': this.writeLineStringGeometry_,\n          'Polygon': this.writePolygonGeometry_,\n          'MultiPoint': this.writeMultiPointGeometry_,\n          'MultiLineString': this.writeMultiLineStringGeometry_,\n          'MultiPolygon': this.writeMultiPolygonGeometry_,\n          'Circle': this.writeCircleGeometry_,\n          'GeometryCollection': this.writeGeometryCollectionGeometry_\n        };\n        /**\n         * @type {VectorSource}\n         * @private\n         */\n\n        this.source_ = null;\n        var features;\n\n        if (options.source) {\n          this.source_ = options.source;\n          features = new Collection(this.source_.getFeatures());\n          listen(this.source_, VectorEventType.ADDFEATURE, this.handleSourceAdd_, this);\n          listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleSourceRemove_, this);\n        } else {\n          features = options.features;\n        }\n\n        if (!features) {\n          throw new Error('The modify interaction requires features or a source');\n        }\n        /**\n         * @type {Collection<Feature>}\n         * @private\n         */\n\n\n        this.features_ = features;\n        this.features_.forEach(this.addFeature_.bind(this));\n        listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this);\n        listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this);\n        /**\n         * @type {import(\"../MapBrowserPointerEvent.js\").default}\n         * @private\n         */\n\n        this.lastPointerEvent_ = null;\n      }\n\n      if (PointerInteraction$$1) Modify.__proto__ = PointerInteraction$$1;\n      Modify.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      Modify.prototype.constructor = Modify;\n      /**\n       * @param {Feature} feature Feature.\n       * @private\n       */\n\n      Modify.prototype.addFeature_ = function addFeature_(feature) {\n        var geometry = feature.getGeometry();\n\n        if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {\n          this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);\n        }\n\n        var map = this.getMap();\n\n        if (map && map.isRendered() && this.getActive()) {\n          this.handlePointerAtPixel_(this.lastPixel_, map);\n        }\n\n        listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n      };\n      /**\n       * @param {import(\"../MapBrowserPointerEvent.js\").default} evt Map browser event\n       * @private\n       */\n\n\n      Modify.prototype.willModifyFeatures_ = function willModifyFeatures_(evt) {\n        if (!this.modified_) {\n          this.modified_ = true;\n          this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.features_, evt));\n        }\n      };\n      /**\n       * @param {Feature} feature Feature.\n       * @private\n       */\n\n\n      Modify.prototype.removeFeature_ = function removeFeature_(feature) {\n        this.removeFeatureSegmentData_(feature); // Remove the vertex feature if the collection of canditate features\n        // is empty.\n\n        if (this.vertexFeature_ && this.features_.getLength() === 0) {\n          /** @type {VectorSource} */\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n\n        unlisten(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n      };\n      /**\n       * @param {Feature} feature Feature.\n       * @private\n       */\n\n\n      Modify.prototype.removeFeatureSegmentData_ = function removeFeatureSegmentData_(feature) {\n        var rBush = this.rBush_;\n        var\n        /** @type {Array<SegmentData>} */\n        nodesToRemove = [];\n        rBush.forEach(\n        /**\n         * @param {SegmentData} node RTree node.\n         */\n        function (node) {\n          if (feature === node.feature) {\n            nodesToRemove.push(node);\n          }\n        });\n\n        for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n          rBush.remove(nodesToRemove[i]);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Modify.prototype.setActive = function setActive(active) {\n        if (this.vertexFeature_ && !active) {\n          /** @type {VectorSource} */\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n\n        PointerInteraction$$1.prototype.setActive.call(this, active);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Modify.prototype.setMap = function setMap(map) {\n        this.overlay_.setMap(map);\n        PointerInteraction$$1.prototype.setMap.call(this, map);\n      };\n      /**\n       * Get the overlay layer that this interaction renders sketch features to.\n       * @return {VectorLayer} Overlay layer.\n       * @api\n       */\n\n\n      Modify.prototype.getOverlay = function getOverlay() {\n        return this.overlay_;\n      };\n      /**\n       * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n       * @private\n       */\n\n\n      Modify.prototype.handleSourceAdd_ = function handleSourceAdd_(event) {\n        if (event.feature) {\n          this.features_.push(event.feature);\n        }\n      };\n      /**\n       * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n       * @private\n       */\n\n\n      Modify.prototype.handleSourceRemove_ = function handleSourceRemove_(event) {\n        if (event.feature) {\n          this.features_.remove(event.feature);\n        }\n      };\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} evt Event.\n       * @private\n       */\n\n\n      Modify.prototype.handleFeatureAdd_ = function handleFeatureAdd_(evt) {\n        this.addFeature_(\n        /** @type {Feature} */\n        evt.element);\n      };\n      /**\n       * @param {import(\"../events/Event.js\").default} evt Event.\n       * @private\n       */\n\n\n      Modify.prototype.handleFeatureChange_ = function handleFeatureChange_(evt) {\n        if (!this.changingFeature_) {\n          var feature =\n          /** @type {Feature} */\n          evt.target;\n          this.removeFeature_(feature);\n          this.addFeature_(feature);\n        }\n      };\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} evt Event.\n       * @private\n       */\n\n\n      Modify.prototype.handleFeatureRemove_ = function handleFeatureRemove_(evt) {\n        var feature =\n        /** @type {Feature} */\n        evt.element;\n        this.removeFeature_(feature);\n      };\n      /**\n       * @param {Feature} feature Feature\n       * @param {Point} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writePointGeometry_ = function writePointGeometry_(feature, geometry) {\n        var coordinates = geometry.getCoordinates();\n        var segmentData =\n        /** @type {SegmentData} */\n        {\n          feature: feature,\n          geometry: geometry,\n          segment: [coordinates, coordinates]\n        };\n        this.rBush_.insert(geometry.getExtent(), segmentData);\n      };\n      /**\n       * @param {Feature} feature Feature\n       * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_(feature, geometry) {\n        var points = geometry.getCoordinates();\n\n        for (var i = 0, ii = points.length; i < ii; ++i) {\n          var coordinates = points[i];\n          var segmentData =\n          /** @type {SegmentData} */\n          {\n            feature: feature,\n            geometry: geometry,\n            depth: [i],\n            index: i,\n            segment: [coordinates, coordinates]\n          };\n          this.rBush_.insert(geometry.getExtent(), segmentData);\n        }\n      };\n      /**\n       * @param {Feature} feature Feature\n       * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_(feature, geometry) {\n        var coordinates = geometry.getCoordinates();\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData =\n          /** @type {SegmentData} */\n          {\n            feature: feature,\n            geometry: geometry,\n            index: i,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      };\n      /**\n       * @param {Feature} feature Feature\n       * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_(feature, geometry) {\n        var lines = geometry.getCoordinates();\n\n        for (var j = 0, jj = lines.length; j < jj; ++j) {\n          var coordinates = lines[j];\n\n          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            var segment = coordinates.slice(i, i + 2);\n            var segmentData =\n            /** @type {SegmentData} */\n            {\n              feature: feature,\n              geometry: geometry,\n              depth: [j],\n              index: i,\n              segment: segment\n            };\n            this.rBush_.insert(boundingExtent(segment), segmentData);\n          }\n        }\n      };\n      /**\n       * @param {Feature} feature Feature\n       * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writePolygonGeometry_ = function writePolygonGeometry_(feature, geometry) {\n        var rings = geometry.getCoordinates();\n\n        for (var j = 0, jj = rings.length; j < jj; ++j) {\n          var coordinates = rings[j];\n\n          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            var segment = coordinates.slice(i, i + 2);\n            var segmentData =\n            /** @type {SegmentData} */\n            {\n              feature: feature,\n              geometry: geometry,\n              depth: [j],\n              index: i,\n              segment: segment\n            };\n            this.rBush_.insert(boundingExtent(segment), segmentData);\n          }\n        }\n      };\n      /**\n       * @param {Feature} feature Feature\n       * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_(feature, geometry) {\n        var polygons = geometry.getCoordinates();\n\n        for (var k = 0, kk = polygons.length; k < kk; ++k) {\n          var rings = polygons[k];\n\n          for (var j = 0, jj = rings.length; j < jj; ++j) {\n            var coordinates = rings[j];\n\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n              var segment = coordinates.slice(i, i + 2);\n              var segmentData =\n              /** @type {SegmentData} */\n              {\n                feature: feature,\n                geometry: geometry,\n                depth: [j, k],\n                index: i,\n                segment: segment\n              };\n              this.rBush_.insert(boundingExtent(segment), segmentData);\n            }\n          }\n        }\n      };\n      /**\n       * We convert a circle into two segments.  The segment at index\n       * {@link CIRCLE_CENTER_INDEX} is the\n       * circle's center (a point).  The segment at index\n       * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\n       * the circumference, and is not a line segment.\n       *\n       * @param {Feature} feature Feature.\n       * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writeCircleGeometry_ = function writeCircleGeometry_(feature, geometry) {\n        var coordinates = geometry.getCenter();\n        var centerSegmentData =\n        /** @type {SegmentData} */\n        {\n          feature: feature,\n          geometry: geometry,\n          index: CIRCLE_CENTER_INDEX,\n          segment: [coordinates, coordinates]\n        };\n        var circumferenceSegmentData =\n        /** @type {SegmentData} */\n        {\n          feature: feature,\n          geometry: geometry,\n          index: CIRCLE_CIRCUMFERENCE_INDEX,\n          segment: [coordinates, coordinates]\n        };\n        var featureSegments = [centerSegmentData, circumferenceSegmentData];\n        centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;\n        this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n        this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);\n      };\n      /**\n       * @param {Feature} feature Feature\n       * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Modify.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_(feature, geometry) {\n        var geometries = geometry.getGeometriesArray();\n\n        for (var i = 0; i < geometries.length; ++i) {\n          this.SEGMENT_WRITERS_[geometries[i].getType()].call(this, feature, geometries[i]);\n        }\n      };\n      /**\n       * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n       * @return {Feature} Vertex feature.\n       * @private\n       */\n\n\n      Modify.prototype.createOrUpdateVertexFeature_ = function createOrUpdateVertexFeature_(coordinates) {\n        var vertexFeature = this.vertexFeature_;\n\n        if (!vertexFeature) {\n          vertexFeature = new Feature(new Point(coordinates));\n          this.vertexFeature_ = vertexFeature;\n          /** @type {VectorSource} */\n\n          this.overlay_.getSource().addFeature(vertexFeature);\n        } else {\n          var geometry =\n          /** @type {Point} */\n          vertexFeature.getGeometry();\n          geometry.setCoordinates(coordinates);\n        }\n\n        return vertexFeature;\n      };\n      /**\n       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the geometry.\n       * @override\n       */\n\n\n      Modify.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n        if (!\n        /** @type {import(\"../MapBrowserPointerEvent.js\").default} */\n        mapBrowserEvent.pointerEvent) {\n          return true;\n        }\n\n        this.lastPointerEvent_ = mapBrowserEvent;\n        var handled;\n\n        if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {\n          this.handlePointerMove_(mapBrowserEvent);\n        }\n\n        if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n          if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {\n            handled = this.removePoint();\n          } else {\n            handled = true;\n          }\n        }\n\n        if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n          this.ignoreNextSingleClick_ = false;\n        }\n\n        return PointerInteraction$$1.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Modify.prototype.handleDragEvent = function handleDragEvent(evt) {\n        this.ignoreNextSingleClick_ = false;\n        this.willModifyFeatures_(evt);\n        var vertex = evt.coordinate;\n\n        for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n          var dragSegment = this.dragSegments_[i];\n          var segmentData = dragSegment[0];\n          var depth = segmentData.depth;\n          var geometry = segmentData.geometry;\n          var coordinates = void 0;\n          var segment = segmentData.segment;\n          var index = dragSegment[1];\n\n          while (vertex.length < geometry.getStride()) {\n            vertex.push(segment[index][vertex.length]);\n          }\n\n          switch (geometry.getType()) {\n            case GeometryType.POINT:\n              coordinates = vertex;\n              segment[0] = segment[1] = vertex;\n              break;\n\n            case GeometryType.MULTI_POINT:\n              coordinates = geometry.getCoordinates();\n              coordinates[segmentData.index] = vertex;\n              segment[0] = segment[1] = vertex;\n              break;\n\n            case GeometryType.LINE_STRING:\n              coordinates = geometry.getCoordinates();\n              coordinates[segmentData.index + index] = vertex;\n              segment[index] = vertex;\n              break;\n\n            case GeometryType.MULTI_LINE_STRING:\n              coordinates = geometry.getCoordinates();\n              coordinates[depth[0]][segmentData.index + index] = vertex;\n              segment[index] = vertex;\n              break;\n\n            case GeometryType.POLYGON:\n              coordinates = geometry.getCoordinates();\n              coordinates[depth[0]][segmentData.index + index] = vertex;\n              segment[index] = vertex;\n              break;\n\n            case GeometryType.MULTI_POLYGON:\n              coordinates = geometry.getCoordinates();\n              coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n              segment[index] = vertex;\n              break;\n\n            case GeometryType.CIRCLE:\n              segment[0] = segment[1] = vertex;\n\n              if (segmentData.index === CIRCLE_CENTER_INDEX) {\n                this.changingFeature_ = true;\n                geometry.setCenter(vertex);\n                this.changingFeature_ = false;\n              } else {\n                // We're dragging the circle's circumference:\n                this.changingFeature_ = true;\n                geometry.setRadius(distance(geometry.getCenter(), vertex));\n                this.changingFeature_ = false;\n              }\n\n              break;\n\n            default: // pass\n\n          }\n\n          if (coordinates) {\n            this.setGeometryCoordinates_(geometry, coordinates);\n          }\n        }\n\n        this.createOrUpdateVertexFeature_(vertex);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Modify.prototype.handleDownEvent = function handleDownEvent(evt) {\n        if (!this.condition_(evt)) {\n          return false;\n        }\n\n        this.handlePointerAtPixel_(evt.pixel, evt.map);\n        var pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);\n        this.dragSegments_.length = 0;\n        this.modified_ = false;\n        var vertexFeature = this.vertexFeature_;\n\n        if (vertexFeature) {\n          var insertVertices = [];\n          var geometry =\n          /** @type {Point} */\n          vertexFeature.getGeometry();\n          var vertex = geometry.getCoordinates();\n          var vertexExtent = boundingExtent([vertex]);\n          var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n          var componentSegments = {};\n          segmentDataMatches.sort(compareIndexes);\n\n          for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n            var segmentDataMatch = segmentDataMatches[i];\n            var segment = segmentDataMatch.segment;\n            var uid = getUid(segmentDataMatch.feature);\n            var depth = segmentDataMatch.depth;\n\n            if (depth) {\n              uid += '-' + depth.join('-'); // separate feature components\n            }\n\n            if (!componentSegments[uid]) {\n              componentSegments[uid] = new Array(2);\n            }\n\n            if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n              var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);\n\n              if (equals$1(closestVertex, vertex) && !componentSegments[uid][0]) {\n                this.dragSegments_.push([segmentDataMatch, 0]);\n                componentSegments[uid][0] = segmentDataMatch;\n              }\n            } else if (equals$1(segment[0], vertex) && !componentSegments[uid][0]) {\n              this.dragSegments_.push([segmentDataMatch, 0]);\n              componentSegments[uid][0] = segmentDataMatch;\n            } else if (equals$1(segment[1], vertex) && !componentSegments[uid][1]) {\n              // prevent dragging closed linestrings by the connecting node\n              if ((segmentDataMatch.geometry.getType() === GeometryType.LINE_STRING || segmentDataMatch.geometry.getType() === GeometryType.MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) {\n                continue;\n              }\n\n              this.dragSegments_.push([segmentDataMatch, 1]);\n              componentSegments[uid][1] = segmentDataMatch;\n            } else if (this.insertVertexCondition_(evt) && getUid(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1]) {\n              insertVertices.push([segmentDataMatch, vertex]);\n            }\n          }\n\n          if (insertVertices.length) {\n            this.willModifyFeatures_(evt);\n          }\n\n          for (var j = insertVertices.length - 1; j >= 0; --j) {\n            this.insertVertex_.apply(this, insertVertices[j]);\n          }\n        }\n\n        return !!this.vertexFeature_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Modify.prototype.handleUpEvent = function handleUpEvent(evt) {\n        for (var i = this.dragSegments_.length - 1; i >= 0; --i) {\n          var segmentData = this.dragSegments_[i][0];\n          var geometry = segmentData.geometry;\n\n          if (geometry.getType() === GeometryType.CIRCLE) {\n            // Update a circle object in the R* bush:\n            var coordinates = geometry.getCenter();\n            var centerSegmentData = segmentData.featureSegments[0];\n            var circumferenceSegmentData = segmentData.featureSegments[1];\n            centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;\n            circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;\n            this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n            this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);\n          } else {\n            this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\n          }\n        }\n\n        if (this.modified_) {\n          this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));\n          this.modified_ = false;\n        }\n\n        return false;\n      };\n      /**\n       * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n       * @private\n       */\n\n\n      Modify.prototype.handlePointerMove_ = function handlePointerMove_(evt) {\n        this.lastPixel_ = evt.pixel;\n        this.handlePointerAtPixel_(evt.pixel, evt.map);\n      };\n      /**\n       * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @private\n       */\n\n\n      Modify.prototype.handlePointerAtPixel_ = function handlePointerAtPixel_(pixel, map) {\n        var pixelCoordinate = map.getCoordinateFromPixel(pixel);\n\n        var sortByDistance = function sortByDistance(a, b) {\n          return pointDistanceToSegmentDataSquared(pixelCoordinate, a) - pointDistanceToSegmentDataSquared(pixelCoordinate, b);\n        };\n\n        var box = buffer(createOrUpdateFromCoordinate(pixelCoordinate), map.getView().getResolution() * this.pixelTolerance_);\n        var rBush = this.rBush_;\n        var nodes = rBush.getInExtent(box);\n\n        if (nodes.length > 0) {\n          nodes.sort(sortByDistance);\n          var node = nodes[0];\n          var closestSegment = node.segment;\n          var vertex = closestOnSegmentData(pixelCoordinate, node);\n          var vertexPixel = map.getPixelFromCoordinate(vertex);\n          var dist = distance(pixel, vertexPixel);\n\n          if (dist <= this.pixelTolerance_) {\n            /** @type {Object<string, boolean>} */\n            var vertexSegments = {};\n\n            if (node.geometry.getType() === GeometryType.CIRCLE && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n              this.snappedToVertex_ = true;\n              this.createOrUpdateVertexFeature_(vertex);\n            } else {\n              var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n              var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n              var squaredDist1 = squaredDistance$1(vertexPixel, pixel1);\n              var squaredDist2 = squaredDistance$1(vertexPixel, pixel2);\n              dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n              this.snappedToVertex_ = dist <= this.pixelTolerance_;\n\n              if (this.snappedToVertex_) {\n                vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              }\n\n              this.createOrUpdateVertexFeature_(vertex);\n\n              for (var i = 1, ii = nodes.length; i < ii; ++i) {\n                var segment = nodes[i].segment;\n\n                if (equals$1(closestSegment[0], segment[0]) && equals$1(closestSegment[1], segment[1]) || equals$1(closestSegment[0], segment[1]) && equals$1(closestSegment[1], segment[0])) {\n                  vertexSegments[getUid(segment)] = true;\n                } else {\n                  break;\n                }\n              }\n            }\n\n            vertexSegments[getUid(closestSegment)] = true;\n            this.vertexSegments_ = vertexSegments;\n            return;\n          }\n        }\n\n        if (this.vertexFeature_) {\n          /** @type {VectorSource} */\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n      };\n      /**\n       * @param {SegmentData} segmentData Segment data.\n       * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n       * @private\n       */\n\n\n      Modify.prototype.insertVertex_ = function insertVertex_(segmentData, vertex) {\n        var segment = segmentData.segment;\n        var feature = segmentData.feature;\n        var geometry = segmentData.geometry;\n        var depth = segmentData.depth;\n        var index =\n        /** @type {number} */\n        segmentData.index;\n        var coordinates;\n\n        while (vertex.length < geometry.getStride()) {\n          vertex.push(0);\n        }\n\n        switch (geometry.getType()) {\n          case GeometryType.MULTI_LINE_STRING:\n            coordinates = geometry.getCoordinates();\n            coordinates[depth[0]].splice(index + 1, 0, vertex);\n            break;\n\n          case GeometryType.POLYGON:\n            coordinates = geometry.getCoordinates();\n            coordinates[depth[0]].splice(index + 1, 0, vertex);\n            break;\n\n          case GeometryType.MULTI_POLYGON:\n            coordinates = geometry.getCoordinates();\n            coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n            break;\n\n          case GeometryType.LINE_STRING:\n            coordinates = geometry.getCoordinates();\n            coordinates.splice(index + 1, 0, vertex);\n            break;\n\n          default:\n            return;\n        }\n\n        this.setGeometryCoordinates_(geometry, coordinates);\n        var rTree = this.rBush_;\n        rTree.remove(segmentData);\n        this.updateSegmentIndices_(geometry, index, depth, 1);\n        var newSegmentData =\n        /** @type {SegmentData} */\n        {\n          segment: [segment[0], vertex],\n          feature: feature,\n          geometry: geometry,\n          depth: depth,\n          index: index\n        };\n        rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n        this.dragSegments_.push([newSegmentData, 1]);\n        var newSegmentData2 =\n        /** @type {SegmentData} */\n        {\n          segment: [vertex, segment[1]],\n          feature: feature,\n          geometry: geometry,\n          depth: depth,\n          index: index + 1\n        };\n        rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n        this.dragSegments_.push([newSegmentData2, 0]);\n        this.ignoreNextSingleClick_ = true;\n      };\n      /**\n       * Removes the vertex currently being pointed.\n       * @return {boolean} True when a vertex was removed.\n       * @api\n       */\n\n\n      Modify.prototype.removePoint = function removePoint() {\n        if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {\n          var evt = this.lastPointerEvent_;\n          this.willModifyFeatures_(evt);\n          this.removeVertex_();\n          this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));\n          this.modified_ = false;\n          return true;\n        }\n\n        return false;\n      };\n      /**\n       * Removes a vertex from all matching features.\n       * @return {boolean} True when a vertex was removed.\n       * @private\n       */\n\n\n      Modify.prototype.removeVertex_ = function removeVertex_() {\n        var dragSegments = this.dragSegments_;\n        var segmentsByFeature = {};\n        var deleted = false;\n        var component, coordinates, dragSegment, geometry, i, index, left;\n        var newIndex, right, segmentData, uid;\n\n        for (i = dragSegments.length - 1; i >= 0; --i) {\n          dragSegment = dragSegments[i];\n          segmentData = dragSegment[0];\n          uid = getUid(segmentData.feature);\n\n          if (segmentData.depth) {\n            // separate feature components\n            uid += '-' + segmentData.depth.join('-');\n          }\n\n          if (!(uid in segmentsByFeature)) {\n            segmentsByFeature[uid] = {};\n          }\n\n          if (dragSegment[1] === 0) {\n            segmentsByFeature[uid].right = segmentData;\n            segmentsByFeature[uid].index = segmentData.index;\n          } else if (dragSegment[1] == 1) {\n            segmentsByFeature[uid].left = segmentData;\n            segmentsByFeature[uid].index = segmentData.index + 1;\n          }\n        }\n\n        for (uid in segmentsByFeature) {\n          right = segmentsByFeature[uid].right;\n          left = segmentsByFeature[uid].left;\n          index = segmentsByFeature[uid].index;\n          newIndex = index - 1;\n\n          if (left !== undefined) {\n            segmentData = left;\n          } else {\n            segmentData = right;\n          }\n\n          if (newIndex < 0) {\n            newIndex = 0;\n          }\n\n          geometry = segmentData.geometry;\n          coordinates = geometry.getCoordinates();\n          component = coordinates;\n          deleted = false;\n\n          switch (geometry.getType()) {\n            case GeometryType.MULTI_LINE_STRING:\n              if (coordinates[segmentData.depth[0]].length > 2) {\n                coordinates[segmentData.depth[0]].splice(index, 1);\n                deleted = true;\n              }\n\n              break;\n\n            case GeometryType.LINE_STRING:\n              if (coordinates.length > 2) {\n                coordinates.splice(index, 1);\n                deleted = true;\n              }\n\n              break;\n\n            case GeometryType.MULTI_POLYGON:\n              component = component[segmentData.depth[1]];\n\n            /* falls through */\n\n            case GeometryType.POLYGON:\n              component = component[segmentData.depth[0]];\n\n              if (component.length > 4) {\n                if (index == component.length - 1) {\n                  index = 0;\n                }\n\n                component.splice(index, 1);\n                deleted = true;\n\n                if (index === 0) {\n                  // close the ring again\n                  component.pop();\n                  component.push(component[0]);\n                  newIndex = component.length - 1;\n                }\n              }\n\n              break;\n\n            default: // pass\n\n          }\n\n          if (deleted) {\n            this.setGeometryCoordinates_(geometry, coordinates);\n            var segments = [];\n\n            if (left !== undefined) {\n              this.rBush_.remove(left);\n              segments.push(left.segment[0]);\n            }\n\n            if (right !== undefined) {\n              this.rBush_.remove(right);\n              segments.push(right.segment[1]);\n            }\n\n            if (left !== undefined && right !== undefined) {\n              var newSegmentData =\n              /** @type {SegmentData} */\n              {\n                depth: segmentData.depth,\n                feature: segmentData.feature,\n                geometry: segmentData.geometry,\n                index: newIndex,\n                segment: segments\n              };\n              this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n            }\n\n            this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n\n            if (this.vertexFeature_) {\n              /** @type {VectorSource} */\n              this.overlay_.getSource().removeFeature(this.vertexFeature_);\n              this.vertexFeature_ = null;\n            }\n\n            dragSegments.length = 0;\n          }\n        }\n\n        return deleted;\n      };\n      /**\n       * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n       * @param {Array} coordinates Coordinates.\n       * @private\n       */\n\n\n      Modify.prototype.setGeometryCoordinates_ = function setGeometryCoordinates_(geometry, coordinates) {\n        this.changingFeature_ = true;\n        geometry.setCoordinates(coordinates);\n        this.changingFeature_ = false;\n      };\n      /**\n       * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n       * @param {number} index Index.\n       * @param {Array<number>|undefined} depth Depth.\n       * @param {number} delta Delta (1 or -1).\n       * @private\n       */\n\n\n      Modify.prototype.updateSegmentIndices_ = function updateSegmentIndices_(geometry, index, depth, delta) {\n        this.rBush_.forEachInExtent(geometry.getExtent(), function (segmentDataMatch) {\n          if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || equals(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {\n            segmentDataMatch.index += delta;\n          }\n        });\n      };\n\n      return Modify;\n    }(PointerInteraction);\n    /**\n     * @param {SegmentData} a The first segment data.\n     * @param {SegmentData} b The second segment data.\n     * @return {number} The difference in indexes.\n     */\n\n\n    function compareIndexes(a, b) {\n      return a.index - b.index;\n    }\n    /**\n     * Returns the distance from a point to a line segment.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The coordinates of the point from\n     *        which to calculate the distance.\n     * @param {SegmentData} segmentData The object describing the line\n     *        segment we are calculating the distance to.\n     * @return {number} The square of the distance between a point and a line segment.\n     */\n\n\n    function pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {\n      var geometry = segmentData.geometry;\n\n      if (geometry.getType() === GeometryType.CIRCLE) {\n        var circleGeometry =\n        /** @type {import(\"../geom/Circle.js\").default} */\n        geometry;\n\n        if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n          var distanceToCenterSquared = squaredDistance$1(circleGeometry.getCenter(), pointCoordinates);\n          var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n          return distanceToCircumference * distanceToCircumference;\n        }\n      }\n\n      return squaredDistanceToSegment(pointCoordinates, segmentData.segment);\n    }\n    /**\n     * Returns the point closest to a given line segment.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The point to which a closest point\n     *        should be found.\n     * @param {SegmentData} segmentData The object describing the line\n     *        segment which should contain the closest point.\n     * @return {import(\"../coordinate.js\").Coordinate} The point closest to the specified line segment.\n     */\n\n\n    function closestOnSegmentData(pointCoordinates, segmentData) {\n      var geometry = segmentData.geometry;\n\n      if (geometry.getType() === GeometryType.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n        return geometry.getClosestPoint(pointCoordinates);\n      }\n\n      return closestOnSegment(pointCoordinates, segmentData.segment);\n    }\n    /**\n     * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n     */\n\n\n    function getDefaultStyleFunction$1() {\n      var style = createEditingStyle();\n      return function (feature, resolution) {\n        return style[GeometryType.POINT];\n      };\n    }\n    /**\n     * @module ol/interaction/Select\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var SelectEventType = {\n      /**\n       * Triggered when feature(s) has been (de)selected.\n       * @event SelectEvent#select\n       * @api\n       */\n      SELECT: 'select'\n    };\n    /**\n     * A function that takes an {@link module:ol/Feature} or\n     * {@link module:ol/render/Feature} and an\n     * {@link module:ol/layer/Layer} and returns `true` if the feature may be\n     * selected or `false` otherwise.\n     * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default):boolean} FilterFunction\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled.\n     * By default, this is {@link module:ol/events/condition~never}. Use this if you\n     * want to use different events for add and remove instead of `toggle`.\n     * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled. This is the event\n     * for the selected features as a whole. By default, this is\n     * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that\n     * feature and removes any that were in the selection. Clicking outside any\n     * feature removes all from the selection.\n     * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n     * from the selection.\n     * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default): boolean} [layers]\n     * A list of layers from which features should be selected. Alternatively, a\n     * filter function can be provided. The function will be called for each layer\n     * in the map and should return `true` for layers that you want to be\n     * selectable. If the option is absent, all visible layers will be considered\n     * selectable.\n     * @property {import(\"../style/Style.js\").StyleLike} [style]\n     * Style for the selected features. By default the default edit style is used\n     * (see {@link module:ol/style}).\n     * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled.\n     * By default, this is {@link module:ol/events/condition~never}. Use this if you\n     * want to use different events for add and remove instead of `toggle`.\n     * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n     * boolean to indicate whether that event should be handled. This is in addition\n     * to the `condition` event. By default,\n     * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as\n     * well as the `condition` event, adds that feature to the current selection if\n     * it is not currently selected, and removes it if it is. See `add` and `remove`\n     * if you want to use different events instead of a toggle.\n     * @property {boolean} [multi=false] A boolean that determines if the default\n     * behaviour should select only single features or all (overlapping) features at\n     * the clicked map position. The default of `false` means single select.\n     * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features]\n     * Collection where the interaction will place selected features. Optional. If\n     * not set the interaction will create a collection. In any case the collection\n     * used by the interaction is returned by\n     * {@link module:ol/interaction/Select~Select#getFeatures}.\n     * @property {FilterFunction} [filter] A function\n     * that takes an {@link module:ol/Feature} and an\n     * {@link module:ol/layer/Layer} and returns `true` if the feature may be\n     * selected or `false` otherwise.\n     * @property {boolean} [wrapX=true] Wrap the world horizontally on the selection\n     * overlay.\n     * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n     * the radius around the given position will be checked for features. This only\n     * works for the canvas renderer and not for WebGL.\n     */\n\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n     * this type.\n     */\n\n    var SelectEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function SelectEvent(type, selected, deselected, mapBrowserEvent) {\n        Event$$1.call(this, type);\n        /**\n         * Selected features array.\n         * @type {Array<import(\"../Feature.js\").default>}\n         * @api\n         */\n\n        this.selected = selected;\n        /**\n         * Deselected features array.\n         * @type {Array<import(\"../Feature.js\").default>}\n         * @api\n         */\n\n        this.deselected = deselected;\n        /**\n         * Associated {@link module:ol/MapBrowserEvent}.\n         * @type {import(\"../MapBrowserEvent.js\").default}\n         * @api\n         */\n\n        this.mapBrowserEvent = mapBrowserEvent;\n      }\n\n      if (Event$$1) SelectEvent.__proto__ = Event$$1;\n      SelectEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      SelectEvent.prototype.constructor = SelectEvent;\n      return SelectEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Interaction for selecting vector features. By default, selected features are\n     * styled differently, so this interaction can be used for visual highlighting,\n     * as well as selecting features for other actions, such as modification or\n     * output. There are three ways of controlling which features are selected:\n     * using the browser event as defined by the `condition` and optionally the\n     * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n     * further feature filter using the `filter` option.\n     *\n     * Selected features are added to an internal unmanaged layer.\n     *\n     * @fires SelectEvent\n     * @api\n     */\n\n\n    var Select =\n    /*@__PURE__*/\n    function (Interaction$$1) {\n      function Select(opt_options) {\n        Interaction$$1.call(this, {\n          handleEvent: handleEvent$3\n        });\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.condition_ = options.condition ? options.condition : singleClick;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.addCondition_ = options.addCondition ? options.addCondition : never;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.removeCondition_ = options.removeCondition ? options.removeCondition : never;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n\n        this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.multi_ = options.multi ? options.multi : false;\n        /**\n         * @private\n         * @type {FilterFunction}\n         */\n\n        this.filter_ = options.filter ? options.filter : TRUE;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n        var featureOverlay = new VectorLayer({\n          source: new VectorSource({\n            useSpatialIndex: false,\n            features: options.features,\n            wrapX: options.wrapX\n          }),\n          style: options.style ? options.style : getDefaultStyleFunction$2(),\n          updateWhileAnimating: true,\n          updateWhileInteracting: true\n        });\n        /**\n         * @private\n         * @type {VectorLayer}\n         */\n\n        this.featureOverlay_ = featureOverlay;\n        /** @type {function(import(\"../layer/Layer.js\").default): boolean} */\n\n        var layerFilter;\n\n        if (options.layers) {\n          if (typeof options.layers === 'function') {\n            layerFilter = options.layers;\n          } else {\n            var layers = options.layers;\n\n            layerFilter = function layerFilter(layer) {\n              return includes(layers, layer);\n            };\n          }\n        } else {\n          layerFilter = TRUE;\n        }\n        /**\n         * @private\n         * @type {function(import(\"../layer/Layer.js\").default): boolean}\n         */\n\n\n        this.layerFilter_ = layerFilter;\n        /**\n         * An association between selected feature (key)\n         * and layer (value)\n         * @private\n         * @type {Object<string, import(\"../layer/Layer.js\").default>}\n         */\n\n        this.featureLayerAssociation_ = {};\n        var features = this.getFeatures();\n        listen(features, CollectionEventType.ADD, this.addFeature_, this);\n        listen(features, CollectionEventType.REMOVE, this.removeFeature_, this);\n      }\n\n      if (Interaction$$1) Select.__proto__ = Interaction$$1;\n      Select.prototype = Object.create(Interaction$$1 && Interaction$$1.prototype);\n      Select.prototype.constructor = Select;\n      /**\n       * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n       * @param {import(\"../layer/Layer.js\").default} layer Layer.\n       * @private\n       */\n\n      Select.prototype.addFeatureLayerAssociation_ = function addFeatureLayerAssociation_(feature, layer) {\n        this.featureLayerAssociation_[getUid(feature)] = layer;\n      };\n      /**\n       * Get the selected features.\n       * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} Features collection.\n       * @api\n       */\n\n\n      Select.prototype.getFeatures = function getFeatures() {\n        return (\n          /** @type {VectorSource} */\n          this.featureOverlay_.getSource().getFeaturesCollection()\n        );\n      };\n      /**\n       * Returns the Hit-detection tolerance.\n       * @returns {number} Hit tolerance in pixels.\n       * @api\n       */\n\n\n      Select.prototype.getHitTolerance = function getHitTolerance() {\n        return this.hitTolerance_;\n      };\n      /**\n       * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of\n       * the (last) selected feature. Note that this will not work with any\n       * programmatic method like pushing features to\n       * {@link module:ol/interaction/Select~Select#getFeatures collection}.\n       * @param {import(\"../Feature.js\").FeatureLike} feature Feature\n       * @return {VectorLayer} Layer.\n       * @api\n       */\n\n\n      Select.prototype.getLayer = function getLayer(feature) {\n        return (\n          /** @type {VectorLayer} */\n          this.featureLayerAssociation_[getUid(feature)]\n        );\n      };\n      /**\n       * Get the overlay layer that this interaction renders selected features to.\n       * @return {VectorLayer} Overlay layer.\n       * @api\n       */\n\n\n      Select.prototype.getOverlay = function getOverlay() {\n        return this.featureOverlay_;\n      };\n      /**\n       * Hit-detection tolerance. Pixels inside the radius around the given position\n       * will be checked for features. This only works for the canvas renderer and\n       * not for WebGL.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @api\n       */\n\n\n      Select.prototype.setHitTolerance = function setHitTolerance(hitTolerance) {\n        this.hitTolerance_ = hitTolerance;\n      };\n      /**\n       * Remove the interaction from its current map, if any,  and attach it to a new\n       * map, if any. Pass `null` to just remove the interaction from the current map.\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @override\n       * @api\n       */\n\n\n      Select.prototype.setMap = function setMap(map) {\n        var currentMap = this.getMap();\n        var selectedFeatures = this.getFeatures();\n\n        if (currentMap) {\n          selectedFeatures.forEach(currentMap.unskipFeature.bind(currentMap));\n        }\n\n        Interaction$$1.prototype.setMap.call(this, map);\n        this.featureOverlay_.setMap(map);\n\n        if (map) {\n          selectedFeatures.forEach(map.skipFeature.bind(map));\n        }\n      };\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} evt Event.\n       * @private\n       */\n\n\n      Select.prototype.addFeature_ = function addFeature_(evt) {\n        var map = this.getMap();\n\n        if (map) {\n          map.skipFeature(\n          /** @type {import(\"../Feature.js\").default} */\n          evt.element);\n        }\n      };\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} evt Event.\n       * @private\n       */\n\n\n      Select.prototype.removeFeature_ = function removeFeature_(evt) {\n        var map = this.getMap();\n\n        if (map) {\n          map.unskipFeature(\n          /** @type {import(\"../Feature.js\").default} */\n          evt.element);\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n       * @private\n       */\n\n\n      Select.prototype.removeFeatureLayerAssociation_ = function removeFeatureLayerAssociation_(feature) {\n        delete this.featureLayerAssociation_[getUid(feature)];\n      };\n\n      return Select;\n    }(Interaction);\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the\n     * selected state of features.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @this {Select}\n     */\n\n\n    function handleEvent$3(mapBrowserEvent) {\n      if (!this.condition_(mapBrowserEvent)) {\n        return true;\n      }\n\n      var add = this.addCondition_(mapBrowserEvent);\n      var remove$$1 = this.removeCondition_(mapBrowserEvent);\n      var toggle = this.toggleCondition_(mapBrowserEvent);\n      var set = !add && !remove$$1 && !toggle;\n      var map = mapBrowserEvent.map;\n      var features = this.getFeatures();\n      var deselected = [];\n      var selected = [];\n\n      if (set) {\n        // Replace the currently selected feature(s) with the feature(s) at the\n        // pixel, or clear the selected feature(s) if there is no feature at\n        // the pixel.\n        clear(this.featureLayerAssociation_);\n        map.forEachFeatureAtPixel(mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        function (feature, layer) {\n          if (this.filter_(feature, layer)) {\n            selected.push(feature);\n            this.addFeatureLayerAssociation_(feature, layer);\n            return !this.multi_;\n          }\n        }.bind(this), {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_\n        });\n\n        for (var i = features.getLength() - 1; i >= 0; --i) {\n          var feature = features.item(i);\n          var index = selected.indexOf(feature);\n\n          if (index > -1) {\n            // feature is already selected\n            selected.splice(index, 1);\n          } else {\n            features.remove(feature);\n            deselected.push(feature);\n          }\n        }\n\n        if (selected.length !== 0) {\n          features.extend(selected);\n        }\n      } else {\n        // Modify the currently selected feature(s).\n        map.forEachFeatureAtPixel(mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        function (feature, layer) {\n          if (this.filter_(feature, layer)) {\n            if ((add || toggle) && !includes(features.getArray(), feature)) {\n              selected.push(feature);\n              this.addFeatureLayerAssociation_(feature, layer);\n            } else if ((remove$$1 || toggle) && includes(features.getArray(), feature)) {\n              deselected.push(feature);\n              this.removeFeatureLayerAssociation_(feature);\n            }\n\n            return !this.multi_;\n          }\n        }.bind(this), {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_\n        });\n\n        for (var j = deselected.length - 1; j >= 0; --j) {\n          features.remove(deselected[j]);\n        }\n\n        features.extend(selected);\n      }\n\n      if (selected.length > 0 || deselected.length > 0) {\n        this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));\n      }\n\n      return pointerMove$1(mapBrowserEvent);\n    }\n    /**\n     * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n     */\n\n\n    function getDefaultStyleFunction$2() {\n      var styles = createEditingStyle();\n      extend(styles[GeometryType.POLYGON], styles[GeometryType.LINE_STRING]);\n      extend(styles[GeometryType.GEOMETRY_COLLECTION], styles[GeometryType.LINE_STRING]);\n      return function (feature, resolution) {\n        if (!feature.getGeometry()) {\n          return null;\n        }\n\n        return styles[feature.getGeometry().getType()];\n      };\n    }\n    /**\n     * @module ol/interaction/Snap\n     */\n\n    /**\n     * @typedef {Object} Result\n     * @property {boolean} snapped\n     * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n     * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n     */\n\n    /**\n     * @typedef {Object} SegmentData\n     * @property {import(\"../Feature.js\").default} feature\n     * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n     * @property {boolean} [edge=true] Snap to edges.\n     * @property {boolean} [vertex=true] Snap to vertices.\n     * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n     * vertex for snapping.\n     * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n     */\n\n    /**\n     * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n\n\n    function getFeatureFromEvent(evt) {\n      if (\n      /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n      evt.feature) {\n        return (\n          /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n          evt.feature\n        );\n      } else if (\n      /** @type {import(\"../Collection.js\").CollectionEvent} */\n      evt.element) {\n        return (\n          /** @type {import(\"../Feature.js\").default} */\n\n          /** @type {import(\"../Collection.js\").CollectionEvent} */\n          evt.element\n        );\n      }\n    }\n    /**\n     * @classdesc\n     * Handles snapping of vector features while modifying or drawing them.  The\n     * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n     * Any interaction object that allows the user to interact\n     * with the features using the mouse can benefit from the snapping, as long\n     * as it is added before.\n     *\n     * The snap interaction modifies map browser event `coordinate` and `pixel`\n     * properties to force the snap to occur to any interaction that them.\n     *\n     * Example:\n     *\n     *     import Snap from 'ol/interaction/Snap';\n     *\n     *     var snap = new Snap({\n     *       source: source\n     *     });\n     *\n     * @api\n     */\n\n\n    var Snap =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function Snap(opt_options) {\n        var options = opt_options ? opt_options : {};\n        var pointerOptions =\n        /** @type {import(\"./Pointer.js\").Options} */\n        options;\n\n        if (!pointerOptions.handleDownEvent) {\n          pointerOptions.handleDownEvent = TRUE;\n        }\n\n        if (!pointerOptions.stopDown) {\n          pointerOptions.stopDown = FALSE;\n        }\n\n        PointerInteraction$$1.call(this, pointerOptions);\n        /**\n         * @type {import(\"../source/Vector.js\").default}\n         * @private\n         */\n\n        this.source_ = options.source ? options.source : null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.edge_ = options.edge !== undefined ? options.edge : true;\n        /**\n         * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n         * @private\n         */\n\n        this.features_ = options.features ? options.features : null;\n        /**\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         * @private\n         */\n\n        this.featuresListenerKeys_ = [];\n        /**\n         * @type {Object<string, import(\"../events.js\").EventsKey>}\n         * @private\n         */\n\n        this.featureChangeListenerKeys_ = {};\n        /**\n         * Extents are preserved so indexed segment can be quickly removed\n         * when its feature geometry changes\n         * @type {Object<string, import(\"../extent.js\").Extent>}\n         * @private\n         */\n\n        this.indexedFeaturesExtents_ = {};\n        /**\n         * If a feature geometry changes while a pointer drag|move event occurs, the\n         * feature doesn't get updated right away.  It will be at the next 'pointerup'\n         * event fired.\n         * @type {!Object<string, import(\"../Feature.js\").default>}\n         * @private\n         */\n\n        this.pendingFeatures_ = {};\n        /**\n         * Used for distance sorting in sortByDistance_\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n\n        this.pixelCoordinate_ = null;\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n        /**\n         * @type {function(SegmentData, SegmentData): number}\n         * @private\n         */\n\n        this.sortByDistance_ = sortByDistance.bind(this);\n        /**\n        * Segment RTree for each layer\n        * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n        * @private\n        */\n\n        this.rBush_ = new RBush();\n        /**\n        * @const\n        * @private\n        * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default)>}\n        */\n\n        this.SEGMENT_WRITERS_ = {\n          'Point': this.writePointGeometry_,\n          'LineString': this.writeLineStringGeometry_,\n          'LinearRing': this.writeLineStringGeometry_,\n          'Polygon': this.writePolygonGeometry_,\n          'MultiPoint': this.writeMultiPointGeometry_,\n          'MultiLineString': this.writeMultiLineStringGeometry_,\n          'MultiPolygon': this.writeMultiPolygonGeometry_,\n          'GeometryCollection': this.writeGeometryCollectionGeometry_,\n          'Circle': this.writeCircleGeometry_\n        };\n      }\n\n      if (PointerInteraction$$1) Snap.__proto__ = PointerInteraction$$1;\n      Snap.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      Snap.prototype.constructor = Snap;\n      /**\n       * Add a feature to the collection of features that we may snap to.\n       * @param {import(\"../Feature.js\").default} feature Feature.\n       * @param {boolean=} opt_listen Whether to listen to the feature change or not\n       *     Defaults to `true`.\n       * @api\n       */\n\n      Snap.prototype.addFeature = function addFeature(feature, opt_listen) {\n        var register = opt_listen !== undefined ? opt_listen : true;\n        var feature_uid = getUid(feature);\n        var geometry = feature.getGeometry();\n\n        if (geometry) {\n          var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n\n          if (segmentWriter) {\n            this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n            segmentWriter.call(this, feature, geometry);\n          }\n        }\n\n        if (register) {\n          this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature.\n       * @private\n       */\n\n\n      Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_(feature) {\n        this.addFeature(feature);\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature.\n       * @private\n       */\n\n\n      Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_(feature) {\n        this.removeFeature(feature);\n      };\n      /**\n       * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n       * @private\n       */\n\n\n      Snap.prototype.getFeatures_ = function getFeatures_() {\n        var features;\n\n        if (this.features_) {\n          features = this.features_;\n        } else if (this.source_) {\n          features = this.source_.getFeatures();\n        }\n\n        return features;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Snap.prototype.handleEvent = function handleEvent(evt) {\n        var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n        if (result.snapped) {\n          evt.coordinate = result.vertex.slice(0, 2);\n          evt.pixel = result.vertexPixel;\n        }\n\n        return PointerInteraction$$1.prototype.handleEvent.call(this, evt);\n      };\n      /**\n       * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n       * @private\n       */\n\n\n      Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_(evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.addFeature(feature);\n      };\n      /**\n       * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n       * @private\n       */\n\n\n      Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_(evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.removeFeature(feature);\n      };\n      /**\n       * @param {import(\"../events/Event.js\").default} evt Event.\n       * @private\n       */\n\n\n      Snap.prototype.handleFeatureChange_ = function handleFeatureChange_(evt) {\n        var feature =\n        /** @type {import(\"../Feature.js\").default} */\n        evt.target;\n\n        if (this.handlingDownUpSequence) {\n          var uid = getUid(feature);\n\n          if (!(uid in this.pendingFeatures_)) {\n            this.pendingFeatures_[uid] = feature;\n          }\n        } else {\n          this.updateFeature_(feature);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Snap.prototype.handleUpEvent = function handleUpEvent(evt) {\n        var featuresToUpdate = getValues(this.pendingFeatures_);\n\n        if (featuresToUpdate.length) {\n          featuresToUpdate.forEach(this.updateFeature_.bind(this));\n          this.pendingFeatures_ = {};\n        }\n\n        return false;\n      };\n      /**\n       * Remove a feature from the collection of features that we may snap to.\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n       *     or not. Defaults to `true`.\n       * @api\n       */\n\n\n      Snap.prototype.removeFeature = function removeFeature(feature, opt_unlisten) {\n        var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n        var feature_uid = getUid(feature);\n        var extent = this.indexedFeaturesExtents_[feature_uid];\n\n        if (extent) {\n          var rBush = this.rBush_;\n          var nodesToRemove = [];\n          rBush.forEachInExtent(extent, function (node) {\n            if (feature === node.feature) {\n              nodesToRemove.push(node);\n            }\n          });\n\n          for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n            rBush.remove(nodesToRemove[i]);\n          }\n        }\n\n        if (unregister) {\n          unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n          delete this.featureChangeListenerKeys_[feature_uid];\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Snap.prototype.setMap = function setMap(map) {\n        var currentMap = this.getMap();\n        var keys = this.featuresListenerKeys_;\n        var features =\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        this.getFeatures_();\n\n        if (currentMap) {\n          keys.forEach(unlistenByKey);\n          keys.length = 0;\n          features.forEach(this.forEachFeatureRemove_.bind(this));\n        }\n\n        PointerInteraction$$1.prototype.setMap.call(this, map);\n\n        if (map) {\n          if (this.features_) {\n            keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n          } else if (this.source_) {\n            keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n          }\n\n          features.forEach(this.forEachFeatureAdd_.bind(this));\n        }\n      };\n      /**\n       * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n       * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @return {Result} Snap result\n       */\n\n\n      Snap.prototype.snapTo = function snapTo(pixel, pixelCoordinate, map) {\n        var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n        var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n        var box = boundingExtent([lowerLeft, upperRight]);\n        var segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles\n\n        if (this.vertex_ && !this.edge_) {\n          segments = segments.filter(function (segment) {\n            return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n          });\n        }\n\n        var snappedToVertex = false;\n        var snapped = false;\n        var vertex = null;\n        var vertexPixel = null;\n        var dist, pixel1, pixel2, squaredDist1, squaredDist2;\n\n        if (segments.length > 0) {\n          this.pixelCoordinate_ = pixelCoordinate;\n          segments.sort(this.sortByDistance_);\n          var closestSegment = segments[0].segment;\n          var isCircle = segments[0].feature.getGeometry().getType() === GeometryType.CIRCLE;\n\n          if (this.vertex_ && !this.edge_) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredDistance$1(pixel, pixel1);\n            squaredDist2 = squaredDistance$1(pixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n\n            if (snappedToVertex) {\n              snapped = true;\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          } else if (this.edge_) {\n            if (isCircle) {\n              vertex = closestOnCircle(pixelCoordinate,\n              /** @type {import(\"../geom/Circle.js\").default} */\n              segments[0].feature.getGeometry());\n            } else {\n              vertex = closestOnSegment(pixelCoordinate, closestSegment);\n            }\n\n            vertexPixel = map.getPixelFromCoordinate(vertex);\n\n            if (distance(pixel, vertexPixel) <= this.pixelTolerance_) {\n              snapped = true;\n\n              if (this.vertex_ && !isCircle) {\n                pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n                pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n                squaredDist1 = squaredDistance$1(vertexPixel, pixel1);\n                squaredDist2 = squaredDistance$1(vertexPixel, pixel2);\n                dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n                snappedToVertex = dist <= this.pixelTolerance_;\n\n                if (snappedToVertex) {\n                  vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n                  vertexPixel = map.getPixelFromCoordinate(vertex);\n                }\n              }\n            }\n          }\n\n          if (snapped) {\n            vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n          }\n        }\n\n        return (\n          /** @type {Result} */\n          {\n            snapped: snapped,\n            vertex: vertex,\n            vertexPixel: vertexPixel\n          }\n        );\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @private\n       */\n\n\n      Snap.prototype.updateFeature_ = function updateFeature_(feature) {\n        this.removeFeature(feature, false);\n        this.addFeature(feature, false);\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_(feature, geometry) {\n        var polygon = fromCircle(geometry);\n        var coordinates = polygon.getCoordinates()[0];\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData =\n          /** @type {SegmentData} */\n          {\n            feature: feature,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_(feature, geometry) {\n        var geometries = geometry.getGeometriesArray();\n\n        for (var i = 0; i < geometries.length; ++i) {\n          var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n\n          if (segmentWriter) {\n            segmentWriter.call(this, feature, geometries[i]);\n          }\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_(feature, geometry) {\n        var coordinates = geometry.getCoordinates();\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData =\n          /** @type {SegmentData} */\n          {\n            feature: feature,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_(feature, geometry) {\n        var lines = geometry.getCoordinates();\n\n        for (var j = 0, jj = lines.length; j < jj; ++j) {\n          var coordinates = lines[j];\n\n          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            var segment = coordinates.slice(i, i + 2);\n            var segmentData =\n            /** @type {SegmentData} */\n            {\n              feature: feature,\n              segment: segment\n            };\n            this.rBush_.insert(boundingExtent(segment), segmentData);\n          }\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_(feature, geometry) {\n        var points = geometry.getCoordinates();\n\n        for (var i = 0, ii = points.length; i < ii; ++i) {\n          var coordinates = points[i];\n          var segmentData =\n          /** @type {SegmentData} */\n          {\n            feature: feature,\n            segment: [coordinates, coordinates]\n          };\n          this.rBush_.insert(geometry.getExtent(), segmentData);\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_(feature, geometry) {\n        var polygons = geometry.getCoordinates();\n\n        for (var k = 0, kk = polygons.length; k < kk; ++k) {\n          var rings = polygons[k];\n\n          for (var j = 0, jj = rings.length; j < jj; ++j) {\n            var coordinates = rings[j];\n\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n              var segment = coordinates.slice(i, i + 2);\n              var segmentData =\n              /** @type {SegmentData} */\n              {\n                feature: feature,\n                segment: segment\n              };\n              this.rBush_.insert(boundingExtent(segment), segmentData);\n            }\n          }\n        }\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writePointGeometry_ = function writePointGeometry_(feature, geometry) {\n        var coordinates = geometry.getCoordinates();\n        var segmentData =\n        /** @type {SegmentData} */\n        {\n          feature: feature,\n          segment: [coordinates, coordinates]\n        };\n        this.rBush_.insert(geometry.getExtent(), segmentData);\n      };\n      /**\n       * @param {import(\"../Feature.js\").default} feature Feature\n       * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n       * @private\n       */\n\n\n      Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_(feature, geometry) {\n        var rings = geometry.getCoordinates();\n\n        for (var j = 0, jj = rings.length; j < jj; ++j) {\n          var coordinates = rings[j];\n\n          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            var segment = coordinates.slice(i, i + 2);\n            var segmentData =\n            /** @type {SegmentData} */\n            {\n              feature: feature,\n              segment: segment\n            };\n            this.rBush_.insert(boundingExtent(segment), segmentData);\n          }\n        }\n      };\n\n      return Snap;\n    }(PointerInteraction);\n    /**\n     * Sort segments by distance, helper function\n     * @param {SegmentData} a The first segment data.\n     * @param {SegmentData} b The second segment data.\n     * @return {number} The difference in distance.\n     * @this {Snap}\n     */\n\n\n    function sortByDistance(a, b) {\n      var deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n      var deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n      return deltaA - deltaB;\n    }\n    /**\n     * @module ol/interaction/Translate\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var TranslateEventType = {\n      /**\n       * Triggered upon feature translation start.\n       * @event TranslateEvent#translatestart\n       * @api\n       */\n      TRANSLATESTART: 'translatestart',\n\n      /**\n       * Triggered upon feature translation.\n       * @event TranslateEvent#translating\n       * @api\n       */\n      TRANSLATING: 'translating',\n\n      /**\n       * Triggered upon feature translation end.\n       * @event TranslateEvent#translateend\n       * @api\n       */\n      TRANSLATEEND: 'translateend'\n    };\n    /**\n     * @typedef {Object} Options\n     * @property {Collection<import(\"../Feature.js\").default>} [features] Only features contained in this collection will be able to be translated. If\n     * not specified, all features on the map will be able to be translated.\n     * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default): boolean} [layers] A list of layers from which features should be\n     * translated. Alternatively, a filter function can be provided. The\n     * function will be called for each layer in the map and should return\n     * `true` for layers that you want to be translatable. If the option is\n     * absent, all visible layers will be considered translatable.\n     * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n     * will be checked for features. This only works for the canvas renderer and\n     * not for WebGL.\n     */\n\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n     * are instances of this type.\n     */\n\n    var TranslateEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function TranslateEvent(type, features, coordinate) {\n        Event$$1.call(this, type);\n        /**\n         * The features being translated.\n         * @type {Collection<import(\"../Feature.js\").default>}\n         * @api\n         */\n\n        this.features = features;\n        /**\n         * The coordinate of the drag event.\n         * @const\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @api\n         */\n\n        this.coordinate = coordinate;\n      }\n\n      if (Event$$1) TranslateEvent.__proto__ = Event$$1;\n      TranslateEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      TranslateEvent.prototype.constructor = TranslateEvent;\n      return TranslateEvent;\n    }(Event);\n    /**\n     * @classdesc\n     * Interaction for translating (moving) features.\n     *\n     * @fires TranslateEvent\n     * @api\n     */\n\n\n    var Translate =\n    /*@__PURE__*/\n    function (PointerInteraction$$1) {\n      function Translate(opt_options) {\n        var options = opt_options ? opt_options : {};\n        PointerInteraction$$1.call(\n        /** @type {import(\"./Pointer.js\").Options} */\n        this, options);\n        /**\n         * The last position we translated to.\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n\n        this.lastCoordinate_ = null;\n        /**\n         * @type {Collection<import(\"../Feature.js\").default>}\n         * @private\n         */\n\n        this.features_ = options.features !== undefined ? options.features : null;\n        /** @type {function(import(\"../layer/Layer.js\").default): boolean} */\n\n        var layerFilter;\n\n        if (options.layers) {\n          if (typeof options.layers === 'function') {\n            layerFilter = options.layers;\n          } else {\n            var layers = options.layers;\n\n            layerFilter = function layerFilter(layer) {\n              return includes(layers, layer);\n            };\n          }\n        } else {\n          layerFilter = TRUE;\n        }\n        /**\n         * @private\n         * @type {function(import(\"../layer/Layer.js\").default): boolean}\n         */\n\n\n        this.layerFilter_ = layerFilter;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n        /**\n         * @type {import(\"../Feature.js\").default}\n         * @private\n         */\n\n        this.lastFeature_ = null;\n        listen(this, getChangeEventType(InteractionProperty.ACTIVE), this.handleActiveChanged_, this);\n      }\n\n      if (PointerInteraction$$1) Translate.__proto__ = PointerInteraction$$1;\n      Translate.prototype = Object.create(PointerInteraction$$1 && PointerInteraction$$1.prototype);\n      Translate.prototype.constructor = Translate;\n      /**\n       * @inheritDoc\n       */\n\n      Translate.prototype.handleDownEvent = function handleDownEvent(event) {\n        this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n\n        if (!this.lastCoordinate_ && this.lastFeature_) {\n          this.lastCoordinate_ = event.coordinate;\n          this.handleMoveEvent(event);\n          var features = this.features_ || new Collection([this.lastFeature_]);\n          this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate));\n          return true;\n        }\n\n        return false;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Translate.prototype.handleUpEvent = function handleUpEvent(event) {\n        if (this.lastCoordinate_) {\n          this.lastCoordinate_ = null;\n          this.handleMoveEvent(event);\n          var features = this.features_ || new Collection([this.lastFeature_]);\n          this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate));\n          return true;\n        }\n\n        return false;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Translate.prototype.handleDragEvent = function handleDragEvent(event) {\n        if (this.lastCoordinate_) {\n          var newCoordinate = event.coordinate;\n          var deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n          var deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n          var features = this.features_ || new Collection([this.lastFeature_]);\n          features.forEach(function (feature) {\n            var geom = feature.getGeometry();\n            geom.translate(deltaX, deltaY);\n            feature.setGeometry(geom);\n          });\n          this.lastCoordinate_ = newCoordinate;\n          this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate));\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Translate.prototype.handleMoveEvent = function handleMoveEvent(event) {\n        var elem = event.map.getViewport(); // Change the cursor to grab/grabbing if hovering any of the features managed\n        // by the interaction\n\n        if (this.featuresAtPixel_(event.pixel, event.map)) {\n          elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n          elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n        } else {\n          elem.classList.remove('ol-grab', 'ol-grabbing');\n        }\n      };\n      /**\n       * Tests to see if the given coordinates intersects any of our selected\n       * features.\n       * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n       * @param {import(\"../PluggableMap.js\").default} map Map to test the intersection on.\n       * @return {import(\"../Feature.js\").default} Returns the feature found at the specified pixel\n       * coordinates.\n       * @private\n       */\n\n\n      Translate.prototype.featuresAtPixel_ = function featuresAtPixel_(pixel, map) {\n        return map.forEachFeatureAtPixel(pixel, function (feature) {\n          if (!this.features_ || includes(this.features_.getArray(), feature)) {\n            return feature;\n          }\n        }.bind(this), {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_\n        });\n      };\n      /**\n       * Returns the Hit-detection tolerance.\n       * @returns {number} Hit tolerance in pixels.\n       * @api\n       */\n\n\n      Translate.prototype.getHitTolerance = function getHitTolerance() {\n        return this.hitTolerance_;\n      };\n      /**\n       * Hit-detection tolerance. Pixels inside the radius around the given position\n       * will be checked for features. This only works for the canvas renderer and\n       * not for WebGL.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @api\n       */\n\n\n      Translate.prototype.setHitTolerance = function setHitTolerance(hitTolerance) {\n        this.hitTolerance_ = hitTolerance;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      Translate.prototype.setMap = function setMap(map) {\n        var oldMap = this.getMap();\n        PointerInteraction$$1.prototype.setMap.call(this, map);\n        this.updateState_(oldMap);\n      };\n      /**\n       * @private\n       */\n\n\n      Translate.prototype.handleActiveChanged_ = function handleActiveChanged_() {\n        this.updateState_(null);\n      };\n      /**\n       * @param {import(\"../PluggableMap.js\").default} oldMap Old map.\n       * @private\n       */\n\n\n      Translate.prototype.updateState_ = function updateState_(oldMap) {\n        var map = this.getMap();\n        var active = this.getActive();\n\n        if (!map || !active) {\n          map = map || oldMap;\n\n          if (map) {\n            var elem = map.getViewport();\n            elem.classList.remove('ol-grab', 'ol-grabbing');\n          }\n        }\n      };\n\n      return Translate;\n    }(PointerInteraction);\n    /**\n     * @module ol/interaction\n     */\n\n    /**\n     * @typedef {Object} DefaultsOptions\n     * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is\n     * desired.\n     * @property {boolean} [onFocusOnly=false] Interact only when the map has the\n     * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is\n     * useful when page scroll is desired for maps that do not have the browser's\n     * focus.\n     * @property {boolean} [constrainResolution=false] Zoom to the closest integer\n     * zoom level after the wheel/trackpad or pinch gesture ends.\n     * @property {boolean} [doubleClickZoom=true] Whether double click zoom is\n     * desired.\n     * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.\n     * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.\n     * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.\n     * @property {boolean} [dragPan=true] Whether drag pan is desired.\n     * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.\n     * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.\n     * @property {number} [zoomDelta] Zoom level delta when using keyboard or\n     * mousewheel zoom.\n     * @property {number} [zoomDuration] Duration of the zoom animation in\n     * milliseconds.\n     */\n\n    /**\n     * Set of interactions included in maps by default. Specific interactions can be\n     * excluded by setting the appropriate option to false in the constructor\n     * options, but the order of the interactions is fixed.  If you want to specify\n     * a different order for interactions, you will need to create your own\n     * {@link module:ol/interaction/Interaction} instances and insert\n     * them into a {@link module:ol/Collection} in the order you want\n     * before creating your {@link module:ol/Map~Map} instance. The default set of\n     * interactions, in sequence, is:\n     * * {@link module:ol/interaction/DragRotate~DragRotate}\n     * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}\n     * * {@link module:ol/interaction/DragPan~DragPan}\n     * * {@link module:ol/interaction/PinchRotate~PinchRotate}\n     * * {@link module:ol/interaction/PinchZoom~PinchZoom}\n     * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}\n     * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}\n     * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}\n     * * {@link module:ol/interaction/DragZoom~DragZoom}\n     *\n     * @param {DefaultsOptions=} opt_options Defaults options.\n     * @return {import(\"./Collection.js\").default<import(\"./interaction/Interaction.js\").default>}\n     * A collection of interactions to be used with the {@link module:ol/Map~Map}\n     * constructor's `interactions` option.\n     * @api\n     */\n\n\n    function defaults$1(opt_options) {\n      var options = opt_options ? opt_options : {};\n      var interactions = new Collection();\n      var kinetic = new Kinetic(-0.005, 0.05, 100);\n      var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;\n\n      if (altShiftDragRotate) {\n        interactions.push(new DragRotate());\n      }\n\n      var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;\n\n      if (doubleClickZoom) {\n        interactions.push(new DoubleClickZoom({\n          delta: options.zoomDelta,\n          duration: options.zoomDuration\n        }));\n      }\n\n      var dragPan = options.dragPan !== undefined ? options.dragPan : true;\n\n      if (dragPan) {\n        interactions.push(new DragPan({\n          condition: options.onFocusOnly ? focus : undefined,\n          kinetic: kinetic\n        }));\n      }\n\n      var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;\n\n      if (pinchRotate) {\n        interactions.push(new PinchRotate());\n      }\n\n      var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\n\n      if (pinchZoom) {\n        interactions.push(new PinchZoom({\n          constrainResolution: options.constrainResolution,\n          duration: options.zoomDuration\n        }));\n      }\n\n      var keyboard = options.keyboard !== undefined ? options.keyboard : true;\n\n      if (keyboard) {\n        interactions.push(new KeyboardPan());\n        interactions.push(new KeyboardZoom({\n          delta: options.zoomDelta,\n          duration: options.zoomDuration\n        }));\n      }\n\n      var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;\n\n      if (mouseWheelZoom) {\n        interactions.push(new MouseWheelZoom({\n          condition: options.onFocusOnly ? focus : undefined,\n          constrainResolution: options.constrainResolution,\n          duration: options.zoomDuration\n        }));\n      }\n\n      var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;\n\n      if (shiftDragZoom) {\n        interactions.push(new DragZoom({\n          duration: options.zoomDuration\n        }));\n      }\n\n      return interactions;\n    }\n    /**\n     * @module ol/reproj/common\n     */\n\n    /**\n     * Default maximum allowed threshold  (in pixels) for reprojection\n     * triangulation.\n     * @type {number}\n     */\n\n\n    var ERROR_THRESHOLD = 0.5;\n    /**\n     * @module ol/ImageBase\n     */\n\n    /**\n     * @abstract\n     */\n\n    var ImageBase =\n    /*@__PURE__*/\n    function (EventTarget) {\n      function ImageBase(extent, resolution, pixelRatio, state) {\n        EventTarget.call(this);\n        /**\n         * @protected\n         * @type {import(\"./extent.js\").Extent}\n         */\n\n        this.extent = extent;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.pixelRatio_ = pixelRatio;\n        /**\n         * @protected\n         * @type {number|undefined}\n         */\n\n        this.resolution = resolution;\n        /**\n         * @protected\n         * @type {import(\"./ImageState.js\").default}\n         */\n\n        this.state = state;\n      }\n\n      if (EventTarget) ImageBase.__proto__ = EventTarget;\n      ImageBase.prototype = Object.create(EventTarget && EventTarget.prototype);\n      ImageBase.prototype.constructor = ImageBase;\n      /**\n       * @protected\n       */\n\n      ImageBase.prototype.changed = function changed() {\n        this.dispatchEvent(EventType.CHANGE);\n      };\n      /**\n       * @return {import(\"./extent.js\").Extent} Extent.\n       */\n\n\n      ImageBase.prototype.getExtent = function getExtent() {\n        return this.extent;\n      };\n      /**\n       * @abstract\n       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n       */\n\n\n      ImageBase.prototype.getImage = function getImage() {\n        return _abstract();\n      };\n      /**\n       * @return {number} PixelRatio.\n       */\n\n\n      ImageBase.prototype.getPixelRatio = function getPixelRatio() {\n        return this.pixelRatio_;\n      };\n      /**\n       * @return {number} Resolution.\n       */\n\n\n      ImageBase.prototype.getResolution = function getResolution() {\n        return (\n          /** @type {number} */\n          this.resolution\n        );\n      };\n      /**\n       * @return {import(\"./ImageState.js\").default} State.\n       */\n\n\n      ImageBase.prototype.getState = function getState() {\n        return this.state;\n      };\n      /**\n       * Load not yet loaded URI.\n       * @abstract\n       */\n\n\n      ImageBase.prototype.load = function load() {\n        _abstract();\n      };\n\n      return ImageBase;\n    }(Target);\n    /**\n     * @module ol/ImageCanvas\n     */\n\n    /**\n     * A function that is called to trigger asynchronous canvas drawing.  It is\n     * called with a \"done\" callback that should be called when drawing is done.\n     * If any error occurs during drawing, the \"done\" callback should be called with\n     * that error.\n     *\n     * @typedef {function(function(Error=))} Loader\n     */\n\n\n    var ImageCanvas =\n    /*@__PURE__*/\n    function (ImageBase$$1) {\n      function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {\n        var state = opt_loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\n        ImageBase$$1.call(this, extent, resolution, pixelRatio, state);\n        /**\n         * Optional canvas loader function.\n         * @type {?Loader}\n         * @private\n         */\n\n        this.loader_ = opt_loader !== undefined ? opt_loader : null;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.canvas_ = canvas;\n        /**\n         * @private\n         * @type {Error}\n         */\n\n        this.error_ = null;\n      }\n\n      if (ImageBase$$1) ImageCanvas.__proto__ = ImageBase$$1;\n      ImageCanvas.prototype = Object.create(ImageBase$$1 && ImageBase$$1.prototype);\n      ImageCanvas.prototype.constructor = ImageCanvas;\n      /**\n       * Get any error associated with asynchronous rendering.\n       * @return {Error} Any error that occurred during rendering.\n       */\n\n      ImageCanvas.prototype.getError = function getError() {\n        return this.error_;\n      };\n      /**\n       * Handle async drawing complete.\n       * @param {Error=} err Any error during drawing.\n       * @private\n       */\n\n\n      ImageCanvas.prototype.handleLoad_ = function handleLoad_(err) {\n        if (err) {\n          this.error_ = err;\n          this.state = ImageState.ERROR;\n        } else {\n          this.state = ImageState.LOADED;\n        }\n\n        this.changed();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ImageCanvas.prototype.load = function load() {\n        if (this.state == ImageState.IDLE) {\n          this.state = ImageState.LOADING;\n          this.changed();\n          this.loader_(this.handleLoad_.bind(this));\n        }\n      };\n      /**\n       * @return {HTMLCanvasElement} Canvas element.\n       */\n\n\n      ImageCanvas.prototype.getImage = function getImage() {\n        return this.canvas_;\n      };\n\n      return ImageCanvas;\n    }(ImageBase);\n    /**\n     * @module ol/render/Event\n     */\n\n\n    var RenderEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function RenderEvent(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {\n        Event$$1.call(this, type);\n        /**\n         * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.\n         * @type {import(\"./VectorContext.js\").default|undefined}\n         * @api\n         */\n\n        this.vectorContext = opt_vectorContext;\n        /**\n         * An object representing the current render frame state.\n         * @type {import(\"../PluggableMap.js\").FrameState|undefined}\n         * @api\n         */\n\n        this.frameState = opt_frameState;\n        /**\n         * Canvas context. Only available when a Canvas renderer is used, null\n         * otherwise.\n         * @type {CanvasRenderingContext2D|null|undefined}\n         * @api\n         */\n\n        this.context = opt_context;\n        /**\n         * WebGL context. Only available when a WebGL renderer is used, null\n         * otherwise.\n         * @type {import(\"../webgl/Context.js\").default|null|undefined}\n         * @api\n         */\n\n        this.glContext = opt_glContext;\n      }\n\n      if (Event$$1) RenderEvent.__proto__ = Event$$1;\n      RenderEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      RenderEvent.prototype.constructor = RenderEvent;\n      return RenderEvent;\n    }(Event);\n    /**\n     * @module ol/render/VectorContext\n     */\n\n    /**\n     * @classdesc\n     * Context for drawing geometries.  A vector context is available on render\n     * events and does not need to be constructed directly.\n     * @api\n     */\n\n\n    var VectorContext = function VectorContext() {};\n\n    VectorContext.prototype.drawCustom = function drawCustom(geometry, feature, renderer) {};\n    /**\n     * Render a geometry.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry The geometry to render.\n     */\n\n\n    VectorContext.prototype.drawGeometry = function drawGeometry(geometry) {};\n    /**\n     * Set the rendering style.\n     *\n     * @param {import(\"../style/Style.js\").default} style The rendering style.\n     */\n\n\n    VectorContext.prototype.setStyle = function setStyle(style) {};\n    /**\n     * @param {import(\"../geom/Circle.js\").default} circleGeometry Circle geometry.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawCircle = function drawCircle(circleGeometry, feature) {};\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     */\n\n\n    VectorContext.prototype.drawFeature = function drawFeature(feature, style) {};\n    /**\n     * @param {import(\"../geom/GeometryCollection.js\").default} geometryCollectionGeometry Geometry collection.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawGeometryCollection = function drawGeometryCollection(geometryCollectionGeometry, feature) {};\n    /**\n     * @param {import(\"../geom/LineString.js\").default|import(\"./Feature.js\").default} lineStringGeometry Line string geometry.\n     * @param {import(\"../Feature.js\").default|import(\"./Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawLineString = function drawLineString(lineStringGeometry, feature) {};\n    /**\n     * @param {import(\"../geom/MultiLineString.js\").default|import(\"./Feature.js\").default} multiLineStringGeometry MultiLineString geometry.\n     * @param {import(\"../Feature.js\").default|import(\"./Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawMultiLineString = function drawMultiLineString(multiLineStringGeometry, feature) {};\n    /**\n     * @param {import(\"../geom/MultiPoint.js\").default|import(\"./Feature.js\").default} multiPointGeometry MultiPoint geometry.\n     * @param {import(\"../Feature.js\").default|import(\"./Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawMultiPoint = function drawMultiPoint(multiPointGeometry, feature) {};\n    /**\n     * @param {import(\"../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n     * @param {import(\"../Feature.js\").default|import(\"./Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {};\n    /**\n     * @param {import(\"../geom/Point.js\").default|import(\"./Feature.js\").default} pointGeometry Point geometry.\n     * @param {import(\"../Feature.js\").default|import(\"./Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawPoint = function drawPoint(pointGeometry, feature) {};\n    /**\n     * @param {import(\"../geom/Polygon.js\").default|import(\"./Feature.js\").default} polygonGeometry Polygon geometry.\n     * @param {import(\"../Feature.js\").default|import(\"./Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {};\n    /**\n     * @param {import(\"../geom/Geometry.js\").default|import(\"./Feature.js\").default} geometry Geometry.\n     * @param {import(\"../Feature.js\").default|import(\"./Feature.js\").default} feature Feature.\n     */\n\n\n    VectorContext.prototype.drawText = function drawText(geometry, feature) {};\n    /**\n     * @param {import(\"../style/Fill.js\").default} fillStyle Fill style.\n     * @param {import(\"../style/Stroke.js\").default} strokeStyle Stroke style.\n     */\n\n\n    VectorContext.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {};\n    /**\n     * @param {import(\"../style/Image.js\").default} imageStyle Image style.\n     * @param {import(\"./canvas.js\").DeclutterGroup=} opt_declutterGroup Declutter.\n     */\n\n\n    VectorContext.prototype.setImageStyle = function setImageStyle(imageStyle, opt_declutterGroup) {};\n    /**\n     * @param {import(\"../style/Text.js\").default} textStyle Text style.\n     * @param {import(\"./canvas.js\").DeclutterGroup=} opt_declutterGroup Declutter.\n     */\n\n\n    VectorContext.prototype.setTextStyle = function setTextStyle(textStyle, opt_declutterGroup) {};\n    /**\n     * @module ol/render/canvas/Immediate\n     */\n\n    /**\n     * @classdesc\n     * A concrete subclass of {@link module:ol/render/VectorContext} that implements\n     * direct rendering of features and geometries to an HTML5 Canvas context.\n     * Instances of this class are created internally by the library and\n     * provided to application code as vectorContext member of the\n     * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and\n     * render events emitted by layers and maps.\n     */\n\n\n    var CanvasImmediateRenderer =\n    /*@__PURE__*/\n    function (VectorContext$$1) {\n      function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation) {\n        VectorContext$$1.call(this);\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.context_ = context;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.extent_ = extent;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.transform_ = transform;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.viewRotation_ = viewRotation;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").FillState}\n         */\n\n        this.contextFillState_ = null;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").StrokeState}\n         */\n\n        this.contextStrokeState_ = null;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").TextState}\n         */\n\n        this.contextTextState_ = null;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").FillState}\n         */\n\n        this.fillState_ = null;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").StrokeState}\n         */\n\n        this.strokeState_ = null;\n        /**\n         * @private\n         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}\n         */\n\n        this.image_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageAnchorX_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageAnchorY_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageHeight_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageOpacity_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageOriginX_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageOriginY_ = 0;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.imageRotateWithView_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageRotation_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageScale_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.imageWidth_ = 0;\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.text_ = '';\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.textOffsetX_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.textOffsetY_ = 0;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.textRotateWithView_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.textRotation_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.textScale_ = 0;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").FillState}\n         */\n\n        this.textFillState_ = null;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").StrokeState}\n         */\n\n        this.textStrokeState_ = null;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").TextState}\n         */\n\n        this.textState_ = null;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.pixelCoordinates_ = [];\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.tmpLocalTransform_ = create();\n      }\n\n      if (VectorContext$$1) CanvasImmediateRenderer.__proto__ = VectorContext$$1;\n      CanvasImmediateRenderer.prototype = Object.create(VectorContext$$1 && VectorContext$$1.prototype);\n      CanvasImmediateRenderer.prototype.constructor = CanvasImmediateRenderer;\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @private\n       */\n\n      CanvasImmediateRenderer.prototype.drawImages_ = function drawImages_(flatCoordinates, offset, end, stride) {\n        if (!this.image_) {\n          return;\n        }\n\n        var pixelCoordinates = transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);\n        var context = this.context_;\n        var localTransform = this.tmpLocalTransform_;\n        var alpha = context.globalAlpha;\n\n        if (this.imageOpacity_ != 1) {\n          context.globalAlpha = alpha * this.imageOpacity_;\n        }\n\n        var rotation = this.imageRotation_;\n\n        if (this.imageRotateWithView_) {\n          rotation += this.viewRotation_;\n        }\n\n        for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {\n          var x = pixelCoordinates[i] - this.imageAnchorX_;\n          var y = pixelCoordinates[i + 1] - this.imageAnchorY_;\n\n          if (rotation !== 0 || this.imageScale_ != 1) {\n            var centerX = x + this.imageAnchorX_;\n            var centerY = y + this.imageAnchorY_;\n            compose(localTransform, centerX, centerY, this.imageScale_, this.imageScale_, rotation, -centerX, -centerY);\n            context.setTransform.apply(context, localTransform);\n          }\n\n          context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);\n        }\n\n        if (rotation !== 0 || this.imageScale_ != 1) {\n          context.setTransform(1, 0, 0, 1, 0, 0);\n        }\n\n        if (this.imageOpacity_ != 1) {\n          context.globalAlpha = alpha;\n        }\n      };\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @private\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawText_ = function drawText_(flatCoordinates, offset, end, stride) {\n        if (!this.textState_ || this.text_ === '') {\n          return;\n        }\n\n        if (this.textFillState_) {\n          this.setContextFillState_(this.textFillState_);\n        }\n\n        if (this.textStrokeState_) {\n          this.setContextStrokeState_(this.textStrokeState_);\n        }\n\n        this.setContextTextState_(this.textState_);\n        var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);\n        var context = this.context_;\n        var rotation = this.textRotation_;\n\n        if (this.textRotateWithView_) {\n          rotation += this.viewRotation_;\n        }\n\n        for (; offset < end; offset += stride) {\n          var x = pixelCoordinates[offset] + this.textOffsetX_;\n          var y = pixelCoordinates[offset + 1] + this.textOffsetY_;\n\n          if (rotation !== 0 || this.textScale_ != 1) {\n            var localTransform = compose(this.tmpLocalTransform_, x, y, this.textScale_, this.textScale_, rotation, -x, -y);\n            context.setTransform.apply(context, localTransform);\n          }\n\n          if (this.textStrokeState_) {\n            context.strokeText(this.text_, x, y);\n          }\n\n          if (this.textFillState_) {\n            context.fillText(this.text_, x, y);\n          }\n        }\n\n        if (rotation !== 0 || this.textScale_ != 1) {\n          context.setTransform(1, 0, 0, 1, 0, 0);\n        }\n      };\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @param {boolean} close Close.\n       * @private\n       * @return {number} end End.\n       */\n\n\n      CanvasImmediateRenderer.prototype.moveToLineTo_ = function moveToLineTo_(flatCoordinates, offset, end, stride, close) {\n        var context = this.context_;\n        var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);\n        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);\n        var length = pixelCoordinates.length;\n\n        if (close) {\n          length -= 2;\n        }\n\n        for (var i = 2; i < length; i += 2) {\n          context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);\n        }\n\n        if (close) {\n          context.closePath();\n        }\n\n        return end;\n      };\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {Array<number>} ends Ends.\n       * @param {number} stride Stride.\n       * @private\n       * @return {number} End.\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawRings_ = function drawRings_(flatCoordinates, offset, ends, stride) {\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);\n        }\n\n        return offset;\n      };\n      /**\n       * Render a circle geometry into the canvas.  Rendering is immediate and uses\n       * the current fill and stroke styles.\n       *\n       * @param {import(\"../../geom/Circle.js\").default} geometry Circle geometry.\n       * @override\n       * @api\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawCircle = function drawCircle(geometry) {\n        if (!intersects(this.extent_, geometry.getExtent())) {\n          return;\n        }\n\n        if (this.fillState_ || this.strokeState_) {\n          if (this.fillState_) {\n            this.setContextFillState_(this.fillState_);\n          }\n\n          if (this.strokeState_) {\n            this.setContextStrokeState_(this.strokeState_);\n          }\n\n          var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);\n          var dx = pixelCoordinates[2] - pixelCoordinates[0];\n          var dy = pixelCoordinates[3] - pixelCoordinates[1];\n          var radius = Math.sqrt(dx * dx + dy * dy);\n          var context = this.context_;\n          context.beginPath();\n          context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);\n\n          if (this.fillState_) {\n            context.fill();\n          }\n\n          if (this.strokeState_) {\n            context.stroke();\n          }\n        }\n\n        if (this.text_ !== '') {\n          this.drawText_(geometry.getCenter(), 0, 2, 2);\n        }\n      };\n      /**\n       * Set the rendering style.  Note that since this is an immediate rendering API,\n       * any `zIndex` on the provided style will be ignored.\n       *\n       * @param {import(\"../../style/Style.js\").default} style The rendering style.\n       * @override\n       * @api\n       */\n\n\n      CanvasImmediateRenderer.prototype.setStyle = function setStyle(style) {\n        this.setFillStrokeStyle(style.getFill(), style.getStroke());\n        this.setImageStyle(style.getImage());\n        this.setTextStyle(style.getText());\n      };\n      /**\n       * Render a geometry into the canvas.  Call\n       * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.\n       *\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry The geometry to render.\n       * @override\n       * @api\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawGeometry = function drawGeometry(geometry) {\n        var type = geometry.getType();\n\n        switch (type) {\n          case GeometryType.POINT:\n            this.drawPoint(\n            /** @type {import(\"../../geom/Point.js\").default} */\n            geometry);\n            break;\n\n          case GeometryType.LINE_STRING:\n            this.drawLineString(\n            /** @type {import(\"../../geom/LineString.js\").default} */\n            geometry);\n            break;\n\n          case GeometryType.POLYGON:\n            this.drawPolygon(\n            /** @type {import(\"../../geom/Polygon.js\").default} */\n            geometry);\n            break;\n\n          case GeometryType.MULTI_POINT:\n            this.drawMultiPoint(\n            /** @type {import(\"../../geom/MultiPoint.js\").default} */\n            geometry);\n            break;\n\n          case GeometryType.MULTI_LINE_STRING:\n            this.drawMultiLineString(\n            /** @type {import(\"../../geom/MultiLineString.js\").default} */\n            geometry);\n            break;\n\n          case GeometryType.MULTI_POLYGON:\n            this.drawMultiPolygon(\n            /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n            geometry);\n            break;\n\n          case GeometryType.GEOMETRY_COLLECTION:\n            this.drawGeometryCollection(\n            /** @type {import(\"../../geom/GeometryCollection.js\").default} */\n            geometry);\n            break;\n\n          case GeometryType.CIRCLE:\n            this.drawCircle(\n            /** @type {import(\"../../geom/Circle.js\").default} */\n            geometry);\n            break;\n\n          default:\n        }\n      };\n      /**\n       * Render a feature into the canvas.  Note that any `zIndex` on the provided\n       * style will be ignored - features are rendered immediately in the order that\n       * this method is called.  If you need `zIndex` support, you should be using an\n       * {@link module:ol/layer/Vector~VectorLayer} instead.\n       *\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       * @param {import(\"../../style/Style.js\").default} style Style.\n       * @override\n       * @api\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawFeature = function drawFeature(feature, style) {\n        var geometry = style.getGeometryFunction()(feature);\n\n        if (!geometry || !intersects(this.extent_, geometry.getExtent())) {\n          return;\n        }\n\n        this.setStyle(style);\n        this.drawGeometry(geometry);\n      };\n      /**\n       * Render a GeometryCollection to the canvas.  Rendering is immediate and\n       * uses the current styles appropriate for each geometry in the collection.\n       *\n       * @param {import(\"../../geom/GeometryCollection.js\").default} geometry Geometry collection.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection(geometry) {\n        var geometries = geometry.getGeometriesArray();\n\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n          this.drawGeometry(geometries[i]);\n        }\n      };\n      /**\n       * Render a Point geometry into the canvas.  Rendering is immediate and uses\n       * the current style.\n       *\n       * @param {import(\"../../geom/Point.js\").default|import(\"../Feature.js\").default} geometry Point geometry.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawPoint = function drawPoint(geometry) {\n        var flatCoordinates = geometry.getFlatCoordinates();\n        var stride = geometry.getStride();\n\n        if (this.image_) {\n          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n        }\n\n        if (this.text_ !== '') {\n          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n        }\n      };\n      /**\n       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and\n       * uses the current style.\n       *\n       * @param {import(\"../../geom/MultiPoint.js\").default|import(\"../Feature.js\").default} geometry MultiPoint geometry.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint(geometry) {\n        var flatCoordinates = geometry.getFlatCoordinates();\n        var stride = geometry.getStride();\n\n        if (this.image_) {\n          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n        }\n\n        if (this.text_ !== '') {\n          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n        }\n      };\n      /**\n       * Render a LineString into the canvas.  Rendering is immediate and uses\n       * the current style.\n       *\n       * @param {import(\"../../geom/LineString.js\").default|import(\"../Feature.js\").default} geometry LineString geometry.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawLineString = function drawLineString(geometry) {\n        if (!intersects(this.extent_, geometry.getExtent())) {\n          return;\n        }\n\n        if (this.strokeState_) {\n          this.setContextStrokeState_(this.strokeState_);\n          var context = this.context_;\n          var flatCoordinates = geometry.getFlatCoordinates();\n          context.beginPath();\n          this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);\n          context.stroke();\n        }\n\n        if (this.text_ !== '') {\n          var flatMidpoint = geometry.getFlatMidpoint();\n          this.drawText_(flatMidpoint, 0, 2, 2);\n        }\n      };\n      /**\n       * Render a MultiLineString geometry into the canvas.  Rendering is immediate\n       * and uses the current style.\n       *\n       * @param {import(\"../../geom/MultiLineString.js\").default|import(\"../Feature.js\").default} geometry MultiLineString geometry.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString(geometry) {\n        var geometryExtent = geometry.getExtent();\n\n        if (!intersects(this.extent_, geometryExtent)) {\n          return;\n        }\n\n        if (this.strokeState_) {\n          this.setContextStrokeState_(this.strokeState_);\n          var context = this.context_;\n          var flatCoordinates = geometry.getFlatCoordinates();\n          var offset = 0;\n          var ends =\n          /** @type {Array<number>} */\n          geometry.getEnds();\n          var stride = geometry.getStride();\n          context.beginPath();\n\n          for (var i = 0, ii = ends.length; i < ii; ++i) {\n            offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);\n          }\n\n          context.stroke();\n        }\n\n        if (this.text_ !== '') {\n          var flatMidpoints = geometry.getFlatMidpoints();\n          this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);\n        }\n      };\n      /**\n       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses\n       * the current style.\n       *\n       * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} geometry Polygon geometry.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawPolygon = function drawPolygon(geometry) {\n        if (!intersects(this.extent_, geometry.getExtent())) {\n          return;\n        }\n\n        if (this.strokeState_ || this.fillState_) {\n          if (this.fillState_) {\n            this.setContextFillState_(this.fillState_);\n          }\n\n          if (this.strokeState_) {\n            this.setContextStrokeState_(this.strokeState_);\n          }\n\n          var context = this.context_;\n          context.beginPath();\n          this.drawRings_(geometry.getOrientedFlatCoordinates(), 0,\n          /** @type {Array<number>} */\n          geometry.getEnds(), geometry.getStride());\n\n          if (this.fillState_) {\n            context.fill();\n          }\n\n          if (this.strokeState_) {\n            context.stroke();\n          }\n        }\n\n        if (this.text_ !== '') {\n          var flatInteriorPoint = geometry.getFlatInteriorPoint();\n          this.drawText_(flatInteriorPoint, 0, 2, 2);\n        }\n      };\n      /**\n       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and\n       * uses the current style.\n       * @param {import(\"../../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon(geometry) {\n        if (!intersects(this.extent_, geometry.getExtent())) {\n          return;\n        }\n\n        if (this.strokeState_ || this.fillState_) {\n          if (this.fillState_) {\n            this.setContextFillState_(this.fillState_);\n          }\n\n          if (this.strokeState_) {\n            this.setContextStrokeState_(this.strokeState_);\n          }\n\n          var context = this.context_;\n          var flatCoordinates = geometry.getOrientedFlatCoordinates();\n          var offset = 0;\n          var endss = geometry.getEndss();\n          var stride = geometry.getStride();\n          context.beginPath();\n\n          for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var ends = endss[i];\n            offset = this.drawRings_(flatCoordinates, offset, ends, stride);\n          }\n\n          if (this.fillState_) {\n            context.fill();\n          }\n\n          if (this.strokeState_) {\n            context.stroke();\n          }\n        }\n\n        if (this.text_ !== '') {\n          var flatInteriorPoints = geometry.getFlatInteriorPoints();\n          this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);\n        }\n      };\n      /**\n       * @param {import(\"../canvas.js\").FillState} fillState Fill state.\n       * @private\n       */\n\n\n      CanvasImmediateRenderer.prototype.setContextFillState_ = function setContextFillState_(fillState) {\n        var context = this.context_;\n        var contextFillState = this.contextFillState_;\n\n        if (!contextFillState) {\n          context.fillStyle = fillState.fillStyle;\n          this.contextFillState_ = {\n            fillStyle: fillState.fillStyle\n          };\n        } else {\n          if (contextFillState.fillStyle != fillState.fillStyle) {\n            contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;\n          }\n        }\n      };\n      /**\n       * @param {import(\"../canvas.js\").StrokeState} strokeState Stroke state.\n       * @private\n       */\n\n\n      CanvasImmediateRenderer.prototype.setContextStrokeState_ = function setContextStrokeState_(strokeState) {\n        var context = this.context_;\n        var contextStrokeState = this.contextStrokeState_;\n\n        if (!contextStrokeState) {\n          context.lineCap =\n          /** @type {CanvasLineCap} */\n          strokeState.lineCap;\n\n          if (CANVAS_LINE_DASH) {\n            context.setLineDash(strokeState.lineDash);\n            context.lineDashOffset = strokeState.lineDashOffset;\n          }\n\n          context.lineJoin =\n          /** @type {CanvasLineJoin} */\n          strokeState.lineJoin;\n          context.lineWidth = strokeState.lineWidth;\n          context.miterLimit = strokeState.miterLimit;\n          context.strokeStyle = strokeState.strokeStyle;\n          this.contextStrokeState_ = {\n            lineCap: strokeState.lineCap,\n            lineDash: strokeState.lineDash,\n            lineDashOffset: strokeState.lineDashOffset,\n            lineJoin: strokeState.lineJoin,\n            lineWidth: strokeState.lineWidth,\n            miterLimit: strokeState.miterLimit,\n            strokeStyle: strokeState.strokeStyle\n          };\n        } else {\n          if (contextStrokeState.lineCap != strokeState.lineCap) {\n            contextStrokeState.lineCap = context.lineCap =\n            /** @type {CanvasLineCap} */\n            strokeState.lineCap;\n          }\n\n          if (CANVAS_LINE_DASH) {\n            if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {\n              context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);\n            }\n\n            if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {\n              contextStrokeState.lineDashOffset = context.lineDashOffset = strokeState.lineDashOffset;\n            }\n          }\n\n          if (contextStrokeState.lineJoin != strokeState.lineJoin) {\n            contextStrokeState.lineJoin = context.lineJoin =\n            /** @type {CanvasLineJoin} */\n            strokeState.lineJoin;\n          }\n\n          if (contextStrokeState.lineWidth != strokeState.lineWidth) {\n            contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;\n          }\n\n          if (contextStrokeState.miterLimit != strokeState.miterLimit) {\n            contextStrokeState.miterLimit = context.miterLimit = strokeState.miterLimit;\n          }\n\n          if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {\n            contextStrokeState.strokeStyle = context.strokeStyle = strokeState.strokeStyle;\n          }\n        }\n      };\n      /**\n       * @param {import(\"../canvas.js\").TextState} textState Text state.\n       * @private\n       */\n\n\n      CanvasImmediateRenderer.prototype.setContextTextState_ = function setContextTextState_(textState) {\n        var context = this.context_;\n        var contextTextState = this.contextTextState_;\n        var textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;\n\n        if (!contextTextState) {\n          context.font = textState.font;\n          context.textAlign =\n          /** @type {CanvasTextAlign} */\n          textAlign;\n          context.textBaseline =\n          /** @type {CanvasTextBaseline} */\n          textState.textBaseline;\n          this.contextTextState_ = {\n            font: textState.font,\n            textAlign: textAlign,\n            textBaseline: textState.textBaseline\n          };\n        } else {\n          if (contextTextState.font != textState.font) {\n            contextTextState.font = context.font = textState.font;\n          }\n\n          if (contextTextState.textAlign != textAlign) {\n            contextTextState.textAlign = context.textAlign =\n            /** @type {CanvasTextAlign} */\n            textAlign;\n          }\n\n          if (contextTextState.textBaseline != textState.textBaseline) {\n            contextTextState.textBaseline = context.textBaseline =\n            /** @type {CanvasTextBaseline} */\n            textState.textBaseline;\n          }\n        }\n      };\n      /**\n       * Set the fill and stroke style for subsequent draw operations.  To clear\n       * either fill or stroke styles, pass null for the appropriate parameter.\n       *\n       * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n       * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n        if (!fillStyle) {\n          this.fillState_ = null;\n        } else {\n          var fillStyleColor = fillStyle.getColor();\n          this.fillState_ = {\n            fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)\n          };\n        }\n\n        if (!strokeStyle) {\n          this.strokeState_ = null;\n        } else {\n          var strokeStyleColor = strokeStyle.getColor();\n          var strokeStyleLineCap = strokeStyle.getLineCap();\n          var strokeStyleLineDash = strokeStyle.getLineDash();\n          var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n          var strokeStyleLineJoin = strokeStyle.getLineJoin();\n          var strokeStyleWidth = strokeStyle.getWidth();\n          var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n          this.strokeState_ = {\n            lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap,\n            lineDash: strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash,\n            lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset,\n            lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin,\n            lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth),\n            miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit,\n            strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)\n          };\n        }\n      };\n      /**\n       * Set the image style for subsequent draw operations.  Pass null to remove\n       * the image style.\n       *\n       * @param {import(\"../../style/Image.js\").default} imageStyle Image style.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.setImageStyle = function setImageStyle(imageStyle) {\n        if (!imageStyle) {\n          this.image_ = null;\n        } else {\n          var imageAnchor = imageStyle.getAnchor(); // FIXME pixel ratio\n\n          var imageImage = imageStyle.getImage(1);\n          var imageOrigin = imageStyle.getOrigin();\n          var imageSize = imageStyle.getSize();\n          this.imageAnchorX_ = imageAnchor[0];\n          this.imageAnchorY_ = imageAnchor[1];\n          this.imageHeight_ = imageSize[1];\n          this.image_ = imageImage;\n          this.imageOpacity_ = imageStyle.getOpacity();\n          this.imageOriginX_ = imageOrigin[0];\n          this.imageOriginY_ = imageOrigin[1];\n          this.imageRotateWithView_ = imageStyle.getRotateWithView();\n          this.imageRotation_ = imageStyle.getRotation();\n          this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;\n          this.imageWidth_ = imageSize[0];\n        }\n      };\n      /**\n       * Set the text style for subsequent draw operations.  Pass null to\n       * remove the text style.\n       *\n       * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n       * @override\n       */\n\n\n      CanvasImmediateRenderer.prototype.setTextStyle = function setTextStyle(textStyle) {\n        if (!textStyle) {\n          this.text_ = '';\n        } else {\n          var textFillStyle = textStyle.getFill();\n\n          if (!textFillStyle) {\n            this.textFillState_ = null;\n          } else {\n            var textFillStyleColor = textFillStyle.getColor();\n            this.textFillState_ = {\n              fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)\n            };\n          }\n\n          var textStrokeStyle = textStyle.getStroke();\n\n          if (!textStrokeStyle) {\n            this.textStrokeState_ = null;\n          } else {\n            var textStrokeStyleColor = textStrokeStyle.getColor();\n            var textStrokeStyleLineCap = textStrokeStyle.getLineCap();\n            var textStrokeStyleLineDash = textStrokeStyle.getLineDash();\n            var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();\n            var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();\n            var textStrokeStyleWidth = textStrokeStyle.getWidth();\n            var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();\n            this.textStrokeState_ = {\n              lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : defaultLineCap,\n              lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,\n              lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,\n              lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : defaultLineJoin,\n              lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : defaultLineWidth,\n              miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : defaultMiterLimit,\n              strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)\n            };\n          }\n\n          var textFont = textStyle.getFont();\n          var textOffsetX = textStyle.getOffsetX();\n          var textOffsetY = textStyle.getOffsetY();\n          var textRotateWithView = textStyle.getRotateWithView();\n          var textRotation = textStyle.getRotation();\n          var textScale = textStyle.getScale();\n          var textText = textStyle.getText();\n          var textTextAlign = textStyle.getTextAlign();\n          var textTextBaseline = textStyle.getTextBaseline();\n          this.textState_ = {\n            font: textFont !== undefined ? textFont : defaultFont,\n            textAlign: textTextAlign !== undefined ? textTextAlign : defaultTextAlign,\n            textBaseline: textTextBaseline !== undefined ? textTextBaseline : defaultTextBaseline\n          };\n          this.text_ = textText !== undefined ? textText : '';\n          this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;\n          this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;\n          this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;\n          this.textRotation_ = textRotation !== undefined ? textRotation : 0;\n          this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);\n        }\n      };\n\n      return CanvasImmediateRenderer;\n    }(VectorContext);\n    /**\n     * @module ol/style/IconImageCache\n     */\n\n    /**\n     * @classdesc\n     * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.\n     */\n\n\n    var IconImageCache = function IconImageCache() {\n      /**\n      * @type {!Object<string, import(\"./IconImage.js\").default>}\n      * @private\n      */\n      this.cache_ = {};\n      /**\n      * @type {number}\n      * @private\n      */\n\n      this.cacheSize_ = 0;\n      /**\n      * @type {number}\n      * @private\n      */\n\n      this.maxCacheSize_ = 32;\n    };\n    /**\n    * FIXME empty description for jsdoc\n    */\n\n\n    IconImageCache.prototype.clear = function clear() {\n      this.cache_ = {};\n      this.cacheSize_ = 0;\n    };\n    /**\n    * FIXME empty description for jsdoc\n    */\n\n\n    IconImageCache.prototype.expire = function expire() {\n      if (this.cacheSize_ > this.maxCacheSize_) {\n        var i = 0;\n\n        for (var key in this.cache_) {\n          var iconImage = this.cache_[key];\n\n          if ((i++ & 3) === 0 && !iconImage.hasListener()) {\n            delete this.cache_[key];\n            --this.cacheSize_;\n          }\n        }\n      }\n    };\n    /**\n    * @param {string} src Src.\n    * @param {?string} crossOrigin Cross origin.\n    * @param {import(\"../color.js\").Color} color Color.\n    * @return {import(\"./IconImage.js\").default} Icon image.\n    */\n\n\n    IconImageCache.prototype.get = function get(src, crossOrigin, color) {\n      var key = getKey(src, crossOrigin, color);\n      return key in this.cache_ ? this.cache_[key] : null;\n    };\n    /**\n    * @param {string} src Src.\n    * @param {?string} crossOrigin Cross origin.\n    * @param {import(\"../color.js\").Color} color Color.\n    * @param {import(\"./IconImage.js\").default} iconImage Icon image.\n    */\n\n\n    IconImageCache.prototype.set = function set(src, crossOrigin, color, iconImage) {\n      var key = getKey(src, crossOrigin, color);\n      this.cache_[key] = iconImage;\n      ++this.cacheSize_;\n    };\n    /**\n    * Set the cache size of the icon cache. Default is `32`. Change this value when\n    * your map uses more than 32 different icon images and you are not caching icon\n    * styles on the application level.\n    * @param {number} maxCacheSize Cache max size.\n    * @api\n    */\n\n\n    IconImageCache.prototype.setSize = function setSize(maxCacheSize) {\n      this.maxCacheSize_ = maxCacheSize;\n      this.expire();\n    };\n    /**\n     * @param {string} src Src.\n     * @param {?string} crossOrigin Cross origin.\n     * @param {import(\"../color.js\").Color} color Color.\n     * @return {string} Cache key.\n     */\n\n\n    function getKey(src, crossOrigin, color) {\n      var colorString = color ? asString(color) : 'null';\n      return crossOrigin + ':' + src + ':' + colorString;\n    }\n    /**\n     * The {@link module:ol/style/IconImageCache~IconImageCache} for\n     * {@link module:ol/style/Icon~Icon} images.\n     * @api\n     */\n\n\n    var shared = new IconImageCache();\n    /**\n     * @module ol/renderer/Map\n     */\n\n    /**\n     * @abstract\n     */\n\n    var MapRenderer =\n    /*@__PURE__*/\n    function (Disposable$$1) {\n      function MapRenderer(map) {\n        Disposable$$1.call(this);\n        /**\n         * @private\n         * @type {import(\"../PluggableMap.js\").default}\n         */\n\n        this.map_ = map;\n        /**\n         * @private\n         * @type {!Object<string, import(\"./Layer.js\").default>}\n         */\n\n        this.layerRenderers_ = {};\n        /**\n         * @private\n         * @type {Object<string, import(\"../events.js\").EventsKey>}\n         */\n\n        this.layerRendererListeners_ = {};\n        /**\n         * @private\n         * @type {Array<typeof import(\"./Layer.js\").default>}\n         */\n\n        this.layerRendererConstructors_ = [];\n      }\n\n      if (Disposable$$1) MapRenderer.__proto__ = Disposable$$1;\n      MapRenderer.prototype = Object.create(Disposable$$1 && Disposable$$1.prototype);\n      MapRenderer.prototype.constructor = MapRenderer;\n      /**\n       * @abstract\n       * @param {import(\"../render/EventType.js\").default} type Event type.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n\n      MapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent(type, frameState) {\n        _abstract();\n      };\n      /**\n       * Register layer renderer constructors.\n       * @param {Array<typeof import(\"./Layer.js\").default>} constructors Layer renderers.\n       */\n\n\n      MapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers(constructors) {\n        this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);\n      };\n      /**\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n       * @protected\n       */\n\n\n      MapRenderer.prototype.calculateMatrices2D = function calculateMatrices2D(frameState) {\n        var viewState = frameState.viewState;\n        var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n        var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n        compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n        invert(setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));\n      };\n      /**\n       * Removes all layer renderers.\n       */\n\n\n      MapRenderer.prototype.removeLayerRenderers = function removeLayerRenderers() {\n        for (var key in this.layerRenderers_) {\n          this.removeLayerRendererByKey_(key).dispose();\n        }\n      };\n      /**\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @param {function(this: S, import(\"../Feature.js\").FeatureLike,\n       *     import(\"../layer/Layer.js\").default): T} callback Feature callback.\n       * @param {S} thisArg Value to use as `this` when executing `callback`.\n       * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n       *     function, only layers which are visible and for which this function\n       *     returns `true` will be tested for features.  By default, all visible\n       *     layers will be tested.\n       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n       * @return {T|undefined} Callback result.\n       * @template S,T,U\n       */\n\n\n      MapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n        var result;\n        var viewState = frameState.viewState;\n        var viewResolution = viewState.resolution;\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {?} Callback result.\n         */\n\n        function forEachFeatureAtCoordinate(feature, layer) {\n          var managed = frameState.layerStates[getUid(layer)].managed;\n\n          if (!(getUid(feature) in frameState.skippedFeatureUids && !managed)) {\n            return callback.call(thisArg, feature, managed ? layer : null);\n          }\n        }\n\n        var projection = viewState.projection;\n        var translatedCoordinate = coordinate;\n\n        if (projection.canWrapX()) {\n          var projectionExtent = projection.getExtent();\n          var worldWidth = getWidth(projectionExtent);\n          var x = coordinate[0];\n\n          if (x < projectionExtent[0] || x > projectionExtent[2]) {\n            var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);\n            translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];\n          }\n        }\n\n        var layerStates = frameState.layerStatesArray;\n        var numLayers = layerStates.length;\n        var i;\n\n        for (i = numLayers - 1; i >= 0; --i) {\n          var layerState = layerStates[i];\n          var layer = layerState.layer;\n\n          if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\n            var layerRenderer = this.getLayerRenderer(layer);\n            var source =\n            /** @type {import(\"../layer/Layer.js\").default} */\n            layer.getSource();\n\n            if (source) {\n              result = layerRenderer.forEachFeatureAtCoordinate(source.getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate);\n            }\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @abstract\n       * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @param {function(this: S, import(\"../layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n       *     callback.\n       * @param {S} thisArg Value to use as `this` when executing `callback`.\n       * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n       *     function, only layers which are visible and for which this function\n       *     returns `true` will be tested for features.  By default, all visible\n       *     layers will be tested.\n       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n       * @return {T|undefined} Callback result.\n       * @template S,T,U\n       */\n\n\n      MapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n        return _abstract();\n      };\n      /**\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n       *     function, only layers which are visible and for which this function\n       *     returns `true` will be tested for features.  By default, all visible\n       *     layers will be tested.\n       * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n       * @return {boolean} Is there a feature at the given coordinate?\n       * @template U\n       */\n\n\n      MapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, layerFilter, thisArg) {\n        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, TRUE, this, layerFilter, thisArg);\n        return hasFeature !== undefined;\n      };\n      /**\n       * @param {import(\"../layer/Base.js\").default} layer Layer.\n       * @protected\n       * @return {import(\"./Layer.js\").default} Layer renderer.\n       */\n\n\n      MapRenderer.prototype.getLayerRenderer = function getLayerRenderer(layer) {\n        var layerKey = getUid(layer);\n\n        if (layerKey in this.layerRenderers_) {\n          return this.layerRenderers_[layerKey];\n        } else {\n          var renderer;\n\n          for (var i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {\n            var candidate = this.layerRendererConstructors_[i];\n\n            if (candidate['handles'](layer)) {\n              renderer = candidate['create'](this, layer);\n              break;\n            }\n          }\n\n          if (renderer) {\n            this.layerRenderers_[layerKey] = renderer;\n            this.layerRendererListeners_[layerKey] = listen(renderer, EventType.CHANGE, this.handleLayerRendererChange_, this);\n          } else {\n            throw new Error('Unable to create renderer for layer: ' + layer.getType());\n          }\n\n          return renderer;\n        }\n      };\n      /**\n       * @param {string} layerKey Layer key.\n       * @protected\n       * @return {import(\"./Layer.js\").default} Layer renderer.\n       */\n\n\n      MapRenderer.prototype.getLayerRendererByKey = function getLayerRendererByKey(layerKey) {\n        return this.layerRenderers_[layerKey];\n      };\n      /**\n       * @protected\n       * @return {Object<string, import(\"./Layer.js\").default>} Layer renderers.\n       */\n\n\n      MapRenderer.prototype.getLayerRenderers = function getLayerRenderers() {\n        return this.layerRenderers_;\n      };\n      /**\n       * @return {import(\"../PluggableMap.js\").default} Map.\n       */\n\n\n      MapRenderer.prototype.getMap = function getMap() {\n        return this.map_;\n      };\n      /**\n       * Handle changes in a layer renderer.\n       * @private\n       */\n\n\n      MapRenderer.prototype.handleLayerRendererChange_ = function handleLayerRendererChange_() {\n        this.map_.render();\n      };\n      /**\n       * @param {string} layerKey Layer key.\n       * @return {import(\"./Layer.js\").default} Layer renderer.\n       * @private\n       */\n\n\n      MapRenderer.prototype.removeLayerRendererByKey_ = function removeLayerRendererByKey_(layerKey) {\n        var layerRenderer = this.layerRenderers_[layerKey];\n        delete this.layerRenderers_[layerKey];\n        unlistenByKey(this.layerRendererListeners_[layerKey]);\n        delete this.layerRendererListeners_[layerKey];\n        return layerRenderer;\n      };\n      /**\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @private\n       */\n\n\n      MapRenderer.prototype.removeUnusedLayerRenderers_ = function removeUnusedLayerRenderers_(map, frameState) {\n        for (var layerKey in this.layerRenderers_) {\n          if (!frameState || !(layerKey in frameState.layerStates)) {\n            this.removeLayerRendererByKey_(layerKey).dispose();\n          }\n        }\n      };\n      /**\n       * Render.\n       * @abstract\n       * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n\n\n      MapRenderer.prototype.renderFrame = function renderFrame(frameState) {\n        _abstract();\n      };\n      /**\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @protected\n       */\n\n\n      MapRenderer.prototype.scheduleExpireIconCache = function scheduleExpireIconCache(frameState) {\n        frameState.postRenderFunctions.push(\n        /** @type {import(\"../PluggableMap.js\").PostRenderFunction} */\n        expireIconCache);\n      };\n      /**\n       * @param {!import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @protected\n       */\n\n\n      MapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function scheduleRemoveUnusedLayerRenderers(frameState) {\n        for (var layerKey in this.layerRenderers_) {\n          if (!(layerKey in frameState.layerStates)) {\n            frameState.postRenderFunctions.push(\n            /** @type {import(\"../PluggableMap.js\").PostRenderFunction} */\n            this.removeUnusedLayerRenderers_.bind(this));\n            return;\n          }\n        }\n      };\n\n      return MapRenderer;\n    }(Disposable);\n    /**\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n\n\n    function expireIconCache(map, frameState) {\n      shared.expire();\n    }\n    /**\n     * @param {import(\"../layer/Layer.js\").State} state1 First layer state.\n     * @param {import(\"../layer/Layer.js\").State} state2 Second layer state.\n     * @return {number} The zIndex difference.\n     */\n\n\n    function sortByZIndex(state1, state2) {\n      return state1.zIndex - state2.zIndex;\n    }\n    /**\n     * @module ol/renderer/canvas/Map\n     */\n\n    /**\n     * @type {Array<typeof import(\"../Layer.js\").default>}\n     */\n\n\n    var layerRendererConstructors = [];\n    /**\n     * @classdesc\n     * Canvas map renderer.\n     * @api\n     */\n\n    var CanvasMapRenderer =\n    /*@__PURE__*/\n    function (MapRenderer$$1) {\n      function CanvasMapRenderer(map) {\n        MapRenderer$$1.call(this, map);\n        var container = map.getViewport();\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.context_ = createCanvasContext2D();\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.canvas_ = this.context_.canvas;\n        this.canvas_.style.width = '100%';\n        this.canvas_.style.height = '100%';\n        this.canvas_.style.display = 'block';\n        this.canvas_.className = CLASS_UNSELECTABLE;\n        container.insertBefore(this.canvas_, container.childNodes[0] || null);\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.renderedVisible_ = true;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.transform_ = create();\n      }\n\n      if (MapRenderer$$1) CanvasMapRenderer.__proto__ = MapRenderer$$1;\n      CanvasMapRenderer.prototype = Object.create(MapRenderer$$1 && MapRenderer$$1.prototype);\n      CanvasMapRenderer.prototype.constructor = CanvasMapRenderer;\n      /**\n       * @param {import(\"../../render/EventType.js\").default} type Event type.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n\n      CanvasMapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent(type, frameState) {\n        var map = this.getMap();\n        var context = this.context_;\n\n        if (map.hasListener(type)) {\n          var extent = frameState.extent;\n          var pixelRatio = frameState.pixelRatio;\n          var viewState = frameState.viewState;\n          var rotation = viewState.rotation;\n          var transform = this.getTransform(frameState);\n          var vectorContext = new CanvasImmediateRenderer(context, pixelRatio, extent, transform, rotation);\n          var composeEvent = new RenderEvent(type, vectorContext, frameState, context, null);\n          map.dispatchEvent(composeEvent);\n        }\n      };\n      /**\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @protected\n       * @return {!import(\"../../transform.js\").Transform} Transform.\n       */\n\n\n      CanvasMapRenderer.prototype.getTransform = function getTransform(frameState) {\n        var viewState = frameState.viewState;\n        var dx1 = this.canvas_.width / 2;\n        var dy1 = this.canvas_.height / 2;\n        var sx = frameState.pixelRatio / viewState.resolution;\n        var sy = -sx;\n        var angle = -viewState.rotation;\n        var dx2 = -viewState.center[0];\n        var dy2 = -viewState.center[1];\n        return compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasMapRenderer.prototype.renderFrame = function renderFrame(frameState) {\n        if (!frameState) {\n          if (this.renderedVisible_) {\n            this.canvas_.style.display = 'none';\n            this.renderedVisible_ = false;\n          }\n\n          return;\n        }\n\n        var context = this.context_;\n        var pixelRatio = frameState.pixelRatio;\n        var width = Math.round(frameState.size[0] * pixelRatio);\n        var height = Math.round(frameState.size[1] * pixelRatio);\n\n        if (this.canvas_.width != width || this.canvas_.height != height) {\n          this.canvas_.width = width;\n          this.canvas_.height = height;\n        } else {\n          context.clearRect(0, 0, width, height);\n        }\n\n        var rotation = frameState.viewState.rotation;\n        this.calculateMatrices2D(frameState);\n        this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n        var layerStatesArray = frameState.layerStatesArray;\n        stableSort(layerStatesArray, sortByZIndex);\n\n        if (rotation) {\n          context.save();\n          rotateAtOffset(context, rotation, width / 2, height / 2);\n        }\n\n        var viewResolution = frameState.viewState.resolution;\n        var i, ii;\n\n        for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n          var layerState = layerStatesArray[i];\n          var layer = layerState.layer;\n          var layerRenderer =\n          /** @type {import(\"./Layer.js\").default} */\n          this.getLayerRenderer(layer);\n\n          if (!visibleAtResolution(layerState, viewResolution) || layerState.sourceState != SourceState.READY) {\n            continue;\n          }\n\n          if (layerRenderer.prepareFrame(frameState, layerState)) {\n            layerRenderer.composeFrame(frameState, layerState, context);\n          }\n        }\n\n        if (rotation) {\n          context.restore();\n        }\n\n        this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n\n        if (!this.renderedVisible_) {\n          this.canvas_.style.display = '';\n          this.renderedVisible_ = true;\n        }\n\n        this.scheduleRemoveUnusedLayerRenderers(frameState);\n        this.scheduleExpireIconCache(frameState);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n        var result;\n        var viewState = frameState.viewState;\n        var viewResolution = viewState.resolution;\n        var layerStates = frameState.layerStatesArray;\n        var numLayers = layerStates.length;\n        var coordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());\n        var i;\n\n        for (i = numLayers - 1; i >= 0; --i) {\n          var layerState = layerStates[i];\n          var layer = layerState.layer;\n\n          if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\n            var layerRenderer =\n            /** @type {import(\"./Layer.js\").default} */\n            this.getLayerRenderer(layer);\n            result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasMapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers(constructors) {\n        MapRenderer$$1.prototype.registerLayerRenderers.call(this, constructors);\n\n        for (var i = 0, ii = constructors.length; i < ii; ++i) {\n          var ctor = constructors[i];\n\n          if (!includes(layerRendererConstructors, ctor)) {\n            layerRendererConstructors.push(ctor);\n          }\n        }\n      };\n\n      return CanvasMapRenderer;\n    }(MapRenderer);\n    /**\n     * @module ol/renderer/Layer\n     */\n\n\n    var LayerRenderer =\n    /*@__PURE__*/\n    function (Observable$$1) {\n      function LayerRenderer(layer) {\n        Observable$$1.call(this);\n        /**\n         * @private\n         * @type {import(\"../layer/Layer.js\").default}\n         */\n\n        this.layer_ = layer;\n      }\n\n      if (Observable$$1) LayerRenderer.__proto__ = Observable$$1;\n      LayerRenderer.prototype = Object.create(Observable$$1 && Observable$$1.prototype);\n      LayerRenderer.prototype.constructor = LayerRenderer;\n      /**\n       * Create a function that adds loaded tiles to the tile lookup.\n       * @param {import(\"../source/Tile.js\").default} source Tile source.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n       * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n       * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n       *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n       * @protected\n       */\n\n      LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder(source, projection, tiles) {\n        return (\n          /**\n           * @param {number} zoom Zoom level.\n           * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n           * @return {boolean} The tile range is fully loaded.\n           */\n          function (zoom, tileRange) {\n            /**\n             * @param {import(\"../Tile.js\").default} tile Tile.\n             */\n            function callback(tile) {\n              if (!tiles[zoom]) {\n                tiles[zoom] = {};\n              }\n\n              tiles[zoom][tile.tileCoord.toString()] = tile;\n            }\n\n            return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n          }\n        );\n      };\n      /**\n       * @abstract\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @param {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default): T} callback Feature callback.\n       * @return {T|void} Callback result.\n       * @template T\n       */\n\n\n      LayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback) {};\n      /**\n       * @return {import(\"../layer/Layer.js\").default} Layer.\n       */\n\n\n      LayerRenderer.prototype.getLayer = function getLayer() {\n        return this.layer_;\n      };\n      /**\n       * Handle changes in image state.\n       * @param {import(\"../events/Event.js\").default} event Image change event.\n       * @private\n       */\n\n\n      LayerRenderer.prototype.handleImageChange_ = function handleImageChange_(event) {\n        var image =\n        /** @type {import(\"../Image.js\").default} */\n        event.target;\n\n        if (image.getState() === ImageState.LOADED) {\n          this.renderIfReadyAndVisible();\n        }\n      };\n      /**\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @return {boolean} Is there a feature at the given coordinate?\n       */\n\n\n      LayerRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, frameState) {\n        return false;\n      };\n      /**\n       * Load the image if not already loaded, and register the image change\n       * listener if needed.\n       * @param {import(\"../ImageBase.js\").default} image Image.\n       * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n       * @protected\n       */\n\n\n      LayerRenderer.prototype.loadImage = function loadImage(image) {\n        var imageState = image.getState();\n\n        if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n          listen(image, EventType.CHANGE, this.handleImageChange_, this);\n        }\n\n        if (imageState == ImageState.IDLE) {\n          image.load();\n          imageState = image.getState();\n        }\n\n        return imageState == ImageState.LOADED;\n      };\n      /**\n       * @protected\n       */\n\n\n      LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible() {\n        var layer = this.getLayer();\n\n        if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n          this.changed();\n        }\n      };\n      /**\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n       * @protected\n       */\n\n\n      LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache(frameState, tileSource) {\n        if (tileSource.canExpireCache()) {\n          /**\n           * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n           * @param {import(\"../PluggableMap.js\").default} map Map.\n           * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n           */\n          var postRenderFunction = function (tileSource, map, frameState) {\n            var tileSourceKey = getUid(tileSource);\n\n            if (tileSourceKey in frameState.usedTiles) {\n              tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n            }\n          }.bind(null, tileSource);\n\n          frameState.postRenderFunctions.push(\n          /** @type {import(\"../PluggableMap.js\").PostRenderFunction} */\n          postRenderFunction);\n        }\n      };\n      /**\n       * @param {!Object<string, !Object<string, import(\"../TileRange.js\").default>>} usedTiles Used tiles.\n       * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n       * @param {number} z Z.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @protected\n       */\n\n\n      LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles(usedTiles, tileSource, z, tileRange) {\n        // FIXME should we use tilesToDrawByZ instead?\n        var tileSourceKey = getUid(tileSource);\n        var zKey = z.toString();\n\n        if (tileSourceKey in usedTiles) {\n          if (zKey in usedTiles[tileSourceKey]) {\n            usedTiles[tileSourceKey][zKey].extend(tileRange);\n          } else {\n            usedTiles[tileSourceKey][zKey] = tileRange;\n          }\n        } else {\n          usedTiles[tileSourceKey] = {};\n          usedTiles[tileSourceKey][zKey] = tileRange;\n        }\n      };\n      /**\n       * Manage tile pyramid.\n       * This function performs a number of functions related to the tiles at the\n       * current zoom and lower zoom levels:\n       * - registers idle tiles in frameState.wantedTiles so that they are not\n       *   discarded by the tile queue\n       * - enqueues missing tiles\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @param {import(\"../extent.js\").Extent} extent Extent.\n       * @param {number} currentZ Current Z.\n       * @param {number} preload Load low resolution tiles up to 'preload' levels.\n       * @param {function(this: T, import(\"../Tile.js\").default)=} opt_tileCallback Tile callback.\n       * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n       * @protected\n       * @template T\n       */\n\n\n      LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {\n        var tileSourceKey = getUid(tileSource);\n\n        if (!(tileSourceKey in frameState.wantedTiles)) {\n          frameState.wantedTiles[tileSourceKey] = {};\n        }\n\n        var wantedTiles = frameState.wantedTiles[tileSourceKey];\n        var tileQueue = frameState.tileQueue;\n        var minZoom = tileGrid.getMinZoom();\n        var tile, tileRange, tileResolution, x, y, z;\n\n        for (z = minZoom; z <= currentZ; ++z) {\n          tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n          tileResolution = tileGrid.getResolution(z);\n\n          for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n              if (currentZ - z <= preload) {\n                tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n                if (tile.getState() == TileState.IDLE) {\n                  wantedTiles[tile.getKey()] = true;\n\n                  if (!tileQueue.isKeyQueued(tile.getKey())) {\n                    tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n                  }\n                }\n\n                if (opt_tileCallback !== undefined) {\n                  opt_tileCallback.call(opt_this, tile);\n                }\n              } else {\n                tileSource.useTile(z, x, y, projection);\n              }\n            }\n          }\n        }\n      };\n\n      return LayerRenderer;\n    }(Observable);\n    /**\n     * @module ol/renderer/canvas/Layer\n     */\n\n    /**\n     * @abstract\n     */\n\n\n    var CanvasLayerRenderer =\n    /*@__PURE__*/\n    function (LayerRenderer$$1) {\n      function CanvasLayerRenderer(layer) {\n        LayerRenderer$$1.call(this, layer);\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.renderedResolution;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.transform_ = create();\n      }\n\n      if (LayerRenderer$$1) CanvasLayerRenderer.__proto__ = LayerRenderer$$1;\n      CanvasLayerRenderer.prototype = Object.create(LayerRenderer$$1 && LayerRenderer$$1.prototype);\n      CanvasLayerRenderer.prototype.constructor = CanvasLayerRenderer;\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n       * @protected\n       */\n\n      CanvasLayerRenderer.prototype.clip = function clip(context, frameState, extent) {\n        var pixelRatio = frameState.pixelRatio;\n        var width = frameState.size[0] * pixelRatio;\n        var height = frameState.size[1] * pixelRatio;\n        var rotation = frameState.viewState.rotation;\n        var topLeft = getTopLeft(extent);\n        var topRight = getTopRight(extent);\n        var bottomRight = getBottomRight(extent);\n        var bottomLeft = getBottomLeft(extent);\n        apply(frameState.coordinateToPixelTransform, topLeft);\n        apply(frameState.coordinateToPixelTransform, topRight);\n        apply(frameState.coordinateToPixelTransform, bottomRight);\n        apply(frameState.coordinateToPixelTransform, bottomLeft);\n        context.save();\n        rotateAtOffset(context, -rotation, width / 2, height / 2);\n        context.beginPath();\n        context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);\n        context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);\n        context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);\n        context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);\n        context.clip();\n        rotateAtOffset(context, rotation, width / 2, height / 2);\n      };\n      /**\n       * @param {import(\"../../render/EventType.js\").default} type Event type.\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../transform.js\").Transform=} opt_transform Transform.\n       * @private\n       */\n\n\n      CanvasLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_(type, context, frameState, opt_transform) {\n        var layer = this.getLayer();\n\n        if (layer.hasListener(type)) {\n          var width = frameState.size[0] * frameState.pixelRatio;\n          var height = frameState.size[1] * frameState.pixelRatio;\n          var rotation = frameState.viewState.rotation;\n          rotateAtOffset(context, -rotation, width / 2, height / 2);\n          var transform = opt_transform !== undefined ? opt_transform : this.getTransform(frameState, 0);\n          var render = new CanvasImmediateRenderer(context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation);\n          var composeEvent = new RenderEvent(type, render, frameState, context, null);\n          layer.dispatchEvent(composeEvent);\n          rotateAtOffset(context, rotation, width / 2, height / 2);\n        }\n      };\n      /**\n       * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @param {function(this: S, import(\"../../layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n       *     callback.\n       * @param {S} thisArg Value to use as `this` when executing `callback`.\n       * @return {T|undefined} Callback result.\n       * @template S,T,U\n       */\n\n\n      CanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, TRUE);\n\n        if (hasFeature) {\n          return callback.call(thisArg, this.getLayer(), null);\n        } else {\n          return undefined;\n        }\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n       * @param {import(\"../../transform.js\").Transform=} opt_transform Transform.\n       * @protected\n       */\n\n\n      CanvasLayerRenderer.prototype.postCompose = function postCompose(context, frameState, layerState, opt_transform) {\n        this.dispatchComposeEvent_(RenderEventType.POSTCOMPOSE, context, frameState, opt_transform);\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../transform.js\").Transform=} opt_transform Transform.\n       * @protected\n       */\n\n\n      CanvasLayerRenderer.prototype.preCompose = function preCompose(context, frameState, opt_transform) {\n        this.dispatchComposeEvent_(RenderEventType.PRECOMPOSE, context, frameState, opt_transform);\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../transform.js\").Transform=} opt_transform Transform.\n       * @protected\n       */\n\n\n      CanvasLayerRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent(context, frameState, opt_transform) {\n        this.dispatchComposeEvent_(RenderEventType.RENDER, context, frameState, opt_transform);\n      };\n      /**\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {number} offsetX Offset on the x-axis in view coordinates.\n       * @protected\n       * @return {!import(\"../../transform.js\").Transform} Transform.\n       */\n\n\n      CanvasLayerRenderer.prototype.getTransform = function getTransform(frameState, offsetX) {\n        var viewState = frameState.viewState;\n        var pixelRatio = frameState.pixelRatio;\n        var dx1 = pixelRatio * frameState.size[0] / 2;\n        var dy1 = pixelRatio * frameState.size[1] / 2;\n        var sx = pixelRatio / viewState.resolution;\n        var sy = -sx;\n        var angle = -viewState.rotation;\n        var dx2 = -viewState.center[0] + offsetX;\n        var dy2 = -viewState.center[1];\n        return compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\n      };\n      /**\n       * @abstract\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n       * @param {CanvasRenderingContext2D} context Context.\n       */\n\n\n      CanvasLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n        _abstract();\n      };\n      /**\n       * @abstract\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n       * @return {boolean} whether composeFrame should be called.\n       */\n\n\n      CanvasLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n        return _abstract();\n      };\n\n      return CanvasLayerRenderer;\n    }(LayerRenderer);\n    /**\n     * @module ol/renderer/canvas/IntermediateCanvas\n     */\n\n    /**\n     * @abstract\n     */\n\n\n    var IntermediateCanvasRenderer =\n    /*@__PURE__*/\n    function (CanvasLayerRenderer$$1) {\n      function IntermediateCanvasRenderer(layer) {\n        CanvasLayerRenderer$$1.call(this, layer);\n        /**\n         * @protected\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.coordinateToCanvasPixelTransform = create();\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.hitCanvasContext_ = null;\n      }\n\n      if (CanvasLayerRenderer$$1) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer$$1;\n      IntermediateCanvasRenderer.prototype = Object.create(CanvasLayerRenderer$$1 && CanvasLayerRenderer$$1.prototype);\n      IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;\n      /**\n       * @inheritDoc\n       */\n\n      IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n        this.preCompose(context, frameState);\n        var image = this.getImage();\n\n        if (image) {\n          // clipped rendering if layer extent is set\n          var extent = layerState.extent;\n          var clipped = extent !== undefined && !containsExtent(extent, frameState.extent) && intersects(extent, frameState.extent);\n\n          if (clipped) {\n            this.clip(context, frameState,\n            /** @type {import(\"../../extent.js\").Extent} */\n            extent);\n          }\n\n          var imageTransform = this.getImageTransform(); // for performance reasons, context.save / context.restore is not used\n          // to save and restore the transformation matrix and the opacity.\n          // see http://jsperf.com/context-save-restore-versus-variable\n\n          var alpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity; // for performance reasons, context.setTransform is only used\n          // when the view is rotated. see http://jsperf.com/canvas-transform\n\n          var dx = imageTransform[4];\n          var dy = imageTransform[5];\n          var dw = image.width * imageTransform[0];\n          var dh = image.height * imageTransform[3];\n\n          if (dw >= 0.5 && dh >= 0.5) {\n            context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n          }\n\n          context.globalAlpha = alpha;\n\n          if (clipped) {\n            context.restore();\n          }\n        }\n\n        this.postCompose(context, frameState, layerState);\n      };\n      /**\n       * @abstract\n       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n       */\n\n\n      IntermediateCanvasRenderer.prototype.getImage = function getImage() {\n        return _abstract();\n      };\n      /**\n       * @abstract\n       * @return {!import(\"../../transform.js\").Transform} Image transform.\n       */\n\n\n      IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform() {\n        return _abstract();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n        if (!this.getImage()) {\n          return undefined;\n        }\n\n        var pixel = apply(this.coordinateToCanvasPixelTransform, coordinate.slice());\n        scale(pixel, frameState.viewState.resolution / this.renderedResolution);\n\n        if (!this.hitCanvasContext_) {\n          this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n        }\n\n        this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n        this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n        var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n\n        if (imageData[3] > 0) {\n          return callback.call(thisArg, this.getLayer(), imageData);\n        } else {\n          return undefined;\n        }\n      };\n\n      return IntermediateCanvasRenderer;\n    }(CanvasLayerRenderer);\n    /**\n     * @module ol/renderer/canvas/ImageLayer\n     */\n\n    /**\n     * @classdesc\n     * Canvas renderer for image layers.\n     * @api\n     */\n\n\n    var CanvasImageLayerRenderer =\n    /*@__PURE__*/\n    function (IntermediateCanvasRenderer$$1) {\n      function CanvasImageLayerRenderer(imageLayer) {\n        IntermediateCanvasRenderer$$1.call(this, imageLayer);\n        /**\n         * @private\n         * @type {?import(\"../../ImageBase.js\").default}\n         */\n\n        this.image_ = null;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.imageTransform_ = create();\n        /**\n         * @type {!Array<string>}\n         */\n\n        this.skippedFeatures_ = [];\n        /**\n         * @private\n         * @type {import(\"./VectorLayer.js\").default}\n         */\n\n        this.vectorRenderer_ = null;\n\n        if (imageLayer.getType() === LayerType.VECTOR) {\n          for (var i = 0, ii = layerRendererConstructors.length; i < ii; ++i) {\n            var ctor = layerRendererConstructors[i];\n\n            if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {\n              this.vectorRenderer_ =\n              /** @type {import(\"./VectorLayer.js\").default} */\n              new ctor(imageLayer);\n              break;\n            }\n          }\n        }\n      }\n\n      if (IntermediateCanvasRenderer$$1) CanvasImageLayerRenderer.__proto__ = IntermediateCanvasRenderer$$1;\n      CanvasImageLayerRenderer.prototype = Object.create(IntermediateCanvasRenderer$$1 && IntermediateCanvasRenderer$$1.prototype);\n      CanvasImageLayerRenderer.prototype.constructor = CanvasImageLayerRenderer;\n      /**\n       * @inheritDoc\n       */\n\n      CanvasImageLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n        if (this.vectorRenderer_) {\n          this.vectorRenderer_.dispose();\n        }\n\n        IntermediateCanvasRenderer$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageLayerRenderer.prototype.getImage = function getImage() {\n        return !this.image_ ? null : this.image_.getImage();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageLayerRenderer.prototype.getImageTransform = function getImageTransform() {\n        return this.imageTransform_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n        var pixelRatio = frameState.pixelRatio;\n        var size = frameState.size;\n        var viewState = frameState.viewState;\n        var viewCenter = viewState.center;\n        var viewResolution = viewState.resolution;\n        var image;\n        var imageLayer =\n        /** @type {import(\"../../layer/Image.js\").default} */\n        this.getLayer();\n        var imageSource =\n        /** @type {import(\"../../source/Image.js\").default} */\n        imageLayer.getSource();\n        var hints = frameState.viewHints;\n        var vectorRenderer = this.vectorRenderer_;\n        var renderedExtent = frameState.extent;\n\n        if (!vectorRenderer && layerState.extent !== undefined) {\n          renderedExtent = getIntersection(renderedExtent, layerState.extent);\n        }\n\n        if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty$1(renderedExtent)) {\n          var projection = viewState.projection;\n          var skippedFeatures = this.skippedFeatures_;\n\n          if (vectorRenderer) {\n            var context = vectorRenderer.context;\n            var imageFrameState =\n            /** @type {import(\"../../PluggableMap.js\").FrameState} */\n            assign({}, frameState, {\n              size: [getWidth(renderedExtent) / viewResolution, getHeight(renderedExtent) / viewResolution],\n              viewState:\n              /** @type {import(\"../../View.js\").State} */\n              assign({}, frameState.viewState, {\n                rotation: 0\n              })\n            });\n            var newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();\n            image = new ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {\n              if (vectorRenderer.prepareFrame(imageFrameState, layerState) && (vectorRenderer.replayGroupChanged || !equals(skippedFeatures, newSkippedFeatures))) {\n                context.canvas.width = imageFrameState.size[0] * pixelRatio;\n                context.canvas.height = imageFrameState.size[1] * pixelRatio;\n                vectorRenderer.compose(context, imageFrameState, layerState);\n                skippedFeatures = newSkippedFeatures;\n                callback();\n              }\n            });\n          } else {\n            image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n          }\n\n          if (image && this.loadImage(image)) {\n            this.image_ = image;\n            this.skippedFeatures_ = skippedFeatures;\n          }\n        }\n\n        if (this.image_) {\n          image = this.image_;\n          var imageExtent = image.getExtent();\n          var imageResolution = image.getResolution();\n          var imagePixelRatio = image.getPixelRatio();\n          var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);\n          var transform = compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n          compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n          this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n        }\n\n        return !!this.image_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback) {\n        if (this.vectorRenderer_) {\n          return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback);\n        } else {\n          return IntermediateCanvasRenderer$$1.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback);\n        }\n      };\n\n      return CanvasImageLayerRenderer;\n    }(IntermediateCanvasRenderer);\n    /**\n     * Determine if this renderer handles the provided layer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n     * @return {boolean} The renderer can render the layer.\n     */\n\n\n    CanvasImageLayerRenderer['handles'] = function (layer) {\n      return layer.getType() === LayerType.IMAGE || layer.getType() === LayerType.VECTOR &&\n      /** @type {import(\"../../layer/Vector.js\").default} */\n      layer.getRenderMode() === VectorRenderType.IMAGE;\n    };\n    /**\n     * Create a layer renderer.\n     * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n     * @return {CanvasImageLayerRenderer} The layer renderer.\n     */\n\n\n    CanvasImageLayerRenderer['create'] = function (mapRenderer, layer) {\n      return new CanvasImageLayerRenderer(\n      /** @type {import(\"../../layer/Image.js\").default} */\n      layer);\n    };\n    /**\n     * @module ol/TileRange\n     */\n\n    /**\n     * A representation of a contiguous block of tiles.  A tile range is specified\n     * by its min/max tile coordinates and is inclusive of coordinates.\n     */\n\n\n    var TileRange = function TileRange(minX, maxX, minY, maxY) {\n      /**\n       * @type {number}\n       */\n      this.minX = minX;\n      /**\n       * @type {number}\n       */\n\n      this.maxX = maxX;\n      /**\n       * @type {number}\n       */\n\n      this.minY = minY;\n      /**\n       * @type {number}\n       */\n\n      this.maxY = maxY;\n    };\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {boolean} Contains tile coordinate.\n     */\n\n\n    TileRange.prototype.contains = function contains(tileCoord) {\n      return this.containsXY(tileCoord[1], tileCoord[2]);\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Contains.\n     */\n\n\n    TileRange.prototype.containsTileRange = function containsTileRange(tileRange) {\n      return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;\n    };\n    /**\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @return {boolean} Contains coordinate.\n     */\n\n\n    TileRange.prototype.containsXY = function containsXY(x, y) {\n      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Equals.\n     */\n\n\n    TileRange.prototype.equals = function equals(tileRange) {\n      return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     */\n\n\n    TileRange.prototype.extend = function extend(tileRange) {\n      if (tileRange.minX < this.minX) {\n        this.minX = tileRange.minX;\n      }\n\n      if (tileRange.maxX > this.maxX) {\n        this.maxX = tileRange.maxX;\n      }\n\n      if (tileRange.minY < this.minY) {\n        this.minY = tileRange.minY;\n      }\n\n      if (tileRange.maxY > this.maxY) {\n        this.maxY = tileRange.maxY;\n      }\n    };\n    /**\n     * @return {number} Height.\n     */\n\n\n    TileRange.prototype.getHeight = function getHeight() {\n      return this.maxY - this.minY + 1;\n    };\n    /**\n     * @return {import(\"./size.js\").Size} Size.\n     */\n\n\n    TileRange.prototype.getSize = function getSize() {\n      return [this.getWidth(), this.getHeight()];\n    };\n    /**\n     * @return {number} Width.\n     */\n\n\n    TileRange.prototype.getWidth = function getWidth() {\n      return this.maxX - this.minX + 1;\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Intersects.\n     */\n\n\n    TileRange.prototype.intersects = function intersects(tileRange) {\n      return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;\n    };\n    /**\n     * @param {number} minX Minimum X.\n     * @param {number} maxX Maximum X.\n     * @param {number} minY Minimum Y.\n     * @param {number} maxY Maximum Y.\n     * @param {TileRange=} tileRange TileRange.\n     * @return {TileRange} Tile range.\n     */\n\n\n    function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {\n      if (tileRange !== undefined) {\n        tileRange.minX = minX;\n        tileRange.maxX = maxX;\n        tileRange.minY = minY;\n        tileRange.maxY = maxY;\n        return tileRange;\n      } else {\n        return new TileRange(minX, maxX, minY, maxY);\n      }\n    }\n    /**\n     * @module ol/renderer/canvas/TileLayer\n     */\n\n    /**\n     * @classdesc\n     * Canvas renderer for tile layers.\n     * @api\n     */\n\n\n    var CanvasTileLayerRenderer =\n    /*@__PURE__*/\n    function (IntermediateCanvasRenderer$$1) {\n      function CanvasTileLayerRenderer(tileLayer, opt_noContext) {\n        IntermediateCanvasRenderer$$1.call(this, tileLayer);\n        /**\n         * @protected\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.context = opt_noContext ? null : createCanvasContext2D();\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.oversampling_;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.renderedExtent_ = null;\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.renderedRevision;\n        /**\n         * @protected\n         * @type {!Array<import(\"../../Tile.js\").default>}\n         */\n\n        this.renderedTiles = [];\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.newTiles_ = false;\n        /**\n         * @protected\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.tmpExtent = createEmpty();\n        /**\n         * @private\n         * @type {import(\"../../TileRange.js\").default}\n         */\n\n        this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.imageTransform_ = create();\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.zDirection = 0;\n      }\n\n      if (IntermediateCanvasRenderer$$1) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer$$1;\n      CanvasTileLayerRenderer.prototype = Object.create(IntermediateCanvasRenderer$$1 && IntermediateCanvasRenderer$$1.prototype);\n      CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;\n      /**\n       * @private\n       * @param {import(\"../../Tile.js\").default} tile Tile.\n       * @return {boolean} Tile is drawable.\n       */\n\n      CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_(tile) {\n        var tileLayer =\n        /** @type {import(\"../../layer/Tile.js\").default} */\n        this.getLayer();\n        var tileState = tile.getState();\n        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n        return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n      };\n      /**\n       * @param {number} z Tile coordinate z.\n       * @param {number} x Tile coordinate x.\n       * @param {number} y Tile coordinate y.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n       * @return {!import(\"../../Tile.js\").default} Tile.\n       */\n\n\n      CanvasTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n        var tileLayer =\n        /** @type {import(\"../../layer/Tile.js\").default} */\n        this.getLayer();\n        var tileSource =\n        /** @type {import(\"../../source/Tile.js\").default} */\n        tileLayer.getSource();\n        var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n        if (tile.getState() == TileState.ERROR) {\n          if (!tileLayer.getUseInterimTilesOnError()) {\n            // When useInterimTilesOnError is false, we consider the error tile as loaded.\n            tile.setState(TileState.LOADED);\n          } else if (tileLayer.getPreload() > 0) {\n            // Preloaded tiles for lower resolutions might have finished loading.\n            this.newTiles_ = true;\n          }\n        }\n\n        if (!this.isDrawableTile_(tile)) {\n          tile = tile.getInterimTile();\n        }\n\n        return tile;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n        var pixelRatio = frameState.pixelRatio;\n        var size = frameState.size;\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var viewResolution = viewState.resolution;\n        var viewCenter = viewState.center;\n        var tileLayer =\n        /** @type {import(\"../../layer/Tile.js\").default} */\n        this.getLayer();\n        var tileSource =\n        /** @type {import(\"../../source/Tile.js\").default} */\n        tileLayer.getSource();\n        var sourceRevision = tileSource.getRevision();\n        var tileGrid = tileSource.getTileGridForProjection(projection);\n        var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n        var tileResolution = tileGrid.getResolution(z);\n        var oversampling = Math.round(viewResolution / tileResolution) || 1;\n        var extent = frameState.extent;\n\n        if (layerState.extent !== undefined) {\n          extent = getIntersection(extent, layerState.extent);\n        }\n\n        if (isEmpty$1(extent)) {\n          // Return false to prevent the rendering of the layer.\n          return false;\n        }\n\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n        var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n        /**\n         * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n         */\n\n        var tilesToDrawByZ = {};\n        tilesToDrawByZ[z] = {};\n        var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n        var hints = frameState.viewHints;\n        var animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n        var tmpExtent = this.tmpExtent;\n        var tmpTileRange = this.tmpTileRange_;\n        this.newTiles_ = false;\n        var tile, x, y;\n\n        for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n          for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n            if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n              continue;\n            }\n\n            tile = this.getTile(z, x, y, pixelRatio, projection);\n\n            if (this.isDrawableTile_(tile)) {\n              var uid = getUid(this);\n\n              if (tile.getState() == TileState.LOADED) {\n                tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n                var inTransition = tile.inTransition(uid);\n\n                if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n                  this.newTiles_ = true;\n                }\n              }\n\n              if (tile.getAlpha(uid, frameState.time) === 1) {\n                // don't look for alt tiles if alpha is 1\n                continue;\n              }\n            }\n\n            var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n            var covered = false;\n\n            if (childTileRange) {\n              covered = findLoadedTiles(z + 1, childTileRange);\n            }\n\n            if (!covered) {\n              tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n            }\n          }\n        }\n\n        var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n\n        if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (this.newTiles_ || !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {\n          var context = this.context;\n\n          if (context) {\n            var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n            var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n            var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n            var canvas = context.canvas;\n\n            if (canvas.width != width || canvas.height != height) {\n              this.oversampling_ = oversampling;\n              canvas.width = width;\n              canvas.height = height;\n            } else {\n              if (this.renderedExtent_ && !equals$2(imageExtent, this.renderedExtent_)) {\n                context.clearRect(0, 0, width, height);\n              }\n\n              oversampling = this.oversampling_;\n            }\n          }\n\n          this.renderedTiles.length = 0;\n          /** @type {Array<number>} */\n\n          var zs = Object.keys(tilesToDrawByZ).map(Number);\n          zs.sort(function (a, b) {\n            if (a === z) {\n              return 1;\n            } else if (b === z) {\n              return -1;\n            } else {\n              return a > b ? 1 : a < b ? -1 : 0;\n            }\n          });\n          var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n          var tileExtent, tileGutter, tilesToDraw, w, h;\n\n          for (i = 0, ii = zs.length; i < ii; ++i) {\n            currentZ = zs[i];\n            currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n            currentResolution = tileGrid.getResolution(currentZ);\n            currentScale = currentResolution / tileResolution;\n            tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n            tilesToDraw = tilesToDrawByZ[currentZ];\n\n            for (var tileCoordKey in tilesToDraw) {\n              tile = tilesToDraw[tileCoordKey];\n              tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n              x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n              y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n              w = currentTilePixelSize[0] * currentScale / oversampling;\n              h = currentTilePixelSize[1] * currentScale / oversampling;\n              this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n              this.renderedTiles.push(tile);\n            }\n          }\n\n          this.renderedRevision = sourceRevision;\n          this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n          this.renderedExtent_ = imageExtent;\n        }\n\n        var scale = this.renderedResolution / viewResolution;\n        var transform = compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n        compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n        this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n        this.scheduleExpireCache(frameState, tileSource);\n        return this.renderedTiles.length > 0;\n      };\n      /**\n       * @param {import(\"../../Tile.js\").default} tile Tile.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n       * @param {number} x Left of the tile.\n       * @param {number} y Top of the tile.\n       * @param {number} w Width of the tile.\n       * @param {number} h Height of the tile.\n       * @param {number} gutter Tile gutter.\n       * @param {boolean} transition Apply an alpha transition.\n       */\n\n\n      CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n        var image = this.getTileImage(tile);\n\n        if (!image) {\n          return;\n        }\n\n        var uid = getUid(this);\n        var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n        var tileLayer =\n        /** @type {import(\"../../layer/Tile.js\").default} */\n        this.getLayer();\n        var tileSource =\n        /** @type {import(\"../../source/Tile.js\").default} */\n        tileLayer.getSource();\n\n        if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n          this.context.clearRect(x, y, w, h);\n        }\n\n        var alphaChanged = alpha !== this.context.globalAlpha;\n\n        if (alphaChanged) {\n          this.context.save();\n          this.context.globalAlpha = alpha;\n        }\n\n        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n        if (alphaChanged) {\n          this.context.restore();\n        }\n\n        if (alpha !== 1) {\n          frameState.animate = true;\n        } else if (transition) {\n          tile.endTransition(uid);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasTileLayerRenderer.prototype.getImage = function getImage() {\n        var context = this.context;\n        return context ? context.canvas : null;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform() {\n        return this.imageTransform_;\n      };\n      /**\n       * Get the image from a tile.\n       * @param {import(\"../../Tile.js\").default} tile Tile.\n       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n       * @protected\n       */\n\n\n      CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n        return (\n          /** @type {import(\"../../ImageTile.js\").default} */\n          tile.getImage()\n        );\n      };\n\n      return CanvasTileLayerRenderer;\n    }(IntermediateCanvasRenderer);\n    /**\n     * Determine if this renderer handles the provided layer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n     * @return {boolean} The renderer can render the layer.\n     */\n\n\n    CanvasTileLayerRenderer['handles'] = function (layer) {\n      return layer.getType() === LayerType.TILE;\n    };\n    /**\n     * Create a layer renderer.\n     * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n     * @return {CanvasTileLayerRenderer} The layer renderer.\n     */\n\n\n    CanvasTileLayerRenderer['create'] = function (mapRenderer, layer) {\n      return new CanvasTileLayerRenderer(\n      /** @type {import(\"../../layer/Tile.js\").default} */\n      layer);\n    };\n    /**\n     * @function\n     * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n     */\n\n\n    CanvasTileLayerRenderer.prototype.getLayer;\n    /**\n     * @module ol/render/ReplayGroup\n     */\n\n    /**\n     * Base class for replay groups.\n     */\n\n    var ReplayGroup = function ReplayGroup() {};\n\n    ReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n      return _abstract();\n    };\n    /**\n     * @abstract\n     * @return {boolean} Is empty.\n     */\n\n\n    ReplayGroup.prototype.isEmpty = function isEmpty() {\n      return _abstract();\n    };\n    /**\n     * @abstract\n     * @param {boolean} group Group with previous replay\n     * @return {Array<*>} The resulting instruction group\n     */\n\n\n    ReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n      return _abstract();\n    };\n    /**\n     * @module ol/render/ReplayType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var ReplayType = {\n      CIRCLE: 'Circle',\n      DEFAULT: 'Default',\n      IMAGE: 'Image',\n      LINE_STRING: 'LineString',\n      POLYGON: 'Polygon',\n      TEXT: 'Text'\n    };\n    /**\n     * @module ol/geom/flat/textpath\n     */\n\n    /**\n     * @param {Array<number>} flatCoordinates Path to put text on.\n     * @param {number} offset Start offset of the `flatCoordinates`.\n     * @param {number} end End offset of the `flatCoordinates`.\n     * @param {number} stride Stride.\n     * @param {string} text Text to place on the path.\n     * @param {function(string):number} measure Measure function returning the\n     * width of the character passed as 1st argument.\n     * @param {number} startM m along the path where the text starts.\n     * @param {number} maxAngle Max angle between adjacent chars in radians.\n     * @return {Array<Array<*>>} The result array of null if `maxAngle` was\n     * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n     */\n\n    function drawTextOnPath(flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n      var result = []; // Keep text upright\n\n      var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n      var numChars = text.length;\n      var x1 = flatCoordinates[offset];\n      var y1 = flatCoordinates[offset + 1];\n      offset += stride;\n      var x2 = flatCoordinates[offset];\n      var y2 = flatCoordinates[offset + 1];\n      var segmentM = 0;\n      var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n      var chunk = '';\n      var chunkLength = 0;\n      var data, index, previousAngle;\n\n      for (var i = 0; i < numChars; ++i) {\n        index = reverse ? numChars - i - 1 : i;\n\n        var _char = text.charAt(index);\n\n        chunk = reverse ? _char + chunk : chunk + _char;\n        var charLength = measure(chunk) - chunkLength;\n        chunkLength += charLength;\n        var charM = startM + charLength / 2;\n\n        while (offset < end - stride && segmentM + segmentLength < charM) {\n          x1 = x2;\n          y1 = y2;\n          offset += stride;\n          x2 = flatCoordinates[offset];\n          y2 = flatCoordinates[offset + 1];\n          segmentM += segmentLength;\n          segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n        }\n\n        var segmentPos = charM - segmentM;\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n\n        if (reverse) {\n          angle += angle > 0 ? -Math.PI : Math.PI;\n        }\n\n        if (previousAngle !== undefined) {\n          var delta = angle - previousAngle;\n          delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;\n\n          if (Math.abs(delta) > maxAngle) {\n            return null;\n          }\n        }\n\n        var interpolate = segmentPos / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n\n        if (previousAngle == angle) {\n          if (reverse) {\n            data[0] = x;\n            data[1] = y;\n            data[2] = charLength / 2;\n          }\n\n          data[4] = chunk;\n        } else {\n          chunk = _char;\n          chunkLength = charLength;\n          data = [x, y, charLength / 2, angle, chunk];\n\n          if (reverse) {\n            result.unshift(data);\n          } else {\n            result.push(data);\n          }\n\n          previousAngle = angle;\n        }\n\n        startM += charLength;\n      }\n\n      return result;\n    }\n    /**\n     * @module ol/render/canvas/Instruction\n     */\n\n    /**\n     * @enum {number}\n     */\n\n\n    var Instruction = {\n      BEGIN_GEOMETRY: 0,\n      BEGIN_PATH: 1,\n      CIRCLE: 2,\n      CLOSE_PATH: 3,\n      CUSTOM: 4,\n      DRAW_CHARS: 5,\n      DRAW_IMAGE: 6,\n      END_GEOMETRY: 7,\n      FILL: 8,\n      MOVE_TO_LINE_TO: 9,\n      SET_FILL_STYLE: 10,\n      SET_STROKE_STYLE: 11,\n      STROKE: 12\n    };\n    /**\n     * @type {Array<Instruction>}\n     */\n\n    var fillInstruction = [Instruction.FILL];\n    /**\n     * @type {Array<Instruction>}\n     */\n\n    var strokeInstruction = [Instruction.STROKE];\n    /**\n     * @type {Array<Instruction>}\n     */\n\n    var beginPathInstruction = [Instruction.BEGIN_PATH];\n    /**\n     * @type {Array<Instruction>}\n     */\n\n    var closePathInstruction = [Instruction.CLOSE_PATH];\n    /**\n     * @module ol/render/replay\n     */\n\n    /**\n     * @const\n     * @type {Array<ReplayType>}\n     */\n\n    var ORDER = [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT];\n    /**\n     * @const\n     * @enum {number}\n     */\n\n    var TEXT_ALIGN = {};\n    TEXT_ALIGN['left'] = 0;\n    TEXT_ALIGN['end'] = 0;\n    TEXT_ALIGN['center'] = 0.5;\n    TEXT_ALIGN['right'] = 1;\n    TEXT_ALIGN['start'] = 1;\n    TEXT_ALIGN['top'] = 0;\n    TEXT_ALIGN['middle'] = 0.5;\n    TEXT_ALIGN['hanging'] = 0.2;\n    TEXT_ALIGN['alphabetic'] = 0.8;\n    TEXT_ALIGN['ideographic'] = 0.8;\n    TEXT_ALIGN['bottom'] = 1;\n    /**\n     * @module ol/render/canvas/Replay\n     */\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    var tmpExtent = createEmpty();\n    /**\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n\n    var tmpTransform$1 = create();\n\n    var CanvasReplay =\n    /*@__PURE__*/\n    function (VectorContext$$1) {\n      function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n        VectorContext$$1.call(this);\n        /**\n         * @type {?}\n         */\n\n        this.declutterTree = declutterTree;\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.tolerance = tolerance;\n        /**\n         * @protected\n         * @const\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.maxExtent = maxExtent;\n        /**\n         * @protected\n         * @type {boolean}\n         */\n\n        this.overlaps = overlaps;\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.maxLineWidth = 0;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n\n        this.resolution = resolution;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.alignFill_;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n\n        this.beginGeometryInstruction1_ = null;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n\n        this.beginGeometryInstruction2_ = null;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.bufferedMaxExtent_ = null;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n\n        this.instructions = [];\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n\n        this.coordinates = [];\n        /**\n         * @private\n         * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n         */\n\n        this.coordinateCache_ = {};\n        /**\n         * @private\n         * @type {!import(\"../../transform.js\").Transform}\n         */\n\n        this.renderedTransform_ = create();\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n\n        this.hitDetectionInstructions = [];\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.pixelCoordinates_ = null;\n        /**\n         * @protected\n         * @type {import(\"../canvas.js\").FillStrokeState}\n         */\n\n        this.state =\n        /** @type {import(\"../canvas.js\").FillStrokeState} */\n        {};\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.viewRotation_ = 0;\n      }\n\n      if (VectorContext$$1) CanvasReplay.__proto__ = VectorContext$$1;\n      CanvasReplay.prototype = Object.create(VectorContext$$1 && VectorContext$$1.prototype);\n      CanvasReplay.prototype.constructor = CanvasReplay;\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n       * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n       * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n       * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n       * @param {Array<*>} fillInstruction Fill instruction.\n       * @param {Array<*>} strokeInstruction Stroke instruction.\n       */\n\n      CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_(context, p1, p2, p3, p4, fillInstruction$$1, strokeInstruction$$1) {\n        context.beginPath();\n        context.moveTo.apply(context, p1);\n        context.lineTo.apply(context, p2);\n        context.lineTo.apply(context, p3);\n        context.lineTo.apply(context, p4);\n        context.lineTo.apply(context, p1);\n\n        if (fillInstruction$$1) {\n          this.alignFill_ =\n          /** @type {boolean} */\n          fillInstruction$$1[2];\n          this.fill_(context);\n        }\n\n        if (strokeInstruction$$1) {\n          this.setStrokeStyle_(context,\n          /** @type {Array<*>} */\n          strokeInstruction$$1);\n          context.stroke();\n        }\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {number} x X.\n       * @param {number} y Y.\n       * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n       * @param {number} anchorX Anchor X.\n       * @param {number} anchorY Anchor Y.\n       * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n       * @param {number} height Height.\n       * @param {number} opacity Opacity.\n       * @param {number} originX Origin X.\n       * @param {number} originY Origin Y.\n       * @param {number} rotation Rotation.\n       * @param {number} scale Scale.\n       * @param {boolean} snapToPixel Snap to pixel.\n       * @param {number} width Width.\n       * @param {Array<number>} padding Padding.\n       * @param {Array<*>} fillInstruction Fill instruction.\n       * @param {Array<*>} strokeInstruction Stroke instruction.\n       */\n\n\n      CanvasReplay.prototype.replayImage_ = function replayImage_(context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction$$1, strokeInstruction$$1) {\n        var fillStroke = fillInstruction$$1 || strokeInstruction$$1;\n        anchorX *= scale;\n        anchorY *= scale;\n        x -= anchorX;\n        y -= anchorY;\n        var w = width + originX > image.width ? image.width - originX : width;\n        var h = height + originY > image.height ? image.height - originY : height;\n        var boxW = padding[3] + w * scale + padding[1];\n        var boxH = padding[0] + h * scale + padding[2];\n        var boxX = x - padding[3];\n        var boxY = y - padding[0];\n        /** @type {import(\"../../coordinate.js\").Coordinate} */\n\n        var p1;\n        /** @type {import(\"../../coordinate.js\").Coordinate} */\n\n        var p2;\n        /** @type {import(\"../../coordinate.js\").Coordinate} */\n\n        var p3;\n        /** @type {import(\"../../coordinate.js\").Coordinate} */\n\n        var p4;\n\n        if (fillStroke || rotation !== 0) {\n          p1 = [boxX, boxY];\n          p2 = [boxX + boxW, boxY];\n          p3 = [boxX + boxW, boxY + boxH];\n          p4 = [boxX, boxY + boxH];\n        }\n\n        var transform = null;\n\n        if (rotation !== 0) {\n          var centerX = x + anchorX;\n          var centerY = y + anchorY;\n          transform = compose(tmpTransform$1, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n          createOrUpdateEmpty(tmpExtent);\n          extendCoordinate(tmpExtent, apply(tmpTransform$1, p1));\n          extendCoordinate(tmpExtent, apply(tmpTransform$1, p2));\n          extendCoordinate(tmpExtent, apply(tmpTransform$1, p3));\n          extendCoordinate(tmpExtent, apply(tmpTransform$1, p4));\n        } else {\n          createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n        }\n\n        var canvas = context.canvas;\n        var strokePadding = strokeInstruction$$1 ? strokeInstruction$$1[2] * scale / 2 : 0;\n        var intersects$$1 = tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 && tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;\n\n        if (snapToPixel) {\n          x = Math.round(x);\n          y = Math.round(y);\n        }\n\n        if (declutterGroup) {\n          if (!intersects$$1 && declutterGroup[4] == 1) {\n            return;\n          }\n\n          extend$1(declutterGroup, tmpExtent);\n          var declutterArgs = intersects$$1 ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;\n\n          if (declutterArgs && fillStroke) {\n            declutterArgs.push(fillInstruction$$1, strokeInstruction$$1, p1, p2, p3, p4);\n          }\n\n          declutterGroup.push(declutterArgs);\n        } else if (intersects$$1) {\n          if (fillStroke) {\n            this.replayTextBackground_(context, p1, p2, p3, p4,\n            /** @type {Array<*>} */\n            fillInstruction$$1,\n            /** @type {Array<*>} */\n            strokeInstruction$$1);\n          }\n\n          drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n        }\n      };\n      /**\n       * @protected\n       * @param {Array<number>} dashArray Dash array.\n       * @return {Array<number>} Dash array with pixel ratio applied\n       */\n\n\n      CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio(dashArray) {\n        var pixelRatio = this.pixelRatio;\n        return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n          return dash * pixelRatio;\n        });\n      };\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @param {boolean} closed Last input coordinate equals first.\n       * @param {boolean} skipFirst Skip first coordinate.\n       * @protected\n       * @return {number} My end.\n       */\n\n\n      CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n        var myEnd = this.coordinates.length;\n        var extent = this.getBufferedMaxExtent();\n\n        if (skipFirst) {\n          offset += stride;\n        }\n\n        var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n        var nextCoord = [NaN, NaN];\n        var skipped = true;\n        var i, lastRel, nextRel;\n\n        for (i = offset + stride; i < end; i += stride) {\n          nextCoord[0] = flatCoordinates[i];\n          nextCoord[1] = flatCoordinates[i + 1];\n          nextRel = coordinateRelationship(extent, nextCoord);\n\n          if (nextRel !== lastRel) {\n            if (skipped) {\n              this.coordinates[myEnd++] = lastCoord[0];\n              this.coordinates[myEnd++] = lastCoord[1];\n            }\n\n            this.coordinates[myEnd++] = nextCoord[0];\n            this.coordinates[myEnd++] = nextCoord[1];\n            skipped = false;\n          } else if (nextRel === Relationship.INTERSECTING) {\n            this.coordinates[myEnd++] = nextCoord[0];\n            this.coordinates[myEnd++] = nextCoord[1];\n            skipped = false;\n          } else {\n            skipped = true;\n          }\n\n          lastCoord[0] = nextCoord[0];\n          lastCoord[1] = nextCoord[1];\n          lastRel = nextRel;\n        } // Last coordinate equals first or only one point to append:\n\n\n        if (closed && skipped || i === offset + stride) {\n          this.coordinates[myEnd++] = lastCoord[0];\n          this.coordinates[myEnd++] = lastCoord[1];\n        }\n\n        return myEnd;\n      };\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {Array<number>} ends Ends.\n       * @param {number} stride Stride.\n       * @param {Array<number>} replayEnds Replay ends.\n       * @return {number} Offset.\n       */\n\n\n      CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, replayEnds) {\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n          var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n          replayEnds.push(replayEnd);\n          offset = end;\n        }\n\n        return offset;\n      };\n      /**\n       * @inheritDoc.\n       */\n\n\n      CanvasReplay.prototype.drawCustom = function drawCustom(geometry, feature, renderer) {\n        this.beginGeometry(geometry, feature);\n        var type = geometry.getType();\n        var stride = geometry.getStride();\n        var replayBegin = this.coordinates.length;\n        var flatCoordinates, replayEnd, replayEnds, replayEndss;\n        var offset;\n\n        if (type == GeometryType.MULTI_POLYGON) {\n          geometry =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n          geometry;\n          flatCoordinates = geometry.getOrientedFlatCoordinates();\n          replayEndss = [];\n          var endss = geometry.getEndss();\n          offset = 0;\n\n          for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var myEnds = [];\n            offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n            replayEndss.push(myEnds);\n          }\n\n          this.instructions.push([Instruction.CUSTOM, replayBegin, replayEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n        } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n          replayEnds = [];\n          flatCoordinates = type == GeometryType.POLYGON ?\n          /** @type {import(\"../../geom/Polygon.js\").default} */\n          geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n          offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n          /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */\n          geometry.getEnds(), stride, replayEnds);\n          this.instructions.push([Instruction.CUSTOM, replayBegin, replayEnds, geometry, renderer, inflateCoordinatesArray]);\n        } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n          flatCoordinates = geometry.getFlatCoordinates();\n          replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n          this.instructions.push([Instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer, inflateCoordinates]);\n        } else if (type == GeometryType.POINT) {\n          flatCoordinates = geometry.getFlatCoordinates();\n          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n          replayEnd = this.coordinates.length;\n          this.instructions.push([Instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer]);\n        }\n\n        this.endGeometry(geometry, feature);\n      };\n      /**\n       * @protected\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n       * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n       */\n\n\n      CanvasReplay.prototype.beginGeometry = function beginGeometry(geometry, feature) {\n        this.beginGeometryInstruction1_ = [Instruction.BEGIN_GEOMETRY, feature, 0];\n        this.instructions.push(this.beginGeometryInstruction1_);\n        this.beginGeometryInstruction2_ = [Instruction.BEGIN_GEOMETRY, feature, 0];\n        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n      };\n      /**\n       * FIXME empty description for jsdoc\n       */\n\n\n      CanvasReplay.prototype.finish = function finish() {};\n      /**\n       * @private\n       * @param {CanvasRenderingContext2D} context Context.\n       */\n\n\n      CanvasReplay.prototype.fill_ = function fill_(context) {\n        if (this.alignFill_) {\n          var origin = apply(this.renderedTransform_, [0, 0]);\n          var repeatSize = 512 * this.pixelRatio;\n          context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n          context.rotate(this.viewRotation_);\n        }\n\n        context.fill();\n\n        if (this.alignFill_) {\n          context.setTransform.apply(context, resetTransform);\n        }\n      };\n      /**\n       * @private\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {Array<*>} instruction Instruction.\n       */\n\n\n      CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_(context, instruction) {\n        context.strokeStyle =\n        /** @type {import(\"../../colorlike.js\").ColorLike} */\n        instruction[1];\n        context.lineWidth =\n        /** @type {number} */\n        instruction[2];\n        context.lineCap =\n        /** @type {CanvasLineCap} */\n        instruction[3];\n        context.lineJoin =\n        /** @type {CanvasLineJoin} */\n        instruction[4];\n        context.miterLimit =\n        /** @type {number} */\n        instruction[5];\n\n        if (CANVAS_LINE_DASH) {\n          context.lineDashOffset =\n          /** @type {number} */\n          instruction[7];\n          context.setLineDash(\n          /** @type {Array<number>} */\n          instruction[6]);\n        }\n      };\n      /**\n       * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n       * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n       */\n\n\n      CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_(declutterGroup, feature) {\n        if (declutterGroup && declutterGroup.length > 5) {\n          var groupCount = declutterGroup[4];\n\n          if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n            /** @type {import(\"../../structs/RBush.js\").Entry} */\n            var box = {\n              minX:\n              /** @type {number} */\n              declutterGroup[0],\n              minY:\n              /** @type {number} */\n              declutterGroup[1],\n              maxX:\n              /** @type {number} */\n              declutterGroup[2],\n              maxY:\n              /** @type {number} */\n              declutterGroup[3],\n              value: feature\n            };\n\n            if (!this.declutterTree.collides(box)) {\n              this.declutterTree.insert(box);\n\n              for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n                var declutterData =\n                /** @type {Array} */\n                declutterGroup[j];\n\n                if (declutterData) {\n                  if (declutterData.length > 11) {\n                    this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);\n                  }\n\n                  drawImage.apply(undefined, declutterData);\n                }\n              }\n            }\n\n            declutterGroup.length = 5;\n            createOrUpdateEmpty(declutterGroup);\n          }\n        }\n      };\n      /**\n       * @private\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../transform.js\").Transform} transform Transform.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n       *     to skip.\n       * @param {Array<*>} instructions Instructions array.\n       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n       * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n       *     extent.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      CanvasReplay.prototype.replay_ = function replay_(context, transform, skippedFeaturesHash, instructions, snapToPixel, featureCallback, opt_hitExtent) {\n        /** @type {Array<number>} */\n        var pixelCoordinates;\n\n        if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n          pixelCoordinates = this.pixelCoordinates_;\n        } else {\n          if (!this.pixelCoordinates_) {\n            this.pixelCoordinates_ = [];\n          }\n\n          pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n          setFromArray(this.renderedTransform_, transform);\n        }\n\n        var skipFeatures = !isEmpty(skippedFeaturesHash);\n        var i = 0; // instruction index\n\n        var ii = instructions.length; // end of instructions\n\n        var d = 0; // data index\n\n        var dd; // end of per-instruction data\n\n        var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n        var pendingFill = 0;\n        var pendingStroke = 0;\n        var lastFillInstruction = null;\n        var lastStrokeInstruction = null;\n        var coordinateCache = this.coordinateCache_;\n        var viewRotation = this.viewRotation_;\n        var state =\n        /** @type {import(\"../../render.js\").State} */\n        {\n          context: context,\n          pixelRatio: this.pixelRatio,\n          resolution: this.resolution,\n          rotation: viewRotation\n        }; // When the batch size gets too big, performance decreases. 200 is a good\n        // balance between batch size and number of fill/stroke instructions.\n\n        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n        var\n        /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */\n        feature;\n        var x, y;\n\n        while (i < ii) {\n          var instruction = instructions[i];\n          var type =\n          /** @type {CanvasInstruction} */\n          instruction[0];\n\n          switch (type) {\n            case Instruction.BEGIN_GEOMETRY:\n              feature =\n              /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */\n              instruction[1];\n\n              if (skipFeatures && skippedFeaturesHash[getUid(feature)] || !feature.getGeometry()) {\n                i =\n                /** @type {number} */\n                instruction[2];\n              } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, feature.getGeometry().getExtent())) {\n                i =\n                /** @type {number} */\n                instruction[2] + 1;\n              } else {\n                ++i;\n              }\n\n              break;\n\n            case Instruction.BEGIN_PATH:\n              if (pendingFill > batchSize) {\n                this.fill_(context);\n                pendingFill = 0;\n              }\n\n              if (pendingStroke > batchSize) {\n                context.stroke();\n                pendingStroke = 0;\n              }\n\n              if (!pendingFill && !pendingStroke) {\n                context.beginPath();\n                prevX = prevY = NaN;\n              }\n\n              ++i;\n              break;\n\n            case Instruction.CIRCLE:\n              d =\n              /** @type {number} */\n              instruction[1];\n              var x1 = pixelCoordinates[d];\n              var y1 = pixelCoordinates[d + 1];\n              var x2 = pixelCoordinates[d + 2];\n              var y2 = pixelCoordinates[d + 3];\n              var dx = x2 - x1;\n              var dy = y2 - y1;\n              var r = Math.sqrt(dx * dx + dy * dy);\n              context.moveTo(x1 + r, y1);\n              context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n              ++i;\n              break;\n\n            case Instruction.CLOSE_PATH:\n              context.closePath();\n              ++i;\n              break;\n\n            case Instruction.CUSTOM:\n              d =\n              /** @type {number} */\n              instruction[1];\n              dd = instruction[2];\n              var geometry =\n              /** @type {import(\"../../geom/SimpleGeometry.js\").default} */\n              instruction[3];\n              var renderer = instruction[4];\n              var fn = instruction.length == 6 ? instruction[5] : undefined;\n              state.geometry = geometry;\n              state.feature = feature;\n\n              if (!(i in coordinateCache)) {\n                coordinateCache[i] = [];\n              }\n\n              var coords = coordinateCache[i];\n\n              if (fn) {\n                fn(pixelCoordinates, d, dd, 2, coords);\n              } else {\n                coords[0] = pixelCoordinates[d];\n                coords[1] = pixelCoordinates[d + 1];\n                coords.length = 2;\n              }\n\n              renderer(coords, state);\n              ++i;\n              break;\n\n            case Instruction.DRAW_IMAGE:\n              d =\n              /** @type {number} */\n              instruction[1];\n              dd =\n              /** @type {number} */\n              instruction[2];\n              image =\n              /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n              instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n              anchorX =\n              /** @type {number} */\n              instruction[4];\n              anchorY =\n              /** @type {number} */\n              instruction[5];\n              declutterGroup = featureCallback ? null :\n              /** @type {import(\"../canvas.js\").DeclutterGroup} */\n              instruction[6];\n              var height =\n              /** @type {number} */\n              instruction[7];\n              var opacity =\n              /** @type {number} */\n              instruction[8];\n              var originX =\n              /** @type {number} */\n              instruction[9];\n              var originY =\n              /** @type {number} */\n              instruction[10];\n              var rotateWithView =\n              /** @type {boolean} */\n              instruction[11];\n              var rotation =\n              /** @type {number} */\n              instruction[12];\n              var scale =\n              /** @type {number} */\n              instruction[13];\n              var width =\n              /** @type {number} */\n              instruction[14];\n              var padding = void 0,\n                  backgroundFill = void 0,\n                  backgroundStroke = void 0;\n\n              if (instruction.length > 16) {\n                padding =\n                /** @type {Array<number>} */\n                instruction[15];\n                backgroundFill =\n                /** @type {boolean} */\n                instruction[16];\n                backgroundStroke =\n                /** @type {boolean} */\n                instruction[17];\n              } else {\n                padding = defaultPadding;\n                backgroundFill = backgroundStroke = false;\n              }\n\n              if (rotateWithView) {\n                rotation += viewRotation;\n              }\n\n              for (; d < dd; d += 2) {\n                this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?\n                /** @type {Array<*>} */\n                lastFillInstruction : null, backgroundStroke ?\n                /** @type {Array<*>} */\n                lastStrokeInstruction : null);\n              }\n\n              this.renderDeclutter_(declutterGroup, feature);\n              ++i;\n              break;\n\n            case Instruction.DRAW_CHARS:\n              var begin =\n              /** @type {number} */\n              instruction[1];\n              var end =\n              /** @type {number} */\n              instruction[2];\n              var baseline =\n              /** @type {number} */\n              instruction[3];\n              declutterGroup = featureCallback ? null :\n              /** @type {import(\"../canvas.js\").DeclutterGroup} */\n              instruction[4];\n              var overflow =\n              /** @type {number} */\n              instruction[5];\n              var fillKey =\n              /** @type {string} */\n              instruction[6];\n              var maxAngle =\n              /** @type {number} */\n              instruction[7];\n              var measure =\n              /** @type {function(string):number} */\n              instruction[8];\n              var offsetY =\n              /** @type {number} */\n              instruction[9];\n              var strokeKey =\n              /** @type {string} */\n              instruction[10];\n              var strokeWidth =\n              /** @type {number} */\n              instruction[11];\n              var text =\n              /** @type {string} */\n              instruction[12];\n              var textKey =\n              /** @type {string} */\n              instruction[13];\n              var textScale =\n              /** @type {number} */\n              instruction[14];\n              var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n              var textLength = measure(text);\n\n              if (overflow || textLength <= pathLength) {\n                /** @type {import(\"./TextReplay.js\").default} */\n                var textReplay =\n                /** @type {?} */\n                this;\n                var textAlign = textReplay.textStates[textKey].textAlign;\n                var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n                var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n\n                if (parts) {\n                  var c = void 0,\n                      cc = void 0,\n                      chars = void 0,\n                      label = void 0,\n                      part = void 0;\n\n                  if (strokeKey) {\n                    for (c = 0, cc = parts.length; c < cc; ++c) {\n                      part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                      chars =\n                      /** @type {string} */\n                      part[4];\n                      label = textReplay.getImage(chars, textKey, '', strokeKey);\n                      anchorX =\n                      /** @type {number} */\n                      part[2] + strokeWidth;\n                      anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                      this.replayImage_(context,\n                      /** @type {number} */\n                      part[0],\n                      /** @type {number} */\n                      part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                      /** @type {number} */\n                      part[3], textScale, false, label.width, defaultPadding, null, null);\n                    }\n                  }\n\n                  if (fillKey) {\n                    for (c = 0, cc = parts.length; c < cc; ++c) {\n                      part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                      chars =\n                      /** @type {string} */\n                      part[4];\n                      label = textReplay.getImage(chars, textKey, fillKey, '');\n                      anchorX =\n                      /** @type {number} */\n                      part[2];\n                      anchorY = baseline * label.height - offsetY;\n                      this.replayImage_(context,\n                      /** @type {number} */\n                      part[0],\n                      /** @type {number} */\n                      part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                      /** @type {number} */\n                      part[3], textScale, false, label.width, defaultPadding, null, null);\n                    }\n                  }\n                }\n              }\n\n              this.renderDeclutter_(declutterGroup, feature);\n              ++i;\n              break;\n\n            case Instruction.END_GEOMETRY:\n              if (featureCallback !== undefined) {\n                feature =\n                /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */\n                instruction[1];\n                var result = featureCallback(feature);\n\n                if (result) {\n                  return result;\n                }\n              }\n\n              ++i;\n              break;\n\n            case Instruction.FILL:\n              if (batchSize) {\n                pendingFill++;\n              } else {\n                this.fill_(context);\n              }\n\n              ++i;\n              break;\n\n            case Instruction.MOVE_TO_LINE_TO:\n              d =\n              /** @type {number} */\n              instruction[1];\n              dd =\n              /** @type {number} */\n              instruction[2];\n              x = pixelCoordinates[d];\n              y = pixelCoordinates[d + 1];\n              roundX = x + 0.5 | 0;\n              roundY = y + 0.5 | 0;\n\n              if (roundX !== prevX || roundY !== prevY) {\n                context.moveTo(x, y);\n                prevX = roundX;\n                prevY = roundY;\n              }\n\n              for (d += 2; d < dd; d += 2) {\n                x = pixelCoordinates[d];\n                y = pixelCoordinates[d + 1];\n                roundX = x + 0.5 | 0;\n                roundY = y + 0.5 | 0;\n\n                if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n                  context.lineTo(x, y);\n                  prevX = roundX;\n                  prevY = roundY;\n                }\n              }\n\n              ++i;\n              break;\n\n            case Instruction.SET_FILL_STYLE:\n              lastFillInstruction = instruction;\n              this.alignFill_ = instruction[2];\n\n              if (pendingFill) {\n                this.fill_(context);\n                pendingFill = 0;\n\n                if (pendingStroke) {\n                  context.stroke();\n                  pendingStroke = 0;\n                }\n              }\n\n              context.fillStyle =\n              /** @type {import(\"../../colorlike.js\").ColorLike} */\n              instruction[1];\n              ++i;\n              break;\n\n            case Instruction.SET_STROKE_STYLE:\n              lastStrokeInstruction = instruction;\n\n              if (pendingStroke) {\n                context.stroke();\n                pendingStroke = 0;\n              }\n\n              this.setStrokeStyle_(context,\n              /** @type {Array<*>} */\n              instruction);\n              ++i;\n              break;\n\n            case Instruction.STROKE:\n              if (batchSize) {\n                pendingStroke++;\n              } else {\n                context.stroke();\n              }\n\n              ++i;\n              break;\n\n            default:\n              ++i; // consume the instruction anyway, to avoid an infinite loop\n\n              break;\n          }\n        }\n\n        if (pendingFill) {\n          this.fill_(context);\n        }\n\n        if (pendingStroke) {\n          context.stroke();\n        }\n\n        return undefined;\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../transform.js\").Transform} transform Transform.\n       * @param {number} viewRotation View rotation.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n       *     to skip.\n       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n       */\n\n\n      CanvasReplay.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel) {\n        this.viewRotation_ = viewRotation;\n        this.replay_(context, transform, skippedFeaturesHash, this.instructions, snapToPixel, undefined, undefined);\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../transform.js\").Transform} transform Transform.\n       * @param {number} viewRotation View rotation.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n       *     to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T=} opt_featureCallback\n       *     Feature callback.\n       * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n       *     extent.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      CanvasReplay.prototype.replayHitDetection = function replayHitDetection(context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {\n        this.viewRotation_ = viewRotation;\n        return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n      };\n      /**\n       * Reverse the hit detection instructions.\n       */\n\n\n      CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions() {\n        var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n        hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n        var i;\n        var n = hitDetectionInstructions.length;\n        var instruction;\n        var type;\n        var begin = -1;\n\n        for (i = 0; i < n; ++i) {\n          instruction = hitDetectionInstructions[i];\n          type =\n          /** @type {CanvasInstruction} */\n          instruction[0];\n\n          if (type == Instruction.END_GEOMETRY) {\n            begin = i;\n          } else if (type == Instruction.BEGIN_GEOMETRY) {\n            instruction[2] = i;\n            reverseSubArray(this.hitDetectionInstructions, begin, i);\n            begin = -1;\n          }\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n        var state = this.state;\n\n        if (fillStyle) {\n          var fillStyleColor = fillStyle.getColor();\n          state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n        } else {\n          state.fillStyle = undefined;\n        }\n\n        if (strokeStyle) {\n          var strokeStyleColor = strokeStyle.getColor();\n          state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n          var strokeStyleLineCap = strokeStyle.getLineCap();\n          state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n          var strokeStyleLineDash = strokeStyle.getLineDash();\n          state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n          var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n          state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n          var strokeStyleLineJoin = strokeStyle.getLineJoin();\n          state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n          var strokeStyleWidth = strokeStyle.getWidth();\n          state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n          var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n          state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n\n          if (state.lineWidth > this.maxLineWidth) {\n            this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n            this.bufferedMaxExtent_ = null;\n          }\n        } else {\n          state.strokeStyle = undefined;\n          state.lineCap = undefined;\n          state.lineDash = null;\n          state.lineDashOffset = undefined;\n          state.lineJoin = undefined;\n          state.lineWidth = undefined;\n          state.miterLimit = undefined;\n        }\n      };\n      /**\n       * @param {import(\"../canvas.js\").FillStrokeState} state State.\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n       * @return {Array<*>} Fill instruction.\n       */\n\n\n      CanvasReplay.prototype.createFill = function createFill(state, geometry) {\n        var fillStyle = state.fillStyle;\n        /** @type {Array<*>} */\n\n        var fillInstruction$$1 = [Instruction.SET_FILL_STYLE, fillStyle];\n\n        if (typeof fillStyle !== 'string') {\n          // Fill is a pattern or gradient - align it!\n          fillInstruction$$1.push(true);\n        }\n\n        return fillInstruction$$1;\n      };\n      /**\n       * @param {import(\"../canvas.js\").FillStrokeState} state State.\n       */\n\n\n      CanvasReplay.prototype.applyStroke = function applyStroke(state) {\n        this.instructions.push(this.createStroke(state));\n      };\n      /**\n       * @param {import(\"../canvas.js\").FillStrokeState} state State.\n       * @return {Array<*>} Stroke instruction.\n       */\n\n\n      CanvasReplay.prototype.createStroke = function createStroke(state) {\n        return [Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n      };\n      /**\n       * @param {import(\"../canvas.js\").FillStrokeState} state State.\n       * @param {function(this:CanvasReplay, import(\"../canvas.js\").FillStrokeState, (import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default)):Array<*>} createFill Create fill.\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n       */\n\n\n      CanvasReplay.prototype.updateFillStyle = function updateFillStyle(state, createFill, geometry) {\n        var fillStyle = state.fillStyle;\n\n        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n          if (fillStyle !== undefined) {\n            this.instructions.push(createFill.call(this, state, geometry));\n          }\n\n          state.currentFillStyle = fillStyle;\n        }\n      };\n      /**\n       * @param {import(\"../canvas.js\").FillStrokeState} state State.\n       * @param {function(this:CanvasReplay, import(\"../canvas.js\").FillStrokeState)} applyStroke Apply stroke.\n       */\n\n\n      CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle(state, applyStroke) {\n        var strokeStyle = state.strokeStyle;\n        var lineCap = state.lineCap;\n        var lineDash = state.lineDash;\n        var lineDashOffset = state.lineDashOffset;\n        var lineJoin = state.lineJoin;\n        var lineWidth = state.lineWidth;\n        var miterLimit = state.miterLimit;\n\n        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n          if (strokeStyle !== undefined) {\n            applyStroke.call(this, state);\n          }\n\n          state.currentStrokeStyle = strokeStyle;\n          state.currentLineCap = lineCap;\n          state.currentLineDash = lineDash;\n          state.currentLineDashOffset = lineDashOffset;\n          state.currentLineJoin = lineJoin;\n          state.currentLineWidth = lineWidth;\n          state.currentMiterLimit = miterLimit;\n        }\n      };\n      /**\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n       * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n       */\n\n\n      CanvasReplay.prototype.endGeometry = function endGeometry(geometry, feature) {\n        this.beginGeometryInstruction1_[2] = this.instructions.length;\n        this.beginGeometryInstruction1_ = null;\n        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n        this.beginGeometryInstruction2_ = null;\n        var endGeometryInstruction = [Instruction.END_GEOMETRY, feature];\n        this.instructions.push(endGeometryInstruction);\n        this.hitDetectionInstructions.push(endGeometryInstruction);\n      };\n      /**\n       * Get the buffered rendering extent.  Rendering will be clipped to the extent\n       * provided to the constructor.  To account for symbolizers that may intersect\n       * this extent, we calculate a buffered extent (e.g. based on stroke width).\n       * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n       * @protected\n       */\n\n\n      CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent() {\n        if (!this.bufferedMaxExtent_) {\n          this.bufferedMaxExtent_ = clone(this.maxExtent);\n\n          if (this.maxLineWidth > 0) {\n            var width = this.resolution * (this.maxLineWidth + 1) / 2;\n            buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n          }\n        }\n\n        return this.bufferedMaxExtent_;\n      };\n\n      return CanvasReplay;\n    }(VectorContext);\n    /**\n     * @module ol/render/canvas/ImageReplay\n     */\n\n\n    var CanvasImageReplay =\n    /*@__PURE__*/\n    function (CanvasReplay$$1) {\n      function CanvasImageReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n        /**\n         * @private\n         * @type {import(\"../canvas.js\").DeclutterGroup}\n         */\n\n        this.declutterGroup_ = null;\n        /**\n         * @private\n         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}\n         */\n\n        this.hitDetectionImage_ = null;\n        /**\n         * @private\n         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}\n         */\n\n        this.image_ = null;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.anchorX_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.anchorY_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.height_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.opacity_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.originX_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.originY_ = undefined;\n        /**\n         * @private\n         * @type {boolean|undefined}\n         */\n\n        this.rotateWithView_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.rotation_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.scale_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.width_ = undefined;\n      }\n\n      if (CanvasReplay$$1) CanvasImageReplay.__proto__ = CanvasReplay$$1;\n      CanvasImageReplay.prototype = Object.create(CanvasReplay$$1 && CanvasReplay$$1.prototype);\n      CanvasImageReplay.prototype.constructor = CanvasImageReplay;\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @private\n       * @return {number} My end.\n       */\n\n      CanvasImageReplay.prototype.drawCoordinates_ = function drawCoordinates_(flatCoordinates, offset, end, stride) {\n        return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageReplay.prototype.drawPoint = function drawPoint(pointGeometry, feature) {\n        if (!this.image_) {\n          return;\n        }\n\n        this.beginGeometry(pointGeometry, feature);\n        var flatCoordinates = pointGeometry.getFlatCoordinates();\n        var stride = pointGeometry.getStride();\n        var myBegin = this.coordinates.length;\n        var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n        this.instructions.push([Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n        this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]);\n        this.hitDetectionInstructions.push([Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n        this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]);\n        this.endGeometry(pointGeometry, feature);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageReplay.prototype.drawMultiPoint = function drawMultiPoint(multiPointGeometry, feature) {\n        if (!this.image_) {\n          return;\n        }\n\n        this.beginGeometry(multiPointGeometry, feature);\n        var flatCoordinates = multiPointGeometry.getFlatCoordinates();\n        var stride = multiPointGeometry.getStride();\n        var myBegin = this.coordinates.length;\n        var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n        this.instructions.push([Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n        this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]);\n        this.hitDetectionInstructions.push([Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n        this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]);\n        this.endGeometry(multiPointGeometry, feature);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageReplay.prototype.finish = function finish() {\n        this.reverseHitDetectionInstructions(); // FIXME this doesn't really protect us against further calls to draw*Geometry\n\n        this.anchorX_ = undefined;\n        this.anchorY_ = undefined;\n        this.hitDetectionImage_ = null;\n        this.image_ = null;\n        this.height_ = undefined;\n        this.scale_ = undefined;\n        this.opacity_ = undefined;\n        this.originX_ = undefined;\n        this.originY_ = undefined;\n        this.rotateWithView_ = undefined;\n        this.rotation_ = undefined;\n        this.width_ = undefined;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasImageReplay.prototype.setImageStyle = function setImageStyle(imageStyle, declutterGroup) {\n        var anchor = imageStyle.getAnchor();\n        var size = imageStyle.getSize();\n        var hitDetectionImage = imageStyle.getHitDetectionImage(1);\n        var image = imageStyle.getImage(1);\n        var origin = imageStyle.getOrigin();\n        this.anchorX_ = anchor[0];\n        this.anchorY_ = anchor[1];\n        this.declutterGroup_ =\n        /** @type {import(\"../canvas.js\").DeclutterGroup} */\n        declutterGroup;\n        this.hitDetectionImage_ = hitDetectionImage;\n        this.image_ = image;\n        this.height_ = size[1];\n        this.opacity_ = imageStyle.getOpacity();\n        this.originX_ = origin[0];\n        this.originY_ = origin[1];\n        this.rotateWithView_ = imageStyle.getRotateWithView();\n        this.rotation_ = imageStyle.getRotation();\n        this.scale_ = imageStyle.getScale();\n        this.width_ = size[0];\n      };\n\n      return CanvasImageReplay;\n    }(CanvasReplay);\n    /**\n     * @module ol/render/canvas/LineStringReplay\n     */\n\n\n    var CanvasLineStringReplay =\n    /*@__PURE__*/\n    function (CanvasReplay$$1) {\n      function CanvasLineStringReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n      }\n\n      if (CanvasReplay$$1) CanvasLineStringReplay.__proto__ = CanvasReplay$$1;\n      CanvasLineStringReplay.prototype = Object.create(CanvasReplay$$1 && CanvasReplay$$1.prototype);\n      CanvasLineStringReplay.prototype.constructor = CanvasLineStringReplay;\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @private\n       * @return {number} end.\n       */\n\n      CanvasLineStringReplay.prototype.drawFlatCoordinates_ = function drawFlatCoordinates_(flatCoordinates, offset, end, stride) {\n        var myBegin = this.coordinates.length;\n        var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n        var moveToLineToInstruction = [Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n        this.instructions.push(moveToLineToInstruction);\n        this.hitDetectionInstructions.push(moveToLineToInstruction);\n        return end;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasLineStringReplay.prototype.drawLineString = function drawLineString(lineStringGeometry, feature) {\n        var state = this.state;\n        var strokeStyle = state.strokeStyle;\n        var lineWidth = state.lineWidth;\n\n        if (strokeStyle === undefined || lineWidth === undefined) {\n          return;\n        }\n\n        this.updateStrokeStyle(state, this.applyStroke);\n        this.beginGeometry(lineStringGeometry, feature);\n        this.hitDetectionInstructions.push([Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n        var flatCoordinates = lineStringGeometry.getFlatCoordinates();\n        var stride = lineStringGeometry.getStride();\n        this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n        this.hitDetectionInstructions.push(strokeInstruction);\n        this.endGeometry(lineStringGeometry, feature);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString(multiLineStringGeometry, feature) {\n        var state = this.state;\n        var strokeStyle = state.strokeStyle;\n        var lineWidth = state.lineWidth;\n\n        if (strokeStyle === undefined || lineWidth === undefined) {\n          return;\n        }\n\n        this.updateStrokeStyle(state, this.applyStroke);\n        this.beginGeometry(multiLineStringGeometry, feature);\n        this.hitDetectionInstructions.push([Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n        var ends = multiLineStringGeometry.getEnds();\n        var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n        var stride = multiLineStringGeometry.getStride();\n        var offset = 0;\n\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);\n        }\n\n        this.hitDetectionInstructions.push(strokeInstruction);\n        this.endGeometry(multiLineStringGeometry, feature);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasLineStringReplay.prototype.finish = function finish() {\n        var state = this.state;\n\n        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n          this.instructions.push(strokeInstruction);\n        }\n\n        this.reverseHitDetectionInstructions();\n        this.state = null;\n      };\n      /**\n       * @inheritDoc.\n       */\n\n\n      CanvasLineStringReplay.prototype.applyStroke = function applyStroke(state) {\n        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n          this.instructions.push(strokeInstruction);\n          state.lastStroke = this.coordinates.length;\n        }\n\n        state.lastStroke = 0;\n        CanvasReplay$$1.prototype.applyStroke.call(this, state);\n        this.instructions.push(beginPathInstruction);\n      };\n\n      return CanvasLineStringReplay;\n    }(CanvasReplay);\n    /**\n     * @module ol/render/canvas/PolygonReplay\n     */\n\n\n    var CanvasPolygonReplay =\n    /*@__PURE__*/\n    function (CanvasReplay$$1) {\n      function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n      }\n\n      if (CanvasReplay$$1) CanvasPolygonReplay.__proto__ = CanvasReplay$$1;\n      CanvasPolygonReplay.prototype = Object.create(CanvasReplay$$1 && CanvasReplay$$1.prototype);\n      CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {Array<number>} ends Ends.\n       * @param {number} stride Stride.\n       * @private\n       * @return {number} End.\n       */\n\n      CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n        var state = this.state;\n        var fill = state.fillStyle !== undefined;\n        var stroke = state.strokeStyle != undefined;\n        var numEnds = ends.length;\n        this.instructions.push(beginPathInstruction);\n        this.hitDetectionInstructions.push(beginPathInstruction);\n\n        for (var i = 0; i < numEnds; ++i) {\n          var end = ends[i];\n          var myBegin = this.coordinates.length;\n          var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n          var moveToLineToInstruction = [Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n          this.instructions.push(moveToLineToInstruction);\n          this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n          if (stroke) {\n            // Performance optimization: only call closePath() when we have a stroke.\n            // Otherwise the ring is closed already (see appendFlatCoordinates above).\n            this.instructions.push(closePathInstruction);\n            this.hitDetectionInstructions.push(closePathInstruction);\n          }\n\n          offset = end;\n        }\n\n        if (fill) {\n          this.instructions.push(fillInstruction);\n          this.hitDetectionInstructions.push(fillInstruction);\n        }\n\n        if (stroke) {\n          this.instructions.push(strokeInstruction);\n          this.hitDetectionInstructions.push(strokeInstruction);\n        }\n\n        return offset;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasPolygonReplay.prototype.drawCircle = function drawCircle(circleGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n\n        if (fillStyle === undefined && strokeStyle === undefined) {\n          return;\n        }\n\n        this.setFillStrokeStyles_(circleGeometry);\n        this.beginGeometry(circleGeometry, feature);\n\n        if (state.fillStyle !== undefined) {\n          this.hitDetectionInstructions.push([Instruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n        }\n\n        if (state.strokeStyle !== undefined) {\n          this.hitDetectionInstructions.push([Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n        }\n\n        var flatCoordinates = circleGeometry.getFlatCoordinates();\n        var stride = circleGeometry.getStride();\n        var myBegin = this.coordinates.length;\n        this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        var circleInstruction = [Instruction.CIRCLE, myBegin];\n        this.instructions.push(beginPathInstruction, circleInstruction);\n        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n        this.hitDetectionInstructions.push(fillInstruction);\n\n        if (state.fillStyle !== undefined) {\n          this.instructions.push(fillInstruction);\n        }\n\n        if (state.strokeStyle !== undefined) {\n          this.instructions.push(strokeInstruction);\n          this.hitDetectionInstructions.push(strokeInstruction);\n        }\n\n        this.endGeometry(circleGeometry, feature);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n\n        if (fillStyle === undefined && strokeStyle === undefined) {\n          return;\n        }\n\n        this.setFillStrokeStyles_(polygonGeometry);\n        this.beginGeometry(polygonGeometry, feature);\n\n        if (state.fillStyle !== undefined) {\n          this.hitDetectionInstructions.push([Instruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n        }\n\n        if (state.strokeStyle !== undefined) {\n          this.hitDetectionInstructions.push([Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n        }\n\n        var ends = polygonGeometry.getEnds();\n        var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n        var stride = polygonGeometry.getStride();\n        this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n        this.endGeometry(polygonGeometry, feature);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n\n        if (fillStyle === undefined && strokeStyle === undefined) {\n          return;\n        }\n\n        this.setFillStrokeStyles_(multiPolygonGeometry);\n        this.beginGeometry(multiPolygonGeometry, feature);\n\n        if (state.fillStyle !== undefined) {\n          this.hitDetectionInstructions.push([Instruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n        }\n\n        if (state.strokeStyle !== undefined) {\n          this.hitDetectionInstructions.push([Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n        }\n\n        var endss = multiPolygonGeometry.getEndss();\n        var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n        var stride = multiPolygonGeometry.getStride();\n        var offset = 0;\n\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n          offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n        }\n\n        this.endGeometry(multiPolygonGeometry, feature);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasPolygonReplay.prototype.finish = function finish() {\n        this.reverseHitDetectionInstructions();\n        this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n        // simplified using quantization and point elimination. However, we might\n        // have received a mix of quantized and non-quantized geometries, so ensure\n        // that all are quantized by quantizing all coordinates in the batch.\n\n        var tolerance = this.tolerance;\n\n        if (tolerance !== 0) {\n          var coordinates = this.coordinates;\n\n          for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n            coordinates[i] = snap(coordinates[i], tolerance);\n          }\n        }\n      };\n      /**\n       * @private\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n       */\n\n\n      CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_(geometry) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n\n        if (fillStyle !== undefined) {\n          this.updateFillStyle(state, this.createFill, geometry);\n        }\n\n        if (state.strokeStyle !== undefined) {\n          this.updateStrokeStyle(state, this.applyStroke);\n        }\n      };\n\n      return CanvasPolygonReplay;\n    }(CanvasReplay);\n    /**\n     * @module ol/geom/flat/straightchunk\n     */\n\n    /**\n     * @param {number} maxAngle Maximum acceptable angle delta between segments.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @return {Array<number>} Start and end of the first suitable chunk of the\n     * given `flatCoordinates`.\n     */\n\n\n    function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\n      var chunkStart = offset;\n      var chunkEnd = offset;\n      var chunkM = 0;\n      var m = 0;\n      var start = offset;\n      var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n\n      for (i = offset; i < end; i += stride) {\n        var x2 = flatCoordinates[i];\n        var y2 = flatCoordinates[i + 1];\n\n        if (x1 !== undefined) {\n          x23 = x2 - x1;\n          y23 = y2 - y1;\n          m23 = Math.sqrt(x23 * x23 + y23 * y23);\n\n          if (x12 !== undefined) {\n            m += m12;\n            acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n\n            if (acos > maxAngle) {\n              if (m > chunkM) {\n                chunkM = m;\n                chunkStart = start;\n                chunkEnd = i;\n              }\n\n              m = 0;\n              start = i - stride;\n            }\n          }\n\n          m12 = m23;\n          x12 = x23;\n          y12 = y23;\n        }\n\n        x1 = x2;\n        y1 = y2;\n      }\n\n      m += m23;\n      return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n    }\n    /**\n     * @module ol/style/TextPlacement\n     */\n\n    /**\n     * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that\n     * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},\n     * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or\n     * {@link module:ol/geom/MultiPolygon~MultiPolygon}.\n     * @enum {string}\n     */\n\n\n    var TextPlacement = {\n      POINT: 'point',\n      LINE: 'line'\n    };\n    /**\n     * @module ol/render/canvas/TextReplay\n     */\n\n    var CanvasTextReplay =\n    /*@__PURE__*/\n    function (CanvasReplay$$1) {\n      function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n        /**\n         * @private\n         * @type {import(\"../canvas.js\").DeclutterGroup}\n         */\n\n        this.declutterGroup_;\n        /**\n         * @private\n         * @type {Array<HTMLCanvasElement>}\n         */\n\n        this.labels_ = null;\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.text_ = '';\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.textOffsetX_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.textOffsetY_ = 0;\n        /**\n         * @private\n         * @type {boolean|undefined}\n         */\n\n        this.textRotateWithView_ = undefined;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.textRotation_ = 0;\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").FillState}\n         */\n\n        this.textFillState_ = null;\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").FillState>}\n         */\n\n        this.fillStates = {};\n        /**\n         * @private\n         * @type {?import(\"../canvas.js\").StrokeState}\n         */\n\n        this.textStrokeState_ = null;\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n         */\n\n        this.strokeStates = {};\n        /**\n         * @private\n         * @type {import(\"../canvas.js\").TextState}\n         */\n\n        this.textState_ =\n        /** @type {import(\"../canvas.js\").TextState} */\n        {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").TextState>}\n         */\n\n        this.textStates = {};\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.textKey_ = '';\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.fillKey_ = '';\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.strokeKey_ = '';\n        /**\n         * @private\n         * @type {Object<string, Object<string, number>>}\n         */\n\n        this.widths_ = {};\n        labelCache.prune();\n      }\n\n      if (CanvasReplay$$1) CanvasTextReplay.__proto__ = CanvasReplay$$1;\n      CanvasTextReplay.prototype = Object.create(CanvasReplay$$1 && CanvasReplay$$1.prototype);\n      CanvasTextReplay.prototype.constructor = CanvasTextReplay;\n      /**\n       * @inheritDoc\n       */\n\n      CanvasTextReplay.prototype.drawText = function drawText(geometry, feature) {\n        var fillState = this.textFillState_;\n        var strokeState = this.textStrokeState_;\n        var textState = this.textState_;\n\n        if (this.text_ === '' || !textState || !fillState && !strokeState) {\n          return;\n        }\n\n        var begin = this.coordinates.length;\n        var geometryType = geometry.getType();\n        var flatCoordinates = null;\n        var end = 2;\n        var stride = 2;\n        var i, ii;\n\n        if (textState.placement === TextPlacement.LINE) {\n          if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n            return;\n          }\n\n          var ends;\n          flatCoordinates = geometry.getFlatCoordinates();\n          stride = geometry.getStride();\n\n          if (geometryType == GeometryType.LINE_STRING) {\n            ends = [flatCoordinates.length];\n          } else if (geometryType == GeometryType.MULTI_LINE_STRING) {\n            ends = geometry.getEnds();\n          } else if (geometryType == GeometryType.POLYGON) {\n            ends = geometry.getEnds().slice(0, 1);\n          } else if (geometryType == GeometryType.MULTI_POLYGON) {\n            var endss = geometry.getEndss();\n            ends = [];\n\n            for (i = 0, ii = endss.length; i < ii; ++i) {\n              ends.push(endss[i][0]);\n            }\n          }\n\n          this.beginGeometry(geometry, feature);\n          var textAlign = textState.textAlign;\n          var flatOffset = 0;\n          var flatEnd;\n\n          for (var o = 0, oo = ends.length; o < oo; ++o) {\n            if (textAlign == undefined) {\n              var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n              flatOffset = range[0];\n              flatEnd = range[1];\n            } else {\n              flatEnd = ends[o];\n            }\n\n            for (i = flatOffset; i < flatEnd; i += stride) {\n              this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n            }\n\n            end = this.coordinates.length;\n            flatOffset = ends[o];\n            this.drawChars_(begin, end, this.declutterGroup_);\n            begin = end;\n          }\n\n          this.endGeometry(geometry, feature);\n        } else {\n          var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\n          var width = label.width / this.pixelRatio;\n\n          switch (geometryType) {\n            case GeometryType.POINT:\n            case GeometryType.MULTI_POINT:\n              flatCoordinates = geometry.getFlatCoordinates();\n              end = flatCoordinates.length;\n              break;\n\n            case GeometryType.LINE_STRING:\n              flatCoordinates =\n              /** @type {import(\"../../geom/LineString.js\").default} */\n              geometry.getFlatMidpoint();\n              break;\n\n            case GeometryType.CIRCLE:\n              flatCoordinates =\n              /** @type {import(\"../../geom/Circle.js\").default} */\n              geometry.getCenter();\n              break;\n\n            case GeometryType.MULTI_LINE_STRING:\n              flatCoordinates =\n              /** @type {import(\"../../geom/MultiLineString.js\").default} */\n              geometry.getFlatMidpoints();\n              end = flatCoordinates.length;\n              break;\n\n            case GeometryType.POLYGON:\n              flatCoordinates =\n              /** @type {import(\"../../geom/Polygon.js\").default} */\n              geometry.getFlatInteriorPoint();\n\n              if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\n                return;\n              }\n\n              stride = 3;\n              break;\n\n            case GeometryType.MULTI_POLYGON:\n              var interiorPoints =\n              /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n              geometry.getFlatInteriorPoints();\n              flatCoordinates = [];\n\n              for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n                if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\n                  flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n                }\n              }\n\n              end = flatCoordinates.length;\n\n              if (end == 0) {\n                return;\n              }\n\n              break;\n\n            default:\n          }\n\n          end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n\n          if (textState.backgroundFill || textState.backgroundStroke) {\n            this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n\n            if (textState.backgroundFill) {\n              this.updateFillStyle(this.state, this.createFill, geometry);\n              this.hitDetectionInstructions.push(this.createFill(this.state, geometry));\n            }\n\n            if (textState.backgroundStroke) {\n              this.updateStrokeStyle(this.state, this.applyStroke);\n              this.hitDetectionInstructions.push(this.createStroke(this.state));\n            }\n          }\n\n          this.beginGeometry(geometry, feature);\n          this.drawTextImage_(label, begin, end);\n          this.endGeometry(geometry, feature);\n        }\n      };\n      /**\n       * @param {string} text Text.\n       * @param {string} textKey Text style key.\n       * @param {string} fillKey Fill style key.\n       * @param {string} strokeKey Stroke style key.\n       * @return {HTMLCanvasElement} Image.\n       */\n\n\n      CanvasTextReplay.prototype.getImage = function getImage(text, textKey, fillKey, strokeKey) {\n        var label;\n        var key = strokeKey + textKey + text + fillKey + this.pixelRatio;\n\n        if (!labelCache.containsKey(key)) {\n          var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\n          var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\n          var textState = this.textStates[textKey] || this.textState_;\n          var pixelRatio = this.pixelRatio;\n          var scale = textState.scale * pixelRatio;\n          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n          var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n          var lines = text.split('\\n');\n          var numLines = lines.length;\n          var widths = [];\n          var width = measureTextWidths(textState.font, lines, widths);\n          var lineHeight = measureTextHeight(textState.font);\n          var height = lineHeight * numLines;\n          var renderWidth = width + strokeWidth;\n          var context = createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));\n          label = context.canvas;\n          labelCache.set(key, label);\n\n          if (scale != 1) {\n            context.scale(scale, scale);\n          }\n\n          context.font = textState.font;\n\n          if (strokeKey) {\n            context.strokeStyle = strokeState.strokeStyle;\n            context.lineWidth = strokeWidth;\n            context.lineCap =\n            /** @type {CanvasLineCap} */\n            strokeState.lineCap;\n            context.lineJoin =\n            /** @type {CanvasLineJoin} */\n            strokeState.lineJoin;\n            context.miterLimit = strokeState.miterLimit;\n\n            if (CANVAS_LINE_DASH && strokeState.lineDash.length) {\n              context.setLineDash(strokeState.lineDash);\n              context.lineDashOffset = strokeState.lineDashOffset;\n            }\n          }\n\n          if (fillKey) {\n            context.fillStyle = fillState.fillStyle;\n          }\n\n          context.textBaseline = 'middle';\n          context.textAlign = 'center';\n          var leftRight = 0.5 - align;\n          var x = align * label.width / scale + leftRight * strokeWidth;\n          var i;\n\n          if (strokeKey) {\n            for (i = 0; i < numLines; ++i) {\n              context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n            }\n          }\n\n          if (fillKey) {\n            for (i = 0; i < numLines; ++i) {\n              context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n            }\n          }\n        }\n\n        return labelCache.get(key);\n      };\n      /**\n       * @private\n       * @param {HTMLCanvasElement} label Label.\n       * @param {number} begin Begin.\n       * @param {number} end End.\n       */\n\n\n      CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_(label, begin, end) {\n        var textState = this.textState_;\n        var strokeState = this.textStrokeState_;\n        var pixelRatio = this.pixelRatio;\n        var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n        var baseline = TEXT_ALIGN[textState.textBaseline];\n        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\n        var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n        this.instructions.push([Instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, label.width, textState.padding == defaultPadding ? defaultPadding : textState.padding.map(function (p) {\n          return p * pixelRatio;\n        }), !!textState.backgroundFill, !!textState.backgroundStroke]);\n        this.hitDetectionInstructions.push([Instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);\n      };\n      /**\n       * @private\n       * @param {number} begin Begin.\n       * @param {number} end End.\n       * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n       */\n\n\n      CanvasTextReplay.prototype.drawChars_ = function drawChars_(begin, end, declutterGroup) {\n        var strokeState = this.textStrokeState_;\n        var textState = this.textState_;\n        var fillState = this.textFillState_;\n        var strokeKey = this.strokeKey_;\n\n        if (strokeState) {\n          if (!(strokeKey in this.strokeStates)) {\n            this.strokeStates[strokeKey] =\n            /** @type {import(\"../canvas.js\").StrokeState} */\n            {\n              strokeStyle: strokeState.strokeStyle,\n              lineCap: strokeState.lineCap,\n              lineDashOffset: strokeState.lineDashOffset,\n              lineWidth: strokeState.lineWidth,\n              lineJoin: strokeState.lineJoin,\n              miterLimit: strokeState.miterLimit,\n              lineDash: strokeState.lineDash\n            };\n          }\n        }\n\n        var textKey = this.textKey_;\n\n        if (!(this.textKey_ in this.textStates)) {\n          this.textStates[this.textKey_] =\n          /** @type {import(\"../canvas.js\").TextState} */\n          {\n            font: textState.font,\n            textAlign: textState.textAlign || defaultTextAlign,\n            scale: textState.scale\n          };\n        }\n\n        var fillKey = this.fillKey_;\n\n        if (fillState) {\n          if (!(fillKey in this.fillStates)) {\n            this.fillStates[fillKey] =\n            /** @type {import(\"../canvas.js\").FillState} */\n            {\n              fillStyle: fillState.fillStyle\n            };\n          }\n        }\n\n        var pixelRatio = this.pixelRatio;\n        var baseline = TEXT_ALIGN[textState.textBaseline];\n        var offsetY = this.textOffsetY_ * pixelRatio;\n        var text = this.text_;\n        var font = textState.font;\n        var textScale = textState.scale;\n        var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\n        var widths = this.widths_[font];\n\n        if (!widths) {\n          this.widths_[font] = widths = {};\n        }\n\n        this.instructions.push([Instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n          var width = widths[text];\n\n          if (!width) {\n            width = widths[text] = measureTextWidth(font, text);\n          }\n\n          return width * textScale * pixelRatio;\n        }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);\n        this.hitDetectionInstructions.push([Instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n          var width = widths[text];\n\n          if (!width) {\n            width = widths[text] = measureTextWidth(font, text);\n          }\n\n          return width * textScale;\n        }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasTextReplay.prototype.setTextStyle = function setTextStyle(textStyle, declutterGroup) {\n        var textState, fillState, strokeState;\n\n        if (!textStyle) {\n          this.text_ = '';\n        } else {\n          this.declutterGroup_ =\n          /** @type {import(\"../canvas.js\").DeclutterGroup} */\n          declutterGroup;\n          var textFillStyle = textStyle.getFill();\n\n          if (!textFillStyle) {\n            fillState = this.textFillState_ = null;\n          } else {\n            fillState = this.textFillState_;\n\n            if (!fillState) {\n              fillState = this.textFillState_ =\n              /** @type {import(\"../canvas.js\").FillState} */\n              {};\n            }\n\n            fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);\n          }\n\n          var textStrokeStyle = textStyle.getStroke();\n\n          if (!textStrokeStyle) {\n            strokeState = this.textStrokeState_ = null;\n          } else {\n            strokeState = this.textStrokeState_;\n\n            if (!strokeState) {\n              strokeState = this.textStrokeState_ =\n              /** @type {import(\"../canvas.js\").StrokeState} */\n              {};\n            }\n\n            var lineDash = textStrokeStyle.getLineDash();\n            var lineDashOffset = textStrokeStyle.getLineDashOffset();\n            var lineWidth = textStrokeStyle.getWidth();\n            var miterLimit = textStrokeStyle.getMiterLimit();\n            strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n            strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n            strokeState.lineDashOffset = lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n            strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n            strokeState.lineWidth = lineWidth === undefined ? defaultLineWidth : lineWidth;\n            strokeState.miterLimit = miterLimit === undefined ? defaultMiterLimit : miterLimit;\n            strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);\n          }\n\n          textState = this.textState_;\n          var font = textStyle.getFont() || defaultFont;\n          checkFont(font);\n          var textScale = textStyle.getScale();\n          textState.overflow = textStyle.getOverflow();\n          textState.font = font;\n          textState.maxAngle = textStyle.getMaxAngle();\n          textState.placement = textStyle.getPlacement();\n          textState.textAlign = textStyle.getTextAlign();\n          textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n          textState.backgroundFill = textStyle.getBackgroundFill();\n          textState.backgroundStroke = textStyle.getBackgroundStroke();\n          textState.padding = textStyle.getPadding() || defaultPadding;\n          textState.scale = textScale === undefined ? 1 : textScale;\n          var textOffsetX = textStyle.getOffsetX();\n          var textOffsetY = textStyle.getOffsetY();\n          var textRotateWithView = textStyle.getRotateWithView();\n          var textRotation = textStyle.getRotation();\n          this.text_ = textStyle.getText() || '';\n          this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n          this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n          this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n          this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n          this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';\n          this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');\n          this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + getUid(fillState.fillStyle) : '';\n        }\n      };\n\n      return CanvasTextReplay;\n    }(CanvasReplay);\n    /**\n     * @param {string} font Font to use for measuring.\n     * @param {Array<string>} lines Lines to measure.\n     * @param {Array<number>} widths Array will be populated with the widths of\n     * each line.\n     * @return {number} Width of the whole text.\n     */\n\n\n    function measureTextWidths(font, lines, widths) {\n      var numLines = lines.length;\n      var width = 0;\n\n      for (var i = 0; i < numLines; ++i) {\n        var currentWidth = measureTextWidth(font, lines[i]);\n        width = Math.max(width, currentWidth);\n        widths.push(currentWidth);\n      }\n\n      return width;\n    }\n    /**\n     * @module ol/render/canvas/ReplayGroup\n     */\n\n    /**\n     * @type {Object<ReplayType, typeof CanvasReplay>}\n     */\n\n\n    var BATCH_CONSTRUCTORS = {\n      'Circle': CanvasPolygonReplay,\n      'Default': CanvasReplay,\n      'Image': CanvasImageReplay,\n      'LineString': CanvasLineStringReplay,\n      'Polygon': CanvasPolygonReplay,\n      'Text': CanvasTextReplay\n    };\n\n    var CanvasReplayGroup =\n    /*@__PURE__*/\n    function (ReplayGroup$$1) {\n      function CanvasReplayGroup(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\n        ReplayGroup$$1.call(this);\n        /**\n         * Declutter tree.\n         * @private\n         */\n\n        this.declutterTree_ = declutterTree;\n        /**\n         * @type {import(\"../canvas.js\").DeclutterGroup}\n         * @private\n         */\n\n        this.declutterGroup_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.tolerance_ = tolerance;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.maxExtent_ = maxExtent;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.overlaps_ = overlaps;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.resolution_ = resolution;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.renderBuffer_ = opt_renderBuffer;\n        /**\n         * @private\n         * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n         */\n\n        this.replaysByZIndex_ = {};\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.hitDetectionContext_ = createCanvasContext2D(1, 1);\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.hitDetectionTransform_ = create();\n      }\n\n      if (ReplayGroup$$1) CanvasReplayGroup.__proto__ = ReplayGroup$$1;\n      CanvasReplayGroup.prototype = Object.create(ReplayGroup$$1 && ReplayGroup$$1.prototype);\n      CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;\n      /**\n       * @inheritDoc\n       */\n\n      CanvasReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n        var declutter = null;\n\n        if (this.declutterTree_) {\n          if (group) {\n            declutter = this.declutterGroup_;\n            /** @type {number} */\n\n            declutter[4]++;\n          } else {\n            declutter = this.declutterGroup_ = createEmpty();\n            declutter.push(1);\n          }\n        }\n\n        return declutter;\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../transform.js\").Transform} transform Transform.\n       */\n\n\n      CanvasReplayGroup.prototype.clip = function clip(context, transform) {\n        var flatClipCoords = this.getClipCoords(transform);\n        context.beginPath();\n        context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n        context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n        context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n        context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n        context.clip();\n      };\n      /**\n       * @param {Array<ReplayType>} replays Replays.\n       * @return {boolean} Has replays of the provided types.\n       */\n\n\n      CanvasReplayGroup.prototype.hasReplays = function hasReplays(replays) {\n        for (var zIndex in this.replaysByZIndex_) {\n          var candidates = this.replaysByZIndex_[zIndex];\n\n          for (var i = 0, ii = replays.length; i < ii; ++i) {\n            if (replays[i] in candidates) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /**\n       * FIXME empty description for jsdoc\n       */\n\n\n      CanvasReplayGroup.prototype.finish = function finish() {\n        for (var zKey in this.replaysByZIndex_) {\n          var replays = this.replaysByZIndex_[zKey];\n\n          for (var replayKey in replays) {\n            replays[replayKey].finish();\n          }\n        }\n      };\n      /**\n       * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {number} resolution Resolution.\n       * @param {number} rotation Rotation.\n       * @param {number} hitTolerance Hit tolerance in pixels.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T} callback Feature callback.\n       * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>} declutterReplays Declutter replays.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\n        hitTolerance = Math.round(hitTolerance);\n        var contextSize = hitTolerance * 2 + 1;\n        var transform = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n        var context = this.hitDetectionContext_;\n\n        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n          context.canvas.width = contextSize;\n          context.canvas.height = contextSize;\n        } else {\n          context.clearRect(0, 0, contextSize, contextSize);\n        }\n        /**\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n\n        var hitExtent;\n\n        if (this.renderBuffer_ !== undefined) {\n          hitExtent = createEmpty();\n          extendCoordinate(hitExtent, coordinate);\n          buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n        }\n\n        var mask = getCircleArray(hitTolerance);\n        var declutteredFeatures;\n\n        if (this.declutterTree_) {\n          declutteredFeatures = this.declutterTree_.all().map(function (entry) {\n            return entry.value;\n          });\n        }\n\n        var replayType;\n        /**\n         * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n         * @return {?} Callback result.\n         */\n\n        function featureCallback(feature) {\n          var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n\n          for (var i = 0; i < contextSize; i++) {\n            for (var j = 0; j < contextSize; j++) {\n              if (mask[i][j]) {\n                if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n                  var result = void 0;\n\n                  if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                    result = callback(feature);\n                  }\n\n                  if (result) {\n                    return result;\n                  } else {\n                    context.clearRect(0, 0, contextSize, contextSize);\n                    return undefined;\n                  }\n                }\n              }\n            }\n          }\n        }\n        /** @type {Array<number>} */\n\n\n        var zs = Object.keys(this.replaysByZIndex_).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        var i, j, replays, replay, result;\n\n        for (i = zs.length - 1; i >= 0; --i) {\n          var zIndexKey = zs[i].toString();\n          replays = this.replaysByZIndex_[zIndexKey];\n\n          for (j = ORDER.length - 1; j >= 0; --j) {\n            replayType = ORDER[j];\n            replay = replays[replayType];\n\n            if (replay !== undefined) {\n              if (declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n                var declutter = declutterReplays[zIndexKey];\n\n                if (!declutter) {\n                  declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n                } else {\n                  declutter.push(replay, transform.slice(0));\n                }\n              } else {\n                result = replay.replayHitDetection(context, transform, rotation, skippedFeaturesHash, featureCallback, hitExtent);\n\n                if (result) {\n                  return result;\n                }\n              }\n            }\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @param {import(\"../../transform.js\").Transform} transform Transform.\n       * @return {Array<number>} Clip coordinates.\n       */\n\n\n      CanvasReplayGroup.prototype.getClipCoords = function getClipCoords(transform) {\n        var maxExtent = this.maxExtent_;\n        var minX = maxExtent[0];\n        var minY = maxExtent[1];\n        var maxX = maxExtent[2];\n        var maxY = maxExtent[3];\n        var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n        transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n        return flatClipCoords;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n        var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n        var replays = this.replaysByZIndex_[zIndexKey];\n\n        if (replays === undefined) {\n          replays = {};\n          this.replaysByZIndex_[zIndexKey] = replays;\n        }\n\n        var replay = replays[replayType];\n\n        if (replay === undefined) {\n          var Constructor = BATCH_CONSTRUCTORS[replayType];\n          replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n          replays[replayType] = replay;\n        }\n\n        return replay;\n      };\n      /**\n       * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n       */\n\n\n      CanvasReplayGroup.prototype.getReplays = function getReplays() {\n        return this.replaysByZIndex_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasReplayGroup.prototype.isEmpty = function isEmpty$1$$1() {\n        return isEmpty(this.replaysByZIndex_);\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../transform.js\").Transform} transform Transform.\n       * @param {number} viewRotation View rotation.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n       * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n       *     Default is {@link module:ol/render/replay~ORDER}\n       * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n       */\n\n\n      CanvasReplayGroup.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel, opt_replayTypes, opt_declutterReplays) {\n        /** @type {Array<number>} */\n        var zs = Object.keys(this.replaysByZIndex_).map(Number);\n        zs.sort(numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not\n        // visible outside the current extent when panning\n\n        context.save();\n        this.clip(context, transform);\n        var replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\n        var i, ii, j, jj, replays, replay;\n\n        for (i = 0, ii = zs.length; i < ii; ++i) {\n          var zIndexKey = zs[i].toString();\n          replays = this.replaysByZIndex_[zIndexKey];\n\n          for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n            var replayType = replayTypes[j];\n            replay = replays[replayType];\n\n            if (replay !== undefined) {\n              if (opt_declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n                var declutter = opt_declutterReplays[zIndexKey];\n\n                if (!declutter) {\n                  opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n                } else {\n                  declutter.push(replay, transform.slice(0));\n                }\n              } else {\n                replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n              }\n            }\n          }\n        }\n\n        context.restore();\n      };\n\n      return CanvasReplayGroup;\n    }(ReplayGroup);\n    /**\n     * This cache is used for storing calculated pixel circles for increasing performance.\n     * It is a static property to allow each Replaygroup to access it.\n     * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n     */\n\n\n    var circleArrayCache = {\n      0: [[true]]\n    };\n    /**\n     * This method fills a row in the array from the given coordinate to the\n     * middle with `true`.\n     * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n     * @param {number} x X coordinate.\n     * @param {number} y Y coordinate.\n     */\n\n    function fillCircleArrayRowToMiddle(array, x, y) {\n      var i;\n      var radius = Math.floor(array.length / 2);\n\n      if (x >= radius) {\n        for (i = radius; i < x; i++) {\n          array[i][y] = true;\n        }\n      } else if (x < radius) {\n        for (i = x + 1; i < radius; i++) {\n          array[i][y] = true;\n        }\n      }\n    }\n    /**\n     * This methods creates a circle inside a fitting array. Points inside the\n     * circle are marked by true, points on the outside are undefined.\n     * It uses the midpoint circle algorithm.\n     * A cache is used to increase performance.\n     * @param {number} radius Radius.\n     * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n     */\n\n\n    function getCircleArray(radius) {\n      if (circleArrayCache[radius] !== undefined) {\n        return circleArrayCache[radius];\n      }\n\n      var arraySize = radius * 2 + 1;\n      var arr = new Array(arraySize);\n\n      for (var i = 0; i < arraySize; i++) {\n        arr[i] = new Array(arraySize);\n      }\n\n      var x = radius;\n      var y = 0;\n      var error = 0;\n\n      while (x >= y) {\n        fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n        fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n        fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n        fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n        fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n        fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n        fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n        fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n        y++;\n        error += 1 + 2 * y;\n\n        if (2 * (error - x) + 1 > 0) {\n          x -= 1;\n          error += 1 - 2 * x;\n        }\n      }\n\n      circleArrayCache[radius] = arr;\n      return arr;\n    }\n    /**\n     * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} rotation Rotation.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     */\n\n\n    function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n      var zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n      var skippedFeatureUids = {};\n\n      for (var z = 0, zz = zs.length; z < zz; ++z) {\n        var replayData = declutterReplays[zs[z].toString()];\n\n        for (var i = 0, ii = replayData.length; i < ii;) {\n          var replay = replayData[i++];\n          var transform = replayData[i++];\n          replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n        }\n      }\n    }\n    /**\n     * @module ol/renderer/vector\n     */\n\n    /**\n     * Tolerance for geometry simplification in device pixels.\n     * @type {number}\n     */\n\n\n    var SIMPLIFY_TOLERANCE = 0.5;\n    /**\n     * @const\n     * @type {Object<import(\"../geom/GeometryType.js\").default,\n     *                function(import(\"../render/ReplayGroup.js\").default, import(\"../geom/Geometry.js\").default,\n     *                         import(\"../style/Style.js\").default, Object)>}\n     */\n\n    var GEOMETRY_RENDERERS = {\n      'Point': renderPointGeometry,\n      'LineString': renderLineStringGeometry,\n      'Polygon': renderPolygonGeometry,\n      'MultiPoint': renderMultiPointGeometry,\n      'MultiLineString': renderMultiLineStringGeometry,\n      'MultiPolygon': renderMultiPolygonGeometry,\n      'GeometryCollection': renderGeometryCollectionGeometry,\n      'Circle': renderCircleGeometry\n    };\n    /**\n     * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n     * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n     * @return {number} Order.\n     */\n\n    function defaultOrder(feature1, feature2) {\n      return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n    }\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Squared pixel tolerance.\n     */\n\n\n    function getSquaredTolerance(resolution, pixelRatio) {\n      var tolerance = getTolerance(resolution, pixelRatio);\n      return tolerance * tolerance;\n    }\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Pixel tolerance.\n     */\n\n\n    function getTolerance(resolution, pixelRatio) {\n      return SIMPLIFY_TOLERANCE * resolution / pixelRatio;\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     */\n\n\n    function renderCircleGeometry(replayGroup, geometry, style, feature) {\n      var fillStyle = style.getFill();\n      var strokeStyle = style.getStroke();\n\n      if (fillStyle || strokeStyle) {\n        var circleReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.CIRCLE);\n        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        circleReplay.drawCircle(geometry, feature);\n      }\n\n      var textStyle = style.getText();\n\n      if (textStyle) {\n        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\n        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n        textReplay.drawText(geometry, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {function(this: T, import(\"../events/Event.js\").default)} listener Listener function.\n     * @param {T} thisArg Value to use as `this` when executing `listener`.\n     * @return {boolean} `true` if style is loading.\n     * @template T\n     */\n\n\n    function renderFeature(replayGroup, feature, style, squaredTolerance, listener, thisArg) {\n      var loading = false;\n      var imageStyle = style.getImage();\n\n      if (imageStyle) {\n        var imageState = imageStyle.getImageState();\n\n        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n          imageStyle.unlistenImageChange(listener, thisArg);\n        } else {\n          if (imageState == ImageState.IDLE) {\n            imageStyle.load();\n          }\n\n          imageState = imageStyle.getImageState();\n          imageStyle.listenImageChange(listener, thisArg);\n          loading = true;\n        }\n      }\n\n      renderFeatureInternal(replayGroup, feature, style, squaredTolerance);\n      return loading;\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {number} squaredTolerance Squared tolerance.\n     */\n\n\n    function renderFeatureInternal(replayGroup, feature, style, squaredTolerance) {\n      var geometry = style.getGeometryFunction()(feature);\n\n      if (!geometry) {\n        return;\n      }\n\n      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n      var renderer = style.getRenderer();\n\n      if (renderer) {\n        renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n      } else {\n        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n        geometryRenderer(replayGroup, simplifiedGeometry, style, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     */\n\n\n    function renderGeometry(replayGroup, geometry, style, feature) {\n      if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n        var geometries =\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */\n        geometry.getGeometries();\n\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n          renderGeometry(replayGroup, geometries[i], style, feature);\n        }\n\n        return;\n      }\n\n      var replay = replayGroup.getReplay(style.getZIndex(), ReplayType.DEFAULT);\n      replay.drawCustom(\n      /** @type {import(\"../geom/SimpleGeometry.js\").default} */\n      geometry, feature, style.getRenderer());\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     */\n\n\n    function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {\n      var geometries = geometry.getGeometriesArray();\n      var i, ii;\n\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n        geometryRenderer(replayGroup, geometries[i], style, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     */\n\n\n    function renderLineStringGeometry(replayGroup, geometry, style, feature) {\n      var strokeStyle = style.getStroke();\n\n      if (strokeStyle) {\n        var lineStringReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawLineString(geometry, feature);\n      }\n\n      var textStyle = style.getText();\n\n      if (textStyle) {\n        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\n        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n        textReplay.drawText(geometry, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     */\n\n\n    function renderMultiLineStringGeometry(replayGroup, geometry, style, feature) {\n      var strokeStyle = style.getStroke();\n\n      if (strokeStyle) {\n        var lineStringReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawMultiLineString(geometry, feature);\n      }\n\n      var textStyle = style.getText();\n\n      if (textStyle) {\n        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\n        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n        textReplay.drawText(geometry, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     */\n\n\n    function renderMultiPolygonGeometry(replayGroup, geometry, style, feature) {\n      var fillStyle = style.getFill();\n      var strokeStyle = style.getStroke();\n\n      if (strokeStyle || fillStyle) {\n        var polygonReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawMultiPolygon(geometry, feature);\n      }\n\n      var textStyle = style.getText();\n\n      if (textStyle) {\n        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\n        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n        textReplay.drawText(geometry, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     */\n\n\n    function renderPointGeometry(replayGroup, geometry, style, feature) {\n      var imageStyle = style.getImage();\n\n      if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n          return;\n        }\n\n        var imageReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\n        imageReplay.drawPoint(geometry, feature);\n      }\n\n      var textStyle = style.getText();\n\n      if (textStyle) {\n        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\n        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\n        textReplay.drawText(geometry, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     */\n\n\n    function renderMultiPointGeometry(replayGroup, geometry, style, feature) {\n      var imageStyle = style.getImage();\n\n      if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n          return;\n        }\n\n        var imageReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\n        imageReplay.drawMultiPoint(geometry, feature);\n      }\n\n      var textStyle = style.getText();\n\n      if (textStyle) {\n        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\n        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\n        textReplay.drawText(geometry, feature);\n      }\n    }\n    /**\n     * @param {import(\"../render/ReplayGroup.js\").default} replayGroup Replay group.\n     * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n     * @param {import(\"../style/Style.js\").default} style Style.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     */\n\n\n    function renderPolygonGeometry(replayGroup, geometry, style, feature) {\n      var fillStyle = style.getFill();\n      var strokeStyle = style.getStroke();\n\n      if (fillStyle || strokeStyle) {\n        var polygonReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawPolygon(geometry, feature);\n      }\n\n      var textStyle = style.getText();\n\n      if (textStyle) {\n        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\n        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n        textReplay.drawText(geometry, feature);\n      }\n    }\n    /**\n     * @module ol/renderer/canvas/VectorLayer\n     */\n\n    /**\n     * @classdesc\n     * Canvas renderer for vector layers.\n     * @api\n     */\n\n\n    var CanvasVectorLayerRenderer =\n    /*@__PURE__*/\n    function (CanvasLayerRenderer$$1) {\n      function CanvasVectorLayerRenderer(vectorLayer) {\n        CanvasLayerRenderer$$1.call(this, vectorLayer);\n        /**\n         * Declutter tree.\n         * @private\n         */\n\n        this.declutterTree_ = vectorLayer.getDeclutter() ? rbush_1(9, undefined) : null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.dirty_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.renderedRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.renderedResolution_ = NaN;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.renderedExtent_ = createEmpty();\n        /**\n         * @private\n         * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n         */\n\n        this.renderedRenderOrder_ = null;\n        /**\n         * @private\n         * @type {import(\"../../render/canvas/ReplayGroup.js\").default}\n         */\n\n        this.replayGroup_ = null;\n        /**\n         * A new replay group had to be created by `prepareFrame()`\n         * @type {boolean}\n         */\n\n        this.replayGroupChanged = true;\n        /**\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.context = createCanvasContext2D();\n        listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n      }\n\n      if (CanvasLayerRenderer$$1) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer$$1;\n      CanvasVectorLayerRenderer.prototype = Object.create(CanvasLayerRenderer$$1 && CanvasLayerRenderer$$1.prototype);\n      CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;\n      /**\n       * @inheritDoc\n       */\n\n      CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n        unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n        CanvasLayerRenderer$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * @param {CanvasRenderingContext2D} context Context.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n       */\n\n\n      CanvasVectorLayerRenderer.prototype.compose = function compose(context, frameState, layerState) {\n        var extent = frameState.extent;\n        var pixelRatio = frameState.pixelRatio;\n        var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var rotation = viewState.rotation;\n        var projectionExtent = projection.getExtent();\n        var vectorSource =\n        /** @type {import(\"../../source/Vector.js\").default} */\n        this.getLayer().getSource();\n        var transform = this.getTransform(frameState, 0); // clipped rendering if layer extent is set\n\n        var clipExtent = layerState.extent;\n        var clipped = clipExtent !== undefined;\n\n        if (clipped) {\n          this.clip(context, frameState,\n          /** @type {import(\"../../extent.js\").Extent} */\n          clipExtent);\n        }\n\n        var replayGroup = this.replayGroup_;\n\n        if (replayGroup && !replayGroup.isEmpty()) {\n          if (this.declutterTree_) {\n            this.declutterTree_.clear();\n          }\n\n          var layer =\n          /** @type {import(\"../../layer/Vector.js\").default} */\n          this.getLayer();\n          var drawOffsetX = 0;\n          var drawOffsetY = 0;\n          var replayContext;\n          var transparentLayer = layerState.opacity !== 1;\n          var hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\n\n          if (transparentLayer || hasRenderListeners) {\n            var drawWidth = context.canvas.width;\n            var drawHeight = context.canvas.height;\n\n            if (rotation) {\n              var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n              drawOffsetX = (drawSize - drawWidth) / 2;\n              drawOffsetY = (drawSize - drawHeight) / 2;\n              drawWidth = drawHeight = drawSize;\n            } // resize and clear\n\n\n            this.context.canvas.width = drawWidth;\n            this.context.canvas.height = drawHeight;\n            replayContext = this.context;\n          } else {\n            replayContext = context;\n          }\n\n          var alpha = replayContext.globalAlpha;\n\n          if (!transparentLayer) {\n            // for performance reasons, context.save / context.restore is not used\n            // to save and restore the transformation matrix and the opacity.\n            // see http://jsperf.com/context-save-restore-versus-variable\n            replayContext.globalAlpha = layerState.opacity;\n          }\n\n          if (replayContext != context) {\n            replayContext.translate(drawOffsetX, drawOffsetY);\n          }\n\n          var viewHints = frameState.viewHints;\n          var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n          var width = frameState.size[0] * pixelRatio;\n          var height = frameState.size[1] * pixelRatio;\n          rotateAtOffset(replayContext, -rotation, width / 2, height / 2);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n\n          if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {\n            var startX = extent[0];\n            var worldWidth = getWidth(projectionExtent);\n            var world = 0;\n            var offsetX;\n\n            while (startX < projectionExtent[0]) {\n              --world;\n              offsetX = worldWidth * world;\n              transform = this.getTransform(frameState, offsetX);\n              replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n              startX += worldWidth;\n            }\n\n            world = 0;\n            startX = extent[2];\n\n            while (startX > projectionExtent[2]) {\n              ++world;\n              offsetX = worldWidth * world;\n              transform = this.getTransform(frameState, offsetX);\n              replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n              startX -= worldWidth;\n            }\n          }\n\n          rotateAtOffset(replayContext, rotation, width / 2, height / 2);\n\n          if (hasRenderListeners) {\n            this.dispatchRenderEvent(replayContext, frameState, transform);\n          }\n\n          if (replayContext != context) {\n            if (transparentLayer) {\n              var mainContextAlpha = context.globalAlpha;\n              context.globalAlpha = layerState.opacity;\n              context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n              context.globalAlpha = mainContextAlpha;\n            } else {\n              context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n            }\n\n            replayContext.translate(-drawOffsetX, -drawOffsetY);\n          }\n\n          if (!transparentLayer) {\n            replayContext.globalAlpha = alpha;\n          }\n        }\n\n        if (clipped) {\n          context.restore();\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n        var transform = this.getTransform(frameState, 0);\n        this.preCompose(context, frameState, transform);\n        this.compose(context, frameState, layerState);\n        this.postCompose(context, frameState, layerState, transform);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n        if (!this.replayGroup_) {\n          return undefined;\n        } else {\n          var resolution = frameState.viewState.resolution;\n          var rotation = frameState.viewState.rotation;\n          var layer =\n          /** @type {import(\"../../layer/Vector.js\").default} */\n          this.getLayer();\n          /** @type {!Object<string, boolean>} */\n\n          var features = {};\n          var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n          /**\n           * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n           * @return {?} Callback result.\n           */\n          function (feature) {\n            var key = getUid(feature);\n\n            if (!(key in features)) {\n              features[key] = true;\n              return callback.call(thisArg, feature, layer);\n            }\n          }, null);\n          return result;\n        }\n      };\n      /**\n       * @param {import(\"../../events/Event.js\").default} event Event.\n       */\n\n\n      CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n        var layer = this.getLayer();\n\n        if (layer.getVisible() && this.replayGroup_) {\n          layer.changed();\n        }\n      };\n      /**\n       * Handle changes in image style state.\n       * @param {import(\"../../events/Event.js\").default} event Image style change event.\n       * @private\n       */\n\n\n      CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n        this.renderIfReadyAndVisible();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n        var vectorLayer =\n        /** @type {import(\"../../layer/Vector.js\").default} */\n        this.getLayer();\n        var vectorSource =\n        /** @type {import(\"../../source/Vector.js\").default} */\n        vectorLayer.getSource();\n        var animating = frameState.viewHints[ViewHint.ANIMATING];\n        var interacting = frameState.viewHints[ViewHint.INTERACTING];\n        var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n        var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n        if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {\n          return true;\n        }\n\n        var frameStateExtent = frameState.extent;\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var resolution = viewState.resolution;\n        var pixelRatio = frameState.pixelRatio;\n        var vectorLayerRevision = vectorLayer.getRevision();\n        var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n        var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n        if (vectorLayerRenderOrder === undefined) {\n          vectorLayerRenderOrder = defaultOrder;\n        }\n\n        var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);\n        var projectionExtent = viewState.projection.getExtent();\n\n        if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {\n          // For the replay group, we need an extent that intersects the real world\n          // (-180 to +180). To support geometries in a coordinate range from -540\n          // to +540, we add at least 1 world width on each side of the projection\n          // extent. If the viewport is wider than the world, we need to add half of\n          // the viewport width to make sure we cover the whole viewport.\n          var worldWidth = getWidth(projectionExtent);\n          var gutter = Math.max(getWidth(extent) / 2, worldWidth);\n          extent[0] = projectionExtent[0] - gutter;\n          extent[2] = projectionExtent[2] + gutter;\n        }\n\n        if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.renderedExtent_, extent)) {\n          this.replayGroupChanged = false;\n          return true;\n        }\n\n        this.replayGroup_ = null;\n        this.dirty_ = false;\n        var replayGroup = new CanvasReplayGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n        vectorSource.loadFeatures(extent, resolution, projection);\n        /**\n         * @param {import(\"../../Feature.js\").default} feature Feature.\n         * @this {CanvasVectorLayerRenderer}\n         */\n\n        var render = function (feature) {\n          var styles;\n          var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n\n          if (styleFunction) {\n            styles = styleFunction(feature, resolution);\n          }\n\n          if (styles) {\n            var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);\n            this.dirty_ = this.dirty_ || dirty;\n          }\n        }.bind(this);\n\n        if (vectorLayerRenderOrder) {\n          /** @type {Array<import(\"../../Feature.js\").default>} */\n          var features = [];\n          vectorSource.forEachFeatureInExtent(extent,\n          /**\n           * @param {import(\"../../Feature.js\").default} feature Feature.\n           */\n          function (feature) {\n            features.push(feature);\n          });\n          features.sort(vectorLayerRenderOrder);\n\n          for (var i = 0, ii = features.length; i < ii; ++i) {\n            render(features[i]);\n          }\n        } else {\n          vectorSource.forEachFeatureInExtent(extent, render);\n        }\n\n        replayGroup.finish();\n        this.renderedResolution_ = resolution;\n        this.renderedRevision_ = vectorLayerRevision;\n        this.renderedRenderOrder_ = vectorLayerRenderOrder;\n        this.renderedExtent_ = extent;\n        this.replayGroup_ = replayGroup;\n        this.replayGroupChanged = true;\n        return true;\n      };\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       * @param {number} resolution Resolution.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n       * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n       * @return {boolean} `true` if an image is loading.\n       */\n\n\n      CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, resolution, pixelRatio, styles, replayGroup) {\n        if (!styles) {\n          return false;\n        }\n\n        var loading = false;\n\n        if (Array.isArray(styles)) {\n          for (var i = 0, ii = styles.length; i < ii; ++i) {\n            loading = renderFeature(replayGroup, feature, styles[i], getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;\n          }\n        } else {\n          loading = renderFeature(replayGroup, feature, styles, getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);\n        }\n\n        return loading;\n      };\n\n      return CanvasVectorLayerRenderer;\n    }(CanvasLayerRenderer);\n    /**\n     * Determine if this renderer handles the provided layer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n     * @return {boolean} The renderer can render the layer.\n     */\n\n\n    CanvasVectorLayerRenderer['handles'] = function (layer) {\n      return layer.getType() === LayerType.VECTOR;\n    };\n    /**\n     * Create a layer renderer.\n     * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n     * @return {CanvasVectorLayerRenderer} The layer renderer.\n     */\n\n\n    CanvasVectorLayerRenderer['create'] = function (mapRenderer, layer) {\n      return new CanvasVectorLayerRenderer(\n      /** @type {import(\"../../layer/Vector.js\").default} */\n      layer);\n    };\n    /**\n     * @module ol/layer/VectorTileRenderType\n     */\n\n    /**\n     * @enum {string}\n     * Render mode for vector tiles:\n     *  * `'image'`: Vector tiles are rendered as images. Great performance, but\n     *    point symbols and texts are always rotated with the view and pixels are\n     *    scaled during zoom animations.\n     *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels\n     *    are scaled during zoom animations. Point symbols and texts are accurately\n     *    rendered as vectors and can stay upright on rotated views.\n     *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering\n     *    even during animations, but slower performance than the other options.\n     * @api\n     */\n\n\n    var VectorTileRenderType = {\n      IMAGE: 'image',\n      HYBRID: 'hybrid',\n      VECTOR: 'vector'\n    };\n    /**\n     * @module ol/renderer/canvas/VectorTileLayer\n     */\n\n    /**\n     * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n     */\n\n    var IMAGE_REPLAYS = {\n      'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n      'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n    };\n    /**\n     * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n     */\n\n    var VECTOR_REPLAYS = {\n      'image': [ReplayType.DEFAULT],\n      'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n      'vector': ORDER\n    };\n    /**\n     * @classdesc\n     * Canvas renderer for vector tile layers.\n     * @api\n     */\n\n    var CanvasVectorTileLayerRenderer =\n    /*@__PURE__*/\n    function (CanvasTileLayerRenderer$$1) {\n      function CanvasVectorTileLayerRenderer(layer) {\n        CanvasTileLayerRenderer$$1.call(this, layer, true);\n        /**\n         * Declutter tree.\n         * @private\n         */\n\n        this.declutterTree_ = layer.getDeclutter() ? rbush_1(9, undefined) : null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.dirty_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.renderedLayerRevision_;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.tmpTransform_ = create();\n        var renderMode = layer.getRenderMode(); // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n\n        this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n\n        if (renderMode !== VectorTileRenderType.VECTOR) {\n          this.context = createCanvasContext2D();\n        }\n\n        listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n      }\n\n      if (CanvasTileLayerRenderer$$1) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer$$1;\n      CanvasVectorTileLayerRenderer.prototype = Object.create(CanvasTileLayerRenderer$$1 && CanvasTileLayerRenderer$$1.prototype);\n      CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;\n      /**\n       * @inheritDoc\n       */\n\n      CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n        unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n        CanvasTileLayerRenderer$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n        var tile = CanvasTileLayerRenderer$$1.prototype.getTile.call(this, z, x, y, pixelRatio, projection);\n\n        if (tile.getState() === TileState.LOADED) {\n          this.createReplayGroup_(\n          /** @type {import(\"../../VectorImageTile.js\").default} */\n          tile, pixelRatio, projection);\n\n          if (this.context) {\n            this.renderTileImage_(\n            /** @type {import(\"../../VectorImageTile.js\").default} */\n            tile, pixelRatio, projection);\n          }\n        }\n\n        return tile;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n        var tileLayer =\n        /** @type {import(\"../../layer/Tile.js\").default} */\n        this.getLayer();\n        return (\n          /** @type {import(\"../../VectorImageTile.js\").default} */\n          tile.getImage(tileLayer)\n        );\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n        var layer =\n        /** @type {import(\"../../layer/Vector.js\").default} */\n        this.getLayer();\n        var layerRevision = layer.getRevision();\n\n        if (this.renderedLayerRevision_ != layerRevision) {\n          this.renderedTiles.length = 0;\n        }\n\n        this.renderedLayerRevision_ = layerRevision;\n        return CanvasTileLayerRenderer$$1.prototype.prepareFrame.call(this, frameState, layerState);\n      };\n      /**\n       * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n       * @private\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_(tile, pixelRatio, projection) {\n        var this$1 = this;\n        var layer =\n        /** @type {import(\"../../layer/Vector.js\").default} */\n        this.getLayer();\n        var revision = layer.getRevision();\n        var renderOrder =\n        /** @type {import(\"../../render.js\").OrderFunction} */\n        layer.getRenderOrder() || null;\n        var replayState = tile.getReplayState(layer);\n\n        if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {\n          return;\n        }\n\n        var source =\n        /** @type {import(\"../../source/VectorTile.js\").default} */\n        layer.getSource();\n        var sourceTileGrid = source.getTileGrid();\n        var tileGrid = source.getTileGridForProjection(projection);\n        var resolution = tileGrid.getResolution(tile.tileCoord[0]);\n        var tileExtent = tile.extent;\n\n        var loop = function loop(t, tt) {\n          var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n          if (sourceTile.getState() != TileState.LOADED) {\n            return;\n          }\n\n          var sourceTileCoord = sourceTile.tileCoord;\n          var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n          var bufferedExtent = equals$2(sourceTileExtent, sharedExtent) ? null : buffer(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);\n          var tileProjection = sourceTile.getProjection();\n          var reproject = false;\n\n          if (!equivalent(projection, tileProjection)) {\n            reproject = true;\n            sourceTile.setProjection(projection);\n          }\n\n          replayState.dirty = false;\n          var replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());\n          var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);\n          /**\n           * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n           * @this {CanvasVectorTileLayerRenderer}\n           */\n\n          var render = function render(feature) {\n            var styles;\n            var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n            if (styleFunction) {\n              styles = styleFunction(feature, resolution);\n            }\n\n            if (styles) {\n              var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n              this.dirty_ = this.dirty_ || dirty;\n              replayState.dirty = replayState.dirty || dirty;\n            }\n          };\n\n          var features = sourceTile.getFeatures();\n\n          if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n            features.sort(renderOrder);\n          }\n\n          for (var i = 0, ii = features.length; i < ii; ++i) {\n            var feature = features[i];\n\n            if (reproject) {\n              if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n                // projected tile extent\n                tileProjection.setWorldExtent(sourceTileExtent); // tile extent in tile pixel space\n\n                tileProjection.setExtent(sourceTile.getExtent());\n              }\n\n              feature.getGeometry().transform(tileProjection, projection);\n            }\n\n            if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n              render.call(this$1, feature);\n            }\n          }\n\n          replayGroup.finish();\n          sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n        };\n\n        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          loop(t, tt);\n        }\n\n        replayState.renderedRevision = revision;\n        replayState.renderedRenderOrder = renderOrder;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n        var resolution = frameState.viewState.resolution;\n        var rotation = frameState.viewState.rotation;\n        hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n        var layer = this.getLayer();\n        /** @type {!Object<string, boolean>} */\n\n        var features = {};\n        var renderedTiles =\n        /** @type {Array<import(\"../../VectorImageTile.js\").default>} */\n        this.renderedTiles;\n        var bufferedExtent, found;\n        var i, ii;\n\n        for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n          var tile = renderedTiles[i];\n          bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n\n          if (!containsCoordinate(bufferedExtent, coordinate)) {\n            continue;\n          }\n\n          for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n            var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n            if (sourceTile.getState() != TileState.LOADED) {\n              continue;\n            }\n\n            var replayGroup =\n            /** @type {CanvasReplayGroup} */\n            sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n            found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n            /**\n             * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n             * @return {?} Callback result.\n             */\n            function (feature) {\n              var key = getUid(feature);\n\n              if (!(key in features)) {\n                features[key] = true;\n                return callback.call(thisArg, feature, layer);\n              }\n            }, null);\n          }\n        }\n\n        return found;\n      };\n      /**\n       * @param {import(\"../../VectorTile.js\").default} tile Tile.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @return {import(\"../../transform.js\").Transform} transform Transform.\n       * @private\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_(tile, frameState) {\n        var layer = this.getLayer();\n        var source =\n        /** @type {import(\"../../source/VectorTile.js\").default} */\n        layer.getSource();\n        var tileGrid = source.getTileGrid();\n        var tileCoord = tile.tileCoord;\n        var tileResolution = tileGrid.getResolution(tileCoord[0]);\n        var viewState = frameState.viewState;\n        var pixelRatio = frameState.pixelRatio;\n        var renderResolution = viewState.resolution / pixelRatio;\n        var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n        var center = viewState.center;\n        var origin = getTopLeft(tileExtent);\n        var size = frameState.size;\n        var offsetX = Math.round(pixelRatio * size[0] / 2);\n        var offsetY = Math.round(pixelRatio * size[1] / 2);\n        return compose(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);\n      };\n      /**\n       * @param {import(\"../../events/Event.js\").default} event Event.\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n        var layer = this.getLayer();\n\n        if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n          layer.changed();\n        }\n      };\n      /**\n       * Handle changes in image style state.\n       * @param {import(\"../../events/Event.js\").default} event Image style change event.\n       * @private\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n        this.renderIfReadyAndVisible();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose(context, frameState, layerState) {\n        var layer =\n        /** @type {import(\"../../layer/Vector.js\").default} */\n        this.getLayer();\n        var renderMode = layer.getRenderMode();\n\n        if (renderMode != VectorTileRenderType.IMAGE) {\n          var declutterReplays = layer.getDeclutter() ? {} : null;\n          var source =\n          /** @type {import(\"../../source/VectorTile.js\").default} */\n          layer.getSource();\n          var replayTypes = VECTOR_REPLAYS[renderMode];\n          var pixelRatio = frameState.pixelRatio;\n          var rotation = frameState.viewState.rotation;\n          var size = frameState.size;\n          var offsetX, offsetY;\n\n          if (rotation) {\n            offsetX = Math.round(pixelRatio * size[0] / 2);\n            offsetY = Math.round(pixelRatio * size[1] / 2);\n            rotateAtOffset(context, -rotation, offsetX, offsetY);\n          }\n\n          if (declutterReplays) {\n            this.declutterTree_.clear();\n          }\n\n          var viewHints = frameState.viewHints;\n          var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n          var tiles = this.renderedTiles;\n          var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n          var clips = [];\n          var zs = [];\n\n          for (var i = tiles.length - 1; i >= 0; --i) {\n            var tile =\n            /** @type {import(\"../../VectorImageTile.js\").default} */\n            tiles[i];\n\n            if (tile.getState() == TileState.ABORT) {\n              continue;\n            }\n\n            var tileCoord = tile.tileCoord;\n            var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n            var transform$$1 = undefined;\n\n            for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n              var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n              if (sourceTile.getState() != TileState.LOADED) {\n                continue;\n              }\n\n              var replayGroup =\n              /** @type {CanvasReplayGroup} */\n              sourceTile.getReplayGroup(layer, tileCoord.toString());\n\n              if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n                // sourceTile was not yet loaded when this.createReplayGroup_() was\n                // called, or it has no replays of the types we want to render\n                continue;\n              }\n\n              if (!transform$$1) {\n                transform$$1 = this.getTransform(frameState, worldOffset);\n              }\n\n              var currentZ = sourceTile.tileCoord[0];\n              var currentClip = replayGroup.getClipCoords(transform$$1);\n              context.save();\n              context.globalAlpha = layerState.opacity; // Create a clip mask for regions in this low resolution tile that are\n              // already filled by a higher resolution tile\n\n              for (var j = 0, jj = clips.length; j < jj; ++j) {\n                var clip = clips[j];\n\n                if (currentZ < zs[j]) {\n                  context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile\n\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n\n              replayGroup.replay(context, transform$$1, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n              context.restore();\n              clips.push(currentClip);\n              zs.push(currentZ);\n            }\n          }\n\n          if (declutterReplays) {\n            replayDeclutter(declutterReplays, context, rotation, snapToPixel);\n          }\n\n          if (rotation) {\n            rotateAtOffset(context, rotation,\n            /** @type {number} */\n            offsetX,\n            /** @type {number} */\n            offsetY);\n          }\n        }\n\n        CanvasTileLayerRenderer$$1.prototype.postCompose.call(this, context, frameState, layerState);\n      };\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} squaredTolerance Squared tolerance.\n       * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n       * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n       * @return {boolean} `true` if an image is loading.\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, squaredTolerance, styles, replayGroup) {\n        if (!styles) {\n          return false;\n        }\n\n        var loading = false;\n\n        if (Array.isArray(styles)) {\n          for (var i = 0, ii = styles.length; i < ii; ++i) {\n            loading = renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;\n          }\n        } else {\n          loading = renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);\n        }\n\n        return loading;\n      };\n      /**\n       * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n       * @private\n       */\n\n\n      CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_(tile, pixelRatio, projection) {\n        var layer =\n        /** @type {import(\"../../layer/Vector.js\").default} */\n        this.getLayer();\n        var replayState = tile.getReplayState(layer);\n        var revision = layer.getRevision();\n        var replays = IMAGE_REPLAYS[layer.getRenderMode()];\n\n        if (replays && replayState.renderedTileRevision !== revision) {\n          replayState.renderedTileRevision = revision;\n          var tileCoord = tile.wrappedTileCoord;\n          var z = tileCoord[0];\n          var source =\n          /** @type {import(\"../../source/VectorTile.js\").default} */\n          layer.getSource();\n          var tileGrid = source.getTileGridForProjection(projection);\n          var resolution = tileGrid.getResolution(z);\n          var context = tile.getContext(layer);\n          var size = source.getTilePixelSize(z, pixelRatio, projection);\n          context.canvas.width = size[0];\n          context.canvas.height = size[1];\n          var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n\n          for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n            var sourceTile = tile.getTile(tile.tileKeys[i]);\n\n            if (sourceTile.getState() != TileState.LOADED) {\n              continue;\n            }\n\n            var pixelScale = pixelRatio / resolution;\n            var transform$$1 = reset(this.tmpTransform_);\n            scale$2(transform$$1, pixelScale, -pixelScale);\n            translate$1(transform$$1, -tileExtent[0], -tileExtent[3]);\n            var replayGroup =\n            /** @type {CanvasReplayGroup} */\n            sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n            replayGroup.replay(context, transform$$1, 0, {}, true, replays);\n          }\n        }\n      };\n\n      return CanvasVectorTileLayerRenderer;\n    }(CanvasTileLayerRenderer);\n    /**\n     * Determine if this renderer handles the provided layer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n     * @return {boolean} The renderer can render the layer.\n     */\n\n\n    CanvasVectorTileLayerRenderer['handles'] = function (layer) {\n      return layer.getType() === LayerType.VECTOR_TILE;\n    };\n    /**\n     * Create a layer renderer.\n     * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n     * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n     */\n\n\n    CanvasVectorTileLayerRenderer['create'] = function (mapRenderer, layer) {\n      return new CanvasVectorTileLayerRenderer(\n      /** @type {import(\"../../layer/VectorTile.js\").default} */\n      layer);\n    };\n    /**\n     * @module ol/Map\n     */\n\n    /**\n     * @classdesc\n     * The map is the core component of OpenLayers. For a map to render, a view,\n     * one or more layers, and a target container are needed:\n     *\n     *     import Map from 'ol/Map';\n     *     import View from 'ol/View';\n     *     import TileLayer from 'ol/layer/Tile';\n     *     import OSM from 'ol/source/OSM';\n     *\n     *     var map = new Map({\n     *       view: new View({\n     *         center: [0, 0],\n     *         zoom: 1\n     *       }),\n     *       layers: [\n     *         new TileLayer({\n     *           source: new OSM()\n     *         })\n     *       ],\n     *       target: 'map'\n     *     });\n     *\n     * The above snippet creates a map using a {@link module:ol/layer/Tile} to\n     * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM\n     * element with the id `map`.\n     *\n     * The constructor places a viewport container (with CSS class name\n     * `ol-viewport`) in the target element (see `getViewport()`), and then two\n     * further elements within the viewport: one with CSS class name\n     * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\n     * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\n     * option of {@link module:ol/Overlay~Overlay} for the difference). The map\n     * itself is placed in a further element within the viewport.\n     *\n     * Layers are stored as a {@link module:ol/Collection~Collection} in\n     * layerGroups. A top-level group is provided by the library. This is what is\n     * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the\n     * options are added to this group, and `addLayer` and `removeLayer` change the\n     * layer collection in the group. `getLayers` is a convenience function for\n     * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}\n     * is a subclass of {@link module:ol/layer/Base}, so layers entered in the\n     * options or added with `addLayer` can be groups, which can contain further\n     * groups, and so on.\n     *\n     * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n     * @fires import(\"./MapEvent.js\").MapEvent\n     * @fires module:ol/render/Event~RenderEvent#postcompose\n     * @fires module:ol/render/Event~RenderEvent#precompose\n     * @api\n     */\n\n\n    var Map =\n    /*@__PURE__*/\n    function (PluggableMap$$1) {\n      function Map(options) {\n        options = assign({}, options);\n\n        if (!options.controls) {\n          options.controls = defaults();\n        }\n\n        if (!options.interactions) {\n          options.interactions = defaults$1();\n        }\n\n        PluggableMap$$1.call(this, options);\n      }\n\n      if (PluggableMap$$1) Map.__proto__ = PluggableMap$$1;\n      Map.prototype = Object.create(PluggableMap$$1 && PluggableMap$$1.prototype);\n      Map.prototype.constructor = Map;\n\n      Map.prototype.createRenderer = function createRenderer() {\n        var renderer = new CanvasMapRenderer(this);\n        renderer.registerLayerRenderers([CanvasImageLayerRenderer, CanvasTileLayerRenderer, CanvasVectorLayerRenderer, CanvasVectorTileLayerRenderer]);\n        return renderer;\n      };\n\n      return Map;\n    }(PluggableMap);\n    /**\n     * @module ol/OverlayPositioning\n     */\n\n    /**\n     * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n     * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n     * `'top-center'`, `'top-right'`\n     * @enum {string}\n     */\n\n\n    var OverlayPositioning = {\n      BOTTOM_LEFT: 'bottom-left',\n      BOTTOM_CENTER: 'bottom-center',\n      BOTTOM_RIGHT: 'bottom-right',\n      CENTER_LEFT: 'center-left',\n      CENTER_CENTER: 'center-center',\n      CENTER_RIGHT: 'center-right',\n      TOP_LEFT: 'top-left',\n      TOP_CENTER: 'top-center',\n      TOP_RIGHT: 'top-right'\n    };\n    /**\n     * @module ol/Overlay\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number|string} [id] Set the overlay id. The overlay id can be used\n     * with the {@link module:ol/Map~Map#getOverlayById} method.\n     * @property {HTMLElement} [element] The overlay element.\n     * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n     * the overlay. The first element in the\n     * array is the horizontal offset. A positive value shifts the overlay right.\n     * The second element in the array is the vertical offset. A positive value\n     * shifts the overlay down.\n     * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n     * in map projection.\n     * @property {OverlayPositioning} [positioning='top-left'] Defines how\n     * the overlay is actually positioned with respect to its `position` property.\n     * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n     * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n     * `'top-center'`, and `'top-right'`.\n     * @property {boolean} [stopEvent=true] Whether event propagation to the map\n     * viewport should be stopped. If `true` the overlay is placed in the same\n     * container as that of the controls (CSS class name\n     * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n     * with CSS class name specified by the `className` property.\n     * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n     * in the overlay container, or appended. If the overlay is placed in the same\n     * container as that of the controls (see the `stopEvent` option) you will\n     * probably set `insertFirst` to `true` so the overlay is displayed below the\n     * controls.\n     * @property {boolean} [autoPan=false] If set to `true` the map is panned when\n     * calling `setPosition`, so that the overlay is entirely visible in the current\n     * viewport.\n     * @property {PanOptions} [autoPanAnimation] The\n     * animation options used to pan the overlay into view. This animation is only\n     * used when `autoPan` is enabled. A `duration` and `easing` may be provided to\n     * customize the animation.\n     * @property {number} [autoPanMargin=20] The margin (in pixels) between the\n     * overlay and the borders of the map when autopanning.\n     * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n     * name.\n     */\n\n    /**\n     * @typedef {Object} PanOptions\n     * @property {number} [duration=1000] The duration of the animation in\n     * milliseconds.\n     * @property {function(number):number} [easing] The easing function to use. Can\n     * be one from {@link module:ol/easing} or a custom function.\n     * Default is {@link module:ol/easing~inAndOut}.\n     */\n\n    /**\n     * @enum {string}\n     * @protected\n     */\n\n    var Property$3 = {\n      ELEMENT: 'element',\n      MAP: 'map',\n      OFFSET: 'offset',\n      POSITION: 'position',\n      POSITIONING: 'positioning'\n    };\n    /**\n     * @classdesc\n     * An element to be displayed over the map and attached to a single map\n     * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n     * visible widgets. Unlike Controls, they are not in a fixed position on the\n     * screen, but are tied to a geographical coordinate, so panning the map will\n     * move an Overlay but not a Control.\n     *\n     * Example:\n     *\n     *     import Overlay from 'ol/Overlay';\n     *\n     *     var popup = new Overlay({\n     *       element: document.getElementById('popup')\n     *     });\n     *     popup.setPosition(coordinate);\n     *     map.addOverlay(popup);\n     *\n     * @api\n     */\n\n    var Overlay =\n    /*@__PURE__*/\n    function (BaseObject$$1) {\n      function Overlay(options) {\n        BaseObject$$1.call(this);\n        /**\n         * @protected\n         * @type {Options}\n         */\n\n        this.options = options;\n        /**\n         * @protected\n         * @type {number|string|undefined}\n         */\n\n        this.id = options.id;\n        /**\n         * @protected\n         * @type {boolean}\n         */\n\n        this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;\n        /**\n         * @protected\n         * @type {boolean}\n         */\n\n        this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n        /**\n         * @protected\n         * @type {HTMLElement}\n         */\n\n        this.element = document.createElement('div');\n        this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + CLASS_SELECTABLE;\n        this.element.style.position = 'absolute';\n        /**\n         * @protected\n         * @type {boolean}\n         */\n\n        this.autoPan = options.autoPan !== undefined ? options.autoPan : false;\n        /**\n         * @protected\n         * @type {PanOptions}\n         */\n\n        this.autoPanAnimation = options.autoPanAnimation ||\n        /** @type {PanOptions} */\n        {};\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.autoPanMargin = options.autoPanMargin !== undefined ? options.autoPanMargin : 20;\n        /**\n         * @protected\n         * @type {{bottom_: string,\n         *         left_: string,\n         *         right_: string,\n         *         top_: string,\n         *         visible: boolean}}\n         */\n\n        this.rendered = {\n          bottom_: '',\n          left_: '',\n          right_: '',\n          top_: '',\n          visible: true\n        };\n        /**\n         * @protected\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n\n        this.mapPostrenderListenerKey = null;\n        listen(this, getChangeEventType(Property$3.ELEMENT), this.handleElementChanged, this);\n        listen(this, getChangeEventType(Property$3.MAP), this.handleMapChanged, this);\n        listen(this, getChangeEventType(Property$3.OFFSET), this.handleOffsetChanged, this);\n        listen(this, getChangeEventType(Property$3.POSITION), this.handlePositionChanged, this);\n        listen(this, getChangeEventType(Property$3.POSITIONING), this.handlePositioningChanged, this);\n\n        if (options.element !== undefined) {\n          this.setElement(options.element);\n        }\n\n        this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n        this.setPositioning(options.positioning !== undefined ?\n        /** @type {OverlayPositioning} */\n        options.positioning : OverlayPositioning.TOP_LEFT);\n\n        if (options.position !== undefined) {\n          this.setPosition(options.position);\n        }\n      }\n\n      if (BaseObject$$1) Overlay.__proto__ = BaseObject$$1;\n      Overlay.prototype = Object.create(BaseObject$$1 && BaseObject$$1.prototype);\n      Overlay.prototype.constructor = Overlay;\n      /**\n       * Get the DOM element of this overlay.\n       * @return {HTMLElement|undefined} The Element containing the overlay.\n       * @observable\n       * @api\n       */\n\n      Overlay.prototype.getElement = function getElement() {\n        return (\n          /** @type {HTMLElement|undefined} */\n          this.get(Property$3.ELEMENT)\n        );\n      };\n      /**\n       * Get the overlay identifier which is set on constructor.\n       * @return {number|string|undefined} Id.\n       * @api\n       */\n\n\n      Overlay.prototype.getId = function getId() {\n        return this.id;\n      };\n      /**\n       * Get the map associated with this overlay.\n       * @return {import(\"./PluggableMap.js\").default|undefined} The map that the\n       * overlay is part of.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.getMap = function getMap() {\n        return (\n          /** @type {import(\"./PluggableMap.js\").default|undefined} */\n          this.get(Property$3.MAP)\n        );\n      };\n      /**\n       * Get the offset of this overlay.\n       * @return {Array<number>} The offset.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.getOffset = function getOffset() {\n        return (\n          /** @type {Array<number>} */\n          this.get(Property$3.OFFSET)\n        );\n      };\n      /**\n       * Get the current position of this overlay.\n       * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n       *     anchored at.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.getPosition = function getPosition() {\n        return (\n          /** @type {import(\"./coordinate.js\").Coordinate|undefined} */\n          this.get(Property$3.POSITION)\n        );\n      };\n      /**\n       * Get the current positioning of this overlay.\n       * @return {OverlayPositioning} How the overlay is positioned\n       *     relative to its point on the map.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.getPositioning = function getPositioning() {\n        return (\n          /** @type {OverlayPositioning} */\n          this.get(Property$3.POSITIONING)\n        );\n      };\n      /**\n       * @protected\n       */\n\n\n      Overlay.prototype.handleElementChanged = function handleElementChanged() {\n        removeChildren(this.element);\n        var element = this.getElement();\n\n        if (element) {\n          this.element.appendChild(element);\n        }\n      };\n      /**\n       * @protected\n       */\n\n\n      Overlay.prototype.handleMapChanged = function handleMapChanged() {\n        if (this.mapPostrenderListenerKey) {\n          removeNode(this.element);\n          unlistenByKey(this.mapPostrenderListenerKey);\n          this.mapPostrenderListenerKey = null;\n        }\n\n        var map = this.getMap();\n\n        if (map) {\n          this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);\n          this.updatePixelPosition();\n          var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();\n\n          if (this.insertFirst) {\n            container.insertBefore(this.element, container.childNodes[0] || null);\n          } else {\n            container.appendChild(this.element);\n          }\n        }\n      };\n      /**\n       * @protected\n       */\n\n\n      Overlay.prototype.render = function render() {\n        this.updatePixelPosition();\n      };\n      /**\n       * @protected\n       */\n\n\n      Overlay.prototype.handleOffsetChanged = function handleOffsetChanged() {\n        this.updatePixelPosition();\n      };\n      /**\n       * @protected\n       */\n\n\n      Overlay.prototype.handlePositionChanged = function handlePositionChanged() {\n        this.updatePixelPosition();\n\n        if (this.get(Property$3.POSITION) && this.autoPan) {\n          this.panIntoView();\n        }\n      };\n      /**\n       * @protected\n       */\n\n\n      Overlay.prototype.handlePositioningChanged = function handlePositioningChanged() {\n        this.updatePixelPosition();\n      };\n      /**\n       * Set the DOM element to be associated with this overlay.\n       * @param {HTMLElement|undefined} element The Element containing the overlay.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.setElement = function setElement(element) {\n        this.set(Property$3.ELEMENT, element);\n      };\n      /**\n       * Set the map to be associated with this overlay.\n       * @param {import(\"./PluggableMap.js\").default|undefined} map The map that the\n       * overlay is part of.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.setMap = function setMap(map) {\n        this.set(Property$3.MAP, map);\n      };\n      /**\n       * Set the offset for this overlay.\n       * @param {Array<number>} offset Offset.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.setOffset = function setOffset(offset) {\n        this.set(Property$3.OFFSET, offset);\n      };\n      /**\n       * Set the position for this overlay. If the position is `undefined` the\n       * overlay is hidden.\n       * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n       *     is anchored at.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.setPosition = function setPosition(position) {\n        this.set(Property$3.POSITION, position);\n      };\n      /**\n       * Pan the map so that the overlay is entirely visible in the current viewport\n       * (if necessary).\n       * @protected\n       */\n\n\n      Overlay.prototype.panIntoView = function panIntoView() {\n        var map = this.getMap();\n\n        if (!map || !map.getTargetElement()) {\n          return;\n        }\n\n        var mapRect = this.getRect(map.getTargetElement(), map.getSize());\n        var element = this.getElement();\n        var overlayRect = this.getRect(element, [outerWidth(element), outerHeight(element)]);\n        var margin = this.autoPanMargin;\n\n        if (!containsExtent(mapRect, overlayRect)) {\n          // the overlay is not completely inside the viewport, so pan the map\n          var offsetLeft = overlayRect[0] - mapRect[0];\n          var offsetRight = mapRect[2] - overlayRect[2];\n          var offsetTop = overlayRect[1] - mapRect[1];\n          var offsetBottom = mapRect[3] - overlayRect[3];\n          var delta = [0, 0];\n\n          if (offsetLeft < 0) {\n            // move map to the left\n            delta[0] = offsetLeft - margin;\n          } else if (offsetRight < 0) {\n            // move map to the right\n            delta[0] = Math.abs(offsetRight) + margin;\n          }\n\n          if (offsetTop < 0) {\n            // move map up\n            delta[1] = offsetTop - margin;\n          } else if (offsetBottom < 0) {\n            // move map down\n            delta[1] = Math.abs(offsetBottom) + margin;\n          }\n\n          if (delta[0] !== 0 || delta[1] !== 0) {\n            var center =\n            /** @type {import(\"./coordinate.js\").Coordinate} */\n            map.getView().getCenter();\n            var centerPx = map.getPixelFromCoordinate(center);\n            var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n            map.getView().animate({\n              center: map.getCoordinateFromPixel(newCenterPx),\n              duration: this.autoPanAnimation.duration,\n              easing: this.autoPanAnimation.easing\n            });\n          }\n        }\n      };\n      /**\n       * Get the extent of an element relative to the document\n       * @param {HTMLElement|undefined} element The element.\n       * @param {import(\"./size.js\").Size|undefined} size The size of the element.\n       * @return {import(\"./extent.js\").Extent} The extent.\n       * @protected\n       */\n\n\n      Overlay.prototype.getRect = function getRect(element, size) {\n        var box = element.getBoundingClientRect();\n        var offsetX = box.left + window.pageXOffset;\n        var offsetY = box.top + window.pageYOffset;\n        return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n      };\n      /**\n       * Set the positioning for this overlay.\n       * @param {OverlayPositioning} positioning how the overlay is\n       *     positioned relative to its point on the map.\n       * @observable\n       * @api\n       */\n\n\n      Overlay.prototype.setPositioning = function setPositioning(positioning) {\n        this.set(Property$3.POSITIONING, positioning);\n      };\n      /**\n       * Modify the visibility of the element.\n       * @param {boolean} visible Element visibility.\n       * @protected\n       */\n\n\n      Overlay.prototype.setVisible = function setVisible(visible) {\n        if (this.rendered.visible !== visible) {\n          this.element.style.display = visible ? '' : 'none';\n          this.rendered.visible = visible;\n        }\n      };\n      /**\n       * Update pixel position.\n       * @protected\n       */\n\n\n      Overlay.prototype.updatePixelPosition = function updatePixelPosition() {\n        var map = this.getMap();\n        var position = this.getPosition();\n\n        if (!map || !map.isRendered() || !position) {\n          this.setVisible(false);\n          return;\n        }\n\n        var pixel = map.getPixelFromCoordinate(position);\n        var mapSize = map.getSize();\n        this.updateRenderedPosition(pixel, mapSize);\n      };\n      /**\n       * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n       * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n       * @protected\n       */\n\n\n      Overlay.prototype.updateRenderedPosition = function updateRenderedPosition(pixel, mapSize) {\n        var style = this.element.style;\n        var offset = this.getOffset();\n        var positioning = this.getPositioning();\n        this.setVisible(true);\n        var offsetX = offset[0];\n        var offsetY = offset[1];\n\n        if (positioning == OverlayPositioning.BOTTOM_RIGHT || positioning == OverlayPositioning.CENTER_RIGHT || positioning == OverlayPositioning.TOP_RIGHT) {\n          if (this.rendered.left_ !== '') {\n            this.rendered.left_ = style.left = '';\n          }\n\n          var right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';\n\n          if (this.rendered.right_ != right) {\n            this.rendered.right_ = style.right = right;\n          }\n        } else {\n          if (this.rendered.right_ !== '') {\n            this.rendered.right_ = style.right = '';\n          }\n\n          if (positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.TOP_CENTER) {\n            offsetX -= this.element.offsetWidth / 2;\n          }\n\n          var left = Math.round(pixel[0] + offsetX) + 'px';\n\n          if (this.rendered.left_ != left) {\n            this.rendered.left_ = style.left = left;\n          }\n        }\n\n        if (positioning == OverlayPositioning.BOTTOM_LEFT || positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.BOTTOM_RIGHT) {\n          if (this.rendered.top_ !== '') {\n            this.rendered.top_ = style.top = '';\n          }\n\n          var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';\n\n          if (this.rendered.bottom_ != bottom) {\n            this.rendered.bottom_ = style.bottom = bottom;\n          }\n        } else {\n          if (this.rendered.bottom_ !== '') {\n            this.rendered.bottom_ = style.bottom = '';\n          }\n\n          if (positioning == OverlayPositioning.CENTER_LEFT || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.CENTER_RIGHT) {\n            offsetY -= this.element.offsetHeight / 2;\n          }\n\n          var top = Math.round(pixel[1] + offsetY) + 'px';\n\n          if (this.rendered.top_ != top) {\n            this.rendered.top_ = style.top = top;\n          }\n        }\n      };\n      /**\n       * returns the options this Overlay has been created with\n       * @return {Options} overlay options\n       */\n\n\n      Overlay.prototype.getOptions = function getOptions() {\n        return this.options;\n      };\n\n      return Overlay;\n    }(BaseObject);\n    /**\n     * @module ol/control/OverviewMap\n     */\n\n    /**\n     * Maximum width and/or height extent ratio that determines when the overview\n     * map should be zoomed out.\n     * @type {number}\n     */\n\n\n    var MAX_RATIO = 0.75;\n    /**\n     * Minimum width and/or height extent ratio that determines when the overview\n     * map should be zoomed in.\n     * @type {number}\n     */\n\n    var MIN_RATIO = 0.1;\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-overviewmap'] CSS class name.\n     * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).\n     * @property {string|HTMLElement} [collapseLabel=''] Text label to use for the\n     * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.\n     * @property {string|HTMLElement} [label=''] Text label to use for the collapsed\n     * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {Array<import(\"../layer/Layer.js\").default>|import(\"../Collection.js\").default<import(\"../layer/Layer.js\").default>} [layers]\n     * Layers for the overview map. If not set, then all main map layers are used\n     * instead.\n     * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when the control\n     * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n     * @property {HTMLElement|string} [target] Specify a target if you want the control\n     * to be rendered outside of the map's viewport.\n     * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.\n     * @property {import(\"../View.js\").default} [view] Custom view for the overview map. If not provided,\n     * a default view with an EPSG:3857 projection will be used.\n     */\n\n    /**\n     * Create a new control with a map acting as an overview map for an other\n     * defined map.\n     *\n     * @api\n     */\n\n    var OverviewMap =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function OverviewMap(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          render: options.render || render$3,\n          target: options.target\n        });\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;\n\n        if (!this.collapsible_) {\n          this.collapsed_ = false;\n        }\n\n        var className = options.className !== undefined ? options.className : 'ol-overviewmap';\n        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';\n        var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : \"\\xAB\";\n\n        if (typeof collapseLabel === 'string') {\n          /**\n           * @private\n           * @type {HTMLElement}\n           */\n          this.collapseLabel_ = document.createElement('span');\n          this.collapseLabel_.textContent = collapseLabel;\n        } else {\n          this.collapseLabel_ = collapseLabel;\n        }\n\n        var label = options.label !== undefined ? options.label : \"\\xBB\";\n\n        if (typeof label === 'string') {\n          /**\n           * @private\n           * @type {HTMLElement}\n           */\n          this.label_ = document.createElement('span');\n          this.label_.textContent = label;\n        } else {\n          this.label_ = label;\n        }\n\n        var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;\n        var button = document.createElement('button');\n        button.setAttribute('type', 'button');\n        button.title = tipLabel;\n        button.appendChild(activeLabel);\n        listen(button, EventType.CLICK, this.handleClick_, this);\n        /**\n         * @type {HTMLElement}\n         * @private\n         */\n\n        this.ovmapDiv_ = document.createElement('div');\n        this.ovmapDiv_.className = 'ol-overviewmap-map';\n        /**\n         * @type {import(\"../Map.js\").default}\n         * @private\n         */\n\n        this.ovmap_ = new Map({\n          controls: new Collection(),\n          interactions: new Collection(),\n          view: options.view\n        });\n        var ovmap = this.ovmap_;\n\n        if (options.layers) {\n          /** @type {Array<import(\"../layer/Layer.js\").default>} */\n          options.layers.forEach(\n          /**\n           * @param {import(\"../layer/Layer.js\").default} layer Layer.\n           */\n          function (layer) {\n            ovmap.addLayer(layer);\n          }.bind(this));\n        }\n\n        var box = document.createElement('div');\n        box.className = 'ol-overviewmap-box';\n        box.style.boxSizing = 'border-box';\n        /**\n         * @type {import(\"../Overlay.js\").default}\n         * @private\n         */\n\n        this.boxOverlay_ = new Overlay({\n          position: [0, 0],\n          positioning: OverlayPositioning.BOTTOM_LEFT,\n          element: box\n        });\n        this.ovmap_.addOverlay(this.boxOverlay_);\n        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');\n        var element = this.element;\n        element.className = cssClasses;\n        element.appendChild(this.ovmapDiv_);\n        element.appendChild(button);\n        /* Interactive map */\n\n        var scope = this;\n        var overlay = this.boxOverlay_;\n        var overlayBox = this.boxOverlay_.getElement();\n        /* Functions definition */\n\n        var computeDesiredMousePosition = function computeDesiredMousePosition(mousePosition) {\n          return {\n            clientX: mousePosition.clientX - overlayBox.offsetWidth / 2,\n            clientY: mousePosition.clientY + overlayBox.offsetHeight / 2\n          };\n        };\n\n        var move = function move(event) {\n          var position =\n          /** @type {?} */\n          computeDesiredMousePosition(event);\n          var coordinates = ovmap.getEventCoordinate(\n          /** @type {Event} */\n          position);\n          overlay.setPosition(coordinates);\n        };\n\n        var endMoving = function endMoving(event) {\n          var coordinates = ovmap.getEventCoordinate(event);\n          scope.getMap().getView().setCenter(coordinates);\n          window.removeEventListener('mousemove', move);\n          window.removeEventListener('mouseup', endMoving);\n        };\n        /* Binding */\n\n\n        overlayBox.addEventListener('mousedown', function () {\n          window.addEventListener('mousemove', move);\n          window.addEventListener('mouseup', endMoving);\n        });\n      }\n\n      if (Control$$1) OverviewMap.__proto__ = Control$$1;\n      OverviewMap.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      OverviewMap.prototype.constructor = OverviewMap;\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n      OverviewMap.prototype.setMap = function setMap(map) {\n        var oldMap = this.getMap();\n\n        if (map === oldMap) {\n          return;\n        }\n\n        if (oldMap) {\n          var oldView = oldMap.getView();\n\n          if (oldView) {\n            this.unbindView_(oldView);\n          }\n\n          this.ovmap_.setTarget(null);\n        }\n\n        Control$$1.prototype.setMap.call(this, map);\n\n        if (map) {\n          this.ovmap_.setTarget(this.ovmapDiv_);\n          this.listenerKeys.push(listen(map, ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this)); // TODO: to really support map switching, this would need to be reworked\n\n          if (this.ovmap_.getLayers().getLength() === 0) {\n            this.ovmap_.setLayerGroup(map.getLayerGroup());\n          }\n\n          var view = map.getView();\n\n          if (view) {\n            this.bindView_(view);\n\n            if (view.isDef()) {\n              this.ovmap_.updateSize();\n              this.resetExtent_();\n            }\n          }\n        }\n      };\n      /**\n       * Handle map property changes.  This only deals with changes to the map's view.\n       * @param {import(\"../Object.js\").ObjectEvent} event The propertychange event.\n       * @private\n       */\n\n\n      OverviewMap.prototype.handleMapPropertyChange_ = function handleMapPropertyChange_(event) {\n        if (event.key === MapProperty.VIEW) {\n          var oldView =\n          /** @type {import(\"../View.js\").default} */\n          event.oldValue;\n\n          if (oldView) {\n            this.unbindView_(oldView);\n          }\n\n          var newView = this.getMap().getView();\n          this.bindView_(newView);\n        }\n      };\n      /**\n       * Register listeners for view property changes.\n       * @param {import(\"../View.js\").default} view The view.\n       * @private\n       */\n\n\n      OverviewMap.prototype.bindView_ = function bindView_(view) {\n        listen(view, getChangeEventType(ViewProperty.ROTATION), this.handleRotationChanged_, this);\n      };\n      /**\n       * Unregister listeners for view property changes.\n       * @param {import(\"../View.js\").default} view The view.\n       * @private\n       */\n\n\n      OverviewMap.prototype.unbindView_ = function unbindView_(view) {\n        unlisten(view, getChangeEventType(ViewProperty.ROTATION), this.handleRotationChanged_, this);\n      };\n      /**\n       * Handle rotation changes to the main map.\n       * TODO: This should rotate the extent rectrangle instead of the\n       * overview map's view.\n       * @private\n       */\n\n\n      OverviewMap.prototype.handleRotationChanged_ = function handleRotationChanged_() {\n        this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());\n      };\n      /**\n       * Reset the overview map extent if the box size (width or\n       * height) is less than the size of the overview map size times minRatio\n       * or is greater than the size of the overview size times maxRatio.\n       *\n       * If the map extent was not reset, the box size can fits in the defined\n       * ratio sizes. This method then checks if is contained inside the overview\n       * map current extent. If not, recenter the overview map to the current\n       * main map center location.\n       * @private\n       */\n\n\n      OverviewMap.prototype.validateExtent_ = function validateExtent_() {\n        var map = this.getMap();\n        var ovmap = this.ovmap_;\n\n        if (!map.isRendered() || !ovmap.isRendered()) {\n          return;\n        }\n\n        var mapSize =\n        /** @type {import(\"../size.js\").Size} */\n        map.getSize();\n        var view = map.getView();\n        var extent = view.calculateExtent(mapSize);\n        var ovmapSize =\n        /** @type {import(\"../size.js\").Size} */\n        ovmap.getSize();\n        var ovview = ovmap.getView();\n        var ovextent = ovview.calculateExtent(ovmapSize);\n        var topLeftPixel = ovmap.getPixelFromCoordinate(getTopLeft(extent));\n        var bottomRightPixel = ovmap.getPixelFromCoordinate(getBottomRight(extent));\n        var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);\n        var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);\n        var ovmapWidth = ovmapSize[0];\n        var ovmapHeight = ovmapSize[1];\n\n        if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {\n          this.resetExtent_();\n        } else if (!containsExtent(ovextent, extent)) {\n          this.recenter_();\n        }\n      };\n      /**\n       * Reset the overview map extent to half calculated min and max ratio times\n       * the extent of the main map.\n       * @private\n       */\n\n\n      OverviewMap.prototype.resetExtent_ = function resetExtent_() {\n        var map = this.getMap();\n        var ovmap = this.ovmap_;\n        var mapSize =\n        /** @type {import(\"../size.js\").Size} */\n        map.getSize();\n        var view = map.getView();\n        var extent = view.calculateExtent(mapSize);\n        var ovview = ovmap.getView(); // get how many times the current map overview could hold different\n        // box sizes using the min and max ratio, pick the step in the middle used\n        // to calculate the extent from the main map to set it to the overview map,\n\n        var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;\n        var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);\n        scaleFromCenter(extent, ratio);\n        ovview.fit(extent);\n      };\n      /**\n       * Set the center of the overview map to the map center without changing its\n       * resolution.\n       * @private\n       */\n\n\n      OverviewMap.prototype.recenter_ = function recenter_() {\n        var map = this.getMap();\n        var ovmap = this.ovmap_;\n        var view = map.getView();\n        var ovview = ovmap.getView();\n        ovview.setCenter(view.getCenter());\n      };\n      /**\n       * Update the box using the main map extent\n       * @private\n       */\n\n\n      OverviewMap.prototype.updateBox_ = function updateBox_() {\n        var map = this.getMap();\n        var ovmap = this.ovmap_;\n\n        if (!map.isRendered() || !ovmap.isRendered()) {\n          return;\n        }\n\n        var mapSize =\n        /** @type {import(\"../size.js\").Size} */\n        map.getSize();\n        var view = map.getView();\n        var ovview = ovmap.getView();\n        var rotation = view.getRotation();\n        var overlay = this.boxOverlay_;\n        var box = this.boxOverlay_.getElement();\n        var extent = view.calculateExtent(mapSize);\n        var ovresolution = ovview.getResolution();\n        var bottomLeft = getBottomLeft(extent);\n        var topRight = getTopRight(extent); // set position using bottom left coordinates\n\n        var rotateBottomLeft = this.calculateCoordinateRotate_(rotation, bottomLeft);\n        overlay.setPosition(rotateBottomLeft); // set box size calculated from map extent size and overview map resolution\n\n        if (box) {\n          box.style.width = Math.abs((bottomLeft[0] - topRight[0]) / ovresolution) + 'px';\n          box.style.height = Math.abs((topRight[1] - bottomLeft[1]) / ovresolution) + 'px';\n        }\n      };\n      /**\n       * @param {number} rotation Target rotation.\n       * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @return {import(\"../coordinate.js\").Coordinate|undefined} Coordinate for rotation and center anchor.\n       * @private\n       */\n\n\n      OverviewMap.prototype.calculateCoordinateRotate_ = function calculateCoordinateRotate_(rotation, coordinate) {\n        var coordinateRotate;\n        var map = this.getMap();\n        var view = map.getView();\n        var currentCenter = view.getCenter();\n\n        if (currentCenter) {\n          coordinateRotate = [coordinate[0] - currentCenter[0], coordinate[1] - currentCenter[1]];\n          rotate(coordinateRotate, rotation);\n          add(coordinateRotate, currentCenter);\n        }\n\n        return coordinateRotate;\n      };\n      /**\n       * @param {MouseEvent} event The event to handle\n       * @private\n       */\n\n\n      OverviewMap.prototype.handleClick_ = function handleClick_(event) {\n        event.preventDefault();\n        this.handleToggle_();\n      };\n      /**\n       * @private\n       */\n\n\n      OverviewMap.prototype.handleToggle_ = function handleToggle_() {\n        this.element.classList.toggle(CLASS_COLLAPSED);\n\n        if (this.collapsed_) {\n          replaceNode(this.collapseLabel_, this.label_);\n        } else {\n          replaceNode(this.label_, this.collapseLabel_);\n        }\n\n        this.collapsed_ = !this.collapsed_; // manage overview map if it had not been rendered before and control\n        // is expanded\n\n        var ovmap = this.ovmap_;\n\n        if (!this.collapsed_ && !ovmap.isRendered()) {\n          ovmap.updateSize();\n          this.resetExtent_();\n          listenOnce(ovmap, MapEventType.POSTRENDER, function (event) {\n            this.updateBox_();\n          }, this);\n        }\n      };\n      /**\n       * Return `true` if the overview map is collapsible, `false` otherwise.\n       * @return {boolean} True if the widget is collapsible.\n       * @api\n       */\n\n\n      OverviewMap.prototype.getCollapsible = function getCollapsible() {\n        return this.collapsible_;\n      };\n      /**\n       * Set whether the overview map should be collapsible.\n       * @param {boolean} collapsible True if the widget is collapsible.\n       * @api\n       */\n\n\n      OverviewMap.prototype.setCollapsible = function setCollapsible(collapsible) {\n        if (this.collapsible_ === collapsible) {\n          return;\n        }\n\n        this.collapsible_ = collapsible;\n        this.element.classList.toggle('ol-uncollapsible');\n\n        if (!collapsible && this.collapsed_) {\n          this.handleToggle_();\n        }\n      };\n      /**\n       * Collapse or expand the overview map according to the passed parameter. Will\n       * not do anything if the overview map isn't collapsible or if the current\n       * collapsed state is already the one requested.\n       * @param {boolean} collapsed True if the widget is collapsed.\n       * @api\n       */\n\n\n      OverviewMap.prototype.setCollapsed = function setCollapsed(collapsed) {\n        if (!this.collapsible_ || this.collapsed_ === collapsed) {\n          return;\n        }\n\n        this.handleToggle_();\n      };\n      /**\n       * Determine if the overview map is collapsed.\n       * @return {boolean} The overview map is collapsed.\n       * @api\n       */\n\n\n      OverviewMap.prototype.getCollapsed = function getCollapsed() {\n        return this.collapsed_;\n      };\n      /**\n       * Return the overview map.\n       * @return {import(\"../PluggableMap.js\").default} Overview map.\n       * @api\n       */\n\n\n      OverviewMap.prototype.getOverviewMap = function getOverviewMap() {\n        return this.ovmap_;\n      };\n\n      return OverviewMap;\n    }(Control);\n    /**\n     * Update the overview map element.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @this {OverviewMap}\n     * @api\n     */\n\n\n    function render$3(mapEvent) {\n      this.validateExtent_();\n      this.updateBox_();\n    }\n    /**\n     * @module ol/control/ScaleLine\n     */\n\n    /**\n     * @type {string}\n     */\n\n\n    var UNITS_PROP = 'units';\n    /**\n     * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,\n     * `'nautical'`, `'metric'`, `'us'`.\n     * @enum {string}\n     */\n\n    var Units$1 = {\n      DEGREES: 'degrees',\n      IMPERIAL: 'imperial',\n      NAUTICAL: 'nautical',\n      METRIC: 'metric',\n      US: 'us'\n    };\n    /**\n     * @const\n     * @type {Array<number>}\n     */\n\n    var LEADING_DIGITS = [1, 2, 5];\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-scale-line'] CSS Class name.\n     * @property {number} [minWidth=64] Minimum width in pixels.\n     * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when the control\n     * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n     * @property {HTMLElement|string} [target] Specify a target if you want the control\n     * to be rendered outside of the map's viewport.\n     * @property {Units|string} [units='metric'] Units.\n     */\n\n    /**\n     * @classdesc\n     * A control displaying rough y-axis distances, calculated for the center of the\n     * viewport. For conformal projections (e.g. EPSG:3857, the default view\n     * projection in OpenLayers), the scale is valid for all directions.\n     * No scale line will be shown when the y-axis distance of a pixel at the\n     * viewport center cannot be calculated in the view projection.\n     * By default the scale line will show in the bottom left portion of the map,\n     * but this can be changed by using the css selector `.ol-scale-line`.\n     *\n     * @api\n     */\n\n    var ScaleLine =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function ScaleLine(opt_options) {\n        var options = opt_options ? opt_options : {};\n        var className = options.className !== undefined ? options.className : 'ol-scale-line';\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          render: options.render || render$4,\n          target: options.target\n        });\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n\n        this.innerElement_ = document.createElement('div');\n        this.innerElement_.className = className + '-inner';\n        this.element.className = className + ' ' + CLASS_UNSELECTABLE;\n        this.element.appendChild(this.innerElement_);\n        /**\n         * @private\n         * @type {?import(\"../View.js\").State}\n         */\n\n        this.viewState_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.renderedVisible_ = false;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.renderedWidth_ = undefined;\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.renderedHTML_ = '';\n        listen(this, getChangeEventType(UNITS_PROP), this.handleUnitsChanged_, this);\n        this.setUnits(\n        /** @type {Units} */\n        options.units || Units$1.METRIC);\n      }\n\n      if (Control$$1) ScaleLine.__proto__ = Control$$1;\n      ScaleLine.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      ScaleLine.prototype.constructor = ScaleLine;\n      /**\n       * Return the units to use in the scale line.\n       * @return {Units} The units\n       * to use in the scale line.\n       * @observable\n       * @api\n       */\n\n      ScaleLine.prototype.getUnits = function getUnits() {\n        return this.get(UNITS_PROP);\n      };\n      /**\n       * @private\n       */\n\n\n      ScaleLine.prototype.handleUnitsChanged_ = function handleUnitsChanged_() {\n        this.updateElement_();\n      };\n      /**\n       * Set the units to use in the scale line.\n       * @param {Units} units The units to use in the scale line.\n       * @observable\n       * @api\n       */\n\n\n      ScaleLine.prototype.setUnits = function setUnits(units) {\n        this.set(UNITS_PROP, units);\n      };\n      /**\n       * @private\n       */\n\n\n      ScaleLine.prototype.updateElement_ = function updateElement_() {\n        var viewState = this.viewState_;\n\n        if (!viewState) {\n          if (this.renderedVisible_) {\n            this.element.style.display = 'none';\n            this.renderedVisible_ = false;\n          }\n\n          return;\n        }\n\n        var center = viewState.center;\n        var projection = viewState.projection;\n        var units = this.getUnits();\n        var pointResolutionUnits = units == Units$1.DEGREES ? Units.DEGREES : Units.METERS;\n        var pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);\n\n        if (projection.getUnits() != Units.DEGREES && projection.getMetersPerUnit() && pointResolutionUnits == Units.METERS) {\n          pointResolution *= projection.getMetersPerUnit();\n        }\n\n        var nominalCount = this.minWidth_ * pointResolution;\n        var suffix = '';\n\n        if (units == Units$1.DEGREES) {\n          var metersPerDegree = METERS_PER_UNIT[Units.DEGREES];\n\n          if (projection.getUnits() == Units.DEGREES) {\n            nominalCount *= metersPerDegree;\n          } else {\n            pointResolution /= metersPerDegree;\n          }\n\n          if (nominalCount < metersPerDegree / 60) {\n            suffix = \"\\u2033\"; // seconds\n\n            pointResolution *= 3600;\n          } else if (nominalCount < metersPerDegree) {\n            suffix = \"\\u2032\"; // minutes\n\n            pointResolution *= 60;\n          } else {\n            suffix = \"\\xB0\"; // degrees\n          }\n        } else if (units == Units$1.IMPERIAL) {\n          if (nominalCount < 0.9144) {\n            suffix = 'in';\n            pointResolution /= 0.0254;\n          } else if (nominalCount < 1609.344) {\n            suffix = 'ft';\n            pointResolution /= 0.3048;\n          } else {\n            suffix = 'mi';\n            pointResolution /= 1609.344;\n          }\n        } else if (units == Units$1.NAUTICAL) {\n          pointResolution /= 1852;\n          suffix = 'nm';\n        } else if (units == Units$1.METRIC) {\n          if (nominalCount < 0.001) {\n            suffix = 'm';\n            pointResolution *= 1000000;\n          } else if (nominalCount < 1) {\n            suffix = 'mm';\n            pointResolution *= 1000;\n          } else if (nominalCount < 1000) {\n            suffix = 'm';\n          } else {\n            suffix = 'km';\n            pointResolution /= 1000;\n          }\n        } else if (units == Units$1.US) {\n          if (nominalCount < 0.9144) {\n            suffix = 'in';\n            pointResolution *= 39.37;\n          } else if (nominalCount < 1609.344) {\n            suffix = 'ft';\n            pointResolution /= 0.30480061;\n          } else {\n            suffix = 'mi';\n            pointResolution /= 1609.3472;\n          }\n        } else {\n          assert(false, 33); // Invalid units\n        }\n\n        var i = 3 * Math.floor(Math.log(this.minWidth_ * pointResolution) / Math.log(10));\n        var count, width;\n\n        while (true) {\n          count = LEADING_DIGITS[(i % 3 + 3) % 3] * Math.pow(10, Math.floor(i / 3));\n          width = Math.round(count / pointResolution);\n\n          if (isNaN(width)) {\n            this.element.style.display = 'none';\n            this.renderedVisible_ = false;\n            return;\n          } else if (width >= this.minWidth_) {\n            break;\n          }\n\n          ++i;\n        }\n\n        var html = count + ' ' + suffix;\n\n        if (this.renderedHTML_ != html) {\n          this.innerElement_.innerHTML = html;\n          this.renderedHTML_ = html;\n        }\n\n        if (this.renderedWidth_ != width) {\n          this.innerElement_.style.width = width + 'px';\n          this.renderedWidth_ = width;\n        }\n\n        if (!this.renderedVisible_) {\n          this.element.style.display = '';\n          this.renderedVisible_ = true;\n        }\n      };\n\n      return ScaleLine;\n    }(Control);\n    /**\n     * Update the scale line element.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @this {ScaleLine}\n     * @api\n     */\n\n\n    function render$4(mapEvent) {\n      var frameState = mapEvent.frameState;\n\n      if (!frameState) {\n        this.viewState_ = null;\n      } else {\n        this.viewState_ = frameState.viewState;\n      }\n\n      this.updateElement_();\n    }\n    /**\n     * @module ol/control/ZoomSlider\n     */\n\n    /**\n     * The enum for available directions.\n     *\n     * @enum {number}\n     */\n\n\n    var Direction = {\n      VERTICAL: 0,\n      HORIZONTAL: 1\n    };\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-zoomslider'] CSS class name.\n     * @property {number} [duration=200] Animation duration in milliseconds.\n     * @property {function(import(\"../MapEvent.js\").default)} [render] Function called when the control\n     * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n     */\n\n    /**\n     * @classdesc\n     * A slider type of control for zooming.\n     *\n     * Example:\n     *\n     *     map.addControl(new ZoomSlider());\n     *\n     * @api\n     */\n\n    var ZoomSlider =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function ZoomSlider(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          render: options.render || render$5\n        });\n        /**\n          * @type {!Array.<import(\"../events.js\").EventsKey>}\n          * @private\n          */\n\n        this.dragListenerKeys_ = [];\n        /**\n         * Will hold the current resolution of the view.\n         *\n         * @type {number|undefined}\n         * @private\n         */\n\n        this.currentResolution_ = undefined;\n        /**\n         * The direction of the slider. Will be determined from actual display of the\n         * container and defaults to Direction.VERTICAL.\n         *\n         * @type {Direction}\n         * @private\n         */\n\n        this.direction_ = Direction.VERTICAL;\n        /**\n         * @type {boolean}\n         * @private\n         */\n\n        this.dragging_;\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.heightLimit_ = 0;\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.widthLimit_ = 0;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n\n        this.previousX_;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n\n        this.previousY_;\n        /**\n         * The calculated thumb size (border box plus margins).  Set when initSlider_\n         * is called.\n         * @type {import(\"../size.js\").Size}\n         * @private\n         */\n\n        this.thumbSize_ = null;\n        /**\n         * Whether the slider is initialized.\n         * @type {boolean}\n         * @private\n         */\n\n        this.sliderInitialized_ = false;\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.duration_ = options.duration !== undefined ? options.duration : 200;\n        var className = options.className !== undefined ? options.className : 'ol-zoomslider';\n        var thumbElement = document.createElement('button');\n        thumbElement.setAttribute('type', 'button');\n        thumbElement.className = className + '-thumb ' + CLASS_UNSELECTABLE;\n        var containerElement = this.element;\n        containerElement.className = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n        containerElement.appendChild(thumbElement);\n        /**\n         * @type {PointerEventHandler}\n         * @private\n         */\n\n        this.dragger_ = new PointerEventHandler(containerElement);\n        listen(this.dragger_, PointerEventType.POINTERDOWN, this.handleDraggerStart_, this);\n        listen(this.dragger_, PointerEventType.POINTERMOVE, this.handleDraggerDrag_, this);\n        listen(this.dragger_, PointerEventType.POINTERUP, this.handleDraggerEnd_, this);\n        listen(containerElement, EventType.CLICK, this.handleContainerClick_, this);\n        listen(thumbElement, EventType.CLICK, stopPropagation);\n      }\n\n      if (Control$$1) ZoomSlider.__proto__ = Control$$1;\n      ZoomSlider.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      ZoomSlider.prototype.constructor = ZoomSlider;\n      /**\n       * @inheritDoc\n       */\n\n      ZoomSlider.prototype.disposeInternal = function disposeInternal() {\n        this.dragger_.dispose();\n        Control$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ZoomSlider.prototype.setMap = function setMap(map) {\n        Control$$1.prototype.setMap.call(this, map);\n\n        if (map) {\n          map.render();\n        }\n      };\n      /**\n       * Initializes the slider element. This will determine and set this controls\n       * direction_ and also constrain the dragging of the thumb to always be within\n       * the bounds of the container.\n       *\n       * @private\n       */\n\n\n      ZoomSlider.prototype.initSlider_ = function initSlider_() {\n        var container = this.element;\n        var containerSize = {\n          width: container.offsetWidth,\n          height: container.offsetHeight\n        };\n        var thumb =\n        /** @type {HTMLElement} */\n        container.firstElementChild;\n        var computedStyle = getComputedStyle(thumb);\n        var thumbWidth = thumb.offsetWidth + parseFloat(computedStyle['marginRight']) + parseFloat(computedStyle['marginLeft']);\n        var thumbHeight = thumb.offsetHeight + parseFloat(computedStyle['marginTop']) + parseFloat(computedStyle['marginBottom']);\n        this.thumbSize_ = [thumbWidth, thumbHeight];\n\n        if (containerSize.width > containerSize.height) {\n          this.direction_ = Direction.HORIZONTAL;\n          this.widthLimit_ = containerSize.width - thumbWidth;\n        } else {\n          this.direction_ = Direction.VERTICAL;\n          this.heightLimit_ = containerSize.height - thumbHeight;\n        }\n\n        this.sliderInitialized_ = true;\n      };\n      /**\n       * @param {MouseEvent} event The browser event to handle.\n       * @private\n       */\n\n\n      ZoomSlider.prototype.handleContainerClick_ = function handleContainerClick_(event) {\n        var view = this.getMap().getView();\n        var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);\n        var resolution = this.getResolutionForPosition_(relativePosition);\n        view.animate({\n          resolution: view.constrainResolution(resolution),\n          duration: this.duration_,\n          easing: easeOut\n        });\n      };\n      /**\n       * Handle dragger start events.\n       * @param {import(\"../pointer/PointerEvent.js\").default} event The drag event.\n       * @private\n       */\n\n\n      ZoomSlider.prototype.handleDraggerStart_ = function handleDraggerStart_(event) {\n        if (!this.dragging_ && event.originalEvent.target === this.element.firstElementChild) {\n          this.getMap().getView().setHint(ViewHint.INTERACTING, 1);\n          this.previousX_ = event.clientX;\n          this.previousY_ = event.clientY;\n          this.dragging_ = true;\n\n          if (this.dragListenerKeys_.length === 0) {\n            var drag = this.handleDraggerDrag_;\n            var end = this.handleDraggerEnd_;\n            this.dragListenerKeys_.push(listen(document, EventType.MOUSEMOVE, drag, this), listen(document, PointerEventType.POINTERMOVE, drag, this), listen(document, EventType.MOUSEUP, end, this), listen(document, PointerEventType.POINTERUP, end, this));\n          }\n        }\n      };\n      /**\n       * Handle dragger drag events.\n       *\n       * @param {import(\"../pointer/PointerEvent.js\").default} event The drag event.\n       * @private\n       */\n\n\n      ZoomSlider.prototype.handleDraggerDrag_ = function handleDraggerDrag_(event) {\n        if (this.dragging_) {\n          var element =\n          /** @type {HTMLElement} */\n          this.element.firstElementChild;\n          var deltaX = event.clientX - this.previousX_ + parseFloat(element.style.left);\n          var deltaY = event.clientY - this.previousY_ + parseFloat(element.style.top);\n          var relativePosition = this.getRelativePosition_(deltaX, deltaY);\n          this.currentResolution_ = this.getResolutionForPosition_(relativePosition);\n          this.getMap().getView().setResolution(this.currentResolution_);\n          this.setThumbPosition_(this.currentResolution_);\n          this.previousX_ = event.clientX;\n          this.previousY_ = event.clientY;\n        }\n      };\n      /**\n       * Handle dragger end events.\n       * @param {import(\"../pointer/PointerEvent.js\").default} event The drag event.\n       * @private\n       */\n\n\n      ZoomSlider.prototype.handleDraggerEnd_ = function handleDraggerEnd_(event) {\n        if (this.dragging_) {\n          var view = this.getMap().getView();\n          view.setHint(ViewHint.INTERACTING, -1);\n          view.animate({\n            resolution: view.constrainResolution(this.currentResolution_),\n            duration: this.duration_,\n            easing: easeOut\n          });\n          this.dragging_ = false;\n          this.previousX_ = undefined;\n          this.previousY_ = undefined;\n          this.dragListenerKeys_.forEach(unlistenByKey);\n          this.dragListenerKeys_.length = 0;\n        }\n      };\n      /**\n       * Positions the thumb inside its container according to the given resolution.\n       *\n       * @param {number} res The res.\n       * @private\n       */\n\n\n      ZoomSlider.prototype.setThumbPosition_ = function setThumbPosition_(res) {\n        var position = this.getPositionForResolution_(res);\n        var thumb =\n        /** @type {HTMLElement} */\n        this.element.firstElementChild;\n\n        if (this.direction_ == Direction.HORIZONTAL) {\n          thumb.style.left = this.widthLimit_ * position + 'px';\n        } else {\n          thumb.style.top = this.heightLimit_ * position + 'px';\n        }\n      };\n      /**\n       * Calculates the relative position of the thumb given x and y offsets.  The\n       * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n       * in pixel units within the dragger limits.\n       *\n       * @param {number} x Pixel position relative to the left of the slider.\n       * @param {number} y Pixel position relative to the top of the slider.\n       * @return {number} The relative position of the thumb.\n       * @private\n       */\n\n\n      ZoomSlider.prototype.getRelativePosition_ = function getRelativePosition_(x, y) {\n        var amount;\n\n        if (this.direction_ === Direction.HORIZONTAL) {\n          amount = x / this.widthLimit_;\n        } else {\n          amount = y / this.heightLimit_;\n        }\n\n        return clamp(amount, 0, 1);\n      };\n      /**\n       * Calculates the corresponding resolution of the thumb given its relative\n       * position (where 0 is the minimum and 1 is the maximum).\n       *\n       * @param {number} position The relative position of the thumb.\n       * @return {number} The corresponding resolution.\n       * @private\n       */\n\n\n      ZoomSlider.prototype.getResolutionForPosition_ = function getResolutionForPosition_(position) {\n        var fn = this.getMap().getView().getResolutionForValueFunction();\n        return fn(1 - position);\n      };\n      /**\n       * Determines the relative position of the slider for the given resolution.  A\n       * relative position of 0 corresponds to the minimum view resolution.  A\n       * relative position of 1 corresponds to the maximum view resolution.\n       *\n       * @param {number} res The resolution.\n       * @return {number} The relative position value (between 0 and 1).\n       * @private\n       */\n\n\n      ZoomSlider.prototype.getPositionForResolution_ = function getPositionForResolution_(res) {\n        var fn = this.getMap().getView().getValueForResolutionFunction();\n        return 1 - fn(res);\n      };\n\n      return ZoomSlider;\n    }(Control);\n    /**\n     * Update the zoomslider element.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @this {ZoomSlider}\n     * @api\n     */\n\n\n    function render$5(mapEvent) {\n      if (!mapEvent.frameState) {\n        return;\n      }\n\n      if (!this.sliderInitialized_) {\n        this.initSlider_();\n      }\n\n      var res = mapEvent.frameState.viewState.resolution;\n\n      if (res !== this.currentResolution_) {\n        this.currentResolution_ = res;\n        this.setThumbPosition_(res);\n      }\n    }\n    /**\n     * @module ol/control/ZoomToExtent\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {string} [className='ol-zoom-extent'] Class name.\n     * @property {HTMLElement|string} [target] Specify a target if you want the control\n     * to be rendered outside of the map's viewport.\n     * @property {string|HTMLElement} [label='E'] Text label to use for the button.\n     * Instead of text, also an element (e.g. a `span` element) can be used.\n     * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.\n     * @property {import(\"../extent.js\").Extent} [extent] The extent to zoom to. If undefined the validity\n     * extent of the view projection is used.\n     */\n\n    /**\n     * @classdesc\n     * A button control which, when pressed, changes the map view to a specific\n     * extent. To style this control use the css selector `.ol-zoom-extent`.\n     *\n     * @api\n     */\n\n\n    var ZoomToExtent =\n    /*@__PURE__*/\n    function (Control$$1) {\n      function ZoomToExtent(opt_options) {\n        var options = opt_options ? opt_options : {};\n        Control$$1.call(this, {\n          element: document.createElement('div'),\n          target: options.target\n        });\n        /**\n         * @type {import(\"../extent.js\").Extent}\n         * @protected\n         */\n\n        this.extent = options.extent ? options.extent : null;\n        var className = options.className !== undefined ? options.className : 'ol-zoom-extent';\n        var label = options.label !== undefined ? options.label : 'E';\n        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Fit to extent';\n        var button = document.createElement('button');\n        button.setAttribute('type', 'button');\n        button.title = tipLabel;\n        button.appendChild(typeof label === 'string' ? document.createTextNode(label) : label);\n        listen(button, EventType.CLICK, this.handleClick_, this);\n        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n        var element = this.element;\n        element.className = cssClasses;\n        element.appendChild(button);\n      }\n\n      if (Control$$1) ZoomToExtent.__proto__ = Control$$1;\n      ZoomToExtent.prototype = Object.create(Control$$1 && Control$$1.prototype);\n      ZoomToExtent.prototype.constructor = ZoomToExtent;\n      /**\n       * @param {MouseEvent} event The event to handle\n       * @private\n       */\n\n      ZoomToExtent.prototype.handleClick_ = function handleClick_(event) {\n        event.preventDefault();\n        this.handleZoomToExtent();\n      };\n      /**\n       * @protected\n       */\n\n\n      ZoomToExtent.prototype.handleZoomToExtent = function handleZoomToExtent() {\n        var map = this.getMap();\n        var view = map.getView();\n        var extent = !this.extent ? view.getProjection().getExtent() : this.extent;\n        view.fit(extent);\n      };\n\n      return ZoomToExtent;\n    }(Control);\n    /**\n     * @module ol/control\n     */\n\n    /**\n     * @module ol/webgl/Shader\n     */\n\n    /**\n     * @abstract\n     */\n\n\n    var WebGLShader = function WebGLShader(source) {\n      /**\n       * @private\n       * @type {string}\n       */\n      this.source_ = source;\n    };\n    /**\n     * @return {boolean} Is animated?\n     */\n\n\n    WebGLShader.prototype.isAnimated = function isAnimated() {\n      return false;\n    };\n    /**\n     * @abstract\n     * @return {number} Type.\n     */\n\n\n    WebGLShader.prototype.getType = function getType() {\n      return _abstract();\n    };\n    /**\n     * @return {string} Source.\n     */\n\n\n    WebGLShader.prototype.getSource = function getSource() {\n      return this.source_;\n    };\n    /**\n     * @module ol/webgl/Fragment\n     */\n\n\n    var WebGLFragment =\n    /*@__PURE__*/\n    function (WebGLShader$$1) {\n      function WebGLFragment(source) {\n        WebGLShader$$1.call(this, source);\n      }\n\n      if (WebGLShader$$1) WebGLFragment.__proto__ = WebGLShader$$1;\n      WebGLFragment.prototype = Object.create(WebGLShader$$1 && WebGLShader$$1.prototype);\n      WebGLFragment.prototype.constructor = WebGLFragment;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLFragment.prototype.getType = function getType() {\n        return FRAGMENT_SHADER;\n      };\n\n      return WebGLFragment;\n    }(WebGLShader);\n    /**\n     * @module ol/webgl/Vertex\n     */\n\n\n    var WebGLVertex =\n    /*@__PURE__*/\n    function (WebGLShader$$1) {\n      function WebGLVertex(source) {\n        WebGLShader$$1.call(this, source);\n      }\n\n      if (WebGLShader$$1) WebGLVertex.__proto__ = WebGLShader$$1;\n      WebGLVertex.prototype = Object.create(WebGLShader$$1 && WebGLShader$$1.prototype);\n      WebGLVertex.prototype.constructor = WebGLVertex;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLVertex.prototype.getType = function getType() {\n        return VERTEX_SHADER;\n      };\n\n      return WebGLVertex;\n    }(WebGLShader);\n    /**\n     * @module ol/render/webgl/circlereplay/defaultshader\n     */\n\n\n    var fragment = new WebGLFragment('precision mediump float;\\nvarying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_fillColor;\\nuniform vec4 u_strokeColor;\\nuniform vec2 u_size;\\n\\nvoid main(void) {\\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  float radius = length(windowCenter - windowOffset);\\n  float dist = length(windowCenter - gl_FragCoord.xy);\\n  if (dist > radius + v_halfWidth) {\\n    if (u_strokeColor.a == 0.0) {\\n      gl_FragColor = u_fillColor;\\n    } else {\\n      gl_FragColor = u_strokeColor;\\n    }\\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\\n  } else if (u_fillColor.a == 0.0) {\\n    // Hooray, no fill, just stroke. We can use real antialiasing.\\n    gl_FragColor = u_strokeColor;\\n    if (dist < radius - v_halfWidth) {\\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\\n    }\\n  } else {\\n    gl_FragColor = u_fillColor;\\n    float strokeDist = radius - v_halfWidth;\\n    float antialias = 2.0 * v_pixelRatio;\\n    if (dist > strokeDist) {\\n      gl_FragColor = u_strokeColor;\\n    } else if (dist >= strokeDist - antialias) {\\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\\n    }\\n  }\\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\\n  if (gl_FragColor.a <= 0.0) {\\n    discard;\\n  }\\n}\\n');\n    var vertex = new WebGLVertex('varying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\nattribute vec2 a_position;\\nattribute float a_instruction;\\nattribute float a_radius;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\\n  v_pixelRatio = u_pixelRatio;\\n  float lineWidth = u_lineWidth * u_pixelRatio;\\n  v_halfWidth = lineWidth / 2.0;\\n  if (lineWidth == 0.0) {\\n    lineWidth = 2.0 * u_pixelRatio;\\n  }\\n  vec2 offset;\\n  // Radius with anitaliasing (roughly).\\n  float radius = a_radius + 3.0 * u_pixelRatio;\\n  // Until we get gl_VertexID in WebGL, we store an instruction.\\n  if (a_instruction == 0.0) {\\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\\n    offset = vec2(-1.0, 1.0);\\n  } else if (a_instruction == 1.0) {\\n    offset = vec2(-1.0, -1.0);\\n  } else if (a_instruction == 2.0) {\\n    offset = vec2(1.0, -1.0);\\n  } else {\\n    offset = vec2(1.0, 1.0);\\n  }\\n\\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\\n      0.0, 1.0)).xy;\\n\\n  if (distance(v_center, v_offset) > 20000.0) {\\n    gl_Position = vec4(v_center, 0.0, 1.0);\\n  }\\n}\\n\\n\\n');\n    /**\n     * @module ol/render/webgl/circlereplay/defaultshader/Locations\n     */\n\n    var Locations = function Locations(gl, program) {\n      /**\n       * @type {WebGLUniformLocation}\n       */\n      this.u_projectionMatrix = gl.getUniformLocation(program, 'u_projectionMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetScaleMatrix = gl.getUniformLocation(program, 'u_offsetScaleMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetRotateMatrix = gl.getUniformLocation(program, 'u_offsetRotateMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_lineWidth = gl.getUniformLocation(program, 'u_lineWidth');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_pixelRatio = gl.getUniformLocation(program, 'u_pixelRatio');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_opacity = gl.getUniformLocation(program, 'u_opacity');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_fillColor = gl.getUniformLocation(program, 'u_fillColor');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_strokeColor = gl.getUniformLocation(program, 'u_strokeColor');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_size = gl.getUniformLocation(program, 'u_size');\n      /**\n       * @type {number}\n       */\n\n      this.a_position = gl.getAttribLocation(program, 'a_position');\n      /**\n       * @type {number}\n       */\n\n      this.a_instruction = gl.getAttribLocation(program, 'a_instruction');\n      /**\n       * @type {number}\n       */\n\n      this.a_radius = gl.getAttribLocation(program, 'a_radius');\n    };\n    /**\n     * @module ol/vec/mat4\n     */\n\n    /**\n     * @return {Array<number>} 4x4 matrix representing a 3D identity transform.\n     */\n\n\n    function create$1() {\n      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    }\n    /**\n     * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.\n     * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n     * @return {Array<number>} 2D transformation matrix as flattened 4x4 matrix.\n     */\n\n\n    function fromTransform(mat4, transform) {\n      mat4[0] = transform[0];\n      mat4[1] = transform[1];\n      mat4[4] = transform[2];\n      mat4[5] = transform[3];\n      mat4[12] = transform[4];\n      mat4[13] = transform[5];\n      return mat4;\n    }\n    /**\n     * @module ol/render/webgl/Replay\n     */\n\n\n    var WebGLReplay =\n    /*@__PURE__*/\n    function (VectorContext$$1) {\n      function WebGLReplay(tolerance, maxExtent) {\n        VectorContext$$1.call(this);\n        /**\n         * @protected\n         * @type {number}\n         */\n\n        this.tolerance = tolerance;\n        /**\n         * @protected\n         * @const\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.maxExtent = maxExtent;\n        /**\n         * The origin of the coordinate system for the point coordinates sent to\n         * the GPU. To eliminate jitter caused by precision problems in the GPU\n         * we use the \"Rendering Relative to Eye\" technique described in the \"3D\n         * Engine Design for Virtual Globes\" book.\n         * @protected\n         * @type {import(\"../../coordinate.js\").Coordinate}\n         */\n\n        this.origin = getCenter(maxExtent);\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.projectionMatrix_ = create();\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.offsetRotateMatrix_ = create();\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.offsetScaleMatrix_ = create();\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.tmpMat4_ = create$1();\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n\n        this.indices = [];\n        /**\n         * @protected\n         * @type {?import(\"../../webgl/Buffer.js\").default}\n         */\n\n        this.indicesBuffer = null;\n        /**\n         * Start index per feature (the index).\n         * @protected\n         * @type {Array<number>}\n         */\n\n        this.startIndices = [];\n        /**\n         * Start index per feature (the feature).\n         * @protected\n         * @type {Array<import(\"../../Feature.js\").default|import(\"../Feature.js\").default>}\n         */\n\n        this.startIndicesFeature = [];\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n\n        this.vertices = [];\n        /**\n         * @protected\n         * @type {?import(\"../../webgl/Buffer.js\").default}\n         */\n\n        this.verticesBuffer = null;\n        /**\n         * Optional parameter for PolygonReplay instances.\n         * @protected\n         * @type {import(\"./LineStringReplay.js\").default|undefined}\n         */\n\n        this.lineStringReplay = undefined;\n      }\n\n      if (VectorContext$$1) WebGLReplay.__proto__ = VectorContext$$1;\n      WebGLReplay.prototype = Object.create(VectorContext$$1 && VectorContext$$1.prototype);\n      WebGLReplay.prototype.constructor = WebGLReplay;\n      /**\n       * @abstract\n       * @param {import(\"../../webgl/Context.js\").default} context WebGL context.\n       * @return {function()} Delete resources function.\n       */\n\n      WebGLReplay.prototype.getDeleteResourcesFunction = function getDeleteResourcesFunction(context) {\n        return _abstract();\n      };\n      /**\n       * @abstract\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       */\n\n\n      WebGLReplay.prototype.finish = function finish(context) {\n        _abstract();\n      };\n      /**\n       * @abstract\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {import(\"../../size.js\").Size} size Size.\n       * @param {number} pixelRatio Pixel ratio.\n       * @return {import(\"./circlereplay/defaultshader/Locations.js\").default|\n         import(\"./linestringreplay/defaultshader/Locations.js\").default|\n         import(\"./polygonreplay/defaultshader/Locations.js\").default|\n         import(\"./texturereplay/defaultshader/Locations.js\").default} Locations.\n       */\n\n\n      WebGLReplay.prototype.setUpProgram = function setUpProgram(gl, context, size, pixelRatio) {\n        return _abstract();\n      };\n      /**\n       * @abstract\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"./circlereplay/defaultshader/Locations.js\").default|\n         import(\"./linestringreplay/defaultshader/Locations.js\").default|\n         import(\"./polygonreplay/defaultshader/Locations.js\").default|\n         import(\"./texturereplay/defaultshader/Locations.js\").default} locations Locations.\n       */\n\n\n      WebGLReplay.prototype.shutDownProgram = function shutDownProgram(gl, locations) {\n        _abstract();\n      };\n      /**\n       * @abstract\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {boolean} hitDetection Hit detection mode.\n       */\n\n\n      WebGLReplay.prototype.drawReplay = function drawReplay(gl, context, skippedFeaturesHash, hitDetection) {\n        _abstract();\n      };\n      /**\n       * @abstract\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n       * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Hit extent: Only features intersecting this extent are checked.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      WebGLReplay.prototype.drawHitDetectionReplayOneByOne = function drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {\n        return _abstract();\n      };\n      /**\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n       * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.\n       * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Hit extent: Only features intersecting this extent are checked.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      WebGLReplay.prototype.drawHitDetectionReplay = function drawHitDetectionReplay(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {\n        if (!oneByOne) {\n          // draw all hit-detection features in \"once\" (by texture group)\n          return this.drawHitDetectionReplayAll(gl, context, skippedFeaturesHash, featureCallback);\n        } else {\n          // draw hit-detection features one by one\n          return this.drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent);\n        }\n      };\n      /**\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      WebGLReplay.prototype.drawHitDetectionReplayAll = function drawHitDetectionReplayAll(gl, context, skippedFeaturesHash, featureCallback) {\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        this.drawReplay(gl, context, skippedFeaturesHash, true);\n        var result = featureCallback(null);\n\n        if (result) {\n          return result;\n        } else {\n          return undefined;\n        }\n      };\n      /**\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n       * @param {number} resolution Resolution.\n       * @param {number} rotation Rotation.\n       * @param {import(\"../../size.js\").Size} size Size.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {number} opacity Global opacity.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n       * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.\n       * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Hit extent: Only features intersecting this extent are checked.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      WebGLReplay.prototype.replay = function replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {\n        var gl = context.getGL();\n        var tmpStencil, tmpStencilFunc, tmpStencilMaskVal, tmpStencilRef, tmpStencilMask, tmpStencilOpFail, tmpStencilOpPass, tmpStencilOpZFail;\n\n        if (this.lineStringReplay) {\n          tmpStencil = gl.isEnabled(gl.STENCIL_TEST);\n          tmpStencilFunc = gl.getParameter(gl.STENCIL_FUNC);\n          tmpStencilMaskVal = gl.getParameter(gl.STENCIL_VALUE_MASK);\n          tmpStencilRef = gl.getParameter(gl.STENCIL_REF);\n          tmpStencilMask = gl.getParameter(gl.STENCIL_WRITEMASK);\n          tmpStencilOpFail = gl.getParameter(gl.STENCIL_FAIL);\n          tmpStencilOpPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);\n          tmpStencilOpZFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);\n          gl.enable(gl.STENCIL_TEST);\n          gl.clear(gl.STENCIL_BUFFER_BIT);\n          gl.stencilMask(255);\n          gl.stencilFunc(gl.ALWAYS, 1, 255);\n          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n          this.lineStringReplay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);\n          gl.stencilMask(0);\n          gl.stencilFunc(gl.NOTEQUAL, 1, 255);\n        }\n\n        context.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n        context.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n        var locations = this.setUpProgram(gl, context, size, pixelRatio); // set the \"uniform\" values\n\n        var projectionMatrix = reset(this.projectionMatrix_);\n        scale$2(projectionMatrix, 2 / (resolution * size[0]), 2 / (resolution * size[1]));\n        rotate$2(projectionMatrix, -rotation);\n        translate$1(projectionMatrix, -(center[0] - this.origin[0]), -(center[1] - this.origin[1]));\n        var offsetScaleMatrix = reset(this.offsetScaleMatrix_);\n        scale$2(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n        var offsetRotateMatrix = reset(this.offsetRotateMatrix_);\n\n        if (rotation !== 0) {\n          rotate$2(offsetRotateMatrix, -rotation);\n        }\n\n        gl.uniformMatrix4fv(locations.u_projectionMatrix, false, fromTransform(this.tmpMat4_, projectionMatrix));\n        gl.uniformMatrix4fv(locations.u_offsetScaleMatrix, false, fromTransform(this.tmpMat4_, offsetScaleMatrix));\n        gl.uniformMatrix4fv(locations.u_offsetRotateMatrix, false, fromTransform(this.tmpMat4_, offsetRotateMatrix));\n        gl.uniform1f(locations.u_opacity, opacity); // draw!\n\n        var result;\n\n        if (featureCallback === undefined) {\n          this.drawReplay(gl, context, skippedFeaturesHash, false);\n        } else {\n          // draw feature by feature for the hit-detection\n          result = this.drawHitDetectionReplay(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);\n        } // disable the vertex attrib arrays\n\n\n        this.shutDownProgram(gl, locations);\n\n        if (this.lineStringReplay) {\n          if (!tmpStencil) {\n            gl.disable(gl.STENCIL_TEST);\n          }\n\n          gl.clear(gl.STENCIL_BUFFER_BIT);\n          gl.stencilFunc(\n          /** @type {number} */\n          tmpStencilFunc,\n          /** @type {number} */\n          tmpStencilRef,\n          /** @type {number} */\n          tmpStencilMaskVal);\n          gl.stencilMask(\n          /** @type {number} */\n          tmpStencilMask);\n          gl.stencilOp(\n          /** @type {number} */\n          tmpStencilOpFail,\n          /** @type {number} */\n          tmpStencilOpZFail,\n          /** @type {number} */\n          tmpStencilOpPass);\n        }\n\n        return result;\n      };\n      /**\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {number} start Start index.\n       * @param {number} end End index.\n       */\n\n\n      WebGLReplay.prototype.drawElements = function drawElements(gl, context, start, end) {\n        var elementType = context.hasOESElementIndexUint ? UNSIGNED_INT : UNSIGNED_SHORT;\n        var elementSize = context.hasOESElementIndexUint ? 4 : 2;\n        var numItems = end - start;\n        var offsetInBytes = start * elementSize;\n        gl.drawElements(TRIANGLES, numItems, elementType, offsetInBytes);\n      };\n\n      return WebGLReplay;\n    }(VectorContext);\n    /**\n     * @module ol/render/webgl\n     */\n\n    /**\n     * @const\n     * @type {string}\n     */\n\n\n    var DEFAULT_FONT = '10px sans-serif';\n    /**\n     * @const\n     * @type {import(\"../color.js\").Color}\n     */\n\n    var DEFAULT_FILLSTYLE = [0.0, 0.0, 0.0, 1.0];\n    /**\n     * @const\n     * @type {string}\n     */\n\n    var DEFAULT_LINECAP = 'round';\n    /**\n     * @const\n     * @type {Array<number>}\n     */\n\n    var DEFAULT_LINEDASH = [];\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var DEFAULT_LINEDASHOFFSET = 0;\n    /**\n     * @const\n     * @type {string}\n     */\n\n    var DEFAULT_LINEJOIN = 'round';\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var DEFAULT_MITERLIMIT = 10;\n    /**\n     * @const\n     * @type {import(\"../color.js\").Color}\n     */\n\n    var DEFAULT_STROKESTYLE = [0.0, 0.0, 0.0, 1.0];\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var DEFAULT_TEXTALIGN = 0.5;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var DEFAULT_TEXTBASELINE = 0.5;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var DEFAULT_LINEWIDTH = 1;\n    /**\n     * @const\n     * @type {number}\n     */\n\n    var EPSILON = Number.EPSILON || 2.220446049250313e-16;\n    /**\n     * Calculates the orientation of a triangle based on the determinant method.\n     * @param {number} x1 First X coordinate.\n     * @param {number} y1 First Y coordinate.\n     * @param {number} x2 Second X coordinate.\n     * @param {number} y2 Second Y coordinate.\n     * @param {number} x3 Third X coordinate.\n     * @param {number} y3 Third Y coordinate.\n     * @return {boolean|undefined} Triangle is clockwise.\n     */\n\n    var triangleIsCounterClockwise = function triangleIsCounterClockwise(x1, y1, x2, y2, x3, y3) {\n      var area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n      return area <= EPSILON && area >= -EPSILON ? undefined : area > 0;\n    };\n    /**\n     * @module ol/webgl/Buffer\n     */\n\n    /**\n     * @enum {number}\n     */\n\n\n    var BufferUsage = {\n      STATIC_DRAW: STATIC_DRAW,\n      STREAM_DRAW: STREAM_DRAW,\n      DYNAMIC_DRAW: DYNAMIC_DRAW\n    };\n\n    var WebGLBuffer = function WebGLBuffer(opt_arr, opt_usage) {\n      /**\n       * @private\n       * @type {Array<number>}\n       */\n      this.arr_ = opt_arr !== undefined ? opt_arr : [];\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.usage_ = opt_usage !== undefined ? opt_usage : BufferUsage.STATIC_DRAW;\n    };\n    /**\n     * @return {Array<number>} Array.\n     */\n\n\n    WebGLBuffer.prototype.getArray = function getArray() {\n      return this.arr_;\n    };\n    /**\n     * @return {number} Usage.\n     */\n\n\n    WebGLBuffer.prototype.getUsage = function getUsage() {\n      return this.usage_;\n    };\n    /**\n     * @module ol/render/webgl/CircleReplay\n     */\n\n\n    var WebGLCircleReplay =\n    /*@__PURE__*/\n    function (WebGLReplay$$1) {\n      function WebGLCircleReplay(tolerance, maxExtent) {\n        WebGLReplay$$1.call(this, tolerance, maxExtent);\n        /**\n         * @private\n         * @type {import(\"./circlereplay/defaultshader/Locations.js\").default}\n         */\n\n        this.defaultLocations_ = null;\n        /**\n         * @private\n         * @type {Array<Array<Array<number>|number>>}\n         */\n\n        this.styles_ = [];\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.styleIndices_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.radius_ = 0;\n        /**\n         * @private\n         * @type {{fillColor: (Array<number>|null),\n         *         strokeColor: (Array<number>|null),\n         *         lineDash: Array<number>,\n         *         lineDashOffset: (number|undefined),\n         *         lineWidth: (number|undefined),\n         *         changed: boolean}|null}\n         */\n\n        this.state_ = {\n          fillColor: null,\n          strokeColor: null,\n          lineDash: null,\n          lineDashOffset: undefined,\n          lineWidth: undefined,\n          changed: false\n        };\n      }\n\n      if (WebGLReplay$$1) WebGLCircleReplay.__proto__ = WebGLReplay$$1;\n      WebGLCircleReplay.prototype = Object.create(WebGLReplay$$1 && WebGLReplay$$1.prototype);\n      WebGLCircleReplay.prototype.constructor = WebGLCircleReplay;\n      /**\n       * @private\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       */\n\n      WebGLCircleReplay.prototype.drawCoordinates_ = function drawCoordinates_(flatCoordinates, offset, end, stride) {\n        var numVertices = this.vertices.length;\n        var numIndices = this.indices.length;\n        var n = numVertices / 4;\n        var i, ii;\n\n        for (i = offset, ii = end; i < ii; i += stride) {\n          this.vertices[numVertices++] = flatCoordinates[i];\n          this.vertices[numVertices++] = flatCoordinates[i + 1];\n          this.vertices[numVertices++] = 0;\n          this.vertices[numVertices++] = this.radius_;\n          this.vertices[numVertices++] = flatCoordinates[i];\n          this.vertices[numVertices++] = flatCoordinates[i + 1];\n          this.vertices[numVertices++] = 1;\n          this.vertices[numVertices++] = this.radius_;\n          this.vertices[numVertices++] = flatCoordinates[i];\n          this.vertices[numVertices++] = flatCoordinates[i + 1];\n          this.vertices[numVertices++] = 2;\n          this.vertices[numVertices++] = this.radius_;\n          this.vertices[numVertices++] = flatCoordinates[i];\n          this.vertices[numVertices++] = flatCoordinates[i + 1];\n          this.vertices[numVertices++] = 3;\n          this.vertices[numVertices++] = this.radius_;\n          this.indices[numIndices++] = n;\n          this.indices[numIndices++] = n + 1;\n          this.indices[numIndices++] = n + 2;\n          this.indices[numIndices++] = n + 2;\n          this.indices[numIndices++] = n + 3;\n          this.indices[numIndices++] = n;\n          n += 4;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLCircleReplay.prototype.drawCircle = function drawCircle(circleGeometry, feature) {\n        var radius = circleGeometry.getRadius();\n        var stride = circleGeometry.getStride();\n\n        if (radius) {\n          this.startIndices.push(this.indices.length);\n          this.startIndicesFeature.push(feature);\n\n          if (this.state_.changed) {\n            this.styleIndices_.push(this.indices.length);\n            this.state_.changed = false;\n          }\n\n          this.radius_ = radius;\n          var flatCoordinates = circleGeometry.getFlatCoordinates();\n          flatCoordinates = translate(flatCoordinates, 0, 2, stride, -this.origin[0], -this.origin[1]);\n          this.drawCoordinates_(flatCoordinates, 0, 2, stride);\n        } else {\n          if (this.state_.changed) {\n            this.styles_.pop();\n\n            if (this.styles_.length) {\n              var lastState = this.styles_[this.styles_.length - 1];\n              this.state_.fillColor =\n              /** @type {Array<number>} */\n              lastState[0];\n              this.state_.strokeColor =\n              /** @type {Array<number>} */\n              lastState[1];\n              this.state_.lineWidth =\n              /** @type {number} */\n              lastState[2];\n              this.state_.changed = false;\n            }\n          }\n        }\n      };\n      /**\n       * @inheritDoc\n       **/\n\n\n      WebGLCircleReplay.prototype.finish = function finish(context) {\n        // create, bind, and populate the vertices buffer\n        this.verticesBuffer = new WebGLBuffer(this.vertices); // create, bind, and populate the indices buffer\n\n        this.indicesBuffer = new WebGLBuffer(this.indices);\n        this.startIndices.push(this.indices.length); //Clean up, if there is nothing to draw\n\n        if (this.styleIndices_.length === 0 && this.styles_.length > 0) {\n          this.styles_ = [];\n        }\n\n        this.vertices = null;\n        this.indices = null;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLCircleReplay.prototype.getDeleteResourcesFunction = function getDeleteResourcesFunction(context) {\n        // We only delete our stuff here. The shaders and the program may\n        // be used by other CircleReplay instances (for other layers). And\n        // they will be deleted when disposing of the import(\"../../webgl/Context.js\").WebGLContext\n        // object.\n        var verticesBuffer = this.verticesBuffer;\n        var indicesBuffer = this.indicesBuffer;\n        return function () {\n          context.deleteBuffer(verticesBuffer);\n          context.deleteBuffer(indicesBuffer);\n        };\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLCircleReplay.prototype.setUpProgram = function setUpProgram(gl, context, size, pixelRatio) {\n        // get the program\n        var program = context.getProgram(fragment, vertex); // get the locations\n\n        var locations;\n\n        if (!this.defaultLocations_) {\n          locations = new Locations(gl, program);\n          this.defaultLocations_ = locations;\n        } else {\n          locations = this.defaultLocations_;\n        }\n\n        context.useProgram(program); // enable the vertex attrib arrays\n\n        gl.enableVertexAttribArray(locations.a_position);\n        gl.vertexAttribPointer(locations.a_position, 2, FLOAT, false, 16, 0);\n        gl.enableVertexAttribArray(locations.a_instruction);\n        gl.vertexAttribPointer(locations.a_instruction, 1, FLOAT, false, 16, 8);\n        gl.enableVertexAttribArray(locations.a_radius);\n        gl.vertexAttribPointer(locations.a_radius, 1, FLOAT, false, 16, 12); // Enable renderer specific uniforms.\n\n        gl.uniform2fv(locations.u_size, size);\n        gl.uniform1f(locations.u_pixelRatio, pixelRatio);\n        return locations;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLCircleReplay.prototype.shutDownProgram = function shutDownProgram(gl, locations) {\n        gl.disableVertexAttribArray(locations.a_position);\n        gl.disableVertexAttribArray(locations.a_instruction);\n        gl.disableVertexAttribArray(locations.a_radius);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLCircleReplay.prototype.drawReplay = function drawReplay(gl, context, skippedFeaturesHash, hitDetection) {\n        if (!isEmpty(skippedFeaturesHash)) {\n          this.drawReplaySkipping_(gl, context, skippedFeaturesHash);\n        } else {\n          //Draw by style groups to minimize drawElements() calls.\n          var i, start, end, nextStyle;\n          end = this.startIndices[this.startIndices.length - 1];\n\n          for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n            start = this.styleIndices_[i];\n            nextStyle = this.styles_[i];\n            this.setFillStyle_(gl,\n            /** @type {Array<number>} */\n            nextStyle[0]);\n            this.setStrokeStyle_(gl,\n            /** @type {Array<number>} */\n            nextStyle[1],\n            /** @type {number} */\n            nextStyle[2]);\n            this.drawElements(gl, context, start, end);\n            end = start;\n          }\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLCircleReplay.prototype.drawHitDetectionReplayOneByOne = function drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {\n        var i, start, end, nextStyle, groupStart, feature, featureIndex;\n        featureIndex = this.startIndices.length - 2;\n        end = this.startIndices[featureIndex + 1];\n\n        for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n          nextStyle = this.styles_[i];\n          this.setFillStyle_(gl,\n          /** @type {Array<number>} */\n          nextStyle[0]);\n          this.setStrokeStyle_(gl,\n          /** @type {Array<number>} */\n          nextStyle[1],\n          /** @type {number} */\n          nextStyle[2]);\n          groupStart = this.styleIndices_[i];\n\n          while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n            start = this.startIndices[featureIndex];\n            feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || intersects(\n            /** @type {Array<number>} */\n            opt_hitExtent, feature.getGeometry().getExtent()))) {\n              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n              this.drawElements(gl, context, start, end);\n              var result = featureCallback(feature);\n\n              if (result) {\n                return result;\n              }\n            }\n\n            featureIndex--;\n            end = start;\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @private\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object} skippedFeaturesHash Ids of features to skip.\n       */\n\n\n      WebGLCircleReplay.prototype.drawReplaySkipping_ = function drawReplaySkipping_(gl, context, skippedFeaturesHash) {\n        var i, start, end, nextStyle, groupStart, feature, featureIndex, featureStart;\n        featureIndex = this.startIndices.length - 2;\n        end = start = this.startIndices[featureIndex + 1];\n\n        for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n          nextStyle = this.styles_[i];\n          this.setFillStyle_(gl,\n          /** @type {Array<number>} */\n          nextStyle[0]);\n          this.setStrokeStyle_(gl,\n          /** @type {Array<number>} */\n          nextStyle[1],\n          /** @type {number} */\n          nextStyle[2]);\n          groupStart = this.styleIndices_[i];\n\n          while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n            featureStart = this.startIndices[featureIndex];\n            feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)]) {\n              if (start !== end) {\n                this.drawElements(gl, context, start, end);\n              }\n\n              end = featureStart;\n            }\n\n            featureIndex--;\n            start = featureStart;\n          }\n\n          if (start !== end) {\n            this.drawElements(gl, context, start, end);\n          }\n\n          start = end = groupStart;\n        }\n      };\n      /**\n       * @private\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {Array<number>} color Color.\n       */\n\n\n      WebGLCircleReplay.prototype.setFillStyle_ = function setFillStyle_(gl, color) {\n        gl.uniform4fv(this.defaultLocations_.u_fillColor, color);\n      };\n      /**\n       * @private\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {Array<number>} color Color.\n       * @param {number} lineWidth Line width.\n       */\n\n\n      WebGLCircleReplay.prototype.setStrokeStyle_ = function setStrokeStyle_(gl, color, lineWidth) {\n        gl.uniform4fv(this.defaultLocations_.u_strokeColor, color);\n        gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLCircleReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n        var strokeStyleColor, strokeStyleWidth;\n\n        if (strokeStyle) {\n          var strokeStyleLineDash = strokeStyle.getLineDash();\n          this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : DEFAULT_LINEDASH;\n          var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n          this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : DEFAULT_LINEDASHOFFSET;\n          strokeStyleColor = strokeStyle.getColor();\n\n          if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {\n            strokeStyleColor = asArray(strokeStyleColor).map(function (c, i) {\n              return i != 3 ? c / 255 : c;\n            }) || DEFAULT_STROKESTYLE;\n          } else {\n            strokeStyleColor = DEFAULT_STROKESTYLE;\n          }\n\n          strokeStyleWidth = strokeStyle.getWidth();\n          strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : DEFAULT_LINEWIDTH;\n        } else {\n          strokeStyleColor = [0, 0, 0, 0];\n          strokeStyleWidth = 0;\n        }\n\n        var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];\n\n        if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {\n          fillStyleColor = asArray(fillStyleColor).map(function (c, i) {\n            return i != 3 ? c / 255 : c;\n          }) || DEFAULT_FILLSTYLE;\n        } else {\n          fillStyleColor = DEFAULT_FILLSTYLE;\n        }\n\n        if (!this.state_.strokeColor || !equals(this.state_.strokeColor, strokeStyleColor) || !this.state_.fillColor || !equals(this.state_.fillColor, fillStyleColor) || this.state_.lineWidth !== strokeStyleWidth) {\n          this.state_.changed = true;\n          this.state_.fillColor = fillStyleColor;\n          this.state_.strokeColor = strokeStyleColor;\n          this.state_.lineWidth = strokeStyleWidth;\n          this.styles_.push([fillStyleColor, strokeStyleColor, strokeStyleWidth]);\n        }\n      };\n\n      return WebGLCircleReplay;\n    }(WebGLReplay);\n    /**\n     * @module ol/render/webgl/texturereplay/defaultshader\n     */\n\n\n    var fragment$1 = new WebGLFragment('precision mediump float;\\nvarying vec2 v_texCoord;\\nvarying float v_opacity;\\n\\nuniform float u_opacity;\\nuniform sampler2D u_image;\\n\\nvoid main(void) {\\n  vec4 texColor = texture2D(u_image, v_texCoord);\\n  gl_FragColor.rgb = texColor.rgb;\\n  float alpha = texColor.a * v_opacity * u_opacity;\\n  if (alpha == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor.a = alpha;\\n}\\n');\n    var vertex$1 = new WebGLVertex('varying vec2 v_texCoord;\\nvarying float v_opacity;\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nattribute vec2 a_offsets;\\nattribute float a_opacity;\\nattribute float a_rotateWithView;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix;\\n  if (a_rotateWithView == 1.0) {\\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  }\\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  v_texCoord = a_texCoord;\\n  v_opacity = a_opacity;\\n}\\n\\n\\n');\n    /**\n     * @module ol/render/webgl/texturereplay/defaultshader/Locations\n     */\n\n    var Locations$1 = function Locations(gl, program) {\n      /**\n       * @type {WebGLUniformLocation}\n       */\n      this.u_projectionMatrix = gl.getUniformLocation(program, 'u_projectionMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetScaleMatrix = gl.getUniformLocation(program, 'u_offsetScaleMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetRotateMatrix = gl.getUniformLocation(program, 'u_offsetRotateMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_opacity = gl.getUniformLocation(program, 'u_opacity');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_image = gl.getUniformLocation(program, 'u_image');\n      /**\n       * @type {number}\n       */\n\n      this.a_position = gl.getAttribLocation(program, 'a_position');\n      /**\n       * @type {number}\n       */\n\n      this.a_texCoord = gl.getAttribLocation(program, 'a_texCoord');\n      /**\n       * @type {number}\n       */\n\n      this.a_offsets = gl.getAttribLocation(program, 'a_offsets');\n      /**\n       * @type {number}\n       */\n\n      this.a_opacity = gl.getAttribLocation(program, 'a_opacity');\n      /**\n       * @type {number}\n       */\n\n      this.a_rotateWithView = gl.getAttribLocation(program, 'a_rotateWithView');\n    };\n    /**\n     * @module ol/webgl/ContextEventType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var ContextEventType = {\n      LOST: 'webglcontextlost',\n      RESTORED: 'webglcontextrestored'\n    };\n    /**\n     * @module ol/webgl/Context\n     */\n\n    /**\n     * @typedef {Object} BufferCacheEntry\n     * @property {import(\"./Buffer.js\").default} buf\n     * @property {WebGLBuffer} buffer\n     */\n\n    /**\n     * @classdesc\n     * A WebGL context for accessing low-level WebGL capabilities.\n     */\n\n    var WebGLContext =\n    /*@__PURE__*/\n    function (Disposable$$1) {\n      function WebGLContext(canvas, gl) {\n        Disposable$$1.call(this);\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.canvas_ = canvas;\n        /**\n         * @private\n         * @type {WebGLRenderingContext}\n         */\n\n        this.gl_ = gl;\n        /**\n         * @private\n         * @type {!Object<string, BufferCacheEntry>}\n         */\n\n        this.bufferCache_ = {};\n        /**\n         * @private\n         * @type {!Object<string, WebGLShader>}\n         */\n\n        this.shaderCache_ = {};\n        /**\n         * @private\n         * @type {!Object<string, WebGLProgram>}\n         */\n\n        this.programCache_ = {};\n        /**\n         * @private\n         * @type {WebGLProgram}\n         */\n\n        this.currentProgram_ = null;\n        /**\n         * @private\n         * @type {WebGLFramebuffer}\n         */\n\n        this.hitDetectionFramebuffer_ = null;\n        /**\n         * @private\n         * @type {WebGLTexture}\n         */\n\n        this.hitDetectionTexture_ = null;\n        /**\n         * @private\n         * @type {WebGLRenderbuffer}\n         */\n\n        this.hitDetectionRenderbuffer_ = null;\n        /**\n         * @type {boolean}\n         */\n\n        this.hasOESElementIndexUint = includes(EXTENSIONS, 'OES_element_index_uint'); // use the OES_element_index_uint extension if available\n\n        if (this.hasOESElementIndexUint) {\n          gl.getExtension('OES_element_index_uint');\n        }\n\n        listen(this.canvas_, ContextEventType.LOST, this.handleWebGLContextLost, this);\n        listen(this.canvas_, ContextEventType.RESTORED, this.handleWebGLContextRestored, this);\n      }\n\n      if (Disposable$$1) WebGLContext.__proto__ = Disposable$$1;\n      WebGLContext.prototype = Object.create(Disposable$$1 && Disposable$$1.prototype);\n      WebGLContext.prototype.constructor = WebGLContext;\n      /**\n       * Just bind the buffer if it's in the cache. Otherwise create\n       * the WebGL buffer, bind it, populate it, and add an entry to\n       * the cache.\n       * @param {number} target Target.\n       * @param {import(\"./Buffer.js\").default} buf Buffer.\n       */\n\n      WebGLContext.prototype.bindBuffer = function bindBuffer(target, buf) {\n        var gl = this.getGL();\n        var arr = buf.getArray();\n        var bufferKey = getUid(buf);\n\n        if (bufferKey in this.bufferCache_) {\n          var bufferCacheEntry = this.bufferCache_[bufferKey];\n          gl.bindBuffer(target, bufferCacheEntry.buffer);\n        } else {\n          var buffer = gl.createBuffer();\n          gl.bindBuffer(target, buffer);\n          var\n          /** @type {ArrayBufferView} */\n          arrayBuffer;\n\n          if (target == ARRAY_BUFFER) {\n            arrayBuffer = new Float32Array(arr);\n          } else if (target == ELEMENT_ARRAY_BUFFER) {\n            arrayBuffer = this.hasOESElementIndexUint ? new Uint32Array(arr) : new Uint16Array(arr);\n          }\n\n          gl.bufferData(target, arrayBuffer, buf.getUsage());\n          this.bufferCache_[bufferKey] = {\n            buf: buf,\n            buffer: buffer\n          };\n        }\n      };\n      /**\n       * @param {import(\"./Buffer.js\").default} buf Buffer.\n       */\n\n\n      WebGLContext.prototype.deleteBuffer = function deleteBuffer(buf) {\n        var gl = this.getGL();\n        var bufferKey = getUid(buf);\n        var bufferCacheEntry = this.bufferCache_[bufferKey];\n\n        if (!gl.isContextLost()) {\n          gl.deleteBuffer(bufferCacheEntry.buffer);\n        }\n\n        delete this.bufferCache_[bufferKey];\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLContext.prototype.disposeInternal = function disposeInternal() {\n        unlistenAll(this.canvas_);\n        var gl = this.getGL();\n\n        if (!gl.isContextLost()) {\n          for (var key in this.bufferCache_) {\n            gl.deleteBuffer(this.bufferCache_[key].buffer);\n          }\n\n          for (var key$1 in this.programCache_) {\n            gl.deleteProgram(this.programCache_[key$1]);\n          }\n\n          for (var key$2 in this.shaderCache_) {\n            gl.deleteShader(this.shaderCache_[key$2]);\n          } // delete objects for hit-detection\n\n\n          gl.deleteFramebuffer(this.hitDetectionFramebuffer_);\n          gl.deleteRenderbuffer(this.hitDetectionRenderbuffer_);\n          gl.deleteTexture(this.hitDetectionTexture_);\n        }\n      };\n      /**\n       * @return {HTMLCanvasElement} Canvas.\n       */\n\n\n      WebGLContext.prototype.getCanvas = function getCanvas() {\n        return this.canvas_;\n      };\n      /**\n       * Get the WebGL rendering context\n       * @return {WebGLRenderingContext} The rendering context.\n       * @api\n       */\n\n\n      WebGLContext.prototype.getGL = function getGL() {\n        return this.gl_;\n      };\n      /**\n       * Get the frame buffer for hit detection.\n       * @return {WebGLFramebuffer} The hit detection frame buffer.\n       */\n\n\n      WebGLContext.prototype.getHitDetectionFramebuffer = function getHitDetectionFramebuffer() {\n        if (!this.hitDetectionFramebuffer_) {\n          this.initHitDetectionFramebuffer_();\n        }\n\n        return this.hitDetectionFramebuffer_;\n      };\n      /**\n       * Get shader from the cache if it's in the cache. Otherwise, create\n       * the WebGL shader, compile it, and add entry to cache.\n       * @param {import(\"./Shader.js\").default} shaderObject Shader object.\n       * @return {WebGLShader} Shader.\n       */\n\n\n      WebGLContext.prototype.getShader = function getShader(shaderObject) {\n        var shaderKey = getUid(shaderObject);\n\n        if (shaderKey in this.shaderCache_) {\n          return this.shaderCache_[shaderKey];\n        } else {\n          var gl = this.getGL();\n          var shader = gl.createShader(shaderObject.getType());\n          gl.shaderSource(shader, shaderObject.getSource());\n          gl.compileShader(shader);\n          this.shaderCache_[shaderKey] = shader;\n          return shader;\n        }\n      };\n      /**\n       * Get the program from the cache if it's in the cache. Otherwise create\n       * the WebGL program, attach the shaders to it, and add an entry to the\n       * cache.\n       * @param {import(\"./Fragment.js\").default} fragmentShaderObject Fragment shader.\n       * @param {import(\"./Vertex.js\").default} vertexShaderObject Vertex shader.\n       * @return {WebGLProgram} Program.\n       */\n\n\n      WebGLContext.prototype.getProgram = function getProgram(fragmentShaderObject, vertexShaderObject) {\n        var programKey = getUid(fragmentShaderObject) + '/' + getUid(vertexShaderObject);\n\n        if (programKey in this.programCache_) {\n          return this.programCache_[programKey];\n        } else {\n          var gl = this.getGL();\n          var program = gl.createProgram();\n          gl.attachShader(program, this.getShader(fragmentShaderObject));\n          gl.attachShader(program, this.getShader(vertexShaderObject));\n          gl.linkProgram(program);\n          this.programCache_[programKey] = program;\n          return program;\n        }\n      };\n      /**\n       * FIXME empty description for jsdoc\n       */\n\n\n      WebGLContext.prototype.handleWebGLContextLost = function handleWebGLContextLost() {\n        clear(this.bufferCache_);\n        clear(this.shaderCache_);\n        clear(this.programCache_);\n        this.currentProgram_ = null;\n        this.hitDetectionFramebuffer_ = null;\n        this.hitDetectionTexture_ = null;\n        this.hitDetectionRenderbuffer_ = null;\n      };\n      /**\n       * FIXME empty description for jsdoc\n       */\n\n\n      WebGLContext.prototype.handleWebGLContextRestored = function handleWebGLContextRestored() {};\n      /**\n       * Creates a 1x1 pixel framebuffer for the hit-detection.\n       * @private\n       */\n\n\n      WebGLContext.prototype.initHitDetectionFramebuffer_ = function initHitDetectionFramebuffer_() {\n        var gl = this.gl_;\n        var framebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        var texture = createEmptyTexture(gl, 1, 1);\n        var renderbuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1, 1);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        this.hitDetectionFramebuffer_ = framebuffer;\n        this.hitDetectionTexture_ = texture;\n        this.hitDetectionRenderbuffer_ = renderbuffer;\n      };\n      /**\n       * Use a program.  If the program is already in use, this will return `false`.\n       * @param {WebGLProgram} program Program.\n       * @return {boolean} Changed.\n       * @api\n       */\n\n\n      WebGLContext.prototype.useProgram = function useProgram(program) {\n        if (program == this.currentProgram_) {\n          return false;\n        } else {\n          var gl = this.getGL();\n          gl.useProgram(program);\n          this.currentProgram_ = program;\n          return true;\n        }\n      };\n\n      return WebGLContext;\n    }(Disposable);\n    /**\n     * @param {WebGLRenderingContext} gl WebGL rendering context.\n     * @param {number=} opt_wrapS wrapS.\n     * @param {number=} opt_wrapT wrapT.\n     * @return {WebGLTexture} The texture.\n     */\n\n\n    function createTextureInternal(gl, opt_wrapS, opt_wrapT) {\n      var texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n      if (opt_wrapS !== undefined) {\n        gl.texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, opt_wrapS);\n      }\n\n      if (opt_wrapT !== undefined) {\n        gl.texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, opt_wrapT);\n      }\n\n      return texture;\n    }\n    /**\n     * @param {WebGLRenderingContext} gl WebGL rendering context.\n     * @param {number} width Width.\n     * @param {number} height Height.\n     * @param {number=} opt_wrapS wrapS.\n     * @param {number=} opt_wrapT wrapT.\n     * @return {WebGLTexture} The texture.\n     */\n\n\n    function createEmptyTexture(gl, width, height, opt_wrapS, opt_wrapT) {\n      var texture = createTextureInternal(gl, opt_wrapS, opt_wrapT);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      return texture;\n    }\n    /**\n     * @param {WebGLRenderingContext} gl WebGL rendering context.\n     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n     * @param {number=} opt_wrapS wrapS.\n     * @param {number=} opt_wrapT wrapT.\n     * @return {WebGLTexture} The texture.\n     */\n\n\n    function createTexture(gl, image, opt_wrapS, opt_wrapT) {\n      var texture = createTextureInternal(gl, opt_wrapS, opt_wrapT);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n      return texture;\n    }\n    /**\n     * @module ol/render/webgl/TextureReplay\n     */\n\n\n    var WebGLTextureReplay =\n    /*@__PURE__*/\n    function (WebGLReplay$$1) {\n      function WebGLTextureReplay(tolerance, maxExtent) {\n        WebGLReplay$$1.call(this, tolerance, maxExtent);\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.anchorX = undefined;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.anchorY = undefined;\n        /**\n         * @type {Array<number>}\n         * @protected\n         */\n\n        this.groupIndices = [];\n        /**\n         * @type {Array<number>}\n         * @protected\n         */\n\n        this.hitDetectionGroupIndices = [];\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.height = undefined;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.imageHeight = undefined;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.imageWidth = undefined;\n        /**\n         * @protected\n         * @type {import(\"./texturereplay/defaultshader/Locations.js\").default}\n         */\n\n        this.defaultLocations = null;\n        /**\n         * @protected\n         * @type {number|undefined}\n         */\n\n        this.opacity = undefined;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.originX = undefined;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.originY = undefined;\n        /**\n         * @protected\n         * @type {boolean|undefined}\n         */\n\n        this.rotateWithView = undefined;\n        /**\n         * @protected\n         * @type {number|undefined}\n         */\n\n        this.rotation = undefined;\n        /**\n         * @protected\n         * @type {number|undefined}\n         */\n\n        this.scale = undefined;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n\n        this.width = undefined;\n      }\n\n      if (WebGLReplay$$1) WebGLTextureReplay.__proto__ = WebGLReplay$$1;\n      WebGLTextureReplay.prototype = Object.create(WebGLReplay$$1 && WebGLReplay$$1.prototype);\n      WebGLTextureReplay.prototype.constructor = WebGLTextureReplay;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLTextureReplay.prototype.getDeleteResourcesFunction = function getDeleteResourcesFunction(context) {\n        var verticesBuffer = this.verticesBuffer;\n        var indicesBuffer = this.indicesBuffer;\n        var textures = this.getTextures(true);\n        var gl = context.getGL();\n        return function () {\n          if (!gl.isContextLost()) {\n            var i, ii;\n\n            for (i = 0, ii = textures.length; i < ii; ++i) {\n              gl.deleteTexture(textures[i]);\n            }\n          }\n\n          context.deleteBuffer(verticesBuffer);\n          context.deleteBuffer(indicesBuffer);\n        };\n      };\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @return {number} My end.\n       * @protected\n       */\n\n\n      WebGLTextureReplay.prototype.drawCoordinates = function drawCoordinates(flatCoordinates, offset, end, stride) {\n        var anchorX =\n        /** @type {number} */\n        this.anchorX;\n        var anchorY =\n        /** @type {number} */\n        this.anchorY;\n        var height =\n        /** @type {number} */\n        this.height;\n        var imageHeight =\n        /** @type {number} */\n        this.imageHeight;\n        var imageWidth =\n        /** @type {number} */\n        this.imageWidth;\n        var opacity =\n        /** @type {number} */\n        this.opacity;\n        var originX =\n        /** @type {number} */\n        this.originX;\n        var originY =\n        /** @type {number} */\n        this.originY;\n        var rotateWithView = this.rotateWithView ? 1.0 : 0.0; // this.rotation_ is anti-clockwise, but rotation is clockwise\n\n        var rotation =\n        /** @type {number} */\n        -this.rotation;\n        var scale =\n        /** @type {number} */\n        this.scale;\n        var width =\n        /** @type {number} */\n        this.width;\n        var cos = Math.cos(rotation);\n        var sin = Math.sin(rotation);\n        var numIndices = this.indices.length;\n        var numVertices = this.vertices.length;\n        var i, n, offsetX, offsetY, x, y;\n\n        for (i = offset; i < end; i += stride) {\n          x = flatCoordinates[i] - this.origin[0];\n          y = flatCoordinates[i + 1] - this.origin[1]; // There are 4 vertices per [x, y] point, one for each corner of the\n          // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if\n          // WebGL supported Geometry Shaders (which can emit new vertices), but that\n          // is not currently the case.\n          //\n          // And each vertex includes 8 values: the x and y coordinates, the x and\n          // y offsets used to calculate the position of the corner, the u and\n          // v texture coordinates for the corner, the opacity, and whether the\n          // the image should be rotated with the view (rotateWithView).\n\n          n = numVertices / 8; // bottom-left corner\n\n          offsetX = -scale * anchorX;\n          offsetY = -scale * (height - anchorY);\n          this.vertices[numVertices++] = x;\n          this.vertices[numVertices++] = y;\n          this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n          this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n          this.vertices[numVertices++] = originX / imageWidth;\n          this.vertices[numVertices++] = (originY + height) / imageHeight;\n          this.vertices[numVertices++] = opacity;\n          this.vertices[numVertices++] = rotateWithView; // bottom-right corner\n\n          offsetX = scale * (width - anchorX);\n          offsetY = -scale * (height - anchorY);\n          this.vertices[numVertices++] = x;\n          this.vertices[numVertices++] = y;\n          this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n          this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n          this.vertices[numVertices++] = (originX + width) / imageWidth;\n          this.vertices[numVertices++] = (originY + height) / imageHeight;\n          this.vertices[numVertices++] = opacity;\n          this.vertices[numVertices++] = rotateWithView; // top-right corner\n\n          offsetX = scale * (width - anchorX);\n          offsetY = scale * anchorY;\n          this.vertices[numVertices++] = x;\n          this.vertices[numVertices++] = y;\n          this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n          this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n          this.vertices[numVertices++] = (originX + width) / imageWidth;\n          this.vertices[numVertices++] = originY / imageHeight;\n          this.vertices[numVertices++] = opacity;\n          this.vertices[numVertices++] = rotateWithView; // top-left corner\n\n          offsetX = -scale * anchorX;\n          offsetY = scale * anchorY;\n          this.vertices[numVertices++] = x;\n          this.vertices[numVertices++] = y;\n          this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n          this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n          this.vertices[numVertices++] = originX / imageWidth;\n          this.vertices[numVertices++] = originY / imageHeight;\n          this.vertices[numVertices++] = opacity;\n          this.vertices[numVertices++] = rotateWithView;\n          this.indices[numIndices++] = n;\n          this.indices[numIndices++] = n + 1;\n          this.indices[numIndices++] = n + 2;\n          this.indices[numIndices++] = n;\n          this.indices[numIndices++] = n + 2;\n          this.indices[numIndices++] = n + 3;\n        }\n\n        return numVertices;\n      };\n      /**\n       * @protected\n       * @param {Array<WebGLTexture>} textures Textures.\n       * @param {Array<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images Images.\n       * @param {!Object<string, WebGLTexture>} texturePerImage Texture cache.\n       * @param {WebGLRenderingContext} gl Gl.\n       */\n\n\n      WebGLTextureReplay.prototype.createTextures = function createTextures(textures, images, texturePerImage, gl) {\n        var texture, image, uid, i;\n        var ii = images.length;\n\n        for (i = 0; i < ii; ++i) {\n          image = images[i];\n          uid = getUid(image);\n\n          if (uid in texturePerImage) {\n            texture = texturePerImage[uid];\n          } else {\n            texture = createTexture(gl, image, CLAMP_TO_EDGE, CLAMP_TO_EDGE);\n            texturePerImage[uid] = texture;\n          }\n\n          textures[i] = texture;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextureReplay.prototype.setUpProgram = function setUpProgram(gl, context, size, pixelRatio) {\n        // get the program\n        var program = context.getProgram(fragment$1, vertex$1); // get the locations\n\n        var locations;\n\n        if (!this.defaultLocations) {\n          locations = new Locations$1(gl, program);\n          this.defaultLocations = locations;\n        } else {\n          locations = this.defaultLocations;\n        } // use the program (FIXME: use the return value)\n\n\n        context.useProgram(program); // enable the vertex attrib arrays\n\n        gl.enableVertexAttribArray(locations.a_position);\n        gl.vertexAttribPointer(locations.a_position, 2, FLOAT, false, 32, 0);\n        gl.enableVertexAttribArray(locations.a_offsets);\n        gl.vertexAttribPointer(locations.a_offsets, 2, FLOAT, false, 32, 8);\n        gl.enableVertexAttribArray(locations.a_texCoord);\n        gl.vertexAttribPointer(locations.a_texCoord, 2, FLOAT, false, 32, 16);\n        gl.enableVertexAttribArray(locations.a_opacity);\n        gl.vertexAttribPointer(locations.a_opacity, 1, FLOAT, false, 32, 24);\n        gl.enableVertexAttribArray(locations.a_rotateWithView);\n        gl.vertexAttribPointer(locations.a_rotateWithView, 1, FLOAT, false, 32, 28);\n        return locations;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextureReplay.prototype.shutDownProgram = function shutDownProgram(gl, locations) {\n        gl.disableVertexAttribArray(locations.a_position);\n        gl.disableVertexAttribArray(locations.a_offsets);\n        gl.disableVertexAttribArray(locations.a_texCoord);\n        gl.disableVertexAttribArray(locations.a_opacity);\n        gl.disableVertexAttribArray(locations.a_rotateWithView);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextureReplay.prototype.drawReplay = function drawReplay(gl, context, skippedFeaturesHash, hitDetection) {\n        var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();\n        var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;\n\n        if (!isEmpty(skippedFeaturesHash)) {\n          this.drawReplaySkipping(gl, context, skippedFeaturesHash, textures, groupIndices);\n        } else {\n          var i, ii, start;\n\n          for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {\n            gl.bindTexture(TEXTURE_2D, textures[i]);\n            var end = groupIndices[i];\n            this.drawElements(gl, context, start, end);\n            start = end;\n          }\n        }\n      };\n      /**\n       * Draw the replay while paying attention to skipped features.\n       *\n       * This functions creates groups of features that can be drawn to together,\n       * so that the number of `drawElements` calls is minimized.\n       *\n       * For example given the following texture groups:\n       *\n       *    Group 1: A B C\n       *    Group 2: D [E] F G\n       *\n       * If feature E should be skipped, the following `drawElements` calls will be\n       * made:\n       *\n       *    drawElements with feature A, B and C\n       *    drawElements with feature D\n       *    drawElements with feature F and G\n       *\n       * @protected\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n       *  to skip.\n       * @param {Array<WebGLTexture>} textures Textures.\n       * @param {Array<number>} groupIndices Texture group indices.\n       */\n\n\n      WebGLTextureReplay.prototype.drawReplaySkipping = function drawReplaySkipping(gl, context, skippedFeaturesHash, textures, groupIndices) {\n        var featureIndex = 0;\n        var i, ii;\n\n        for (i = 0, ii = textures.length; i < ii; ++i) {\n          gl.bindTexture(TEXTURE_2D, textures[i]);\n          var groupStart = i > 0 ? groupIndices[i - 1] : 0;\n          var groupEnd = groupIndices[i];\n          var start = groupStart;\n          var end = groupStart;\n\n          while (featureIndex < this.startIndices.length && this.startIndices[featureIndex] <= groupEnd) {\n            var feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)] !== undefined) {\n              // feature should be skipped\n              if (start !== end) {\n                // draw the features so far\n                this.drawElements(gl, context, start, end);\n              } // continue with the next feature\n\n\n              start = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];\n              end = start;\n            } else {\n              // the feature is not skipped, augment the end index\n              end = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];\n            }\n\n            featureIndex++;\n          }\n\n          if (start !== end) {\n            // draw the remaining features (in case there was no skipped feature\n            // in this texture group, all features of a group are drawn together)\n            this.drawElements(gl, context, start, end);\n          }\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextureReplay.prototype.drawHitDetectionReplayOneByOne = function drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {\n        var i, groupStart, start, end, feature;\n        var featureIndex = this.startIndices.length - 1;\n        var hitDetectionTextures = this.getHitDetectionTextures();\n\n        for (i = hitDetectionTextures.length - 1; i >= 0; --i) {\n          gl.bindTexture(TEXTURE_2D, hitDetectionTextures[i]);\n          groupStart = i > 0 ? this.hitDetectionGroupIndices[i - 1] : 0;\n          end = this.hitDetectionGroupIndices[i]; // draw all features for this texture group\n\n          while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n            start = this.startIndices[featureIndex];\n            feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || intersects(\n            /** @type {Array<number>} */\n            opt_hitExtent, feature.getGeometry().getExtent()))) {\n              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n              this.drawElements(gl, context, start, end);\n              var result = featureCallback(feature);\n\n              if (result) {\n                return result;\n              }\n            }\n\n            end = start;\n            featureIndex--;\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextureReplay.prototype.finish = function finish(context) {\n        this.anchorX = undefined;\n        this.anchorY = undefined;\n        this.height = undefined;\n        this.imageHeight = undefined;\n        this.imageWidth = undefined;\n        this.indices = null;\n        this.opacity = undefined;\n        this.originX = undefined;\n        this.originY = undefined;\n        this.rotateWithView = undefined;\n        this.rotation = undefined;\n        this.scale = undefined;\n        this.vertices = null;\n        this.width = undefined;\n      };\n      /**\n       * @abstract\n       * @protected\n       * @param {boolean=} opt_all Return hit detection textures with regular ones.\n       * @return {Array<WebGLTexture>} Textures.\n       */\n\n\n      WebGLTextureReplay.prototype.getTextures = function getTextures(opt_all) {\n        return _abstract();\n      };\n      /**\n       * @abstract\n       * @protected\n       * @return {Array<WebGLTexture>} Textures.\n       */\n\n\n      WebGLTextureReplay.prototype.getHitDetectionTextures = function getHitDetectionTextures() {\n        return _abstract();\n      };\n\n      return WebGLTextureReplay;\n    }(WebGLReplay);\n    /**\n     * @module ol/render/webgl/ImageReplay\n     */\n\n\n    var WebGLImageReplay =\n    /*@__PURE__*/\n    function (WebGLTextureReplay$$1) {\n      function WebGLImageReplay(tolerance, maxExtent) {\n        WebGLTextureReplay$$1.call(this, tolerance, maxExtent);\n        /**\n         * @type {Array<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}\n         * @protected\n         */\n\n        this.images_ = [];\n        /**\n         * @type {Array<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}\n         * @protected\n         */\n\n        this.hitDetectionImages_ = [];\n        /**\n         * @type {Array<WebGLTexture>}\n         * @private\n         */\n\n        this.textures_ = [];\n        /**\n         * @type {Array<WebGLTexture>}\n         * @private\n         */\n\n        this.hitDetectionTextures_ = [];\n      }\n\n      if (WebGLTextureReplay$$1) WebGLImageReplay.__proto__ = WebGLTextureReplay$$1;\n      WebGLImageReplay.prototype = Object.create(WebGLTextureReplay$$1 && WebGLTextureReplay$$1.prototype);\n      WebGLImageReplay.prototype.constructor = WebGLImageReplay;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLImageReplay.prototype.drawMultiPoint = function drawMultiPoint(multiPointGeometry, feature) {\n        this.startIndices.push(this.indices.length);\n        this.startIndicesFeature.push(feature);\n        var flatCoordinates = multiPointGeometry.getFlatCoordinates();\n        var stride = multiPointGeometry.getStride();\n        this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImageReplay.prototype.drawPoint = function drawPoint(pointGeometry, feature) {\n        this.startIndices.push(this.indices.length);\n        this.startIndicesFeature.push(feature);\n        var flatCoordinates = pointGeometry.getFlatCoordinates();\n        var stride = pointGeometry.getStride();\n        this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImageReplay.prototype.finish = function finish(context) {\n        var gl = context.getGL();\n        this.groupIndices.push(this.indices.length);\n        this.hitDetectionGroupIndices.push(this.indices.length); // create, bind, and populate the vertices buffer\n\n        this.verticesBuffer = new WebGLBuffer(this.vertices);\n        var indices = this.indices; // create, bind, and populate the indices buffer\n\n        this.indicesBuffer = new WebGLBuffer(indices); // create textures\n\n        /** @type {Object<string, WebGLTexture>} */\n\n        var texturePerImage = {};\n        this.createTextures(this.textures_, this.images_, texturePerImage, gl);\n        this.createTextures(this.hitDetectionTextures_, this.hitDetectionImages_, texturePerImage, gl);\n        this.images_ = null;\n        this.hitDetectionImages_ = null;\n        WebGLTextureReplay$$1.prototype.finish.call(this, context);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImageReplay.prototype.setImageStyle = function setImageStyle(imageStyle) {\n        var anchor = imageStyle.getAnchor();\n        var image = imageStyle.getImage(1);\n        var imageSize = imageStyle.getImageSize();\n        var hitDetectionImage = imageStyle.getHitDetectionImage(1);\n        var opacity = imageStyle.getOpacity();\n        var origin = imageStyle.getOrigin();\n        var rotateWithView = imageStyle.getRotateWithView();\n        var rotation = imageStyle.getRotation();\n        var size = imageStyle.getSize();\n        var scale = imageStyle.getScale();\n        var currentImage;\n\n        if (this.images_.length === 0) {\n          this.images_.push(image);\n        } else {\n          currentImage = this.images_[this.images_.length - 1];\n\n          if (getUid(currentImage) != getUid(image)) {\n            this.groupIndices.push(this.indices.length);\n            this.images_.push(image);\n          }\n        }\n\n        if (this.hitDetectionImages_.length === 0) {\n          this.hitDetectionImages_.push(hitDetectionImage);\n        } else {\n          currentImage = this.hitDetectionImages_[this.hitDetectionImages_.length - 1];\n\n          if (getUid(currentImage) != getUid(hitDetectionImage)) {\n            this.hitDetectionGroupIndices.push(this.indices.length);\n            this.hitDetectionImages_.push(hitDetectionImage);\n          }\n        }\n\n        this.anchorX = anchor[0];\n        this.anchorY = anchor[1];\n        this.height = size[1];\n        this.imageHeight = imageSize[1];\n        this.imageWidth = imageSize[0];\n        this.opacity = opacity;\n        this.originX = origin[0];\n        this.originY = origin[1];\n        this.rotation = rotation;\n        this.rotateWithView = rotateWithView;\n        this.scale = scale;\n        this.width = size[0];\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImageReplay.prototype.getTextures = function getTextures(opt_all) {\n        return opt_all ? this.textures_.concat(this.hitDetectionTextures_) : this.textures_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImageReplay.prototype.getHitDetectionTextures = function getHitDetectionTextures() {\n        return this.hitDetectionTextures_;\n      };\n\n      return WebGLImageReplay;\n    }(WebGLTextureReplay);\n    /**\n     * @module ol/geom/flat/topology\n     */\n\n    /**\n     * Check if the linestring is a boundary.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @return {boolean} The linestring is a boundary.\n     */\n\n\n    function lineStringIsClosed(flatCoordinates, offset, end, stride) {\n      var lastCoord = end - stride;\n\n      if (flatCoordinates[offset] === flatCoordinates[lastCoord] && flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {\n        return !!linearRing(flatCoordinates, offset, end, stride);\n      }\n\n      return false;\n    }\n    /**\n     * @module ol/render/webgl/linestringreplay/defaultshader\n     */\n\n\n    var fragment$2 = new WebGLFragment('precision mediump float;\\nvarying float v_round;\\nvarying vec2 v_roundVertex;\\nvarying float v_halfWidth;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_color;\\nuniform vec2 u_size;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  if (v_round > 0.0) {\\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\\n      discard;\\n    }\\n  }\\n  gl_FragColor = u_color;\\n  float alpha = u_color.a * u_opacity;\\n  if (alpha == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor.a = alpha;\\n}\\n');\n    var vertex$2 = new WebGLVertex('varying float v_round;\\nvarying vec2 v_roundVertex;\\nvarying float v_halfWidth;\\n\\n\\nattribute vec2 a_lastPos;\\nattribute vec2 a_position;\\nattribute vec2 a_nextPos;\\nattribute float a_direction;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_miterLimit;\\n\\nbool nearlyEquals(in float value, in float ref) {\\n  float epsilon = 0.000000000001;\\n  return value >= ref - epsilon && value <= ref + epsilon;\\n}\\n\\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\\n  vec2 dirVect = nextP - a_position;\\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\\n  offset = u_lineWidth / 2.0 * normal * direction;\\n}\\n\\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\\n  float halfWidth = u_lineWidth / 2.0;\\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\\n  vec2 normal = vec2(-tangent.y, tangent.x);\\n  vec2 dirVect = a_nextPos - a_position;\\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\\n  offset = normal * direction * miterLength;\\n  round = 0.0;\\n  if (isRound) {\\n    round = 1.0;\\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\\n    offset = halfWidth * tmpNormal * direction;\\n  }\\n}\\n\\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\\n  bool degenerate = false;\\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\\n  vec2 normal = vec2(-tangent.y, tangent.x);\\n  vec2 dirVect = a_lastPos - a_position;\\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\\n  vec2 longOffset, shortOffset, longVertex;\\n  vec4 shortProjVertex;\\n  float halfWidth = u_lineWidth / 2.0;\\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\\n    longOffset = tmpNormal * direction * halfWidth;\\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\\n    longVertex = a_nextPos;\\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\\n  } else {\\n    shortOffset = tmpNormal * direction * halfWidth;\\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\\n    longVertex = a_lastPos;\\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\\n  }\\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\\n  float epsilon = 0.000000000001;\\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\\n    offset = shortProjVertex.xy;\\n    degenerate = true;\\n  } else {\\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\\n    offset = normal * direction * miterLength;\\n  }\\n  return degenerate;\\n}\\n\\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\\n    in float turnDir, in float direction) {\\n  round = 0.0;\\n  vec2 dirVect = a_position - nextP;\\n  vec2 firstNormal = normalize(dirVect);\\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\\n  offset = normal * length;\\n  if (isRound) {\\n    round = 1.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  bool degenerate = false;\\n  float direction = float(sign(a_direction));\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  vec2 offset;\\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\\n\\n  v_round = 0.0;\\n  v_halfWidth = u_lineWidth / 2.0;\\n  v_roundVertex = projPos.xy;\\n\\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\\n    alongNormal(offset, a_nextPos, 1.0, direction);\\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\\n    alongNormal(offset, a_lastPos, -1.0, direction);\\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\\n    miterUp(offset, v_round, round, direction);\\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\\n  }\\n  if (!degenerate) {\\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\\n    gl_Position = projPos + offsets;\\n  } else {\\n    gl_Position = vec4(offset, 0.0, 1.0);\\n  }\\n}\\n\\n\\n');\n    /**\n     * @module ol/render/webgl/linestringreplay/defaultshader/Locations\n     */\n\n    var Locations$2 = function Locations(gl, program) {\n      /**\n       * @type {WebGLUniformLocation}\n       */\n      this.u_projectionMatrix = gl.getUniformLocation(program, 'u_projectionMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetScaleMatrix = gl.getUniformLocation(program, 'u_offsetScaleMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetRotateMatrix = gl.getUniformLocation(program, 'u_offsetRotateMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_lineWidth = gl.getUniformLocation(program, 'u_lineWidth');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_miterLimit = gl.getUniformLocation(program, 'u_miterLimit');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_opacity = gl.getUniformLocation(program, 'u_opacity');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_color = gl.getUniformLocation(program, 'u_color');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_size = gl.getUniformLocation(program, 'u_size');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_pixelRatio = gl.getUniformLocation(program, 'u_pixelRatio');\n      /**\n       * @type {number}\n       */\n\n      this.a_lastPos = gl.getAttribLocation(program, 'a_lastPos');\n      /**\n       * @type {number}\n       */\n\n      this.a_position = gl.getAttribLocation(program, 'a_position');\n      /**\n       * @type {number}\n       */\n\n      this.a_nextPos = gl.getAttribLocation(program, 'a_nextPos');\n      /**\n       * @type {number}\n       */\n\n      this.a_direction = gl.getAttribLocation(program, 'a_direction');\n    };\n    /**\n     * @module ol/render/webgl/LineStringReplay\n     */\n\n    /**\n     * @enum {number}\n     */\n\n\n    var Instruction$1 = {\n      ROUND: 2,\n      BEGIN_LINE: 3,\n      END_LINE: 5,\n      BEGIN_LINE_CAP: 7,\n      END_LINE_CAP: 11,\n      BEVEL_FIRST: 13,\n      BEVEL_SECOND: 17,\n      MITER_BOTTOM: 19,\n      MITER_TOP: 23\n    };\n\n    var WebGLLineStringReplay =\n    /*@__PURE__*/\n    function (WebGLReplay$$1) {\n      function WebGLLineStringReplay(tolerance, maxExtent) {\n        WebGLReplay$$1.call(this, tolerance, maxExtent);\n        /**\n         * @private\n         * @type {import(\"./linestringreplay/defaultshader/Locations.js\").default}\n         */\n\n        this.defaultLocations_ = null;\n        /**\n         * @private\n         * @type {Array<Array<?>>}\n         */\n\n        this.styles_ = [];\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.styleIndices_ = [];\n        /**\n         * @private\n         * @type {{strokeColor: (Array<number>|null),\n         *         lineCap: (string|undefined),\n         *         lineDash: Array<number>,\n         *         lineDashOffset: (number|undefined),\n         *         lineJoin: (string|undefined),\n         *         lineWidth: (number|undefined),\n         *         miterLimit: (number|undefined),\n         *         changed: boolean}|null}\n         */\n\n        this.state_ = {\n          strokeColor: null,\n          lineCap: undefined,\n          lineDash: null,\n          lineDashOffset: undefined,\n          lineJoin: undefined,\n          lineWidth: undefined,\n          miterLimit: undefined,\n          changed: false\n        };\n      }\n\n      if (WebGLReplay$$1) WebGLLineStringReplay.__proto__ = WebGLReplay$$1;\n      WebGLLineStringReplay.prototype = Object.create(WebGLReplay$$1 && WebGLReplay$$1.prototype);\n      WebGLLineStringReplay.prototype.constructor = WebGLLineStringReplay;\n      /**\n       * Draw one segment.\n       * @private\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       */\n\n      WebGLLineStringReplay.prototype.drawCoordinates_ = function drawCoordinates_(flatCoordinates, offset, end, stride) {\n        var i, ii;\n        var numVertices = this.vertices.length;\n        var numIndices = this.indices.length; //To save a vertex, the direction of a point is a product of the sign (1 or -1), a prime from\n        //Instruction, and a rounding factor (1 or 2). If the product is even,\n        //we round it. If it is odd, we don't.\n\n        var lineJoin = this.state_.lineJoin === 'bevel' ? 0 : this.state_.lineJoin === 'miter' ? 1 : 2;\n        var lineCap = this.state_.lineCap === 'butt' ? 0 : this.state_.lineCap === 'square' ? 1 : 2;\n        var closed = lineStringIsClosed(flatCoordinates, offset, end, stride);\n        var startCoords, sign, n;\n        var lastIndex = numIndices;\n        var lastSign = 1; //We need the adjacent vertices to define normals in joins. p0 = last, p1 = current, p2 = next.\n\n        var p0, p1, p2;\n\n        for (i = offset, ii = end; i < ii; i += stride) {\n          n = numVertices / 7;\n          p0 = p1;\n          p1 = p2 || [flatCoordinates[i], flatCoordinates[i + 1]]; //First vertex.\n\n          if (i === offset) {\n            p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];\n\n            if (end - offset === stride * 2 && equals(p1, p2)) {\n              break;\n            }\n\n            if (closed) {\n              //A closed line! Complete the circle.\n              p0 = [flatCoordinates[end - stride * 2], flatCoordinates[end - stride * 2 + 1]];\n              startCoords = p2;\n            } else {\n              //Add the first two/four vertices.\n              if (lineCap) {\n                numVertices = this.addVertices_([0, 0], p1, p2, lastSign * Instruction$1.BEGIN_LINE_CAP * lineCap, numVertices);\n                numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * Instruction$1.BEGIN_LINE_CAP * lineCap, numVertices);\n                this.indices[numIndices++] = n + 2;\n                this.indices[numIndices++] = n;\n                this.indices[numIndices++] = n + 1;\n                this.indices[numIndices++] = n + 1;\n                this.indices[numIndices++] = n + 3;\n                this.indices[numIndices++] = n + 2;\n              }\n\n              numVertices = this.addVertices_([0, 0], p1, p2, lastSign * Instruction$1.BEGIN_LINE * (lineCap || 1), numVertices);\n              numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * Instruction$1.BEGIN_LINE * (lineCap || 1), numVertices);\n              lastIndex = numVertices / 7 - 1;\n              continue;\n            }\n          } else if (i === end - stride) {\n            //Last vertex.\n            if (closed) {\n              //Same as the first vertex.\n              p2 = startCoords;\n              break;\n            } else {\n              p0 = p0 || [0, 0];\n              numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * Instruction$1.END_LINE * (lineCap || 1), numVertices);\n              numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * Instruction$1.END_LINE * (lineCap || 1), numVertices);\n              this.indices[numIndices++] = n;\n              this.indices[numIndices++] = lastIndex - 1;\n              this.indices[numIndices++] = lastIndex;\n              this.indices[numIndices++] = lastIndex;\n              this.indices[numIndices++] = n + 1;\n              this.indices[numIndices++] = n;\n\n              if (lineCap) {\n                numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * Instruction$1.END_LINE_CAP * lineCap, numVertices);\n                numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * Instruction$1.END_LINE_CAP * lineCap, numVertices);\n                this.indices[numIndices++] = n + 2;\n                this.indices[numIndices++] = n;\n                this.indices[numIndices++] = n + 1;\n                this.indices[numIndices++] = n + 1;\n                this.indices[numIndices++] = n + 3;\n                this.indices[numIndices++] = n + 2;\n              }\n\n              break;\n            }\n          } else {\n            p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];\n          } // We group CW and straight lines, thus the not so inituitive CCW checking function.\n\n\n          sign = triangleIsCounterClockwise(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]) ? -1 : 1;\n          numVertices = this.addVertices_(p0, p1, p2, sign * Instruction$1.BEVEL_FIRST * (lineJoin || 1), numVertices);\n          numVertices = this.addVertices_(p0, p1, p2, sign * Instruction$1.BEVEL_SECOND * (lineJoin || 1), numVertices);\n          numVertices = this.addVertices_(p0, p1, p2, -sign * Instruction$1.MITER_BOTTOM * (lineJoin || 1), numVertices);\n\n          if (i > offset) {\n            this.indices[numIndices++] = n;\n            this.indices[numIndices++] = lastIndex - 1;\n            this.indices[numIndices++] = lastIndex;\n            this.indices[numIndices++] = n + 2;\n            this.indices[numIndices++] = n;\n            this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;\n          }\n\n          this.indices[numIndices++] = n;\n          this.indices[numIndices++] = n + 2;\n          this.indices[numIndices++] = n + 1;\n          lastIndex = n + 2;\n          lastSign = sign; //Add miter\n\n          if (lineJoin) {\n            numVertices = this.addVertices_(p0, p1, p2, sign * Instruction$1.MITER_TOP * lineJoin, numVertices);\n            this.indices[numIndices++] = n + 1;\n            this.indices[numIndices++] = n + 3;\n            this.indices[numIndices++] = n;\n          }\n        }\n\n        if (closed) {\n          n = n || numVertices / 7;\n          sign = linearRingIsClockwise([p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]], 0, 6, 2) ? 1 : -1;\n          numVertices = this.addVertices_(p0, p1, p2, sign * Instruction$1.BEVEL_FIRST * (lineJoin || 1), numVertices);\n          numVertices = this.addVertices_(p0, p1, p2, -sign * Instruction$1.MITER_BOTTOM * (lineJoin || 1), numVertices);\n          this.indices[numIndices++] = n;\n          this.indices[numIndices++] = lastIndex - 1;\n          this.indices[numIndices++] = lastIndex;\n          this.indices[numIndices++] = n + 1;\n          this.indices[numIndices++] = n;\n          this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;\n        }\n      };\n      /**\n       * @param {Array<number>} p0 Last coordinates.\n       * @param {Array<number>} p1 Current coordinates.\n       * @param {Array<number>} p2 Next coordinates.\n       * @param {number} product Sign, instruction, and rounding product.\n       * @param {number} numVertices Vertex counter.\n       * @return {number} Vertex counter.\n       * @private\n       */\n\n\n      WebGLLineStringReplay.prototype.addVertices_ = function addVertices_(p0, p1, p2, product, numVertices) {\n        this.vertices[numVertices++] = p0[0];\n        this.vertices[numVertices++] = p0[1];\n        this.vertices[numVertices++] = p1[0];\n        this.vertices[numVertices++] = p1[1];\n        this.vertices[numVertices++] = p2[0];\n        this.vertices[numVertices++] = p2[1];\n        this.vertices[numVertices++] = product;\n        return numVertices;\n      };\n      /**\n       * Check if the linestring can be drawn (i. e. valid).\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       * @return {boolean} The linestring can be drawn.\n       * @private\n       */\n\n\n      WebGLLineStringReplay.prototype.isValid_ = function isValid_(flatCoordinates, offset, end, stride) {\n        var range = end - offset;\n\n        if (range < stride * 2) {\n          return false;\n        } else if (range === stride * 2) {\n          var firstP = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n          var lastP = [flatCoordinates[offset + stride], flatCoordinates[offset + stride + 1]];\n          return !equals(firstP, lastP);\n        }\n\n        return true;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.drawLineString = function drawLineString(lineStringGeometry, feature) {\n        var flatCoordinates = lineStringGeometry.getFlatCoordinates();\n        var stride = lineStringGeometry.getStride();\n\n        if (this.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {\n          flatCoordinates = translate(flatCoordinates, 0, flatCoordinates.length, stride, -this.origin[0], -this.origin[1]);\n\n          if (this.state_.changed) {\n            this.styleIndices_.push(this.indices.length);\n            this.state_.changed = false;\n          }\n\n          this.startIndices.push(this.indices.length);\n          this.startIndicesFeature.push(feature);\n          this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString(multiLineStringGeometry, feature) {\n        var indexCount = this.indices.length;\n        var ends = multiLineStringGeometry.getEnds();\n        ends.unshift(0);\n        var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n        var stride = multiLineStringGeometry.getStride();\n        var i, ii;\n\n        if (ends.length > 1) {\n          for (i = 1, ii = ends.length; i < ii; ++i) {\n            if (this.isValid_(flatCoordinates, ends[i - 1], ends[i], stride)) {\n              var lineString = translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);\n              this.drawCoordinates_(lineString, 0, lineString.length, stride);\n            }\n          }\n        }\n\n        if (this.indices.length > indexCount) {\n          this.startIndices.push(indexCount);\n          this.startIndicesFeature.push(feature);\n\n          if (this.state_.changed) {\n            this.styleIndices_.push(indexCount);\n            this.state_.changed = false;\n          }\n        }\n      };\n      /**\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {Array<Array<number>>} holeFlatCoordinates Hole flat coordinates.\n       * @param {number} stride Stride.\n       */\n\n\n      WebGLLineStringReplay.prototype.drawPolygonCoordinates = function drawPolygonCoordinates(flatCoordinates, holeFlatCoordinates, stride) {\n        if (!lineStringIsClosed(flatCoordinates, 0, flatCoordinates.length, stride)) {\n          flatCoordinates.push(flatCoordinates[0]);\n          flatCoordinates.push(flatCoordinates[1]);\n        }\n\n        this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n\n        if (holeFlatCoordinates.length) {\n          var i, ii;\n\n          for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {\n            if (!lineStringIsClosed(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride)) {\n              holeFlatCoordinates[i].push(holeFlatCoordinates[i][0]);\n              holeFlatCoordinates[i].push(holeFlatCoordinates[i][1]);\n            }\n\n            this.drawCoordinates_(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride);\n          }\n        }\n      };\n      /**\n       * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n       * @param {number=} opt_index Index count.\n       */\n\n\n      WebGLLineStringReplay.prototype.setPolygonStyle = function setPolygonStyle(feature, opt_index) {\n        var index = opt_index === undefined ? this.indices.length : opt_index;\n        this.startIndices.push(index);\n        this.startIndicesFeature.push(feature);\n\n        if (this.state_.changed) {\n          this.styleIndices_.push(index);\n          this.state_.changed = false;\n        }\n      };\n      /**\n       * @return {number} Current index.\n       */\n\n\n      WebGLLineStringReplay.prototype.getCurrentIndex = function getCurrentIndex() {\n        return this.indices.length;\n      };\n      /**\n       * @inheritDoc\n       **/\n\n\n      WebGLLineStringReplay.prototype.finish = function finish(context) {\n        // create, bind, and populate the vertices buffer\n        this.verticesBuffer = new WebGLBuffer(this.vertices); // create, bind, and populate the indices buffer\n\n        this.indicesBuffer = new WebGLBuffer(this.indices);\n        this.startIndices.push(this.indices.length); //Clean up, if there is nothing to draw\n\n        if (this.styleIndices_.length === 0 && this.styles_.length > 0) {\n          this.styles_ = [];\n        }\n\n        this.vertices = null;\n        this.indices = null;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.getDeleteResourcesFunction = function getDeleteResourcesFunction(context) {\n        var verticesBuffer = this.verticesBuffer;\n        var indicesBuffer = this.indicesBuffer;\n        return function () {\n          context.deleteBuffer(verticesBuffer);\n          context.deleteBuffer(indicesBuffer);\n        };\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.setUpProgram = function setUpProgram(gl, context, size, pixelRatio) {\n        // get the program\n        var program = context.getProgram(fragment$2, vertex$2); // get the locations\n\n        var locations;\n\n        if (!this.defaultLocations_) {\n          locations = new Locations$2(gl, program);\n          this.defaultLocations_ = locations;\n        } else {\n          locations = this.defaultLocations_;\n        }\n\n        context.useProgram(program); // enable the vertex attrib arrays\n\n        gl.enableVertexAttribArray(locations.a_lastPos);\n        gl.vertexAttribPointer(locations.a_lastPos, 2, FLOAT, false, 28, 0);\n        gl.enableVertexAttribArray(locations.a_position);\n        gl.vertexAttribPointer(locations.a_position, 2, FLOAT, false, 28, 8);\n        gl.enableVertexAttribArray(locations.a_nextPos);\n        gl.vertexAttribPointer(locations.a_nextPos, 2, FLOAT, false, 28, 16);\n        gl.enableVertexAttribArray(locations.a_direction);\n        gl.vertexAttribPointer(locations.a_direction, 1, FLOAT, false, 28, 24); // Enable renderer specific uniforms.\n\n        gl.uniform2fv(locations.u_size, size);\n        gl.uniform1f(locations.u_pixelRatio, pixelRatio);\n        return locations;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.shutDownProgram = function shutDownProgram(gl, locations) {\n        gl.disableVertexAttribArray(locations.a_lastPos);\n        gl.disableVertexAttribArray(locations.a_position);\n        gl.disableVertexAttribArray(locations.a_nextPos);\n        gl.disableVertexAttribArray(locations.a_direction);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.drawReplay = function drawReplay(gl, context, skippedFeaturesHash, hitDetection) {\n        //Save GL parameters.\n        var tmpDepthFunc =\n        /** @type {number} */\n        gl.getParameter(gl.DEPTH_FUNC);\n        var tmpDepthMask =\n        /** @type {boolean} */\n        gl.getParameter(gl.DEPTH_WRITEMASK);\n\n        if (!hitDetection) {\n          gl.enable(gl.DEPTH_TEST);\n          gl.depthMask(true);\n          gl.depthFunc(gl.NOTEQUAL);\n        }\n\n        if (!isEmpty(skippedFeaturesHash)) {\n          this.drawReplaySkipping_(gl, context, skippedFeaturesHash);\n        } else {\n          //Draw by style groups to minimize drawElements() calls.\n          var i, start, end, nextStyle;\n          end = this.startIndices[this.startIndices.length - 1];\n\n          for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n            start = this.styleIndices_[i];\n            nextStyle = this.styles_[i];\n            this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);\n            this.drawElements(gl, context, start, end);\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n            end = start;\n          }\n        }\n\n        if (!hitDetection) {\n          gl.disable(gl.DEPTH_TEST);\n          gl.clear(gl.DEPTH_BUFFER_BIT); //Restore GL parameters.\n\n          gl.depthMask(tmpDepthMask);\n          gl.depthFunc(tmpDepthFunc);\n        }\n      };\n      /**\n       * @private\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object} skippedFeaturesHash Ids of features to skip.\n       */\n\n\n      WebGLLineStringReplay.prototype.drawReplaySkipping_ = function drawReplaySkipping_(gl, context, skippedFeaturesHash) {\n        var i, start, end, nextStyle, groupStart, feature, featureIndex, featureStart;\n        featureIndex = this.startIndices.length - 2;\n        end = start = this.startIndices[featureIndex + 1];\n\n        for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n          nextStyle = this.styles_[i];\n          this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);\n          groupStart = this.styleIndices_[i];\n\n          while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n            featureStart = this.startIndices[featureIndex];\n            feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)]) {\n              if (start !== end) {\n                this.drawElements(gl, context, start, end);\n                gl.clear(gl.DEPTH_BUFFER_BIT);\n              }\n\n              end = featureStart;\n            }\n\n            featureIndex--;\n            start = featureStart;\n          }\n\n          if (start !== end) {\n            this.drawElements(gl, context, start, end);\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n          }\n\n          start = end = groupStart;\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.drawHitDetectionReplayOneByOne = function drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {\n        var i, start, end, nextStyle, groupStart, feature, featureIndex;\n        featureIndex = this.startIndices.length - 2;\n        end = this.startIndices[featureIndex + 1];\n\n        for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n          nextStyle = this.styles_[i];\n          this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);\n          groupStart = this.styleIndices_[i];\n\n          while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n            start = this.startIndices[featureIndex];\n            feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || intersects(\n            /** @type {Array<number>} */\n            opt_hitExtent, feature.getGeometry().getExtent()))) {\n              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n              this.drawElements(gl, context, start, end);\n              var result = featureCallback(feature);\n\n              if (result) {\n                return result;\n              }\n            }\n\n            featureIndex--;\n            end = start;\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @private\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {Array<number>} color Color.\n       * @param {number} lineWidth Line width.\n       * @param {number} miterLimit Miter limit.\n       */\n\n\n      WebGLLineStringReplay.prototype.setStrokeStyle_ = function setStrokeStyle_(gl, color, lineWidth, miterLimit) {\n        gl.uniform4fv(this.defaultLocations_.u_color, color);\n        gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);\n        gl.uniform1f(this.defaultLocations_.u_miterLimit, miterLimit);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLLineStringReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n        var strokeStyleLineCap = strokeStyle.getLineCap();\n        this.state_.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : DEFAULT_LINECAP;\n        var strokeStyleLineDash = strokeStyle.getLineDash();\n        this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : DEFAULT_LINEDASH;\n        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n        this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : DEFAULT_LINEDASHOFFSET;\n        var strokeStyleLineJoin = strokeStyle.getLineJoin();\n        this.state_.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : DEFAULT_LINEJOIN;\n        var strokeStyleColor = strokeStyle.getColor();\n\n        if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {\n          strokeStyleColor = asArray(strokeStyleColor).map(function (c, i) {\n            return i != 3 ? c / 255 : c;\n          }) || DEFAULT_STROKESTYLE;\n        } else {\n          strokeStyleColor = DEFAULT_STROKESTYLE;\n        }\n\n        var strokeStyleWidth = strokeStyle.getWidth();\n        strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : DEFAULT_LINEWIDTH;\n        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n        strokeStyleMiterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : DEFAULT_MITERLIMIT;\n\n        if (!this.state_.strokeColor || !equals(this.state_.strokeColor, strokeStyleColor) || this.state_.lineWidth !== strokeStyleWidth || this.state_.miterLimit !== strokeStyleMiterLimit) {\n          this.state_.changed = true;\n          this.state_.strokeColor = strokeStyleColor;\n          this.state_.lineWidth = strokeStyleWidth;\n          this.state_.miterLimit = strokeStyleMiterLimit;\n          this.styles_.push([strokeStyleColor, strokeStyleWidth, strokeStyleMiterLimit]);\n        }\n      };\n\n      return WebGLLineStringReplay;\n    }(WebGLReplay);\n    /**\n     * @module ol/render/webgl/polygonreplay/defaultshader\n     */\n\n\n    var fragment$3 = new WebGLFragment('precision mediump float;\\n\\n\\n\\nuniform vec4 u_color;\\nuniform float u_opacity;\\n\\nvoid main(void) {\\n  gl_FragColor = u_color;\\n  float alpha = u_color.a * u_opacity;\\n  if (alpha == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor.a = alpha;\\n}\\n');\n    var vertex$3 = new WebGLVertex('\\n\\nattribute vec2 a_position;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\n\\nvoid main(void) {\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\\n}\\n\\n\\n');\n    /**\n     * @module ol/render/webgl/polygonreplay/defaultshader/Locations\n     */\n\n    var Locations$3 = function Locations(gl, program) {\n      /**\n       * @type {WebGLUniformLocation}\n       */\n      this.u_projectionMatrix = gl.getUniformLocation(program, 'u_projectionMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetScaleMatrix = gl.getUniformLocation(program, 'u_offsetScaleMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_offsetRotateMatrix = gl.getUniformLocation(program, 'u_offsetRotateMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_color = gl.getUniformLocation(program, 'u_color');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_opacity = gl.getUniformLocation(program, 'u_opacity');\n      /**\n       * @type {number}\n       */\n\n      this.a_position = gl.getAttribLocation(program, 'a_position');\n    };\n    /**\n     * @module ol/structs/LinkedList\n     */\n\n    /**\n     * @typedef {Object} Item\n     * @property {Item} [prev]\n     * @property {Item} [next]\n     * @property {?} data\n     */\n\n    /**\n     * @classdesc\n     * Creates an empty linked list structure.\n     */\n\n\n    var LinkedList = function LinkedList(opt_circular) {\n      /**\n       * @private\n       * @type {Item|undefined}\n       */\n      this.first_;\n      /**\n       * @private\n       * @type {Item|undefined}\n       */\n\n      this.last_;\n      /**\n       * @private\n       * @type {Item|undefined}\n       */\n\n      this.head_;\n      /**\n       * @private\n       * @type {boolean}\n       */\n\n      this.circular_ = opt_circular === undefined ? true : opt_circular;\n      /**\n       * @private\n       * @type {number}\n       */\n\n      this.length_ = 0;\n    };\n    /**\n     * Inserts an item into the linked list right after the current one.\n     *\n     * @param {?} data Item data.\n     */\n\n\n    LinkedList.prototype.insertItem = function insertItem(data) {\n      /** @type {Item} */\n      var item = {\n        prev: undefined,\n        next: undefined,\n        data: data\n      };\n      var head = this.head_; //Initialize the list.\n\n      if (!head) {\n        this.first_ = item;\n        this.last_ = item;\n\n        if (this.circular_) {\n          item.next = item;\n          item.prev = item;\n        }\n      } else {\n        //Link the new item to the adjacent ones.\n        var next = head.next;\n        item.prev = head;\n        item.next = next;\n        head.next = item;\n\n        if (next) {\n          next.prev = item;\n        }\n\n        if (head === this.last_) {\n          this.last_ = item;\n        }\n      }\n\n      this.head_ = item;\n      this.length_++;\n    };\n    /**\n     * Removes the current item from the list. Sets the cursor to the next item,\n     * if possible.\n     */\n\n\n    LinkedList.prototype.removeItem = function removeItem() {\n      var head = this.head_;\n\n      if (head) {\n        var next = head.next;\n        var prev = head.prev;\n\n        if (next) {\n          next.prev = prev;\n        }\n\n        if (prev) {\n          prev.next = next;\n        }\n\n        this.head_ = next || prev;\n\n        if (this.first_ === this.last_) {\n          this.head_ = undefined;\n          this.first_ = undefined;\n          this.last_ = undefined;\n        } else if (this.first_ === head) {\n          this.first_ = this.head_;\n        } else if (this.last_ === head) {\n          this.last_ = prev ? this.head_.prev : this.head_;\n        }\n\n        this.length_--;\n      }\n    };\n    /**\n     * Sets the cursor to the first item, and returns the associated data.\n     *\n     * @return {?} Item data.\n     */\n\n\n    LinkedList.prototype.firstItem = function firstItem() {\n      this.head_ = this.first_;\n\n      if (this.head_) {\n        return this.head_.data;\n      }\n\n      return undefined;\n    };\n    /**\n    * Sets the cursor to the last item, and returns the associated data.\n    *\n    * @return {?} Item data.\n    */\n\n\n    LinkedList.prototype.lastItem = function lastItem() {\n      this.head_ = this.last_;\n\n      if (this.head_) {\n        return this.head_.data;\n      }\n\n      return undefined;\n    };\n    /**\n     * Sets the cursor to the next item, and returns the associated data.\n     *\n     * @return {?} Item data.\n     */\n\n\n    LinkedList.prototype.nextItem = function nextItem() {\n      if (this.head_ && this.head_.next) {\n        this.head_ = this.head_.next;\n        return this.head_.data;\n      }\n\n      return undefined;\n    };\n    /**\n     * Returns the next item's data without moving the cursor.\n     *\n     * @return {?} Item data.\n     */\n\n\n    LinkedList.prototype.getNextItem = function getNextItem() {\n      if (this.head_ && this.head_.next) {\n        return this.head_.next.data;\n      }\n\n      return undefined;\n    };\n    /**\n     * Sets the cursor to the previous item, and returns the associated data.\n     *\n     * @return {?} Item data.\n     */\n\n\n    LinkedList.prototype.prevItem = function prevItem() {\n      if (this.head_ && this.head_.prev) {\n        this.head_ = this.head_.prev;\n        return this.head_.data;\n      }\n\n      return undefined;\n    };\n    /**\n     * Returns the previous item's data without moving the cursor.\n     *\n     * @return {?} Item data.\n     */\n\n\n    LinkedList.prototype.getPrevItem = function getPrevItem() {\n      if (this.head_ && this.head_.prev) {\n        return this.head_.prev.data;\n      }\n\n      return undefined;\n    };\n    /**\n     * Returns the current item's data.\n     *\n     * @return {?} Item data.\n     */\n\n\n    LinkedList.prototype.getCurrItem = function getCurrItem() {\n      if (this.head_) {\n        return this.head_.data;\n      }\n\n      return undefined;\n    };\n    /**\n     * Sets the first item of the list. This only works for circular lists, and sets\n     * the last item accordingly.\n     */\n\n\n    LinkedList.prototype.setFirstItem = function setFirstItem() {\n      if (this.circular_ && this.head_) {\n        this.first_ = this.head_;\n        this.last_ = this.head_.prev;\n      }\n    };\n    /**\n     * Concatenates two lists.\n     * @param {LinkedList} list List to merge into the current list.\n     */\n\n\n    LinkedList.prototype.concat = function concat(list) {\n      if (list.head_) {\n        if (this.head_) {\n          var end = this.head_.next;\n          this.head_.next = list.first_;\n          list.first_.prev = this.head_;\n          end.prev = list.last_;\n          list.last_.next = end;\n          this.length_ += list.length_;\n        } else {\n          this.head_ = list.head_;\n          this.first_ = list.first_;\n          this.last_ = list.last_;\n          this.length_ = list.length_;\n        }\n\n        list.head_ = undefined;\n        list.first_ = undefined;\n        list.last_ = undefined;\n        list.length_ = 0;\n      }\n    };\n    /**\n     * Returns the current length of the list.\n     *\n     * @return {number} Length.\n     */\n\n\n    LinkedList.prototype.getLength = function getLength() {\n      return this.length_;\n    };\n    /**\n     * @module ol/render/webgl/PolygonReplay\n     */\n\n    /**\n     * @typedef {Object} PolygonVertex\n     * @property {number} x\n     * @property {number} y\n     * @property {number} i\n     * @property {boolean} [reflex]\n     */\n\n    /**\n     * @typedef {Object} PolygonSegment\n     * @property {PolygonVertex} p0\n     * @property {PolygonVertex} p1\n     */\n\n\n    var WebGLPolygonReplay =\n    /*@__PURE__*/\n    function (WebGLReplay$$1) {\n      function WebGLPolygonReplay(tolerance, maxExtent) {\n        WebGLReplay$$1.call(this, tolerance, maxExtent);\n        this.lineStringReplay = new WebGLLineStringReplay(tolerance, maxExtent);\n        /**\n         * @private\n         * @type {import(\"./polygonreplay/defaultshader/Locations.js\").default}\n         */\n\n        this.defaultLocations_ = null;\n        /**\n         * @private\n         * @type {Array<Array<number>>}\n         */\n\n        this.styles_ = [];\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n\n        this.styleIndices_ = [];\n        /**\n         * @private\n         * @type {{fillColor: (Array<number>|null),\n         *         changed: boolean}|null}\n         */\n\n        this.state_ = {\n          fillColor: null,\n          changed: false\n        };\n      }\n\n      if (WebGLReplay$$1) WebGLPolygonReplay.__proto__ = WebGLReplay$$1;\n      WebGLPolygonReplay.prototype = Object.create(WebGLReplay$$1 && WebGLReplay$$1.prototype);\n      WebGLPolygonReplay.prototype.constructor = WebGLPolygonReplay;\n      /**\n       * Draw one polygon.\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {Array<Array<number>>} holeFlatCoordinates Hole flat coordinates.\n       * @param {number} stride Stride.\n       * @private\n       */\n\n      WebGLPolygonReplay.prototype.drawCoordinates_ = function drawCoordinates_(flatCoordinates, holeFlatCoordinates, stride) {\n        // Triangulate the polygon\n        var outerRing = new LinkedList();\n        var rtree = new RBush(); // Initialize the outer ring\n\n        this.processFlatCoordinates_(flatCoordinates, stride, outerRing, rtree, true);\n        var maxCoords = this.getMaxCoords_(outerRing); // Eliminate holes, if there are any\n\n        if (holeFlatCoordinates.length) {\n          var i, ii;\n          var holeLists = [];\n\n          for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {\n            var holeList = {\n              list: new LinkedList(),\n              maxCoords: undefined,\n              rtree: new RBush()\n            };\n            holeLists.push(holeList);\n            this.processFlatCoordinates_(holeFlatCoordinates[i], stride, holeList.list, holeList.rtree, false);\n            this.classifyPoints_(holeList.list, holeList.rtree, true);\n            holeList.maxCoords = this.getMaxCoords_(holeList.list);\n          }\n\n          holeLists.sort(function (a, b) {\n            return b.maxCoords[0] === a.maxCoords[0] ? a.maxCoords[1] - b.maxCoords[1] : b.maxCoords[0] - a.maxCoords[0];\n          });\n\n          for (i = 0; i < holeLists.length; ++i) {\n            var currList = holeLists[i].list;\n            var start = currList.firstItem();\n            var currItem = start;\n            var intersection = void 0;\n\n            do {\n              //TODO: Triangulate holes when they intersect the outer ring.\n              if (this.getIntersections_(currItem, rtree).length) {\n                intersection = true;\n                break;\n              }\n\n              currItem = currList.nextItem();\n            } while (start !== currItem);\n\n            if (!intersection) {\n              if (this.bridgeHole_(currList, holeLists[i].maxCoords[0], outerRing, maxCoords[0], rtree)) {\n                rtree.concat(holeLists[i].rtree);\n                this.classifyPoints_(outerRing, rtree, false);\n              }\n            }\n          }\n        } else {\n          this.classifyPoints_(outerRing, rtree, false);\n        }\n\n        this.triangulate_(outerRing, rtree);\n      };\n      /**\n       * Inserts flat coordinates in a linked list and adds them to the vertex buffer.\n       * @private\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} stride Stride.\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @param {boolean} clockwise Coordinate order should be clockwise.\n       */\n\n\n      WebGLPolygonReplay.prototype.processFlatCoordinates_ = function processFlatCoordinates_(flatCoordinates, stride, list, rtree, clockwise) {\n        var isClockwise = linearRingIsClockwise(flatCoordinates, 0, flatCoordinates.length, stride);\n        var i, ii;\n        var n = this.vertices.length / 2;\n        /** @type {PolygonVertex} */\n\n        var start;\n        /** @type {PolygonVertex} */\n\n        var p0;\n        /** @type {PolygonVertex} */\n\n        var p1;\n        var extents = [];\n        var segments = [];\n\n        if (clockwise === isClockwise) {\n          start = this.createPoint_(flatCoordinates[0], flatCoordinates[1], n++);\n          p0 = start;\n\n          for (i = stride, ii = flatCoordinates.length; i < ii; i += stride) {\n            p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);\n            segments.push(this.insertItem_(p0, p1, list));\n            extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);\n            p0 = p1;\n          }\n\n          segments.push(this.insertItem_(p1, start, list));\n          extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);\n        } else {\n          var end = flatCoordinates.length - stride;\n          start = this.createPoint_(flatCoordinates[end], flatCoordinates[end + 1], n++);\n          p0 = start;\n\n          for (i = end - stride, ii = 0; i >= ii; i -= stride) {\n            p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);\n            segments.push(this.insertItem_(p0, p1, list));\n            extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);\n            p0 = p1;\n          }\n\n          segments.push(this.insertItem_(p1, start, list));\n          extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);\n        }\n\n        rtree.load(extents, segments);\n      };\n      /**\n       * Returns the rightmost coordinates of a polygon on the X axis.\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Polygons ring.\n       * @return {Array<number>} Max X coordinates.\n       */\n\n\n      WebGLPolygonReplay.prototype.getMaxCoords_ = function getMaxCoords_(list) {\n        var start = list.firstItem();\n        var seg = start;\n        var maxCoords = [seg.p0.x, seg.p0.y];\n\n        do {\n          seg = list.nextItem();\n\n          if (seg.p0.x > maxCoords[0]) {\n            maxCoords = [seg.p0.x, seg.p0.y];\n          }\n        } while (seg !== start);\n\n        return maxCoords;\n      };\n      /**\n       * Classifies the points of a polygon list as convex, reflex. Removes collinear vertices.\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Polygon ring.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @param {boolean} ccw The orientation of the polygon is counter-clockwise.\n       * @return {boolean} There were reclassified points.\n       */\n\n\n      WebGLPolygonReplay.prototype.classifyPoints_ = function classifyPoints_(list, rtree, ccw) {\n        var start = list.firstItem();\n        var s0 = start;\n        var s1 = list.nextItem();\n        var pointsReclassified = false;\n\n        do {\n          var reflex = ccw ? triangleIsCounterClockwise(s1.p1.x, s1.p1.y, s0.p1.x, s0.p1.y, s0.p0.x, s0.p0.y) : triangleIsCounterClockwise(s0.p0.x, s0.p0.y, s0.p1.x, s0.p1.y, s1.p1.x, s1.p1.y);\n\n          if (reflex === undefined) {\n            this.removeItem_(s0, s1, list, rtree);\n            pointsReclassified = true;\n\n            if (s1 === start) {\n              start = list.getNextItem();\n            }\n\n            s1 = s0;\n            list.prevItem();\n          } else if (s0.p1.reflex !== reflex) {\n            s0.p1.reflex = reflex;\n            pointsReclassified = true;\n          }\n\n          s0 = s1;\n          s1 = list.nextItem();\n        } while (s0 !== start);\n\n        return pointsReclassified;\n      };\n      /**\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} hole Linked list of the hole.\n       * @param {number} holeMaxX Maximum X value of the hole.\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list of the polygon.\n       * @param {number} listMaxX Maximum X value of the polygon.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @return {boolean} Bridging was successful.\n       */\n\n\n      WebGLPolygonReplay.prototype.bridgeHole_ = function bridgeHole_(hole, holeMaxX, list, listMaxX, rtree) {\n        var seg = hole.firstItem();\n\n        while (seg.p1.x !== holeMaxX) {\n          seg = hole.nextItem();\n        }\n\n        var p1 = seg.p1;\n        /** @type {PolygonVertex} */\n\n        var p2 = {\n          x: listMaxX,\n          y: p1.y,\n          i: -1\n        };\n        var minDist = Infinity;\n        var i, ii, bestPoint;\n        /** @type {PolygonVertex} */\n\n        var p5;\n        var intersectingSegments = this.getIntersections_({\n          p0: p1,\n          p1: p2\n        }, rtree, true);\n\n        for (i = 0, ii = intersectingSegments.length; i < ii; ++i) {\n          var currSeg = intersectingSegments[i];\n          var intersection = this.calculateIntersection_(p1, p2, currSeg.p0, currSeg.p1, true);\n          var dist = Math.abs(p1.x - intersection[0]);\n\n          if (dist < minDist && triangleIsCounterClockwise(p1.x, p1.y, currSeg.p0.x, currSeg.p0.y, currSeg.p1.x, currSeg.p1.y) !== undefined) {\n            minDist = dist;\n            p5 = {\n              x: intersection[0],\n              y: intersection[1],\n              i: -1\n            };\n            seg = currSeg;\n          }\n        }\n\n        if (minDist === Infinity) {\n          return false;\n        }\n\n        bestPoint = seg.p1;\n\n        if (minDist > 0) {\n          var pointsInTriangle = this.getPointsInTriangle_(p1, p5, seg.p1, rtree);\n\n          if (pointsInTriangle.length) {\n            var theta = Infinity;\n\n            for (i = 0, ii = pointsInTriangle.length; i < ii; ++i) {\n              var currPoint = pointsInTriangle[i];\n              var currTheta = Math.atan2(p1.y - currPoint.y, p2.x - currPoint.x);\n\n              if (currTheta < theta || currTheta === theta && currPoint.x < bestPoint.x) {\n                theta = currTheta;\n                bestPoint = currPoint;\n              }\n            }\n          }\n        }\n\n        seg = list.firstItem();\n\n        while (seg.p1.x !== bestPoint.x || seg.p1.y !== bestPoint.y) {\n          seg = list.nextItem();\n        } //We clone the bridge points as they can have different convexity.\n\n\n        var p0Bridge = {\n          x: p1.x,\n          y: p1.y,\n          i: p1.i,\n          reflex: undefined\n        };\n        var p1Bridge = {\n          x: seg.p1.x,\n          y: seg.p1.y,\n          i: seg.p1.i,\n          reflex: undefined\n        };\n        hole.getNextItem().p0 = p0Bridge;\n        this.insertItem_(p1, seg.p1, hole, rtree);\n        this.insertItem_(p1Bridge, p0Bridge, hole, rtree);\n        seg.p1 = p1Bridge;\n        hole.setFirstItem();\n        list.concat(hole);\n        return true;\n      };\n      /**\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list of the polygon.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       */\n\n\n      WebGLPolygonReplay.prototype.triangulate_ = function triangulate_(list, rtree) {\n        var ccw = false;\n        var simple = this.isSimple_(list, rtree); // Start clipping ears\n\n        while (list.getLength() > 3) {\n          if (simple) {\n            if (!this.clipEars_(list, rtree, simple, ccw)) {\n              if (!this.classifyPoints_(list, rtree, ccw)) {\n                // Due to the behavior of OL's PIP algorithm, the ear clipping cannot\n                // introduce touching segments. However, the original data may have some.\n                if (!this.resolveSelfIntersections_(list, rtree, true)) {\n                  break;\n                }\n              }\n            }\n          } else {\n            if (!this.clipEars_(list, rtree, simple, ccw)) {\n              // We ran out of ears, try to reclassify.\n              if (!this.classifyPoints_(list, rtree, ccw)) {\n                // We have a bad polygon, try to resolve local self-intersections.\n                if (!this.resolveSelfIntersections_(list, rtree)) {\n                  simple = this.isSimple_(list, rtree);\n\n                  if (!simple) {\n                    // We have a really bad polygon, try more time consuming methods.\n                    this.splitPolygon_(list, rtree);\n                    break;\n                  } else {\n                    ccw = !this.isClockwise_(list);\n                    this.classifyPoints_(list, rtree, ccw);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (list.getLength() === 3) {\n          var numIndices = this.indices.length;\n          this.indices[numIndices++] = list.getPrevItem().p0.i;\n          this.indices[numIndices++] = list.getCurrItem().p0.i;\n          this.indices[numIndices++] = list.getNextItem().p0.i;\n        }\n      };\n      /**\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list of the polygon.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @param {boolean} simple The polygon is simple.\n       * @param {boolean} ccw Orientation of the polygon is counter-clockwise.\n       * @return {boolean} There were processed ears.\n       */\n\n\n      WebGLPolygonReplay.prototype.clipEars_ = function clipEars_(list, rtree, simple, ccw) {\n        var numIndices = this.indices.length;\n        var start = list.firstItem();\n        var s0 = list.getPrevItem();\n        var s1 = start;\n        var s2 = list.nextItem();\n        var s3 = list.getNextItem();\n        var p0, p1, p2;\n        var processedEars = false;\n\n        do {\n          p0 = s1.p0;\n          p1 = s1.p1;\n          p2 = s2.p1;\n\n          if (p1.reflex === false) {\n            // We might have a valid ear\n            var variableCriterion = void 0;\n\n            if (simple) {\n              variableCriterion = this.getPointsInTriangle_(p0, p1, p2, rtree, true).length === 0;\n            } else {\n              variableCriterion = ccw ? this.diagonalIsInside_(s3.p1, p2, p1, p0, s0.p0) : this.diagonalIsInside_(s0.p0, p0, p1, p2, s3.p1);\n            }\n\n            if ((simple || this.getIntersections_({\n              p0: p0,\n              p1: p2\n            }, rtree).length === 0) && variableCriterion) {\n              //The diagonal is completely inside the polygon\n              if (simple || p0.reflex === false || p2.reflex === false || linearRingIsClockwise([s0.p0.x, s0.p0.y, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, s3.p1.x, s3.p1.y], 0, 10, 2) === !ccw) {\n                //The diagonal is persumably valid, we have an ear\n                this.indices[numIndices++] = p0.i;\n                this.indices[numIndices++] = p1.i;\n                this.indices[numIndices++] = p2.i;\n                this.removeItem_(s1, s2, list, rtree);\n\n                if (s2 === start) {\n                  start = s3;\n                }\n\n                processedEars = true;\n              }\n            }\n          } // Else we have a reflex point.\n\n\n          s0 = list.getPrevItem();\n          s1 = list.getCurrItem();\n          s2 = list.nextItem();\n          s3 = list.getNextItem();\n        } while (s1 !== start && list.getLength() > 3);\n\n        return processedEars;\n      };\n      /**\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list of the polygon.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @param {boolean=} opt_touch Resolve touching segments.\n       * @return {boolean} There were resolved intersections.\n      */\n\n\n      WebGLPolygonReplay.prototype.resolveSelfIntersections_ = function resolveSelfIntersections_(list, rtree, opt_touch) {\n        var start = list.firstItem();\n        list.nextItem();\n        var s0 = start;\n        var s1 = list.nextItem();\n        var resolvedIntersections = false;\n\n        do {\n          var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1, opt_touch);\n\n          if (intersection) {\n            var breakCond = false;\n            var numVertices = this.vertices.length;\n            var numIndices = this.indices.length;\n            var n = numVertices / 2;\n            var seg = list.prevItem();\n            list.removeItem();\n            rtree.remove(seg);\n            breakCond = seg === start;\n            var p = void 0;\n\n            if (opt_touch) {\n              if (intersection[0] === s0.p0.x && intersection[1] === s0.p0.y) {\n                list.prevItem();\n                p = s0.p0;\n                s1.p0 = p;\n                rtree.remove(s0);\n                breakCond = breakCond || s0 === start;\n              } else {\n                p = s1.p1;\n                s0.p1 = p;\n                rtree.remove(s1);\n                breakCond = breakCond || s1 === start;\n              }\n\n              list.removeItem();\n            } else {\n              p = this.createPoint_(intersection[0], intersection[1], n);\n              s0.p1 = p;\n              s1.p0 = p;\n              rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);\n              rtree.update([Math.min(s1.p0.x, s1.p1.x), Math.min(s1.p0.y, s1.p1.y), Math.max(s1.p0.x, s1.p1.x), Math.max(s1.p0.y, s1.p1.y)], s1);\n            }\n\n            this.indices[numIndices++] = seg.p0.i;\n            this.indices[numIndices++] = seg.p1.i;\n            this.indices[numIndices++] = p.i;\n            resolvedIntersections = true;\n\n            if (breakCond) {\n              break;\n            }\n          }\n\n          s0 = list.getPrevItem();\n          s1 = list.nextItem();\n        } while (s0 !== start);\n\n        return resolvedIntersections;\n      };\n      /**\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list of the polygon.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @return {boolean} The polygon is simple.\n       */\n\n\n      WebGLPolygonReplay.prototype.isSimple_ = function isSimple_(list, rtree) {\n        var start = list.firstItem();\n        var seg = start;\n\n        do {\n          if (this.getIntersections_(seg, rtree).length) {\n            return false;\n          }\n\n          seg = list.nextItem();\n        } while (seg !== start);\n\n        return true;\n      };\n      /**\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list of the polygon.\n       * @return {boolean} Orientation is clockwise.\n       */\n\n\n      WebGLPolygonReplay.prototype.isClockwise_ = function isClockwise_(list) {\n        var length = list.getLength() * 2;\n        var flatCoordinates = new Array(length);\n        var start = list.firstItem();\n        var seg = start;\n        var i = 0;\n\n        do {\n          flatCoordinates[i++] = seg.p0.x;\n          flatCoordinates[i++] = seg.p0.y;\n          seg = list.nextItem();\n        } while (seg !== start);\n\n        return linearRingIsClockwise(flatCoordinates, 0, length, 2);\n      };\n      /**\n       * @private\n       * @param {import(\"../../structs/LinkedList.js\").default} list Linked list of the polygon.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       */\n\n\n      WebGLPolygonReplay.prototype.splitPolygon_ = function splitPolygon_(list, rtree) {\n        var start = list.firstItem();\n        var s0 = start;\n\n        do {\n          var intersections = this.getIntersections_(s0, rtree);\n\n          if (intersections.length) {\n            var s1 = intersections[0];\n            var n = this.vertices.length / 2;\n            var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1);\n            var p = this.createPoint_(intersection[0], intersection[1], n);\n            var newPolygon = new LinkedList();\n            var newRtree = new RBush();\n            this.insertItem_(p, s0.p1, newPolygon, newRtree);\n            s0.p1 = p;\n            rtree.update([Math.min(s0.p0.x, p.x), Math.min(s0.p0.y, p.y), Math.max(s0.p0.x, p.x), Math.max(s0.p0.y, p.y)], s0);\n            var currItem = list.nextItem();\n\n            while (currItem !== s1) {\n              this.insertItem_(currItem.p0, currItem.p1, newPolygon, newRtree);\n              rtree.remove(currItem);\n              list.removeItem();\n              currItem = list.getCurrItem();\n            }\n\n            this.insertItem_(s1.p0, p, newPolygon, newRtree);\n            s1.p0 = p;\n            rtree.update([Math.min(s1.p1.x, p.x), Math.min(s1.p1.y, p.y), Math.max(s1.p1.x, p.x), Math.max(s1.p1.y, p.y)], s1);\n            this.classifyPoints_(list, rtree, false);\n            this.triangulate_(list, rtree);\n            this.classifyPoints_(newPolygon, newRtree, false);\n            this.triangulate_(newPolygon, newRtree);\n            break;\n          }\n\n          s0 = list.nextItem();\n        } while (s0 !== start);\n      };\n      /**\n       * @private\n       * @param {number} x X coordinate.\n       * @param {number} y Y coordinate.\n       * @param {number} i Index.\n       * @return {PolygonVertex} List item.\n       */\n\n\n      WebGLPolygonReplay.prototype.createPoint_ = function createPoint_(x, y, i) {\n        var numVertices = this.vertices.length;\n        this.vertices[numVertices++] = x;\n        this.vertices[numVertices++] = y;\n        /** @type {PolygonVertex} */\n\n        var p = {\n          x: x,\n          y: y,\n          i: i,\n          reflex: undefined\n        };\n        return p;\n      };\n      /**\n       * @private\n       * @param {PolygonVertex} p0 First point of segment.\n       * @param {PolygonVertex} p1 Second point of segment.\n       * @param {import(\"../../structs/LinkedList.js\").default} list Polygon ring.\n       * @param {import(\"../../structs/RBush.js\").default=} opt_rtree Insert the segment into the R-Tree.\n       * @return {PolygonSegment} segment.\n       */\n\n\n      WebGLPolygonReplay.prototype.insertItem_ = function insertItem_(p0, p1, list, opt_rtree) {\n        var seg = {\n          p0: p0,\n          p1: p1\n        };\n        list.insertItem(seg);\n\n        if (opt_rtree) {\n          opt_rtree.insert([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)], seg);\n        }\n\n        return seg;\n      };\n      /**\n        * @private\n        * @param {PolygonSegment} s0 Segment before the remove candidate.\n        * @param {PolygonSegment} s1 Remove candidate segment.\n        * @param {import(\"../../structs/LinkedList.js\").default} list Polygon ring.\n        * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n        */\n\n\n      WebGLPolygonReplay.prototype.removeItem_ = function removeItem_(s0, s1, list, rtree) {\n        if (list.getCurrItem() === s1) {\n          list.removeItem();\n          s0.p1 = s1.p1;\n          rtree.remove(s1);\n          rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);\n        }\n      };\n      /**\n       * @private\n       * @param {PolygonVertex} p0 First point.\n       * @param {PolygonVertex} p1 Second point.\n       * @param {PolygonVertex} p2 Third point.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @param {boolean=} opt_reflex Only include reflex points.\n       * @return {Array<PolygonVertex>} Points in the triangle.\n       */\n\n\n      WebGLPolygonReplay.prototype.getPointsInTriangle_ = function getPointsInTriangle_(p0, p1, p2, rtree, opt_reflex) {\n        var result = [];\n        var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y), Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y)]);\n\n        for (var i = 0, ii = segmentsInExtent.length; i < ii; ++i) {\n          for (var j in segmentsInExtent[i]) {\n            var p = segmentsInExtent[i][j];\n\n            if (typeof p === 'object' && (!opt_reflex || p.reflex)) {\n              if ((p.x !== p0.x || p.y !== p0.y) && (p.x !== p1.x || p.y !== p1.y) && (p.x !== p2.x || p.y !== p2.y) && result.indexOf(p) === -1 && linearRingContainsXY([p0.x, p0.y, p1.x, p1.y, p2.x, p2.y], 0, 6, 2, p.x, p.y)) {\n                result.push(p);\n              }\n            }\n          }\n        }\n\n        return result;\n      };\n      /**\n       * @private\n       * @param {PolygonSegment} segment Segment.\n       * @param {import(\"../../structs/RBush.js\").default} rtree R-Tree of the polygon.\n       * @param {boolean=} opt_touch Touching segments should be considered an intersection.\n       * @return {Array<PolygonSegment>} Intersecting segments.\n       */\n\n\n      WebGLPolygonReplay.prototype.getIntersections_ = function getIntersections_(segment, rtree, opt_touch) {\n        var p0 = segment.p0;\n        var p1 = segment.p1;\n        var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);\n        var result = [];\n\n        for (var i = 0, ii = segmentsInExtent.length; i < ii; ++i) {\n          var currSeg = segmentsInExtent[i];\n\n          if (segment !== currSeg && (opt_touch || currSeg.p0 !== p1 || currSeg.p1 !== p0) && this.calculateIntersection_(p0, p1, currSeg.p0, currSeg.p1, opt_touch)) {\n            result.push(currSeg);\n          }\n        }\n\n        return result;\n      };\n      /**\n       * Line intersection algorithm by Paul Bourke.\n       * See http://paulbourke.net/geometry/pointlineplane/.\n       *\n       * @private\n       * @param {PolygonVertex} p0 First point.\n       * @param {PolygonVertex} p1 Second point.\n       * @param {PolygonVertex} p2 Third point.\n       * @param {PolygonVertex} p3 Fourth point.\n       * @param {boolean=} opt_touch Touching segments should be considered an intersection.\n       * @return {Array<number>|undefined} Intersection coordinates.\n       */\n\n\n      WebGLPolygonReplay.prototype.calculateIntersection_ = function calculateIntersection_(p0, p1, p2, p3, opt_touch) {\n        var denom = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y);\n\n        if (denom !== 0) {\n          var ua = ((p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x)) / denom;\n          var ub = ((p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x)) / denom;\n\n          if (!opt_touch && ua > EPSILON && ua < 1 - EPSILON && ub > EPSILON && ub < 1 - EPSILON || opt_touch && ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return [p0.x + ua * (p1.x - p0.x), p0.y + ua * (p1.y - p0.y)];\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @private\n       * @param {PolygonVertex} p0 Point before the start of the diagonal.\n       * @param {PolygonVertex} p1 Start point of the diagonal.\n       * @param {PolygonVertex} p2 Ear candidate.\n       * @param {PolygonVertex} p3 End point of the diagonal.\n       * @param {PolygonVertex} p4 Point after the end of the diagonal.\n       * @return {boolean} Diagonal is inside the polygon.\n       */\n\n\n      WebGLPolygonReplay.prototype.diagonalIsInside_ = function diagonalIsInside_(p0, p1, p2, p3, p4) {\n        if (p1.reflex === undefined || p3.reflex === undefined) {\n          return false;\n        }\n\n        var p1IsLeftOf = (p2.x - p3.x) * (p1.y - p3.y) > (p2.y - p3.y) * (p1.x - p3.x);\n        var p1IsRightOf = (p4.x - p3.x) * (p1.y - p3.y) < (p4.y - p3.y) * (p1.x - p3.x);\n        var p3IsLeftOf = (p0.x - p1.x) * (p3.y - p1.y) > (p0.y - p1.y) * (p3.x - p1.x);\n        var p3IsRightOf = (p2.x - p1.x) * (p3.y - p1.y) < (p2.y - p1.y) * (p3.x - p1.x);\n        var p1InCone = p3.reflex ? p1IsRightOf || p1IsLeftOf : p1IsRightOf && p1IsLeftOf;\n        var p3InCone = p1.reflex ? p3IsRightOf || p3IsLeftOf : p3IsRightOf && p3IsLeftOf;\n        return p1InCone && p3InCone;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {\n        var endss = multiPolygonGeometry.getEndss();\n        var stride = multiPolygonGeometry.getStride();\n        var currIndex = this.indices.length;\n        var currLineIndex = this.lineStringReplay.getCurrentIndex();\n        var flatCoordinates = multiPolygonGeometry.getFlatCoordinates();\n        var i, ii, j, jj;\n        var start = 0;\n\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          var ends = endss[i];\n\n          if (ends.length > 0) {\n            var outerRing = translate(flatCoordinates, start, ends[0], stride, -this.origin[0], -this.origin[1]);\n\n            if (outerRing.length) {\n              var holes = [];\n              var holeFlatCoords = void 0;\n\n              for (j = 1, jj = ends.length; j < jj; ++j) {\n                if (ends[j] !== ends[j - 1]) {\n                  holeFlatCoords = translate(flatCoordinates, ends[j - 1], ends[j], stride, -this.origin[0], -this.origin[1]);\n                  holes.push(holeFlatCoords);\n                }\n              }\n\n              this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);\n              this.drawCoordinates_(outerRing, holes, stride);\n            }\n          }\n\n          start = ends[ends.length - 1];\n        }\n\n        if (this.indices.length > currIndex) {\n          this.startIndices.push(currIndex);\n          this.startIndicesFeature.push(feature);\n\n          if (this.state_.changed) {\n            this.styleIndices_.push(currIndex);\n            this.state_.changed = false;\n          }\n        }\n\n        if (this.lineStringReplay.getCurrentIndex() > currLineIndex) {\n          this.lineStringReplay.setPolygonStyle(feature, currLineIndex);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {\n        var ends = polygonGeometry.getEnds();\n        var stride = polygonGeometry.getStride();\n\n        if (ends.length > 0) {\n          var flatCoordinates = polygonGeometry.getFlatCoordinates().map(Number);\n          var outerRing = translate(flatCoordinates, 0, ends[0], stride, -this.origin[0], -this.origin[1]);\n\n          if (outerRing.length) {\n            var holes = [];\n            var i, ii, holeFlatCoords;\n\n            for (i = 1, ii = ends.length; i < ii; ++i) {\n              if (ends[i] !== ends[i - 1]) {\n                holeFlatCoords = translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);\n                holes.push(holeFlatCoords);\n              }\n            }\n\n            this.startIndices.push(this.indices.length);\n            this.startIndicesFeature.push(feature);\n\n            if (this.state_.changed) {\n              this.styleIndices_.push(this.indices.length);\n              this.state_.changed = false;\n            }\n\n            this.lineStringReplay.setPolygonStyle(feature);\n            this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);\n            this.drawCoordinates_(outerRing, holes, stride);\n          }\n        }\n      };\n      /**\n       * @inheritDoc\n       **/\n\n\n      WebGLPolygonReplay.prototype.finish = function finish(context) {\n        // create, bind, and populate the vertices buffer\n        this.verticesBuffer = new WebGLBuffer(this.vertices); // create, bind, and populate the indices buffer\n\n        this.indicesBuffer = new WebGLBuffer(this.indices);\n        this.startIndices.push(this.indices.length);\n        this.lineStringReplay.finish(context); //Clean up, if there is nothing to draw\n\n        if (this.styleIndices_.length === 0 && this.styles_.length > 0) {\n          this.styles_ = [];\n        }\n\n        this.vertices = null;\n        this.indices = null;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.getDeleteResourcesFunction = function getDeleteResourcesFunction(context) {\n        var verticesBuffer = this.verticesBuffer;\n        var indicesBuffer = this.indicesBuffer;\n        var lineDeleter = this.lineStringReplay.getDeleteResourcesFunction(context);\n        return function () {\n          context.deleteBuffer(verticesBuffer);\n          context.deleteBuffer(indicesBuffer);\n          lineDeleter();\n        };\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.setUpProgram = function setUpProgram(gl, context, size, pixelRatio) {\n        // get the program\n        var program = context.getProgram(fragment$3, vertex$3); // get the locations\n\n        var locations;\n\n        if (!this.defaultLocations_) {\n          locations = new Locations$3(gl, program);\n          this.defaultLocations_ = locations;\n        } else {\n          locations = this.defaultLocations_;\n        }\n\n        context.useProgram(program); // enable the vertex attrib arrays\n\n        gl.enableVertexAttribArray(locations.a_position);\n        gl.vertexAttribPointer(locations.a_position, 2, FLOAT, false, 8, 0);\n        return locations;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.shutDownProgram = function shutDownProgram(gl, locations) {\n        gl.disableVertexAttribArray(locations.a_position);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.drawReplay = function drawReplay(gl, context, skippedFeaturesHash, hitDetection) {\n        //Save GL parameters.\n        var tmpDepthFunc =\n        /** @type {number} */\n        gl.getParameter(gl.DEPTH_FUNC);\n        var tmpDepthMask =\n        /** @type {boolean} */\n        gl.getParameter(gl.DEPTH_WRITEMASK);\n\n        if (!hitDetection) {\n          gl.enable(gl.DEPTH_TEST);\n          gl.depthMask(true);\n          gl.depthFunc(gl.NOTEQUAL);\n        }\n\n        if (!isEmpty(skippedFeaturesHash)) {\n          this.drawReplaySkipping_(gl, context, skippedFeaturesHash);\n        } else {\n          //Draw by style groups to minimize drawElements() calls.\n          var i, start, end, nextStyle;\n          end = this.startIndices[this.startIndices.length - 1];\n\n          for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n            start = this.styleIndices_[i];\n            nextStyle = this.styles_[i];\n            this.setFillStyle_(gl, nextStyle);\n            this.drawElements(gl, context, start, end);\n            end = start;\n          }\n        }\n\n        if (!hitDetection) {\n          gl.disable(gl.DEPTH_TEST);\n          gl.clear(gl.DEPTH_BUFFER_BIT); //Restore GL parameters.\n\n          gl.depthMask(tmpDepthMask);\n          gl.depthFunc(tmpDepthFunc);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.drawHitDetectionReplayOneByOne = function drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {\n        var i, start, end, nextStyle, groupStart, feature, featureIndex;\n        featureIndex = this.startIndices.length - 2;\n        end = this.startIndices[featureIndex + 1];\n\n        for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n          nextStyle = this.styles_[i];\n          this.setFillStyle_(gl, nextStyle);\n          groupStart = this.styleIndices_[i];\n\n          while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n            start = this.startIndices[featureIndex];\n            feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || intersects(\n            /** @type {Array<number>} */\n            opt_hitExtent, feature.getGeometry().getExtent()))) {\n              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n              this.drawElements(gl, context, start, end);\n              var result = featureCallback(feature);\n\n              if (result) {\n                return result;\n              }\n            }\n\n            featureIndex--;\n            end = start;\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @private\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {Object} skippedFeaturesHash Ids of features to skip.\n       */\n\n\n      WebGLPolygonReplay.prototype.drawReplaySkipping_ = function drawReplaySkipping_(gl, context, skippedFeaturesHash) {\n        var i, start, end, nextStyle, groupStart, feature, featureIndex, featureStart;\n        featureIndex = this.startIndices.length - 2;\n        end = start = this.startIndices[featureIndex + 1];\n\n        for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n          nextStyle = this.styles_[i];\n          this.setFillStyle_(gl, nextStyle);\n          groupStart = this.styleIndices_[i];\n\n          while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n            featureStart = this.startIndices[featureIndex];\n            feature = this.startIndicesFeature[featureIndex];\n\n            if (skippedFeaturesHash[getUid(feature)]) {\n              if (start !== end) {\n                this.drawElements(gl, context, start, end);\n                gl.clear(gl.DEPTH_BUFFER_BIT);\n              }\n\n              end = featureStart;\n            }\n\n            featureIndex--;\n            start = featureStart;\n          }\n\n          if (start !== end) {\n            this.drawElements(gl, context, start, end);\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n          }\n\n          start = end = groupStart;\n        }\n      };\n      /**\n       * @private\n       * @param {WebGLRenderingContext} gl gl.\n       * @param {Array<number>} color Color.\n       */\n\n\n      WebGLPolygonReplay.prototype.setFillStyle_ = function setFillStyle_(gl, color) {\n        gl.uniform4fv(this.defaultLocations_.u_color, color);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLPolygonReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n        var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];\n\n        if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {\n          fillStyleColor = asArray(fillStyleColor).map(function (c, i) {\n            return i != 3 ? c / 255 : c;\n          }) || DEFAULT_FILLSTYLE;\n        } else {\n          fillStyleColor = DEFAULT_FILLSTYLE;\n        }\n\n        if (!this.state_.fillColor || !equals(fillStyleColor, this.state_.fillColor)) {\n          this.state_.fillColor = fillStyleColor;\n          this.state_.changed = true;\n          this.styles_.push(fillStyleColor);\n        } //Provide a null stroke style, if no strokeStyle is provided. Required for the draw interaction to work.\n\n\n        if (strokeStyle) {\n          this.lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        } else {\n          var nullStrokeStyle = new Stroke({\n            color: [0, 0, 0, 0],\n            width: 0\n          });\n          this.lineStringReplay.setFillStrokeStyle(null, nullStrokeStyle);\n        }\n      };\n\n      return WebGLPolygonReplay;\n    }(WebGLReplay);\n    /**\n     * @module ol/style/Atlas\n     */\n\n    /**\n     * @typedef {Object} AtlasBlock\n     * @property {number} x\n     * @property {number} y\n     * @property {number} width\n     * @property {number} height\n     */\n\n    /**\n     * Provides information for an image inside an atlas.\n     * `offsetX` and `offsetY` are the position of the image inside the atlas image `image`.\n     * @typedef {Object} AtlasInfo\n     * @property {number} offsetX\n     * @property {number} offsetY\n     * @property {HTMLCanvasElement} image\n     */\n\n    /**\n     * @classesc\n     * This class facilitates the creation of image atlases.\n     *\n     * Images added to an atlas will be rendered onto a single\n     * atlas canvas. The distribution of images on the canvas is\n     * managed with the bin packing algorithm described in:\n     * http://www.blackpawn.com/texts/lightmaps/\n     *\n     * @param {number} size The size in pixels of the sprite image.\n     * @param {number} space The space in pixels between images.\n     *    Because texture coordinates are float values, the edges of\n     *    images might not be completely correct (in a way that the\n     *    edges overlap when being rendered). To avoid this we add a\n     *    padding around each image.\n     */\n\n\n    var Atlas = function Atlas(size, space) {\n      /**\n       * @private\n       * @type {number}\n       */\n      this.space_ = space;\n      /**\n       * @private\n       * @type {Array<AtlasBlock>}\n       */\n\n      this.emptyBlocks_ = [{\n        x: 0,\n        y: 0,\n        width: size,\n        height: size\n      }];\n      /**\n       * @private\n       * @type {Object<string, AtlasInfo>}\n       */\n\n      this.entries_ = {};\n      /**\n       * @private\n       * @type {CanvasRenderingContext2D}\n       */\n\n      this.context_ = createCanvasContext2D(size, size);\n      /**\n       * @private\n       * @type {HTMLCanvasElement}\n       */\n\n      this.canvas_ = this.context_.canvas;\n    };\n    /**\n     * @param {string} id The identifier of the entry to check.\n     * @return {?AtlasInfo} The atlas info.\n     */\n\n\n    Atlas.prototype.get = function get(id) {\n      return this.entries_[id] || null;\n    };\n    /**\n     * @param {string} id The identifier of the entry to add.\n     * @param {number} width The width.\n     * @param {number} height The height.\n     * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n     *  Called to render the new image onto an atlas image.\n     * @param {Object=} opt_this Value to use as `this` when executing\n     *  `renderCallback`.\n     * @return {?AtlasInfo} The position and atlas image for the entry.\n     */\n\n\n    Atlas.prototype.add = function add(id, width, height, renderCallback, opt_this) {\n      for (var i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n        var block = this.emptyBlocks_[i];\n\n        if (block.width >= width + this.space_ && block.height >= height + this.space_) {\n          // we found a block that is big enough for our entry\n          var entry = {\n            offsetX: block.x + this.space_,\n            offsetY: block.y + this.space_,\n            image: this.canvas_\n          };\n          this.entries_[id] = entry; // render the image on the atlas image\n\n          renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_); // split the block after the insertion, either horizontally or vertically\n\n          this.split_(i, block, width + this.space_, height + this.space_);\n          return entry;\n        }\n      } // there is no space for the new entry in this atlas\n\n\n      return null;\n    };\n    /**\n     * @private\n     * @param {number} index The index of the block.\n     * @param {AtlasBlock} block The block to split.\n     * @param {number} width The width of the entry to insert.\n     * @param {number} height The height of the entry to insert.\n     */\n\n\n    Atlas.prototype.split_ = function split_(index, block, width, height) {\n      var deltaWidth = block.width - width;\n      var deltaHeight = block.height - height;\n      /** @type {AtlasBlock} */\n\n      var newBlock1;\n      /** @type {AtlasBlock} */\n\n      var newBlock2;\n\n      if (deltaWidth > deltaHeight) {\n        // split vertically\n        // block right of the inserted entry\n        newBlock1 = {\n          x: block.x + width,\n          y: block.y,\n          width: block.width - width,\n          height: block.height\n        }; // block below the inserted entry\n\n        newBlock2 = {\n          x: block.x,\n          y: block.y + height,\n          width: width,\n          height: block.height - height\n        };\n        this.updateBlocks_(index, newBlock1, newBlock2);\n      } else {\n        // split horizontally\n        // block right of the inserted entry\n        newBlock1 = {\n          x: block.x + width,\n          y: block.y,\n          width: block.width - width,\n          height: height\n        }; // block below the inserted entry\n\n        newBlock2 = {\n          x: block.x,\n          y: block.y + height,\n          width: block.width,\n          height: block.height - height\n        };\n        this.updateBlocks_(index, newBlock1, newBlock2);\n      }\n    };\n    /**\n     * Remove the old block and insert new blocks at the same array position.\n     * The new blocks are inserted at the same position, so that splitted\n     * blocks (that are potentially smaller) are filled first.\n     * @private\n     * @param {number} index The index of the block to remove.\n     * @param {AtlasBlock} newBlock1 The 1st block to add.\n     * @param {AtlasBlock} newBlock2 The 2nd block to add.\n     */\n\n\n    Atlas.prototype.updateBlocks_ = function updateBlocks_(index, newBlock1, newBlock2) {\n      var args =\n      /** @type {Array<*>} */\n      [index, 1];\n\n      if (newBlock1.width > 0 && newBlock1.height > 0) {\n        args.push(newBlock1);\n      }\n\n      if (newBlock2.width > 0 && newBlock2.height > 0) {\n        args.push(newBlock2);\n      }\n\n      this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n    };\n    /**\n     * @module ol/style/AtlasManager\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [initialSize=256] The size in pixels of the first atlas image.\n     * @property {number} [maxSize] The maximum size in pixels of atlas images. Default is\n     * `webgl/MAX_TEXTURE_SIZE` or 2048 if WebGL is not supported.\n     * @property {number} [space=1] The space in pixels between images.\n     */\n\n    /**\n     * Provides information for an image inside an atlas manager.\n     * `offsetX` and `offsetY` is the position of the image inside\n     * the atlas image `image` and the position of the hit-detection image\n     * inside the hit-detection atlas image `hitImage`.\n     * @typedef {Object} AtlasManagerInfo\n     * @property {number} offsetX\n     * @property {number} offsetY\n     * @property {HTMLCanvasElement} image\n     * @property {HTMLCanvasElement} hitImage\n     */\n\n    /**\n     * The size in pixels of the first atlas image.\n     * @type {number}\n     */\n\n\n    var INITIAL_ATLAS_SIZE = 256;\n    /**\n     * @classdesc\n     * Manages the creation of image atlases.\n     *\n     * Images added to this manager will be inserted into an atlas, which\n     * will be used for rendering.\n     * The `size` given in the constructor is the size for the first\n     * atlas. After that, when new atlases are created, they will have\n     * twice the size as the latest atlas (until `maxSize` is reached).\n     *\n     * If an application uses many images or very large images, it is recommended\n     * to set a higher `size` value to avoid the creation of too many atlases.\n     * @api\n     */\n\n    var AtlasManager = function AtlasManager(opt_options) {\n      var options = opt_options || {};\n      /**\n       * The size in pixels of the latest atlas image.\n       * @private\n       * @type {number}\n       */\n\n      this.currentSize_ = options.initialSize !== undefined ? options.initialSize : INITIAL_ATLAS_SIZE;\n      /**\n       * The maximum size in pixels of atlas images.\n       * @private\n       * @type {number}\n       */\n\n      this.maxSize_ = options.maxSize !== undefined ? options.maxSize : MAX_TEXTURE_SIZE !== undefined ? MAX_TEXTURE_SIZE : 2048;\n      /**\n       * The size in pixels between images.\n       * @private\n       * @type {number}\n       */\n\n      this.space_ = options.space !== undefined ? options.space : 1;\n      /**\n       * @private\n       * @type {Array<import(\"./Atlas.js\").default>}\n       */\n\n      this.atlases_ = [new Atlas(this.currentSize_, this.space_)];\n      /**\n       * The size in pixels of the latest atlas image for hit-detection images.\n       * @private\n       * @type {number}\n       */\n\n      this.currentHitSize_ = this.currentSize_;\n      /**\n       * @private\n       * @type {Array<import(\"./Atlas.js\").default>}\n       */\n\n      this.hitAtlases_ = [new Atlas(this.currentHitSize_, this.space_)];\n    };\n    /**\n     * @param {string} id The identifier of the entry to check.\n     * @return {?AtlasManagerInfo} The position and atlas image for the\n     *  entry, or `null` if the entry is not part of the atlas manager.\n     */\n\n\n    AtlasManager.prototype.getInfo = function getInfo(id) {\n      /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n      var info = this.getInfo_(this.atlases_, id);\n\n      if (!info) {\n        return null;\n      }\n\n      var hitInfo =\n      /** @type {import(\"./Atlas.js\").AtlasInfo} */\n      this.getInfo_(this.hitAtlases_, id);\n      return this.mergeInfos_(info, hitInfo);\n    };\n    /**\n     * @private\n     * @param {Array<import(\"./Atlas.js\").default>} atlases The atlases to search.\n     * @param {string} id The identifier of the entry to check.\n     * @return {?import(\"./Atlas.js\").AtlasInfo} The position and atlas image for the entry,\n     *  or `null` if the entry is not part of the atlases.\n     */\n\n\n    AtlasManager.prototype.getInfo_ = function getInfo_(atlases, id) {\n      for (var i = 0, ii = atlases.length; i < ii; ++i) {\n        var atlas = atlases[i];\n        var info = atlas.get(id);\n\n        if (info) {\n          return info;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * @private\n     * @param {import(\"./Atlas.js\").AtlasInfo} info The info for the real image.\n     * @param {import(\"./Atlas.js\").AtlasInfo} hitInfo The info for the hit-detection\n     *  image.\n     * @return {?AtlasManagerInfo} The position and atlas image for the\n     *  entry, or `null` if the entry is not part of the atlases.\n     */\n\n\n    AtlasManager.prototype.mergeInfos_ = function mergeInfos_(info, hitInfo) {\n      return (\n        /** @type {AtlasManagerInfo} */\n        {\n          offsetX: info.offsetX,\n          offsetY: info.offsetY,\n          image: info.image,\n          hitImage: hitInfo.image\n        }\n      );\n    };\n    /**\n     * Add an image to the atlas manager.\n     *\n     * If an entry for the given id already exists, the entry will\n     * be overridden (but the space on the atlas graphic will not be freed).\n     *\n     * If `renderHitCallback` is provided, the image (or the hit-detection version\n     * of the image) will be rendered into a separate hit-detection atlas image.\n     *\n     * @param {string} id The identifier of the entry to add.\n     * @param {number} width The width.\n     * @param {number} height The height.\n     * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n     *  Called to render the new image onto an atlas image.\n     * @param {function(CanvasRenderingContext2D, number, number)=} opt_renderHitCallback Called to render a hit-detection image onto a hit\n     *  detection atlas image.\n     * @param {Object=} opt_this Value to use as `this` when executing\n     *  `renderCallback` and `renderHitCallback`.\n     * @return {?AtlasManagerInfo}The position and atlas image for the\n     *  entry, or `null` if the image is too big.\n     */\n\n\n    AtlasManager.prototype.add = function add(id, width, height, renderCallback, opt_renderHitCallback, opt_this) {\n      if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {\n        return null;\n      }\n      /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n\n\n      var info = this.add_(false, id, width, height, renderCallback, opt_this);\n\n      if (!info) {\n        return null;\n      } // even if no hit-detection entry is requested, we insert a fake entry into\n      // the hit-detection atlas, to make sure that the offset is the same for\n      // the original image and the hit-detection image.\n\n\n      var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : VOID;\n      var hitInfo =\n      /** @type {import(\"./Atlas.js\").AtlasInfo} */\n      this.add_(true, id, width, height, renderHitCallback, opt_this);\n      return this.mergeInfos_(info, hitInfo);\n    };\n    /**\n     * @private\n     * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n     * @param {string} id The identifier of the entry to add.\n     * @param {number} width The width.\n     * @param {number} height The height.\n     * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n     *  Called to render the new image onto an atlas image.\n     * @param {Object=} opt_this Value to use as `this` when executing\n     *  `renderCallback` and `renderHitCallback`.\n     * @return {?import(\"./Atlas.js\").AtlasInfo}The position and atlas image for the entry,\n     *  or `null` if the image is too big.\n     */\n\n\n    AtlasManager.prototype.add_ = function add_(isHitAtlas, id, width, height, renderCallback, opt_this) {\n      var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;\n      var atlas, info, i, ii;\n\n      for (i = 0, ii = atlases.length; i < ii; ++i) {\n        atlas = atlases[i];\n        info = atlas.add(id, width, height, renderCallback, opt_this);\n\n        if (info) {\n          return info;\n        } else if (!info && i === ii - 1) {\n          // the entry could not be added to one of the existing atlases,\n          // create a new atlas that is twice as big and try to add to this one.\n          var size = void 0;\n\n          if (isHitAtlas) {\n            size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n            this.currentHitSize_ = size;\n          } else {\n            size = Math.min(this.currentSize_ * 2, this.maxSize_);\n            this.currentSize_ = size;\n          }\n\n          atlas = new Atlas(size, this.space_);\n          atlases.push(atlas); // run the loop another time\n\n          ++ii;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * @module ol/render/webgl/TextReplay\n     */\n\n    /**\n     * @typedef {Object} GlyphAtlas\n     * @property {import(\"../../style/AtlasManager.js\").default} atlas\n     * @property {Object<string, number>} width\n     * @property {number} height\n     */\n\n\n    var WebGLTextReplay =\n    /*@__PURE__*/\n    function (WebGLTextureReplay$$1) {\n      function WebGLTextReplay(tolerance, maxExtent) {\n        WebGLTextureReplay$$1.call(this, tolerance, maxExtent);\n        /**\n         * @private\n         * @type {Array<HTMLCanvasElement>}\n         */\n\n        this.images_ = [];\n        /**\n         * @private\n         * @type {Array<WebGLTexture>}\n         */\n\n        this.textures_ = [];\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.measureCanvas_ = createCanvasContext2D(0, 0).canvas;\n        /**\n         * @private\n         * @type {{strokeColor: (import(\"../../colorlike.js\").ColorLike|null),\n         *         lineCap: (string|undefined),\n         *         lineDash: Array<number>,\n         *         lineDashOffset: (number|undefined),\n         *         lineJoin: (string|undefined),\n         *         lineWidth: number,\n         *         miterLimit: (number|undefined),\n         *         fillColor: (import(\"../../colorlike.js\").ColorLike|null),\n         *         font: (string|undefined),\n         *         scale: (number|undefined)}}\n         */\n\n        this.state_ = {\n          strokeColor: null,\n          lineCap: undefined,\n          lineDash: null,\n          lineDashOffset: undefined,\n          lineJoin: undefined,\n          lineWidth: 0,\n          miterLimit: undefined,\n          fillColor: null,\n          font: undefined,\n          scale: undefined\n        };\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.text_ = '';\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.textAlign_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.textBaseline_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.offsetX_ = undefined;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.offsetY_ = undefined;\n        /**\n         * @private\n         * @type {Object<string, GlyphAtlas>}\n         */\n\n        this.atlases_ = {};\n        /**\n         * @private\n         * @type {GlyphAtlas|undefined}\n         */\n\n        this.currAtlas_ = undefined;\n        this.scale = 1;\n        this.opacity = 1;\n      }\n\n      if (WebGLTextureReplay$$1) WebGLTextReplay.__proto__ = WebGLTextureReplay$$1;\n      WebGLTextReplay.prototype = Object.create(WebGLTextureReplay$$1 && WebGLTextureReplay$$1.prototype);\n      WebGLTextReplay.prototype.constructor = WebGLTextReplay;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLTextReplay.prototype.drawText = function drawText(geometry, feature) {\n        if (this.text_) {\n          var flatCoordinates = null;\n          var offset = 0;\n          var end = 2;\n          var stride = 2;\n\n          switch (geometry.getType()) {\n            case GeometryType.POINT:\n            case GeometryType.MULTI_POINT:\n              flatCoordinates = geometry.getFlatCoordinates();\n              end = flatCoordinates.length;\n              stride = geometry.getStride();\n              break;\n\n            case GeometryType.CIRCLE:\n              flatCoordinates =\n              /** @type {import(\"../../geom/Circle.js\").default} */\n              geometry.getCenter();\n              break;\n\n            case GeometryType.LINE_STRING:\n              flatCoordinates =\n              /** @type {import(\"../../geom/LineString.js\").default} */\n              geometry.getFlatMidpoint();\n              break;\n\n            case GeometryType.MULTI_LINE_STRING:\n              flatCoordinates =\n              /** @type {import(\"../../geom/MultiLineString.js\").default} */\n              geometry.getFlatMidpoints();\n              end = flatCoordinates.length;\n              break;\n\n            case GeometryType.POLYGON:\n              flatCoordinates =\n              /** @type {import(\"../../geom/Polygon.js\").default} */\n              geometry.getFlatInteriorPoint();\n              break;\n\n            case GeometryType.MULTI_POLYGON:\n              flatCoordinates =\n              /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n              geometry.getFlatInteriorPoints();\n              end = flatCoordinates.length;\n              break;\n\n            default:\n          }\n\n          this.startIndices.push(this.indices.length);\n          this.startIndicesFeature.push(feature);\n          var glyphAtlas = this.currAtlas_;\n          var lines = this.text_.split('\\n');\n          var textSize = this.getTextSize_(lines);\n          var i, ii, j, jj, currX, currY, charArr, charInfo;\n          var anchorX = Math.round(textSize[0] * this.textAlign_ - this.offsetX_);\n          var anchorY = Math.round(textSize[1] * this.textBaseline_ - this.offsetY_);\n          var lineWidth = this.state_.lineWidth / 2 * this.state_.scale;\n\n          for (i = 0, ii = lines.length; i < ii; ++i) {\n            currX = 0;\n            currY = glyphAtlas.height * i;\n            charArr = lines[i].split('');\n\n            for (j = 0, jj = charArr.length; j < jj; ++j) {\n              charInfo = glyphAtlas.atlas.getInfo(charArr[j]);\n\n              if (charInfo) {\n                var image = charInfo.image;\n                this.anchorX = anchorX - currX;\n                this.anchorY = anchorY - currY;\n                this.originX = j === 0 ? charInfo.offsetX - lineWidth : charInfo.offsetX;\n                this.originY = charInfo.offsetY;\n                this.height = glyphAtlas.height;\n                this.width = j === 0 || j === charArr.length - 1 ? glyphAtlas.width[charArr[j]] + lineWidth : glyphAtlas.width[charArr[j]];\n                this.imageHeight = image.height;\n                this.imageWidth = image.width;\n\n                if (this.images_.length === 0) {\n                  this.images_.push(image);\n                } else {\n                  var currentImage = this.images_[this.images_.length - 1];\n\n                  if (getUid(currentImage) != getUid(image)) {\n                    this.groupIndices.push(this.indices.length);\n                    this.images_.push(image);\n                  }\n                }\n\n                this.drawText_(flatCoordinates, offset, end, stride);\n              }\n\n              currX += this.width;\n            }\n          }\n        }\n      };\n      /**\n       * @private\n       * @param {Array<string>} lines Label to draw split to lines.\n       * @return {Array<number>} Size of the label in pixels.\n       */\n\n\n      WebGLTextReplay.prototype.getTextSize_ = function getTextSize_(lines) {\n        var self = this;\n        var glyphAtlas = this.currAtlas_;\n        var textHeight = lines.length * glyphAtlas.height; //Split every line to an array of chars, sum up their width, and select the longest.\n\n        var textWidth = lines.map(function (str) {\n          var sum = 0;\n\n          for (var i = 0, ii = str.length; i < ii; ++i) {\n            var curr = str[i];\n\n            if (!glyphAtlas.width[curr]) {\n              self.addCharToAtlas_(curr);\n            }\n\n            sum += glyphAtlas.width[curr] ? glyphAtlas.width[curr] : 0;\n          }\n\n          return sum;\n        }).reduce(function (max, curr) {\n          return Math.max(max, curr);\n        });\n        return [textWidth, textHeight];\n      };\n      /**\n       * @private\n       * @param {Array<number>} flatCoordinates Flat coordinates.\n       * @param {number} offset Offset.\n       * @param {number} end End.\n       * @param {number} stride Stride.\n       */\n\n\n      WebGLTextReplay.prototype.drawText_ = function drawText_(flatCoordinates, offset, end, stride) {\n        for (var i = offset, ii = end; i < ii; i += stride) {\n          this.drawCoordinates(flatCoordinates, offset, end, stride);\n        }\n      };\n      /**\n       * @private\n       * @param {string} char Character.\n       */\n\n\n      WebGLTextReplay.prototype.addCharToAtlas_ = function addCharToAtlas_(_char2) {\n        if (_char2.length === 1) {\n          var glyphAtlas = this.currAtlas_;\n          var state = this.state_;\n          var mCtx = this.measureCanvas_.getContext('2d');\n          mCtx.font = state.font;\n          var width = Math.ceil(mCtx.measureText(_char2).width * state.scale);\n          var info = glyphAtlas.atlas.add(_char2, width, glyphAtlas.height, function (ctx, x, y) {\n            //Parameterize the canvas\n            ctx.font =\n            /** @type {string} */\n            state.font;\n            ctx.fillStyle = state.fillColor;\n            ctx.strokeStyle = state.strokeColor;\n            ctx.lineWidth = state.lineWidth;\n            ctx.lineCap =\n            /** @type {CanvasLineCap} */\n            state.lineCap;\n            ctx.lineJoin =\n            /** @type {CanvasLineJoin} */\n            state.lineJoin;\n            ctx.miterLimit =\n            /** @type {number} */\n            state.miterLimit;\n            ctx.textAlign = 'left';\n            ctx.textBaseline = 'top';\n\n            if (CANVAS_LINE_DASH && state.lineDash) {\n              //FIXME: use pixelRatio\n              ctx.setLineDash(state.lineDash);\n              ctx.lineDashOffset =\n              /** @type {number} */\n              state.lineDashOffset;\n            }\n\n            if (state.scale !== 1) {\n              //FIXME: use pixelRatio\n              ctx.setTransform(\n              /** @type {number} */\n              state.scale, 0, 0,\n              /** @type {number} */\n              state.scale, 0, 0);\n            } //Draw the character on the canvas\n\n\n            if (state.strokeColor) {\n              ctx.strokeText(_char2, x, y);\n            }\n\n            if (state.fillColor) {\n              ctx.fillText(_char2, x, y);\n            }\n          });\n\n          if (info) {\n            glyphAtlas.width[_char2] = width;\n          }\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextReplay.prototype.finish = function finish(context) {\n        var gl = context.getGL();\n        this.groupIndices.push(this.indices.length);\n        this.hitDetectionGroupIndices = this.groupIndices; // create, bind, and populate the vertices buffer\n\n        this.verticesBuffer = new WebGLBuffer(this.vertices); // create, bind, and populate the indices buffer\n\n        this.indicesBuffer = new WebGLBuffer(this.indices); // create textures\n\n        /** @type {Object<string, WebGLTexture>} */\n\n        var texturePerImage = {};\n        this.createTextures(this.textures_, this.images_, texturePerImage, gl);\n        this.state_ = {\n          strokeColor: null,\n          lineCap: undefined,\n          lineDash: null,\n          lineDashOffset: undefined,\n          lineJoin: undefined,\n          lineWidth: 0,\n          miterLimit: undefined,\n          fillColor: null,\n          font: undefined,\n          scale: undefined\n        };\n        this.text_ = '';\n        this.textAlign_ = undefined;\n        this.textBaseline_ = undefined;\n        this.offsetX_ = undefined;\n        this.offsetY_ = undefined;\n        this.images_ = null;\n        this.atlases_ = {};\n        this.currAtlas_ = undefined;\n        WebGLTextureReplay$$1.prototype.finish.call(this, context);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextReplay.prototype.setTextStyle = function setTextStyle(textStyle) {\n        var state = this.state_;\n        var textFillStyle = textStyle.getFill();\n        var textStrokeStyle = textStyle.getStroke();\n\n        if (!textStyle || !textStyle.getText() || !textFillStyle && !textStrokeStyle) {\n          this.text_ = '';\n        } else {\n          if (!textFillStyle) {\n            state.fillColor = null;\n          } else {\n            var textFillStyleColor = textFillStyle.getColor();\n            state.fillColor = asColorLike(textFillStyleColor ? textFillStyleColor : DEFAULT_FILLSTYLE);\n          }\n\n          if (!textStrokeStyle) {\n            state.strokeColor = null;\n            state.lineWidth = 0;\n          } else {\n            var textStrokeStyleColor = textStrokeStyle.getColor();\n            state.strokeColor = asColorLike(textStrokeStyleColor ? textStrokeStyleColor : DEFAULT_STROKESTYLE);\n            state.lineWidth = textStrokeStyle.getWidth() || DEFAULT_LINEWIDTH;\n            state.lineCap = textStrokeStyle.getLineCap() || DEFAULT_LINECAP;\n            state.lineDashOffset = textStrokeStyle.getLineDashOffset() || DEFAULT_LINEDASHOFFSET;\n            state.lineJoin = textStrokeStyle.getLineJoin() || DEFAULT_LINEJOIN;\n            state.miterLimit = textStrokeStyle.getMiterLimit() || DEFAULT_MITERLIMIT;\n            var lineDash = textStrokeStyle.getLineDash();\n            state.lineDash = lineDash ? lineDash.slice() : DEFAULT_LINEDASH;\n          }\n\n          state.font = textStyle.getFont() || DEFAULT_FONT;\n          state.scale = textStyle.getScale() || 1;\n          this.text_ =\n          /** @type {string} */\n          textStyle.getText();\n          var textAlign = TEXT_ALIGN[textStyle.getTextAlign()];\n          var textBaseline = TEXT_ALIGN[textStyle.getTextBaseline()];\n          this.textAlign_ = textAlign === undefined ? DEFAULT_TEXTALIGN : textAlign;\n          this.textBaseline_ = textBaseline === undefined ? DEFAULT_TEXTBASELINE : textBaseline;\n          this.offsetX_ = textStyle.getOffsetX() || 0;\n          this.offsetY_ = textStyle.getOffsetY() || 0;\n          this.rotateWithView = !!textStyle.getRotateWithView();\n          this.rotation = textStyle.getRotation() || 0;\n          this.currAtlas_ = this.getAtlas_(state);\n        }\n      };\n      /**\n       * @private\n       * @param {Object} state Font attributes.\n       * @return {GlyphAtlas} Glyph atlas.\n       */\n\n\n      WebGLTextReplay.prototype.getAtlas_ = function getAtlas_(state) {\n        var params = [];\n\n        for (var i in state) {\n          if (state[i] || state[i] === 0) {\n            if (Array.isArray(state[i])) {\n              params = params.concat(state[i]);\n            } else {\n              params.push(state[i]);\n            }\n          }\n        }\n\n        var hash = this.calculateHash_(params);\n\n        if (!this.atlases_[hash]) {\n          var mCtx = this.measureCanvas_.getContext('2d');\n          mCtx.font = state.font;\n          var height = Math.ceil((mCtx.measureText('M').width * 1.5 + state.lineWidth / 2) * state.scale);\n          this.atlases_[hash] = {\n            atlas: new AtlasManager({\n              space: state.lineWidth + 1\n            }),\n            width: {},\n            height: height\n          };\n        }\n\n        return this.atlases_[hash];\n      };\n      /**\n       * @private\n       * @param {Array<string|number>} params Array of parameters.\n       * @return {string} Hash string.\n       */\n\n\n      WebGLTextReplay.prototype.calculateHash_ = function calculateHash_(params) {\n        //TODO: Create a more performant, reliable, general hash function.\n        var hash = '';\n\n        for (var i = 0, ii = params.length; i < ii; ++i) {\n          hash += params[i];\n        }\n\n        return hash;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextReplay.prototype.getTextures = function getTextures(opt_all) {\n        return this.textures_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTextReplay.prototype.getHitDetectionTextures = function getHitDetectionTextures() {\n        return this.textures_;\n      };\n\n      return WebGLTextReplay;\n    }(WebGLTextureReplay);\n    /**\n     * @module ol/render/webgl/ReplayGroup\n     */\n\n    /**\n     * @type {Array<number>}\n     */\n\n\n    var HIT_DETECTION_SIZE = [1, 1];\n    /**\n     * @type {Object<import(\"../ReplayType.js\").default, typeof import(\"./Replay.js\").default>}\n     */\n\n    var BATCH_CONSTRUCTORS$1 = {\n      'Circle': WebGLCircleReplay,\n      'Image': WebGLImageReplay,\n      'LineString': WebGLLineStringReplay,\n      'Polygon': WebGLPolygonReplay,\n      'Text': WebGLTextReplay\n    };\n\n    var WebGLReplayGroup =\n    /*@__PURE__*/\n    function (ReplayGroup$$1) {\n      function WebGLReplayGroup(tolerance, maxExtent, opt_renderBuffer) {\n        ReplayGroup$$1.call(this);\n        /**\n         * @type {import(\"../../extent.js\").Extent}\n         * @private\n         */\n\n        this.maxExtent_ = maxExtent;\n        /**\n         * @type {number}\n         * @private\n         */\n\n        this.tolerance_ = tolerance;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n\n        this.renderBuffer_ = opt_renderBuffer;\n        /**\n         * @private\n         * @type {!Object<string,\n         *        Object<import(\"../ReplayType.js\").default, import(\"./Replay.js\").default>>}\n         */\n\n        this.replaysByZIndex_ = {};\n      }\n\n      if (ReplayGroup$$1) WebGLReplayGroup.__proto__ = ReplayGroup$$1;\n      WebGLReplayGroup.prototype = Object.create(ReplayGroup$$1 && ReplayGroup$$1.prototype);\n      WebGLReplayGroup.prototype.constructor = WebGLReplayGroup;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n        return [];\n      };\n      /**\n       * @param {import(\"../../webgl/Context.js\").default} context WebGL context.\n       * @return {function()} Delete resources function.\n       */\n\n\n      WebGLReplayGroup.prototype.getDeleteResourcesFunction = function getDeleteResourcesFunction(context) {\n        var functions = [];\n        var zKey;\n\n        for (zKey in this.replaysByZIndex_) {\n          var replays = this.replaysByZIndex_[zKey];\n\n          for (var replayKey in replays) {\n            functions.push(replays[replayKey].getDeleteResourcesFunction(context));\n          }\n        }\n\n        return function () {\n          var arguments$1 = arguments;\n          var length = functions.length;\n          var result;\n\n          for (var i = 0; i < length; i++) {\n            result = functions[i].apply(this, arguments$1);\n          }\n\n          return result;\n        };\n      };\n      /**\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       */\n\n\n      WebGLReplayGroup.prototype.finish = function finish(context) {\n        var zKey;\n\n        for (zKey in this.replaysByZIndex_) {\n          var replays = this.replaysByZIndex_[zKey];\n\n          for (var replayKey in replays) {\n            replays[replayKey].finish(context);\n          }\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n        var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n        var replays = this.replaysByZIndex_[zIndexKey];\n\n        if (replays === undefined) {\n          replays = {};\n          this.replaysByZIndex_[zIndexKey] = replays;\n        }\n\n        var replay = replays[replayType];\n\n        if (replay === undefined) {\n          var Constructor = BATCH_CONSTRUCTORS$1[replayType];\n          replay = new Constructor(this.tolerance_, this.maxExtent_);\n          replays[replayType] = replay;\n        }\n\n        return replay;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLReplayGroup.prototype.isEmpty = function isEmpty$1$$1() {\n        return isEmpty(this.replaysByZIndex_);\n      };\n      /**\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n       * @param {number} resolution Resolution.\n       * @param {number} rotation Rotation.\n       * @param {import(\"../../size.js\").Size} size Size.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {number} opacity Global opacity.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       */\n\n\n      WebGLReplayGroup.prototype.replay = function replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {\n        /** @type {Array<number>} */\n        var zs = Object.keys(this.replaysByZIndex_).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        var i, ii, j, jj, replays, replay;\n\n        for (i = 0, ii = zs.length; i < ii; ++i) {\n          replays = this.replaysByZIndex_[zs[i].toString()];\n\n          for (j = 0, jj = ORDER.length; j < jj; ++j) {\n            replay = replays[ORDER[j]];\n\n            if (replay !== undefined) {\n              replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, undefined, false);\n            }\n          }\n        }\n      };\n      /**\n       * @private\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n       * @param {number} resolution Resolution.\n       * @param {number} rotation Rotation.\n       * @param {import(\"../../size.js\").Size} size Size.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {number} opacity Global opacity.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n       * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.\n       * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Hit extent: Only features intersecting\n       *  this extent are checked.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      WebGLReplayGroup.prototype.replayHitDetection_ = function replayHitDetection_(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {\n        /** @type {Array<number>} */\n        var zs = Object.keys(this.replaysByZIndex_).map(Number);\n        zs.sort(function (a, b) {\n          return b - a;\n        });\n        var i, ii, j, replays, replay, result;\n\n        for (i = 0, ii = zs.length; i < ii; ++i) {\n          replays = this.replaysByZIndex_[zs[i].toString()];\n\n          for (j = ORDER.length - 1; j >= 0; --j) {\n            replay = replays[ORDER[j]];\n\n            if (replay !== undefined) {\n              result = replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);\n\n              if (result) {\n                return result;\n              }\n            }\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n       * @param {number} resolution Resolution.\n       * @param {number} rotation Rotation.\n       * @param {import(\"../../size.js\").Size} size Size.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {number} opacity Global opacity.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} callback Feature callback.\n       * @return {T|undefined} Callback result.\n       * @template T\n       */\n\n\n      WebGLReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, callback) {\n        var gl = context.getGL();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());\n        /**\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        var hitExtent;\n\n        if (this.renderBuffer_ !== undefined) {\n          // build an extent around the coordinate, so that only features that\n          // intersect this extent are checked\n          hitExtent = buffer(createOrUpdateFromCoordinate(coordinate), resolution * this.renderBuffer_);\n        }\n\n        return this.replayHitDetection_(context, coordinate, resolution, rotation, HIT_DETECTION_SIZE, pixelRatio, opacity, skippedFeaturesHash,\n        /**\n         * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          var imageData = new Uint8Array(4);\n          gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n\n          if (imageData[3] > 0) {\n            var result = callback(feature);\n\n            if (result) {\n              return result;\n            }\n          }\n        }, true, hitExtent);\n      };\n      /**\n       * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n       * @param {number} resolution Resolution.\n       * @param {number} rotation Rotation.\n       * @param {import(\"../../size.js\").Size} size Size.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {number} opacity Global opacity.\n       * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n       * @return {boolean} Is there a feature at the given coordinate?\n       */\n\n\n      WebGLReplayGroup.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {\n        var gl = context.getGL();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());\n        var hasFeature = this.replayHitDetection_(context, coordinate, resolution, rotation, HIT_DETECTION_SIZE, pixelRatio, opacity, skippedFeaturesHash,\n        /**\n         * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n         * @return {boolean} Is there a feature?\n         */\n        function (feature) {\n          var imageData = new Uint8Array(4);\n          gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n          return imageData[3] > 0;\n        }, false);\n        return hasFeature !== undefined;\n      };\n\n      return WebGLReplayGroup;\n    }(ReplayGroup);\n    /**\n     * @module ol/render/webgl/Immediate\n     */\n\n\n    var WebGLImmediateRenderer =\n    /*@__PURE__*/\n    function (VectorContext$$1) {\n      function WebGLImmediateRenderer(context, center, resolution, rotation, size, extent, pixelRatio) {\n        VectorContext$$1.call(this);\n        /**\n         * @private\n         */\n\n        this.context_ = context;\n        /**\n         * @private\n         */\n\n        this.center_ = center;\n        /**\n         * @private\n         */\n\n        this.extent_ = extent;\n        /**\n         * @private\n         */\n\n        this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         */\n\n        this.size_ = size;\n        /**\n         * @private\n         */\n\n        this.rotation_ = rotation;\n        /**\n         * @private\n         */\n\n        this.resolution_ = resolution;\n        /**\n         * @private\n         * @type {import(\"../../style/Image.js\").default}\n         */\n\n        this.imageStyle_ = null;\n        /**\n         * @private\n         * @type {import(\"../../style/Fill.js\").default}\n         */\n\n        this.fillStyle_ = null;\n        /**\n         * @private\n         * @type {import(\"../../style/Stroke.js\").default}\n         */\n\n        this.strokeStyle_ = null;\n        /**\n         * @private\n         * @type {import(\"../../style/Text.js\").default}\n         */\n\n        this.textStyle_ = null;\n      }\n\n      if (VectorContext$$1) WebGLImmediateRenderer.__proto__ = VectorContext$$1;\n      WebGLImmediateRenderer.prototype = Object.create(VectorContext$$1 && VectorContext$$1.prototype);\n      WebGLImmediateRenderer.prototype.constructor = WebGLImmediateRenderer;\n      /**\n       * @param {import(\"./ReplayGroup.js\").default} replayGroup Replay group.\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n       * @private\n       */\n\n      WebGLImmediateRenderer.prototype.drawText_ = function drawText_(replayGroup, geometry) {\n        var context = this.context_;\n        var replay =\n        /** @type {import(\"./TextReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.TEXT);\n        replay.setTextStyle(this.textStyle_);\n        replay.drawText(geometry, null);\n        replay.finish(context); // default colors\n\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n      };\n      /**\n       * Set the rendering style.  Note that since this is an immediate rendering API,\n       * any `zIndex` on the provided style will be ignored.\n       *\n       * @param {import(\"../../style/Style.js\").default} style The rendering style.\n       * @override\n       * @api\n       */\n\n\n      WebGLImmediateRenderer.prototype.setStyle = function setStyle(style) {\n        this.setFillStrokeStyle(style.getFill(), style.getStroke());\n        this.setImageStyle(style.getImage());\n        this.setTextStyle(style.getText());\n      };\n      /**\n       * Render a geometry into the canvas.  Call\n       * {@link ol/render/webgl/Immediate#setStyle} first to set the rendering style.\n       *\n       * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry The geometry to render.\n       * @override\n       * @api\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawGeometry = function drawGeometry(geometry) {\n        var type = geometry.getType();\n\n        switch (type) {\n          case GeometryType.POINT:\n            this.drawPoint(\n            /** @type {import(\"../../geom/Point.js\").default} */\n            geometry, null);\n            break;\n\n          case GeometryType.LINE_STRING:\n            this.drawLineString(\n            /** @type {import(\"../../geom/LineString.js\").default} */\n            geometry, null);\n            break;\n\n          case GeometryType.POLYGON:\n            this.drawPolygon(\n            /** @type {import(\"../../geom/Polygon.js\").default} */\n            geometry, null);\n            break;\n\n          case GeometryType.MULTI_POINT:\n            this.drawMultiPoint(\n            /** @type {import(\"../../geom/MultiPoint.js\").default} */\n            geometry, null);\n            break;\n\n          case GeometryType.MULTI_LINE_STRING:\n            this.drawMultiLineString(\n            /** @type {import(\"../../geom/MultiLineString.js\").default} */\n            geometry, null);\n            break;\n\n          case GeometryType.MULTI_POLYGON:\n            this.drawMultiPolygon(\n            /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n            geometry, null);\n            break;\n\n          case GeometryType.GEOMETRY_COLLECTION:\n            this.drawGeometryCollection(\n            /** @type {import(\"../../geom/GeometryCollection.js\").default} */\n            geometry, null);\n            break;\n\n          case GeometryType.CIRCLE:\n            this.drawCircle(\n            /** @type {import(\"../../geom/Circle.js\").default} */\n            geometry, null);\n            break;\n\n          default: // pass\n\n        }\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawFeature = function drawFeature(feature, style) {\n        var geometry = style.getGeometryFunction()(feature);\n\n        if (!geometry || !intersects(this.extent_, geometry.getExtent())) {\n          return;\n        }\n\n        this.setStyle(style);\n        this.drawGeometry(geometry);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection(geometry, data) {\n        var geometries = geometry.getGeometriesArray();\n        var i, ii;\n\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          this.drawGeometry(geometries[i]);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawPoint = function drawPoint(geometry, data) {\n        var context = this.context_;\n        var replayGroup = new WebGLReplayGroup(1, this.extent_);\n        var replay =\n        /** @type {import(\"./ImageReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.IMAGE);\n        replay.setImageStyle(this.imageStyle_);\n        replay.drawPoint(geometry, data);\n        replay.finish(context); // default colors\n\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n\n        if (this.textStyle_) {\n          this.drawText_(replayGroup, geometry);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint(geometry, data) {\n        var context = this.context_;\n        var replayGroup = new WebGLReplayGroup(1, this.extent_);\n        var replay =\n        /** @type {import(\"./ImageReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.IMAGE);\n        replay.setImageStyle(this.imageStyle_);\n        replay.drawMultiPoint(geometry, data);\n        replay.finish(context);\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n\n        if (this.textStyle_) {\n          this.drawText_(replayGroup, geometry);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawLineString = function drawLineString(geometry, data) {\n        var context = this.context_;\n        var replayGroup = new WebGLReplayGroup(1, this.extent_);\n        var replay =\n        /** @type {import(\"./LineStringReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.LINE_STRING);\n        replay.setFillStrokeStyle(null, this.strokeStyle_);\n        replay.drawLineString(geometry, data);\n        replay.finish(context);\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n\n        if (this.textStyle_) {\n          this.drawText_(replayGroup, geometry);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString(geometry, data) {\n        var context = this.context_;\n        var replayGroup = new WebGLReplayGroup(1, this.extent_);\n        var replay =\n        /** @type {import(\"./LineStringReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.LINE_STRING);\n        replay.setFillStrokeStyle(null, this.strokeStyle_);\n        replay.drawMultiLineString(geometry, data);\n        replay.finish(context);\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n\n        if (this.textStyle_) {\n          this.drawText_(replayGroup, geometry);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawPolygon = function drawPolygon(geometry, data) {\n        var context = this.context_;\n        var replayGroup = new WebGLReplayGroup(1, this.extent_);\n        var replay =\n        /** @type {import(\"./PolygonReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.POLYGON);\n        replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);\n        replay.drawPolygon(geometry, data);\n        replay.finish(context);\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n\n        if (this.textStyle_) {\n          this.drawText_(replayGroup, geometry);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon(geometry, data) {\n        var context = this.context_;\n        var replayGroup = new WebGLReplayGroup(1, this.extent_);\n        var replay =\n        /** @type {import(\"./PolygonReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.POLYGON);\n        replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);\n        replay.drawMultiPolygon(geometry, data);\n        replay.finish(context);\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n\n        if (this.textStyle_) {\n          this.drawText_(replayGroup, geometry);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.drawCircle = function drawCircle(geometry, data) {\n        var context = this.context_;\n        var replayGroup = new WebGLReplayGroup(1, this.extent_);\n        var replay =\n        /** @type {import(\"./CircleReplay.js\").default} */\n        replayGroup.getReplay(0, ReplayType.CIRCLE);\n        replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);\n        replay.drawCircle(geometry, data);\n        replay.finish(context);\n        var opacity = 1;\n        /** @type {Object<string, boolean>} */\n\n        var skippedFeatures = {};\n        var featureCallback;\n        var oneByOne = false;\n        replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);\n        replay.getDeleteResourcesFunction(context)();\n\n        if (this.textStyle_) {\n          this.drawText_(replayGroup, geometry);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.setImageStyle = function setImageStyle(imageStyle) {\n        this.imageStyle_ = imageStyle;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n        this.fillStyle_ = fillStyle;\n        this.strokeStyle_ = strokeStyle;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImmediateRenderer.prototype.setTextStyle = function setTextStyle(textStyle) {\n        this.textStyle_ = textStyle;\n      };\n\n      return WebGLImmediateRenderer;\n    }(VectorContext);\n    /**\n     * @module ol/renderer/webgl/defaultmapshader\n     */\n\n\n    var fragment$4 = new WebGLFragment('precision mediump float;\\nvarying vec2 v_texCoord;\\n\\n\\nuniform float u_opacity;\\nuniform sampler2D u_texture;\\n\\nvoid main(void) {\\n  vec4 texColor = texture2D(u_texture, v_texCoord);\\n  gl_FragColor.rgb = texColor.rgb;\\n  gl_FragColor.a = texColor.a * u_opacity;\\n}\\n');\n    var vertex$4 = new WebGLVertex('varying vec2 v_texCoord;\\n\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\n\\nuniform mat4 u_texCoordMatrix;\\nuniform mat4 u_projectionMatrix;\\n\\nvoid main(void) {\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\\n}\\n\\n\\n');\n    /**\n     * @module ol/renderer/webgl/defaultmapshader/Locations\n     */\n\n    var Locations$4 = function Locations(gl, program) {\n      /**\n       * @type {WebGLUniformLocation}\n       */\n      this.u_texCoordMatrix = gl.getUniformLocation(program, 'u_texCoordMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_projectionMatrix = gl.getUniformLocation(program, 'u_projectionMatrix');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_opacity = gl.getUniformLocation(program, 'u_opacity');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_texture = gl.getUniformLocation(program, 'u_texture');\n      /**\n       * @type {number}\n       */\n\n      this.a_position = gl.getAttribLocation(program, 'a_position');\n      /**\n       * @type {number}\n       */\n\n      this.a_texCoord = gl.getAttribLocation(program, 'a_texCoord');\n    };\n    /**\n     * @module ol/renderer/webgl/Layer\n     */\n\n    /**\n     * @abstract\n     */\n\n\n    var WebGLLayerRenderer =\n    /*@__PURE__*/\n    function (LayerRenderer$$1) {\n      function WebGLLayerRenderer(mapRenderer, layer) {\n        LayerRenderer$$1.call(this, layer);\n        /**\n         * @protected\n         * @type {import(\"./Map.js\").default}\n         */\n\n        this.mapRenderer = mapRenderer;\n        /**\n         * @private\n         * @type {import(\"../../webgl/Buffer.js\").default}\n         */\n\n        this.arrayBuffer_ = new WebGLBuffer([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]);\n        /**\n         * @protected\n         * @type {WebGLTexture}\n         */\n\n        this.texture = null;\n        /**\n         * @protected\n         * @type {WebGLFramebuffer}\n         */\n\n        this.framebuffer = null;\n        /**\n         * @protected\n         * @type {number|undefined}\n         */\n\n        this.framebufferDimension = undefined;\n        /**\n         * @protected\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.texCoordMatrix = create();\n        /**\n         * @protected\n         * @type {import(\"../../transform.js\").Transform}\n         */\n\n        this.projectionMatrix = create();\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n\n        this.tmpMat4_ = create$1();\n        /**\n         * @private\n         * @type {import(\"./defaultmapshader/Locations.js\").default}\n         */\n\n        this.defaultLocations_ = null;\n      }\n\n      if (LayerRenderer$$1) WebGLLayerRenderer.__proto__ = LayerRenderer$$1;\n      WebGLLayerRenderer.prototype = Object.create(LayerRenderer$$1 && LayerRenderer$$1.prototype);\n      WebGLLayerRenderer.prototype.constructor = WebGLLayerRenderer;\n      /**\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {number} framebufferDimension Framebuffer dimension.\n       * @protected\n       */\n\n      WebGLLayerRenderer.prototype.bindFramebuffer = function bindFramebuffer(frameState, framebufferDimension) {\n        var gl = this.mapRenderer.getGL();\n\n        if (this.framebufferDimension === undefined || this.framebufferDimension != framebufferDimension) {\n          /**\n           * @param {WebGLRenderingContext} gl GL.\n           * @param {WebGLFramebuffer} framebuffer Framebuffer.\n           * @param {WebGLTexture} texture Texture.\n           */\n          var postRenderFunction = function (gl, framebuffer, texture) {\n            if (!gl.isContextLost()) {\n              gl.deleteFramebuffer(framebuffer);\n              gl.deleteTexture(texture);\n            }\n          }.bind(null, gl, this.framebuffer, this.texture);\n\n          frameState.postRenderFunctions.push(\n          /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */\n          postRenderFunction);\n          var texture = createEmptyTexture(gl, framebufferDimension, framebufferDimension);\n          var framebuffer = gl.createFramebuffer();\n          gl.bindFramebuffer(FRAMEBUFFER, framebuffer);\n          gl.framebufferTexture2D(FRAMEBUFFER, COLOR_ATTACHMENT0, TEXTURE_2D, texture, 0);\n          this.texture = texture;\n          this.framebuffer = framebuffer;\n          this.framebufferDimension = framebufferDimension;\n        } else {\n          gl.bindFramebuffer(FRAMEBUFFER, this.framebuffer);\n        }\n      };\n      /**\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       */\n\n\n      WebGLLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n        this.dispatchComposeEvent_(RenderEventType.PRECOMPOSE, context, frameState);\n        context.bindBuffer(ARRAY_BUFFER, this.arrayBuffer_);\n        var gl = context.getGL();\n        var program = context.getProgram(fragment$4, vertex$4);\n        var locations;\n\n        if (!this.defaultLocations_) {\n          locations = new Locations$4(gl, program);\n          this.defaultLocations_ = locations;\n        } else {\n          locations = this.defaultLocations_;\n        }\n\n        if (context.useProgram(program)) {\n          gl.enableVertexAttribArray(locations.a_position);\n          gl.vertexAttribPointer(locations.a_position, 2, FLOAT, false, 16, 0);\n          gl.enableVertexAttribArray(locations.a_texCoord);\n          gl.vertexAttribPointer(locations.a_texCoord, 2, FLOAT, false, 16, 8);\n          gl.uniform1i(locations.u_texture, 0);\n        }\n\n        gl.uniformMatrix4fv(locations.u_texCoordMatrix, false, fromTransform(this.tmpMat4_, this.getTexCoordMatrix()));\n        gl.uniformMatrix4fv(locations.u_projectionMatrix, false, fromTransform(this.tmpMat4_, this.getProjectionMatrix()));\n        gl.uniform1f(locations.u_opacity, layerState.opacity);\n        gl.bindTexture(TEXTURE_2D, this.getTexture());\n        gl.drawArrays(TRIANGLE_STRIP, 0, 4);\n        this.dispatchComposeEvent_(RenderEventType.POSTCOMPOSE, context, frameState);\n      };\n      /**\n       * @param {import(\"../../render/EventType.js\").default} type Event type.\n       * @param {import(\"../../webgl/Context.js\").default} context WebGL context.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @private\n       */\n\n\n      WebGLLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_(type, context, frameState) {\n        var layer = this.getLayer();\n\n        if (layer.hasListener(type)) {\n          var viewState = frameState.viewState;\n          var resolution = viewState.resolution;\n          var pixelRatio = frameState.pixelRatio;\n          var extent = frameState.extent;\n          var center = viewState.center;\n          var rotation = viewState.rotation;\n          var size = frameState.size;\n          var render = new WebGLImmediateRenderer(context, center, resolution, rotation, size, extent, pixelRatio);\n          var composeEvent = new RenderEvent(type, render, frameState, null, context);\n          layer.dispatchEvent(composeEvent);\n        }\n      };\n      /**\n       * @return {!import(\"../../transform.js\").Transform} Matrix.\n       */\n\n\n      WebGLLayerRenderer.prototype.getTexCoordMatrix = function getTexCoordMatrix() {\n        return this.texCoordMatrix;\n      };\n      /**\n       * @return {WebGLTexture} Texture.\n       */\n\n\n      WebGLLayerRenderer.prototype.getTexture = function getTexture() {\n        return this.texture;\n      };\n      /**\n       * @return {!import(\"../../transform.js\").Transform} Matrix.\n       */\n\n\n      WebGLLayerRenderer.prototype.getProjectionMatrix = function getProjectionMatrix() {\n        return this.projectionMatrix;\n      };\n      /**\n       * Handle webglcontextlost.\n       */\n\n\n      WebGLLayerRenderer.prototype.handleWebGLContextLost = function handleWebGLContextLost() {\n        this.texture = null;\n        this.framebuffer = null;\n        this.framebufferDimension = undefined;\n      };\n      /**\n       * @abstract\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n       * @param {import(\"../../webgl/Context.js\").default} context Context.\n       * @return {boolean} whether composeFrame should be called.\n       */\n\n\n      WebGLLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState, context) {\n        return _abstract();\n      };\n      /**\n       * @abstract\n       * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n       * @param {function(this: S, import(\"../../layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n       *     callback.\n       * @param {S} thisArg Value to use as `this` when executing `callback`.\n       * @return {T|undefined} Callback result.\n       * @template S,T,U\n       */\n\n\n      WebGLLayerRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, callback, thisArg) {\n        return _abstract();\n      };\n\n      return WebGLLayerRenderer;\n    }(LayerRenderer);\n    /**\n     * @module ol/renderer/webgl/ImageLayer\n     */\n\n    /**\n     * @classdesc\n     * WebGL renderer for image layers.\n     * @api\n     */\n\n\n    var WebGLImageLayerRenderer =\n    /*@__PURE__*/\n    function (WebGLLayerRenderer$$1) {\n      function WebGLImageLayerRenderer(mapRenderer, imageLayer) {\n        WebGLLayerRenderer$$1.call(this, mapRenderer, imageLayer);\n        /**\n         * The last rendered image.\n         * @private\n         * @type {?import(\"../../ImageBase.js\").default}\n         */\n\n        this.image_ = null;\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.hitCanvasContext_ = null;\n        /**\n         * @private\n         * @type {?import(\"../../transform.js\").Transform}\n         */\n\n        this.hitTransformationMatrix_ = null;\n      }\n\n      if (WebGLLayerRenderer$$1) WebGLImageLayerRenderer.__proto__ = WebGLLayerRenderer$$1;\n      WebGLImageLayerRenderer.prototype = Object.create(WebGLLayerRenderer$$1 && WebGLLayerRenderer$$1.prototype);\n      WebGLImageLayerRenderer.prototype.constructor = WebGLImageLayerRenderer;\n      /**\n       * @param {import(\"../../ImageBase.js\").default} image Image.\n       * @private\n       * @return {WebGLTexture} Texture.\n       */\n\n      WebGLImageLayerRenderer.prototype.createTexture_ = function createTexture_(image) {\n        // We meet the conditions to work with non-power of two textures.\n        // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support\n        // http://learningwebgl.com/blog/?p=2101\n        var imageElement = image.getImage();\n        var gl = this.mapRenderer.getGL();\n        return createTexture(gl, imageElement, CLAMP_TO_EDGE, CLAMP_TO_EDGE);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImageLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState, context) {\n        var gl = this.mapRenderer.getGL();\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var viewCenter = viewState.center;\n        var viewResolution = viewState.resolution;\n        var viewRotation = viewState.rotation;\n        var image = this.image_;\n        var texture = this.texture;\n        var imageLayer =\n        /** @type {import(\"../../layer/Image.js\").default} */\n        this.getLayer();\n        var imageSource =\n        /** @type {import(\"../../source/Image.js\").default} */\n        imageLayer.getSource();\n        var hints = frameState.viewHints;\n        var renderedExtent = frameState.extent;\n\n        if (layerState.extent !== undefined) {\n          renderedExtent = getIntersection(renderedExtent, layerState.extent);\n        }\n\n        if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty$1(renderedExtent)) {\n          var projection = viewState.projection;\n          var image_ = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n\n          if (image_) {\n            var loaded = this.loadImage(image_);\n\n            if (loaded) {\n              image = image_;\n              texture = this.createTexture_(image_);\n\n              if (this.texture) {\n                /**\n                 * @param {WebGLRenderingContext} gl GL.\n                 * @param {WebGLTexture} texture Texture.\n                 */\n                var postRenderFunction = function (gl, texture) {\n                  if (!gl.isContextLost()) {\n                    gl.deleteTexture(texture);\n                  }\n                }.bind(null, gl, this.texture);\n\n                frameState.postRenderFunctions.push(\n                /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */\n                postRenderFunction);\n              }\n            }\n          }\n        }\n\n        if (image) {\n          var canvas = this.mapRenderer.getContext().getCanvas();\n          this.updateProjectionMatrix_(canvas.width, canvas.height, pixelRatio, viewCenter, viewResolution, viewRotation, image.getExtent());\n          this.hitTransformationMatrix_ = null; // Translate and scale to flip the Y coord.\n\n          var texCoordMatrix = this.texCoordMatrix;\n          reset(texCoordMatrix);\n          scale$2(texCoordMatrix, 1, -1);\n          translate$1(texCoordMatrix, 0, -1);\n          this.image_ = image;\n          this.texture = texture;\n        }\n\n        return !!image;\n      };\n      /**\n       * @param {number} canvasWidth Canvas width.\n       * @param {number} canvasHeight Canvas height.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../../coordinate.js\").Coordinate} viewCenter View center.\n       * @param {number} viewResolution View resolution.\n       * @param {number} viewRotation View rotation.\n       * @param {import(\"../../extent.js\").Extent} imageExtent Image extent.\n       * @private\n       */\n\n\n      WebGLImageLayerRenderer.prototype.updateProjectionMatrix_ = function updateProjectionMatrix_(canvasWidth, canvasHeight, pixelRatio, viewCenter, viewResolution, viewRotation, imageExtent) {\n        var canvasExtentWidth = canvasWidth * viewResolution;\n        var canvasExtentHeight = canvasHeight * viewResolution;\n        var projectionMatrix = this.projectionMatrix;\n        reset(projectionMatrix);\n        scale$2(projectionMatrix, pixelRatio * 2 / canvasExtentWidth, pixelRatio * 2 / canvasExtentHeight);\n        rotate$2(projectionMatrix, -viewRotation);\n        translate$1(projectionMatrix, imageExtent[0] - viewCenter[0], imageExtent[1] - viewCenter[1]);\n        scale$2(projectionMatrix, (imageExtent[2] - imageExtent[0]) / 2, (imageExtent[3] - imageExtent[1]) / 2);\n        translate$1(projectionMatrix, 1, 1);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLImageLayerRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, callback, thisArg) {\n        if (!this.image_ || !this.image_.getImage()) {\n          return undefined;\n        }\n\n        var imageSize = [this.image_.getImage().width, this.image_.getImage().height];\n\n        if (!this.hitTransformationMatrix_) {\n          this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(frameState.size, imageSize);\n        }\n\n        var pixelOnFrameBuffer = apply(this.hitTransformationMatrix_, pixel.slice());\n\n        if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] || pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {\n          // outside the image, no need to check\n          return undefined;\n        }\n\n        if (!this.hitCanvasContext_) {\n          this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n        }\n\n        this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n        this.hitCanvasContext_.drawImage(this.image_.getImage(), pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);\n        var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n\n        if (imageData[3] > 0) {\n          return callback.call(thisArg, this.getLayer(), imageData);\n        } else {\n          return undefined;\n        }\n      };\n      /**\n       * The transformation matrix to get the pixel on the image for a\n       * pixel on the map.\n       * @param {import(\"../../size.js\").Size} mapSize The map size.\n       * @param {import(\"../../size.js\").Size} imageSize The image size.\n       * @return {import(\"../../transform.js\").Transform} The transformation matrix.\n       * @private\n       */\n\n\n      WebGLImageLayerRenderer.prototype.getHitTransformationMatrix_ = function getHitTransformationMatrix_(mapSize, imageSize) {\n        // the first matrix takes a map pixel, flips the y-axis and scales to\n        // a range between -1 ... 1\n        var mapCoordTransform = create();\n        translate$1(mapCoordTransform, -1, -1);\n        scale$2(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);\n        translate$1(mapCoordTransform, 0, mapSize[1]);\n        scale$2(mapCoordTransform, 1, -1); // the second matrix is the inverse of the projection matrix used in the\n        // shader for drawing\n\n        var projectionMatrixInv = invert(this.projectionMatrix.slice()); // the third matrix scales to the image dimensions and flips the y-axis again\n\n        var transform = create();\n        translate$1(transform, 0, imageSize[1]);\n        scale$2(transform, 1, -1);\n        scale$2(transform, imageSize[0] / 2, imageSize[1] / 2);\n        translate$1(transform, 1, 1);\n        multiply(transform, projectionMatrixInv);\n        multiply(transform, mapCoordTransform);\n        return transform;\n      };\n\n      return WebGLImageLayerRenderer;\n    }(WebGLLayerRenderer);\n    /**\n     * Determine if this renderer handles the provided layer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n     * @return {boolean} The renderer can render the layer.\n     */\n\n\n    WebGLImageLayerRenderer['handles'] = function (layer) {\n      return layer.getType() === LayerType.IMAGE;\n    };\n    /**\n     * Create a layer renderer.\n     * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n     * @return {WebGLImageLayerRenderer} The layer renderer.\n     */\n\n\n    WebGLImageLayerRenderer['create'] = function (mapRenderer, layer) {\n      return new WebGLImageLayerRenderer(\n      /** @type {import(\"./Map.js\").default} */\n      mapRenderer,\n      /** @type {import(\"../../layer/Image.js\").default} */\n      layer);\n    };\n    /**\n     * @module ol/renderer/webgl/Map\n     */\n\n    /**\n     * @typedef {Object} TextureCacheEntry\n     * @property {number} magFilter\n     * @property {number} minFilter\n     * @property {WebGLTexture} texture\n     */\n\n    /**\n     * Texture cache high water mark.\n     * @type {number}\n     */\n\n\n    var WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;\n    /**\n     * @classdesc\n     * WebGL map renderer.\n     * @api\n     */\n\n    var WebGLMapRenderer =\n    /*@__PURE__*/\n    function (MapRenderer$$1) {\n      function WebGLMapRenderer(map) {\n        MapRenderer$$1.call(this, map);\n        var container = map.getViewport();\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.canvas_ =\n        /** @type {HTMLCanvasElement} */\n        document.createElement('canvas');\n        this.canvas_.style.width = '100%';\n        this.canvas_.style.height = '100%';\n        this.canvas_.style.display = 'block';\n        this.canvas_.className = CLASS_UNSELECTABLE;\n        container.insertBefore(this.canvas_, container.childNodes[0] || null);\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.clipTileCanvasWidth_ = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.clipTileCanvasHeight_ = 0;\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n\n        this.clipTileContext_ = createCanvasContext2D();\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.renderedVisible_ = true;\n        /**\n         * @private\n         * @type {WebGLRenderingContext}\n         */\n\n        this.gl_ = getContext(this.canvas_, {\n          antialias: true,\n          depth: true,\n          failIfMajorPerformanceCaveat: true,\n          preserveDrawingBuffer: false,\n          stencil: true\n        });\n        /**\n         * @private\n         * @type {import(\"../../webgl/Context.js\").default}\n         */\n\n        this.context_ = new WebGLContext(this.canvas_, this.gl_);\n        listen(this.canvas_, ContextEventType.LOST, this.handleWebGLContextLost, this);\n        listen(this.canvas_, ContextEventType.RESTORED, this.handleWebGLContextRestored, this);\n        /**\n         * @private\n         * @type {import(\"../../structs/LRUCache.js\").default<TextureCacheEntry|null>}\n         */\n\n        this.textureCache_ = new LRUCache();\n        /**\n         * @private\n         * @type {import(\"../../coordinate.js\").Coordinate}\n         */\n\n        this.focus_ = null;\n        /**\n         * @private\n         * @type {import(\"../../structs/PriorityQueue.js\").default<Array>}\n         */\n\n        this.tileTextureQueue_ = new PriorityQueue(\n        /**\n         * @param {Array<*>} element Element.\n         * @return {number} Priority.\n         * @this {WebGLMapRenderer}\n         */\n        function (element) {\n          var tileCenter =\n          /** @type {import(\"../../coordinate.js\").Coordinate} */\n          element[1];\n          var tileResolution =\n          /** @type {number} */\n          element[2];\n          var deltaX = tileCenter[0] - this.focus_[0];\n          var deltaY = tileCenter[1] - this.focus_[1];\n          return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n        }.bind(this),\n        /**\n         * @param {Array<*>} element Element.\n         * @return {string} Key.\n         */\n        function (element) {\n          return (\n            /** @type {import(\"../../Tile.js\").default} */\n            element[0].getKey()\n          );\n        });\n        /**\n         * @param {import(\"../../PluggableMap.js\").default} map Map.\n         * @param {?import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n         * @return {boolean} false.\n         * @this {WebGLMapRenderer}\n         */\n\n        this.loadNextTileTexture_ = function (map, frameState) {\n          if (!this.tileTextureQueue_.isEmpty()) {\n            this.tileTextureQueue_.reprioritize();\n            var element = this.tileTextureQueue_.dequeue();\n            var tile =\n            /** @type {import(\"../../Tile.js\").default} */\n            element[0];\n            var tileSize =\n            /** @type {import(\"../../size.js\").Size} */\n            element[3];\n            var tileGutter =\n            /** @type {number} */\n            element[4];\n            this.bindTileTexture(tile, tileSize, tileGutter, LINEAR, LINEAR);\n          }\n\n          return false;\n        }.bind(this);\n        /**\n         * @private\n         * @type {number}\n         */\n\n\n        this.textureCacheFrameMarkerCount_ = 0;\n        this.initializeGL_();\n      }\n\n      if (MapRenderer$$1) WebGLMapRenderer.__proto__ = MapRenderer$$1;\n      WebGLMapRenderer.prototype = Object.create(MapRenderer$$1 && MapRenderer$$1.prototype);\n      WebGLMapRenderer.prototype.constructor = WebGLMapRenderer;\n      /**\n       * @param {import(\"../../Tile.js\").default} tile Tile.\n       * @param {import(\"../../size.js\").Size} tileSize Tile size.\n       * @param {number} tileGutter Tile gutter.\n       * @param {number} magFilter Mag filter.\n       * @param {number} minFilter Min filter.\n       */\n\n      WebGLMapRenderer.prototype.bindTileTexture = function bindTileTexture(tile, tileSize, tileGutter, magFilter, minFilter) {\n        var gl = this.getGL();\n        var tileKey = tile.getKey();\n\n        if (this.textureCache_.containsKey(tileKey)) {\n          var textureCacheEntry = this.textureCache_.get(tileKey);\n          gl.bindTexture(TEXTURE_2D, textureCacheEntry.texture);\n\n          if (textureCacheEntry.magFilter != magFilter) {\n            gl.texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, magFilter);\n            textureCacheEntry.magFilter = magFilter;\n          }\n\n          if (textureCacheEntry.minFilter != minFilter) {\n            gl.texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, minFilter);\n            textureCacheEntry.minFilter = minFilter;\n          }\n        } else {\n          var texture = gl.createTexture();\n          var imageTile =\n          /** @type {import(\"../../ImageTile.js\").default} */\n          tile;\n          gl.bindTexture(TEXTURE_2D, texture);\n\n          if (tileGutter > 0) {\n            var clipTileCanvas = this.clipTileContext_.canvas;\n            var clipTileContext = this.clipTileContext_;\n\n            if (this.clipTileCanvasWidth_ !== tileSize[0] || this.clipTileCanvasHeight_ !== tileSize[1]) {\n              clipTileCanvas.width = tileSize[0];\n              clipTileCanvas.height = tileSize[1];\n              this.clipTileCanvasWidth_ = tileSize[0];\n              this.clipTileCanvasHeight_ = tileSize[1];\n            } else {\n              clipTileContext.clearRect(0, 0, tileSize[0], tileSize[1]);\n            }\n\n            clipTileContext.drawImage(imageTile.getImage(), tileGutter, tileGutter, tileSize[0], tileSize[1], 0, 0, tileSize[0], tileSize[1]);\n            gl.texImage2D(TEXTURE_2D, 0, RGBA, RGBA, UNSIGNED_BYTE, clipTileCanvas);\n          } else {\n            gl.texImage2D(TEXTURE_2D, 0, RGBA, RGBA, UNSIGNED_BYTE, imageTile.getImage());\n          }\n\n          gl.texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, magFilter);\n          gl.texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, minFilter);\n          gl.texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, CLAMP_TO_EDGE);\n          gl.texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, CLAMP_TO_EDGE);\n          this.textureCache_.set(tileKey, {\n            texture: texture,\n            magFilter: magFilter,\n            minFilter: minFilter\n          });\n        }\n      };\n      /**\n       * @param {import(\"../../render/EventType.js\").default} type Event type.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n\n\n      WebGLMapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent(type, frameState) {\n        var map = this.getMap();\n\n        if (map.hasListener(type)) {\n          var context = this.context_;\n          var extent = frameState.extent;\n          var size = frameState.size;\n          var viewState = frameState.viewState;\n          var pixelRatio = frameState.pixelRatio;\n          var resolution = viewState.resolution;\n          var center = viewState.center;\n          var rotation = viewState.rotation;\n          var vectorContext = new WebGLImmediateRenderer(context, center, resolution, rotation, size, extent, pixelRatio);\n          var composeEvent = new RenderEvent(type, vectorContext, frameState, null, context);\n          map.dispatchEvent(composeEvent);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLMapRenderer.prototype.disposeInternal = function disposeInternal() {\n        var gl = this.getGL();\n\n        if (!gl.isContextLost()) {\n          this.textureCache_.forEach(\n          /**\n           * @param {?TextureCacheEntry} textureCacheEntry\n           *     Texture cache entry.\n           */\n          function (textureCacheEntry) {\n            if (textureCacheEntry) {\n              gl.deleteTexture(textureCacheEntry.texture);\n            }\n          });\n        }\n\n        this.context_.dispose();\n        MapRenderer$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       * @private\n       */\n\n\n      WebGLMapRenderer.prototype.expireCache_ = function expireCache_(map, frameState) {\n        var gl = this.getGL();\n        var textureCacheEntry;\n\n        while (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {\n          textureCacheEntry = this.textureCache_.peekLast();\n\n          if (!textureCacheEntry) {\n            if (+this.textureCache_.peekLastKey() == frameState.index) {\n              break;\n            } else {\n              --this.textureCacheFrameMarkerCount_;\n            }\n          } else {\n            gl.deleteTexture(textureCacheEntry.texture);\n          }\n\n          this.textureCache_.pop();\n        }\n      };\n      /**\n       * @return {import(\"../../webgl/Context.js\").default} The context.\n       */\n\n\n      WebGLMapRenderer.prototype.getContext = function getContext$$1() {\n        return this.context_;\n      };\n      /**\n       * @return {WebGLRenderingContext} GL.\n       */\n\n\n      WebGLMapRenderer.prototype.getGL = function getGL() {\n        return this.gl_;\n      };\n      /**\n       * @return {import(\"../../structs/PriorityQueue.js\").default<Array>} Tile texture queue.\n       */\n\n\n      WebGLMapRenderer.prototype.getTileTextureQueue = function getTileTextureQueue() {\n        return this.tileTextureQueue_;\n      };\n      /**\n       * @param {import(\"../../events/Event.js\").default} event Event.\n       * @protected\n       */\n\n\n      WebGLMapRenderer.prototype.handleWebGLContextLost = function handleWebGLContextLost(event) {\n        event.preventDefault();\n        this.textureCache_.clear();\n        this.textureCacheFrameMarkerCount_ = 0;\n        var renderers = this.getLayerRenderers();\n\n        for (var id in renderers) {\n          var renderer =\n          /** @type {import(\"./Layer.js\").default} */\n          renderers[id];\n          renderer.handleWebGLContextLost();\n        }\n      };\n      /**\n       * @protected\n       */\n\n\n      WebGLMapRenderer.prototype.handleWebGLContextRestored = function handleWebGLContextRestored() {\n        this.initializeGL_();\n        this.getMap().render();\n      };\n      /**\n       * @private\n       */\n\n\n      WebGLMapRenderer.prototype.initializeGL_ = function initializeGL_() {\n        var gl = this.gl_;\n        gl.activeTexture(TEXTURE0);\n        gl.blendFuncSeparate(SRC_ALPHA, ONE_MINUS_SRC_ALPHA, ONE, ONE_MINUS_SRC_ALPHA);\n        gl.disable(CULL_FACE);\n        gl.disable(DEPTH_TEST);\n        gl.disable(SCISSOR_TEST);\n        gl.disable(STENCIL_TEST);\n      };\n      /**\n       * @param {import(\"../../Tile.js\").default} tile Tile.\n       * @return {boolean} Is tile texture loaded.\n       */\n\n\n      WebGLMapRenderer.prototype.isTileTextureLoaded = function isTileTextureLoaded(tile) {\n        return this.textureCache_.containsKey(tile.getKey());\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLMapRenderer.prototype.renderFrame = function renderFrame(frameState) {\n        var context = this.getContext();\n        var gl = this.getGL();\n\n        if (gl.isContextLost()) {\n          return false;\n        }\n\n        if (!frameState) {\n          if (this.renderedVisible_) {\n            this.canvas_.style.display = 'none';\n            this.renderedVisible_ = false;\n          }\n\n          return false;\n        }\n\n        this.focus_ = frameState.focus;\n        this.textureCache_.set((-frameState.index).toString(), null);\n        ++this.textureCacheFrameMarkerCount_;\n        this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n        /** @type {Array<import(\"../../layer/Layer.js\").State>} */\n\n        var layerStatesToDraw = [];\n        var layerStatesArray = frameState.layerStatesArray;\n        stableSort(layerStatesArray, sortByZIndex);\n        var viewResolution = frameState.viewState.resolution;\n        var i, ii;\n\n        for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n          var layerState = layerStatesArray[i];\n\n          if (visibleAtResolution(layerState, viewResolution) && layerState.sourceState == SourceState.READY) {\n            var layerRenderer =\n            /** @type {import(\"./Layer.js\").default} */\n            this.getLayerRenderer(layerState.layer);\n\n            if (layerRenderer.prepareFrame(frameState, layerState, context)) {\n              layerStatesToDraw.push(layerState);\n            }\n          }\n        }\n\n        var width = frameState.size[0] * frameState.pixelRatio;\n        var height = frameState.size[1] * frameState.pixelRatio;\n\n        if (this.canvas_.width != width || this.canvas_.height != height) {\n          this.canvas_.width = width;\n          this.canvas_.height = height;\n        }\n\n        gl.bindFramebuffer(FRAMEBUFFER, null);\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(COLOR_BUFFER_BIT);\n        gl.enable(BLEND);\n        gl.viewport(0, 0, this.canvas_.width, this.canvas_.height);\n\n        for (i = 0, ii = layerStatesToDraw.length; i < ii; ++i) {\n          var layerState$1 = layerStatesToDraw[i];\n          var layerRenderer$1 =\n          /** @type {import(\"./Layer.js\").default} */\n          this.getLayerRenderer(layerState$1.layer);\n          layerRenderer$1.composeFrame(frameState, layerState$1, context);\n        }\n\n        if (!this.renderedVisible_) {\n          this.canvas_.style.display = '';\n          this.renderedVisible_ = true;\n        }\n\n        this.calculateMatrices2D(frameState);\n\n        if (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {\n          frameState.postRenderFunctions.push(\n          /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */\n          this.expireCache_.bind(this));\n        }\n\n        if (!this.tileTextureQueue_.isEmpty()) {\n          frameState.postRenderFunctions.push(this.loadNextTileTexture_);\n          frameState.animate = true;\n        }\n\n        this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n        this.scheduleRemoveUnusedLayerRenderers(frameState);\n        this.scheduleExpireIconCache(frameState);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLMapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n        var result;\n\n        if (this.getGL().isContextLost()) {\n          return false;\n        }\n\n        var viewState = frameState.viewState;\n        var layerStates = frameState.layerStatesArray;\n        var numLayers = layerStates.length;\n        var i;\n\n        for (i = numLayers - 1; i >= 0; --i) {\n          var layerState = layerStates[i];\n          var layer = layerState.layer;\n\n          if (visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg2, layer)) {\n            var layerRenderer = this.getLayerRenderer(layer);\n            result = layerRenderer.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n\n        return undefined;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLMapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, layerFilter, thisArg) {\n        var hasFeature = false;\n\n        if (this.getGL().isContextLost()) {\n          return false;\n        }\n\n        var viewState = frameState.viewState;\n        var layerStates = frameState.layerStatesArray;\n        var numLayers = layerStates.length;\n        var i;\n\n        for (i = numLayers - 1; i >= 0; --i) {\n          var layerState = layerStates[i];\n          var layer = layerState.layer;\n\n          if (visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {\n            var layerRenderer = this.getLayerRenderer(layer);\n            hasFeature = layerRenderer.hasFeatureAtCoordinate(coordinate, frameState);\n\n            if (hasFeature) {\n              return true;\n            }\n          }\n        }\n\n        return hasFeature;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n        if (this.getGL().isContextLost()) {\n          return false;\n        }\n\n        var viewState = frameState.viewState;\n        var result;\n        var layerStates = frameState.layerStatesArray;\n        var numLayers = layerStates.length;\n        var i;\n\n        for (i = numLayers - 1; i >= 0; --i) {\n          var layerState = layerStates[i];\n          var layer = layerState.layer;\n\n          if (visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {\n            var layerRenderer =\n            /** @type {import(\"./Layer.js\").default} */\n            this.getLayerRenderer(layer);\n            result = layerRenderer.forEachLayerAtPixel(pixel, frameState, callback, thisArg);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n\n        return undefined;\n      };\n\n      return WebGLMapRenderer;\n    }(MapRenderer);\n    /**\n     * @module ol/Tile\n     */\n\n    /**\n     * A function that takes an {@link module:ol/Tile} for the tile and a\n     * `{string}` for the url as arguments. The default is\n     * ```js\n     * source.setTileLoadFunction(function(tile, src) {\n     *   tile.getImage().src = src;\n     * });\n     * ```\n     * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n     * error handling:\n     *\n     * ```js\n     * import TileState from 'ol/TileState';\n     *\n     * source.setTileLoadFunction(function(tile, src) {\n     *   var xhr = new XMLHttpRequest();\n     *   xhr.responseType = 'blob';\n     *   xhr.addEventListener('loadend', function (evt) {\n     *     var data = this.response;\n     *     if (data !== undefined) {\n     *       tile.getImage().src = URL.createObjectURL(data);\n     *     } else {\n     *       tile.setState(TileState.ERROR);\n     *     }\n     *   });\n     *   xhr.addEventListener('error', function () {\n     *     tile.setState(TileState.ERROR);\n     *   });\n     *   xhr.open('GET', src);\n     *   xhr.send();\n     * });\n     * ```\n     *\n     * @typedef {function(Tile, string)} LoadFunction\n     * @api\n     */\n\n    /**\n     * {@link module:ol/source/Tile~Tile} sources use a function of this type to get\n     * the url that provides a tile for a given tile coordinate.\n     *\n     * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n     * coordinate, a `{number}` representing the pixel ratio and a\n     * {@link module:ol/proj/Projection} for the projection  as arguments\n     * and returns a `{string}` representing the tile URL, or undefined if no tile\n     * should be requested for the passed tile coordinate.\n     *\n     * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n     *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n     * @api\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [transition=250] A duration for tile opacity\n     * transitions in milliseconds. A duration of 0 disables the opacity transition.\n     * @api\n     */\n\n    /**\n     * @classdesc\n     * Base class for tiles.\n     *\n     * @abstract\n     */\n\n\n    var Tile =\n    /*@__PURE__*/\n    function (EventTarget) {\n      function Tile(tileCoord, state, opt_options) {\n        EventTarget.call(this);\n        var options = opt_options ? opt_options : {};\n        /**\n         * @type {import(\"./tilecoord.js\").TileCoord}\n         */\n\n        this.tileCoord = tileCoord;\n        /**\n         * @protected\n         * @type {TileState}\n         */\n\n        this.state = state;\n        /**\n         * An \"interim\" tile for this tile. The interim tile may be used while this\n         * one is loading, for \"smooth\" transitions when changing params/dimensions\n         * on the source.\n         * @type {Tile}\n         */\n\n        this.interimTile = null;\n        /**\n         * A key assigned to the tile. This is used by the tile source to determine\n         * if this tile can effectively be used, or if a new tile should be created\n         * and this one be used as an interim tile for this new tile.\n         * @type {string}\n         */\n\n        this.key = '';\n        /**\n         * The duration for the opacity transition.\n         * @type {number}\n         */\n\n        this.transition_ = options.transition === undefined ? 250 : options.transition;\n        /**\n         * Lookup of start times for rendering transitions.  If the start time is\n         * equal to -1, the transition is complete.\n         * @type {Object<string, number>}\n         */\n\n        this.transitionStarts_ = {};\n      }\n\n      if (EventTarget) Tile.__proto__ = EventTarget;\n      Tile.prototype = Object.create(EventTarget && EventTarget.prototype);\n      Tile.prototype.constructor = Tile;\n      /**\n       * @protected\n       */\n\n      Tile.prototype.changed = function changed() {\n        this.dispatchEvent(EventType.CHANGE);\n      };\n      /**\n       * @return {string} Key.\n       */\n\n\n      Tile.prototype.getKey = function getKey() {\n        return this.key + '/' + this.tileCoord;\n      };\n      /**\n       * Get the interim tile most suitable for rendering using the chain of interim\n       * tiles. This corresponds to the  most recent tile that has been loaded, if no\n       * such tile exists, the original tile is returned.\n       * @return {!Tile} Best tile for rendering.\n       */\n\n\n      Tile.prototype.getInterimTile = function getInterimTile() {\n        if (!this.interimTile) {\n          //empty chain\n          return this;\n        }\n\n        var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in\n        // decreasing order of creation time, there is no need to search the remainder\n        // of the list (all those tiles correspond to older requests and will be\n        // cleaned up by refreshInterimChain)\n\n        do {\n          if (tile.getState() == TileState.LOADED) {\n            return tile;\n          }\n\n          tile = tile.interimTile;\n        } while (tile); // we can not find a better tile\n\n\n        return this;\n      };\n      /**\n       * Goes through the chain of interim tiles and discards sections of the chain\n       * that are no longer relevant.\n       */\n\n\n      Tile.prototype.refreshInterimChain = function refreshInterimChain() {\n        if (!this.interimTile) {\n          return;\n        }\n\n        var tile = this.interimTile;\n        var prev =\n        /** @type {Tile} */\n        this;\n\n        do {\n          if (tile.getState() == TileState.LOADED) {\n            //we have a loaded tile, we can discard the rest of the list\n            //we would could abort any LOADING tile request\n            //older than this tile (i.e. any LOADING tile following this entry in the chain)\n            tile.interimTile = null;\n            break;\n          } else if (tile.getState() == TileState.LOADING) {\n            //keep this LOADING tile any loaded tiles later in the chain are\n            //older than this tile, so we're still interested in the request\n            prev = tile;\n          } else if (tile.getState() == TileState.IDLE) {\n            //the head of the list is the most current tile, we don't need\n            //to start any other requests for this chain\n            prev.interimTile = tile.interimTile;\n          } else {\n            prev = tile;\n          }\n\n          tile = prev.interimTile;\n        } while (tile);\n      };\n      /**\n       * Get the tile coordinate for this tile.\n       * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n       * @api\n       */\n\n\n      Tile.prototype.getTileCoord = function getTileCoord() {\n        return this.tileCoord;\n      };\n      /**\n       * @return {TileState} State.\n       */\n\n\n      Tile.prototype.getState = function getState() {\n        return this.state;\n      };\n      /**\n       * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n       * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n       * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n       * the tile queue and will block other requests.\n       * @param {TileState} state State.\n       * @api\n       */\n\n\n      Tile.prototype.setState = function setState(state) {\n        this.state = state;\n        this.changed();\n      };\n      /**\n       * Load the image or retry if loading previously failed.\n       * Loading is taken care of by the tile queue, and calling this method is\n       * only needed for preloading or for reloading in case of an error.\n       * @abstract\n       * @api\n       */\n\n\n      Tile.prototype.load = function load() {};\n      /**\n       * Get the alpha value for rendering.\n       * @param {string} id An id for the renderer.\n       * @param {number} time The render frame time.\n       * @return {number} A number between 0 and 1.\n       */\n\n\n      Tile.prototype.getAlpha = function getAlpha(id, time) {\n        if (!this.transition_) {\n          return 1;\n        }\n\n        var start = this.transitionStarts_[id];\n\n        if (!start) {\n          start = time;\n          this.transitionStarts_[id] = start;\n        } else if (start === -1) {\n          return 1;\n        }\n\n        var delta = time - start + 1000 / 60; // avoid rendering at 0\n\n        if (delta >= this.transition_) {\n          return 1;\n        }\n\n        return easeIn(delta / this.transition_);\n      };\n      /**\n       * Determine if a tile is in an alpha transition.  A tile is considered in\n       * transition if tile.getAlpha() has not yet been called or has been called\n       * and returned 1.\n       * @param {string} id An id for the renderer.\n       * @return {boolean} The tile is in transition.\n       */\n\n\n      Tile.prototype.inTransition = function inTransition(id) {\n        if (!this.transition_) {\n          return false;\n        }\n\n        return this.transitionStarts_[id] !== -1;\n      };\n      /**\n       * Mark a transition as complete.\n       * @param {string} id An id for the renderer.\n       */\n\n\n      Tile.prototype.endTransition = function endTransition(id) {\n        if (this.transition_) {\n          this.transitionStarts_[id] = -1;\n        }\n      };\n\n      return Tile;\n    }(Target);\n    /**\n     * @module ol/ImageTile\n     */\n\n\n    var ImageTile =\n    /*@__PURE__*/\n    function (Tile$$1) {\n      function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\n        Tile$$1.call(this, tileCoord, state, opt_options);\n        /**\n         * @private\n         * @type {?string}\n         */\n\n        this.crossOrigin_ = crossOrigin;\n        /**\n         * Image URI\n         *\n         * @private\n         * @type {string}\n         */\n\n        this.src_ = src;\n        /**\n         * @private\n         * @type {HTMLImageElement|HTMLCanvasElement}\n         */\n\n        this.image_ = new Image();\n\n        if (crossOrigin !== null) {\n          this.image_.crossOrigin = crossOrigin;\n        }\n        /**\n         * @private\n         * @type {Array<import(\"./events.js\").EventsKey>}\n         */\n\n\n        this.imageListenerKeys_ = null;\n        /**\n         * @private\n         * @type {import(\"./Tile.js\").LoadFunction}\n         */\n\n        this.tileLoadFunction_ = tileLoadFunction;\n      }\n\n      if (Tile$$1) ImageTile.__proto__ = Tile$$1;\n      ImageTile.prototype = Object.create(Tile$$1 && Tile$$1.prototype);\n      ImageTile.prototype.constructor = ImageTile;\n      /**\n       * @inheritDoc\n       */\n\n      ImageTile.prototype.disposeInternal = function disposeInternal() {\n        if (this.state == TileState.LOADING) {\n          this.unlistenImage_();\n          this.image_ = getBlankImage();\n        }\n\n        if (this.interimTile) {\n          this.interimTile.dispose();\n        }\n\n        this.state = TileState.ABORT;\n        this.changed();\n        Tile$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n       * @api\n       */\n\n\n      ImageTile.prototype.getImage = function getImage() {\n        return this.image_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ImageTile.prototype.getKey = function getKey() {\n        return this.src_;\n      };\n      /**\n       * Tracks loading or read errors.\n       *\n       * @private\n       */\n\n\n      ImageTile.prototype.handleImageError_ = function handleImageError_() {\n        this.state = TileState.ERROR;\n        this.unlistenImage_();\n        this.image_ = getBlankImage();\n        this.changed();\n      };\n      /**\n       * Tracks successful image load.\n       *\n       * @private\n       */\n\n\n      ImageTile.prototype.handleImageLoad_ = function handleImageLoad_() {\n        var image =\n        /** @type {HTMLImageElement} */\n        this.image_;\n\n        if (image.naturalWidth && image.naturalHeight) {\n          this.state = TileState.LOADED;\n        } else {\n          this.state = TileState.EMPTY;\n        }\n\n        this.unlistenImage_();\n        this.changed();\n      };\n      /**\n       * @inheritDoc\n       * @api\n       */\n\n\n      ImageTile.prototype.load = function load() {\n        if (this.state == TileState.ERROR) {\n          this.state = TileState.IDLE;\n          this.image_ = new Image();\n\n          if (this.crossOrigin_ !== null) {\n            this.image_.crossOrigin = this.crossOrigin_;\n          }\n        }\n\n        if (this.state == TileState.IDLE) {\n          this.state = TileState.LOADING;\n          this.changed();\n          this.imageListenerKeys_ = [listenOnce(this.image_, EventType.ERROR, this.handleImageError_, this), listenOnce(this.image_, EventType.LOAD, this.handleImageLoad_, this)];\n          this.tileLoadFunction_(this, this.src_);\n        }\n      };\n      /**\n       * Discards event handlers which listen for load completion or errors.\n       *\n       * @private\n       */\n\n\n      ImageTile.prototype.unlistenImage_ = function unlistenImage_() {\n        this.imageListenerKeys_.forEach(unlistenByKey);\n        this.imageListenerKeys_ = null;\n      };\n\n      return ImageTile;\n    }(Tile);\n    /**\n     * Get a 1-pixel blank image.\n     * @return {HTMLCanvasElement} Blank image.\n     */\n\n\n    function getBlankImage() {\n      var ctx = createCanvasContext2D(1, 1);\n      ctx.fillStyle = 'rgba(0,0,0,0)';\n      ctx.fillRect(0, 0, 1, 1);\n      return ctx.canvas;\n    }\n    /**\n     * @module ol/tilecoord\n     */\n\n    /**\n     * An array of three numbers representing the location of a tile in a tile\n     * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.\n     * @typedef {Array<number>} TileCoord\n     * @api\n     */\n\n    /**\n     * @param {number} z Z.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {TileCoord=} opt_tileCoord Tile coordinate.\n     * @return {TileCoord} Tile coordinate.\n     */\n\n\n    function createOrUpdate$2(z, x, y, opt_tileCoord) {\n      if (opt_tileCoord !== undefined) {\n        opt_tileCoord[0] = z;\n        opt_tileCoord[1] = x;\n        opt_tileCoord[2] = y;\n        return opt_tileCoord;\n      } else {\n        return [z, x, y];\n      }\n    }\n    /**\n     * @param {number} z Z.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {string} Key.\n     */\n\n\n    function getKeyZXY(z, x, y) {\n      return z + '/' + x + '/' + y;\n    }\n    /**\n     * Get the key for a tile coord.\n     * @param {TileCoord} tileCoord The tile coord.\n     * @return {string} Key.\n     */\n\n\n    function getKey$1(tileCoord) {\n      return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n    }\n    /**\n     * Get a tile coord given a key.\n     * @param {string} key The tile coord key.\n     * @return {TileCoord} The tile coord.\n     */\n\n\n    function fromKey(key) {\n      return key.split('/').map(Number);\n    }\n    /**\n     * @param {TileCoord} tileCoord Tile coord.\n     * @return {number} Hash.\n     */\n\n\n    function hash(tileCoord) {\n      return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n    }\n    /**\n     * @param {TileCoord} tileCoord Tile coordinate.\n     * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @return {boolean} Tile coordinate is within extent and zoom level range.\n     */\n\n\n    function withinExtentAndZ(tileCoord, tileGrid) {\n      var z = tileCoord[0];\n      var x = tileCoord[1];\n      var y = tileCoord[2];\n\n      if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n        return false;\n      }\n\n      var extent = tileGrid.getExtent();\n      var tileRange;\n\n      if (!extent) {\n        tileRange = tileGrid.getFullTileRange(z);\n      } else {\n        tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n      }\n\n      if (!tileRange) {\n        return true;\n      } else {\n        return tileRange.containsXY(x, y);\n      }\n    }\n    /**\n     * @module ol/TileCache\n     */\n\n\n    var TileCache =\n    /*@__PURE__*/\n    function (LRUCache$$1) {\n      function TileCache(opt_highWaterMark) {\n        LRUCache$$1.call(this, opt_highWaterMark);\n      }\n\n      if (LRUCache$$1) TileCache.__proto__ = LRUCache$$1;\n      TileCache.prototype = Object.create(LRUCache$$1 && LRUCache$$1.prototype);\n      TileCache.prototype.constructor = TileCache;\n      /**\n       * @param {!Object<string, import(\"./TileRange.js\").default>} usedTiles Used tiles.\n       */\n\n      TileCache.prototype.expireCache = function expireCache(usedTiles) {\n        while (this.canExpireCache()) {\n          var tile = this.peekLast();\n          var zKey = tile.tileCoord[0].toString();\n\n          if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n            break;\n          } else {\n            this.pop().dispose();\n          }\n        }\n      };\n      /**\n       * Prune all tiles from the cache that don't have the same z as the newest tile.\n       */\n\n\n      TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ() {\n        if (this.getCount() === 0) {\n          return;\n        }\n\n        var key = this.peekFirstKey();\n        var tileCoord = fromKey(key);\n        var z = tileCoord[0];\n        this.forEach(function (tile) {\n          if (tile.tileCoord[0] !== z) {\n            this.remove(getKey$1(tile.tileCoord));\n            tile.dispose();\n          }\n        }, this);\n      };\n\n      return TileCache;\n    }(LRUCache);\n    /**\n     * @module ol/tilegrid/TileGrid\n     */\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n\n\n    var tmpTileCoord = [0, 0, 0];\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n     * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n     * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n     * @property {number} [minZoom=0] Minimum zoom.\n     * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n     * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not\n     * specified, `extent` or `origins` must be provided.\n     * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n     * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n     * should match the length of the `resolutions` array, i.e. each resolution can have a different\n     * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or\n     * `origin` must be provided.\n     * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n     * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n     * array will have a length of `maxZoom + 1`.\n     * @property {Array<import(\"../size.js\").Size>} [sizes] Sizes.\n     * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n     * Default is `[256, 256]`.\n     * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n     * should match the length of the `resolutions` array, i.e. each resolution can have a different\n     * tile size.\n     */\n\n    /**\n     * @classdesc\n     * Base class for setting the grid pattern for sources accessing tiled-image\n     * servers.\n     * @api\n     */\n\n    var TileGrid = function TileGrid(options) {\n      /**\n       * @protected\n       * @type {number}\n       */\n      this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n      /**\n       * @private\n       * @type {!Array<number>}\n       */\n\n      this.resolutions_ = options.resolutions;\n      assert(isSorted(this.resolutions_, function (a, b) {\n        return b - a;\n      }, true), 17); // `resolutions` must be sorted in descending order\n      // check if we've got a consistent zoom factor and origin\n\n      var zoomFactor;\n\n      if (!options.origins) {\n        for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n          if (!zoomFactor) {\n            zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n          } else {\n            if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n              zoomFactor = undefined;\n              break;\n            }\n          }\n        }\n      }\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n\n\n      this.zoomFactor_ = zoomFactor;\n      /**\n       * @protected\n       * @type {number}\n       */\n\n      this.maxZoom = this.resolutions_.length - 1;\n      /**\n       * @private\n       * @type {import(\"../coordinate.js\").Coordinate}\n       */\n\n      this.origin_ = options.origin !== undefined ? options.origin : null;\n      /**\n       * @private\n       * @type {Array<import(\"../coordinate.js\").Coordinate>}\n       */\n\n      this.origins_ = null;\n\n      if (options.origins !== undefined) {\n        this.origins_ = options.origins;\n        assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n      }\n\n      var extent = options.extent;\n\n      if (extent !== undefined && !this.origin_ && !this.origins_) {\n        this.origin_ = getTopLeft(extent);\n      }\n\n      assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both\n\n      /**\n       * @private\n       * @type {Array<number|import(\"../size.js\").Size>}\n       */\n\n      this.tileSizes_ = null;\n\n      if (options.tileSizes !== undefined) {\n        this.tileSizes_ = options.tileSizes;\n        assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n      }\n      /**\n       * @private\n       * @type {number|import(\"../size.js\").Size}\n       */\n\n\n      this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\n      assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n      /**\n       * @private\n       * @type {import(\"../extent.js\").Extent}\n       */\n\n      this.extent_ = extent !== undefined ? extent : null;\n      /**\n       * @private\n       * @type {Array<import(\"../TileRange.js\").default>}\n       */\n\n      this.fullTileRanges_ = null;\n      /**\n       * @private\n       * @type {import(\"../size.js\").Size}\n       */\n\n      this.tmpSize_ = [0, 0];\n\n      if (options.sizes !== undefined) {\n        this.fullTileRanges_ = options.sizes.map(function (size, z) {\n          var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n          return tileRange;\n        }, this);\n      } else if (extent) {\n        this.calculateTileRanges_(extent);\n      }\n    };\n    /**\n     * Call a function with each tile coordinate for a given extent and zoom level.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} zoom Integer zoom level.\n     * @param {function(import(\"../tilecoord.js\").TileCoord)} callback Function called with each tile coordinate.\n     * @api\n     */\n\n\n    TileGrid.prototype.forEachTileCoord = function forEachTileCoord(extent, zoom, callback) {\n      var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n\n      for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n        for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n          callback([zoom, i, j]);\n        }\n      }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {function(this: T, number, import(\"../TileRange.js\").default): boolean} callback Callback.\n     * @param {T=} opt_this The object to use as `this` in `callback`.\n     * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n     * @return {boolean} Callback succeeded.\n     * @template T\n     */\n\n\n    TileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange(tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n      var tileRange, x, y;\n      var tileCoordExtent = null;\n      var z = tileCoord[0] - 1;\n\n      if (this.zoomFactor_ === 2) {\n        x = tileCoord[1];\n        y = tileCoord[2];\n      } else {\n        tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n      }\n\n      while (z >= this.minZoom) {\n        if (this.zoomFactor_ === 2) {\n          x = Math.floor(x / 2);\n          y = Math.floor(y / 2);\n          tileRange = createOrUpdate$1(x, x, y, y, opt_tileRange);\n        } else {\n          tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n        }\n\n        if (callback.call(opt_this, z, tileRange)) {\n          return true;\n        }\n\n        --z;\n      }\n\n      return false;\n    };\n    /**\n     * Get the extent for this tile grid, if it was configured.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n\n\n    TileGrid.prototype.getExtent = function getExtent() {\n      return this.extent_;\n    };\n    /**\n     * Get the maximum zoom level for the grid.\n     * @return {number} Max zoom.\n     * @api\n     */\n\n\n    TileGrid.prototype.getMaxZoom = function getMaxZoom() {\n      return this.maxZoom;\n    };\n    /**\n     * Get the minimum zoom level for the grid.\n     * @return {number} Min zoom.\n     * @api\n     */\n\n\n    TileGrid.prototype.getMinZoom = function getMinZoom() {\n      return this.minZoom;\n    };\n    /**\n     * Get the origin for the grid at the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {import(\"../coordinate.js\").Coordinate} Origin.\n     * @api\n     */\n\n\n    TileGrid.prototype.getOrigin = function getOrigin(z) {\n      if (this.origin_) {\n        return this.origin_;\n      } else {\n        return this.origins_[z];\n      }\n    };\n    /**\n     * Get the resolution for the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {number} Resolution.\n     * @api\n     */\n\n\n    TileGrid.prototype.getResolution = function getResolution(z) {\n      return this.resolutions_[z];\n    };\n    /**\n     * Get the list of resolutions for the tile grid.\n     * @return {Array<number>} Resolutions.\n     * @api\n     */\n\n\n    TileGrid.prototype.getResolutions = function getResolutions() {\n      return this.resolutions_;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n\n\n    TileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange(tileCoord, opt_tileRange, opt_extent) {\n      if (tileCoord[0] < this.maxZoom) {\n        if (this.zoomFactor_ === 2) {\n          var minX = tileCoord[1] * 2;\n          var minY = tileCoord[2] * 2;\n          return createOrUpdate$1(minX, minX + 1, minY, minY + 1, opt_tileRange);\n        }\n\n        var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n        return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n      }\n\n      return null;\n    };\n    /**\n     * Get the extent for a tile range.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n\n\n    TileGrid.prototype.getTileRangeExtent = function getTileRangeExtent(z, tileRange, opt_extent) {\n      var origin = this.getOrigin(z);\n      var resolution = this.getResolution(z);\n      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n      var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n      var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n      var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n      var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get a tile range for the given extent and integer zoom level.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary tile range object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n\n\n    TileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ(extent, z, opt_tileRange) {\n      var tileCoord = tmpTileCoord;\n      this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n      var minX = tileCoord[1];\n      var minY = tileCoord[2];\n      this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n      return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n     */\n\n\n    TileGrid.prototype.getTileCoordCenter = function getTileCoordCenter(tileCoord) {\n      var origin = this.getOrigin(tileCoord[0]);\n      var resolution = this.getResolution(tileCoord[0]);\n      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n      return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];\n    };\n    /**\n     * Get the extent of a tile coordinate.\n     *\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n\n\n    TileGrid.prototype.getTileCoordExtent = function getTileCoordExtent(tileCoord, opt_extent) {\n      var origin = this.getOrigin(tileCoord[0]);\n      var resolution = this.getResolution(tileCoord[0]);\n      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n      var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n      var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n      var maxX = minX + tileSize[0] * resolution;\n      var maxY = minY + tileSize[1] * resolution;\n      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get the tile coordinate for the given map coordinate and resolution.This\n     * method considers that coordinates that intersect tile boundaries should be\n     * assigned the higher tile coordinate.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n\n\n    TileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n      return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n    };\n    /**\n     * Note that this method should not be called for resolutions that correspond\n     * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} resolution Resolution (for a non-integer zoom level).\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *   intersections go to the higher tile coordinate, let edge intersections\n     *   go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n\n\n    TileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n      var z = this.getZForResolution(resolution);\n      var scale = resolution / this.getResolution(z);\n      var origin = this.getOrigin(z);\n      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n      var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n      var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n      var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n      var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n      var tileCoordX = scale * xFromOrigin / tileSize[0];\n      var tileCoordY = scale * yFromOrigin / tileSize[1];\n\n      if (reverseIntersectionPolicy) {\n        tileCoordX = Math.ceil(tileCoordX) - 1;\n        tileCoordY = Math.ceil(tileCoordY) - 1;\n      } else {\n        tileCoordX = Math.floor(tileCoordX);\n        tileCoordY = Math.floor(tileCoordY);\n      }\n\n      return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n     * they should have separate implementations.This method is for integer zoom\n     * levels.The other method should only be called for resolutions corresponding\n     * to non-integer zoom levels.\n     * @param {number} x Map x coordinate.\n     * @param {number} y Map y coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *   intersections go to the higher tile coordinate, let edge intersections\n     *   go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n\n\n    TileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n      var origin = this.getOrigin(z);\n      var resolution = this.getResolution(z);\n      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n      var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n      var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n      var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n      var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n      var tileCoordX = xFromOrigin / tileSize[0];\n      var tileCoordY = yFromOrigin / tileSize[1];\n\n      if (reverseIntersectionPolicy) {\n        tileCoordX = Math.ceil(tileCoordX) - 1;\n        tileCoordY = Math.ceil(tileCoordY) - 1;\n      } else {\n        tileCoordX = Math.floor(tileCoordX);\n        tileCoordY = Math.floor(tileCoordY);\n      }\n\n      return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Get a tile coordinate given a map coordinate and zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} z Zoom level.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n\n\n    TileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n      return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {number} Tile resolution.\n     */\n\n\n    TileGrid.prototype.getTileCoordResolution = function getTileCoordResolution(tileCoord) {\n      return this.resolutions_[tileCoord[0]];\n    };\n    /**\n     * Get the tile size for a zoom level. The type of the return value matches the\n     * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n     * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n     * @param {number} z Z.\n     * @return {number|import(\"../size.js\").Size} Tile size.\n     * @api\n     */\n\n\n    TileGrid.prototype.getTileSize = function getTileSize(z) {\n      if (this.tileSize_) {\n        return this.tileSize_;\n      } else {\n        return this.tileSizes_[z];\n      }\n    };\n    /**\n     * @param {number} z Zoom level.\n     * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n     */\n\n\n    TileGrid.prototype.getFullTileRange = function getFullTileRange(z) {\n      if (!this.fullTileRanges_) {\n        return null;\n      } else {\n        return this.fullTileRanges_[z];\n      }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number=} opt_direction If 0, the nearest resolution will be used.\n     *   If 1, the nearest lower resolution will be used. If -1, the nearest\n     *   higher resolution will be used. Default is 0.\n     * @return {number} Z.\n     * @api\n     */\n\n\n    TileGrid.prototype.getZForResolution = function getZForResolution(resolution, opt_direction) {\n      var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n      return clamp(z, this.minZoom, this.maxZoom);\n    };\n    /**\n     * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n     * @private\n     */\n\n\n    TileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_(extent) {\n      var length = this.resolutions_.length;\n      var fullTileRanges = new Array(length);\n\n      for (var z = this.minZoom; z < length; ++z) {\n        fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n      }\n\n      this.fullTileRanges_ = fullTileRanges;\n    };\n    /**\n     * @module ol/tilegrid\n     */\n\n    /**\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {!TileGrid} Default tile grid for the\n     * passed projection.\n     */\n\n\n    function getForProjection(projection) {\n      var tileGrid = projection.getDefaultTileGrid();\n\n      if (!tileGrid) {\n        tileGrid = createForProjection(projection);\n        projection.setDefaultTileGrid(tileGrid);\n      }\n\n      return tileGrid;\n    }\n    /**\n     * @param {TileGrid} tileGrid Tile grid.\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n     */\n\n\n    function wrapX(tileGrid, tileCoord, projection) {\n      var z = tileCoord[0];\n      var center = tileGrid.getTileCoordCenter(tileCoord);\n      var projectionExtent = extentFromProjection(projection);\n\n      if (!containsCoordinate(projectionExtent, center)) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n        center[0] += worldWidth * worldsAway;\n        return tileGrid.getTileCoordForCoordAndZ(center, z);\n      } else {\n        return tileCoord;\n      }\n    }\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number=} opt_maxZoom Maximum zoom level (default is\n     *     DEFAULT_MAX_ZOOM).\n     * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n     *     DEFAULT_TILE_SIZE).\n     * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n     * @return {!TileGrid} TileGrid instance.\n     */\n\n\n    function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n      var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n      var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n      return new TileGrid({\n        extent: extent,\n        origin: getCorner(extent, corner),\n        resolutions: resolutions,\n        tileSize: opt_tileSize\n      });\n    }\n    /**\n     * @typedef {Object} XYZOptions\n     * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n     * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the\n     * provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n     * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n     * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n     * @property {number} [minZoom=0] Minimum zoom.\n     * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n     */\n\n    /**\n     * Creates a tile grid with a standard XYZ tiling scheme.\n     * @param {XYZOptions=} opt_options Tile grid options.\n     * @return {!TileGrid} Tile grid instance.\n     * @api\n     */\n\n\n    function createXYZ(opt_options) {\n      /** @type {XYZOptions} */\n      var xyzOptions = opt_options || {};\n      var extent = xyzOptions.extent || get$2('EPSG:3857').getExtent();\n      /** @type {import(\"./tilegrid/TileGrid.js\").Options} */\n\n      var gridOptions = {\n        extent: extent,\n        minZoom: xyzOptions.minZoom,\n        tileSize: xyzOptions.tileSize,\n        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize)\n      };\n      return new TileGrid(gridOptions);\n    }\n    /**\n     * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number=} opt_maxZoom Maximum zoom level (default is\n     *     DEFAULT_MAX_ZOOM).\n     * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n     *     DEFAULT_TILE_SIZE).\n     * @return {!Array<number>} Resolutions array.\n     */\n\n\n    function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {\n      var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n      var height = getHeight(extent);\n      var width = getWidth(extent);\n      var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n      var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);\n      var length = maxZoom + 1;\n      var resolutions = new Array(length);\n\n      for (var z = 0; z < length; ++z) {\n        resolutions[z] = maxResolution / Math.pow(2, z);\n      }\n\n      return resolutions;\n    }\n    /**\n     * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n     * @param {number=} opt_maxZoom Maximum zoom level (default is\n     *     DEFAULT_MAX_ZOOM).\n     * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n     *     DEFAULT_TILE_SIZE).\n     * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n     * @return {!TileGrid} TileGrid instance.\n     */\n\n\n    function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n      var extent = extentFromProjection(projection);\n      return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n    }\n    /**\n     * Generate a tile grid extent from a projection.  If the projection has an\n     * extent, it is used.  If not, a global extent is assumed.\n     * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n     * @return {import(\"./extent.js\").Extent} Extent.\n     */\n\n\n    function extentFromProjection(projection) {\n      projection = get$2(projection);\n      var extent = projection.getExtent();\n\n      if (!extent) {\n        var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();\n        extent = createOrUpdate(-half, -half, half, half);\n      }\n\n      return extent;\n    }\n    /**\n     * @module ol/source/Tile\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"./Source.js\").AttributionLike} [attributions]\n     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n     * @property {number} [cacheSize]\n     * @property {boolean} [opaque]\n     * @property {number} [tilePixelRatio]\n     * @property {import(\"../proj.js\").ProjectionLike} [projection]\n     * @property {import(\"./State.js\").default} [state]\n     * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n     * @property {boolean} [wrapX=true]\n     * @property {number} [transition]\n     * @property {string} [key]\n     */\n\n    /**\n     * @classdesc\n     * Abstract base class; normally only used for creating subclasses and not\n     * instantiated in apps.\n     * Base class for sources providing images divided into a tile grid.\n     * @abstract\n     * @api\n     */\n\n\n    var TileSource =\n    /*@__PURE__*/\n    function (Source$$1) {\n      function TileSource(options) {\n        Source$$1.call(this, {\n          attributions: options.attributions,\n          attributionsCollapsible: options.attributionsCollapsible,\n          projection: options.projection,\n          state: options.state,\n          wrapX: options.wrapX\n        });\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n        /**\n         * @protected\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n\n        this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n        /**\n         * @protected\n         * @type {import(\"../TileCache.js\").default}\n         */\n\n        this.tileCache = new TileCache(options.cacheSize);\n        /**\n         * @protected\n         * @type {import(\"../size.js\").Size}\n         */\n\n        this.tmpSize = [0, 0];\n        /**\n         * @private\n         * @type {string}\n         */\n\n        this.key_ = options.key || '';\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").Options}\n         */\n\n        this.tileOptions = {\n          transition: options.transition\n        };\n      }\n\n      if (Source$$1) TileSource.__proto__ = Source$$1;\n      TileSource.prototype = Object.create(Source$$1 && Source$$1.prototype);\n      TileSource.prototype.constructor = TileSource;\n      /**\n       * @return {boolean} Can expire cache.\n       */\n\n      TileSource.prototype.canExpireCache = function canExpireCache() {\n        return this.tileCache.canExpireCache();\n      };\n      /**\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @param {!Object<string, import(\"../TileRange.js\").default>} usedTiles Used tiles.\n       */\n\n\n      TileSource.prototype.expireCache = function expireCache(projection, usedTiles) {\n        var tileCache = this.getTileCacheForProjection(projection);\n\n        if (tileCache) {\n          tileCache.expireCache(usedTiles);\n        }\n      };\n      /**\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @param {number} z Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n       *     loaded tile.  If the callback returns `false`, the tile will not be\n       *     considered loaded.\n       * @return {boolean} The tile range is fully covered with loaded tiles.\n       */\n\n\n      TileSource.prototype.forEachLoadedTile = function forEachLoadedTile(projection, z, tileRange, callback) {\n        var tileCache = this.getTileCacheForProjection(projection);\n\n        if (!tileCache) {\n          return false;\n        }\n\n        var covered = true;\n        var tile, tileCoordKey, loaded;\n\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n          for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n            tileCoordKey = getKeyZXY(z, x, y);\n            loaded = false;\n\n            if (tileCache.containsKey(tileCoordKey)) {\n              tile =\n              /** @type {!import(\"../Tile.js\").default} */\n              tileCache.get(tileCoordKey);\n              loaded = tile.getState() === TileState.LOADED;\n\n              if (loaded) {\n                loaded = callback(tile) !== false;\n              }\n            }\n\n            if (!loaded) {\n              covered = false;\n            }\n          }\n        }\n\n        return covered;\n      };\n      /**\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {number} Gutter.\n       */\n\n\n      TileSource.prototype.getGutterForProjection = function getGutterForProjection(projection) {\n        return 0;\n      };\n      /**\n       * Return the key to be used for all tiles in the source.\n       * @return {string} The key for all tiles.\n       * @protected\n       */\n\n\n      TileSource.prototype.getKey = function getKey() {\n        return this.key_;\n      };\n      /**\n       * Set the value to be used as the key for all tiles in the source.\n       * @param {string} key The key for tiles.\n       * @protected\n       */\n\n\n      TileSource.prototype.setKey = function setKey(key) {\n        if (this.key_ !== key) {\n          this.key_ = key;\n          this.changed();\n        }\n      };\n      /**\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {boolean} Opaque.\n       */\n\n\n      TileSource.prototype.getOpaque = function getOpaque(projection) {\n        return this.opaque_;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileSource.prototype.getResolutions = function getResolutions() {\n        return this.tileGrid.getResolutions();\n      };\n      /**\n       * @abstract\n       * @param {number} z Tile coordinate z.\n       * @param {number} x Tile coordinate x.\n       * @param {number} y Tile coordinate y.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {!import(\"../Tile.js\").default} Tile.\n       */\n\n\n      TileSource.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n        return _abstract();\n      };\n      /**\n       * Return the tile grid of the tile source.\n       * @return {import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n       * @api\n       */\n\n\n      TileSource.prototype.getTileGrid = function getTileGrid() {\n        return this.tileGrid;\n      };\n      /**\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n       */\n\n\n      TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1(projection) {\n        if (!this.tileGrid) {\n          return getForProjection(projection);\n        } else {\n          return this.tileGrid;\n        }\n      };\n      /**\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {import(\"../TileCache.js\").default} Tile cache.\n       * @protected\n       */\n\n\n      TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection(projection) {\n        var thisProj = this.getProjection();\n\n        if (thisProj && !equivalent(thisProj, projection)) {\n          return null;\n        } else {\n          return this.tileCache;\n        }\n      };\n      /**\n       * Get the tile pixel ratio for this source. Subclasses may override this\n       * method, which is meant to return a supported pixel ratio that matches the\n       * provided `pixelRatio` as close as possible.\n       * @param {number} pixelRatio Pixel ratio.\n       * @return {number} Tile pixel ratio.\n       */\n\n\n      TileSource.prototype.getTilePixelRatio = function getTilePixelRatio(pixelRatio) {\n        return this.tilePixelRatio_;\n      };\n      /**\n       * @param {number} z Z.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {import(\"../size.js\").Size} Tile size.\n       */\n\n\n      TileSource.prototype.getTilePixelSize = function getTilePixelSize(z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n\n        if (tilePixelRatio == 1) {\n          return tileSize;\n        } else {\n          return scale$3(tileSize, tilePixelRatio, this.tmpSize);\n        }\n      };\n      /**\n       * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n       * is outside the resolution and extent range of the tile grid, `null` will be\n       * returned.\n       * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n       * @param {import(\"../proj/Projection.js\").default=} opt_projection Projection.\n       * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n       *     null if no tile URL should be created for the passed `tileCoord`.\n       */\n\n\n      TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction(tileCoord, opt_projection) {\n        var projection = opt_projection !== undefined ? opt_projection : this.getProjection();\n        var tileGrid = this.getTileGridForProjection(projection);\n\n        if (this.getWrapX() && projection.isGlobal()) {\n          tileCoord = wrapX(tileGrid, tileCoord, projection);\n        }\n\n        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileSource.prototype.refresh = function refresh() {\n        this.tileCache.clear();\n        this.changed();\n      };\n      /**\n       * Marks a tile coord as being used, without triggering a load.\n       * @abstract\n       * @param {number} z Tile coordinate z.\n       * @param {number} x Tile coordinate x.\n       * @param {number} y Tile coordinate y.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       */\n\n\n      TileSource.prototype.useTile = function useTile(z, x, y, projection) {};\n\n      return TileSource;\n    }(Source);\n    /**\n     * @classdesc\n     * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n     * type.\n     */\n\n\n    var TileSourceEvent =\n    /*@__PURE__*/\n    function (Event$$1) {\n      function TileSourceEvent(type, tile) {\n        Event$$1.call(this, type);\n        /**\n         * The tile related to the event.\n         * @type {import(\"../Tile.js\").default}\n         * @api\n         */\n\n        this.tile = tile;\n      }\n\n      if (Event$$1) TileSourceEvent.__proto__ = Event$$1;\n      TileSourceEvent.prototype = Object.create(Event$$1 && Event$$1.prototype);\n      TileSourceEvent.prototype.constructor = TileSourceEvent;\n      return TileSourceEvent;\n    }(Event);\n    /**\n     * @module ol/renderer/webgl/tilelayershader\n     */\n\n\n    var fragment$5 = new WebGLFragment('precision mediump float;\\nvarying vec2 v_texCoord;\\n\\n\\nuniform sampler2D u_texture;\\n\\nvoid main(void) {\\n  gl_FragColor = texture2D(u_texture, v_texCoord);\\n}\\n');\n    var vertex$5 = new WebGLVertex('varying vec2 v_texCoord;\\n\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nuniform vec4 u_tileOffset;\\n\\nvoid main(void) {\\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\\n  v_texCoord = a_texCoord;\\n}\\n\\n\\n');\n    /**\n     * @module ol/renderer/webgl/tilelayershader/Locations\n     */\n\n    var Locations$5 = function Locations(gl, program) {\n      /**\n       * @type {WebGLUniformLocation}\n       */\n      this.u_tileOffset = gl.getUniformLocation(program, 'u_tileOffset');\n      /**\n       * @type {WebGLUniformLocation}\n       */\n\n      this.u_texture = gl.getUniformLocation(program, 'u_texture');\n      /**\n       * @type {number}\n       */\n\n      this.a_position = gl.getAttribLocation(program, 'a_position');\n      /**\n       * @type {number}\n       */\n\n      this.a_texCoord = gl.getAttribLocation(program, 'a_texCoord');\n    };\n    /**\n     * @module ol/renderer/webgl/TileLayer\n     */\n\n    /**\n     * @classdesc\n     * WebGL renderer for tile layers.\n     * @api\n     */\n\n\n    var WebGLTileLayerRenderer =\n    /*@__PURE__*/\n    function (WebGLLayerRenderer$$1) {\n      function WebGLTileLayerRenderer(mapRenderer, tileLayer) {\n        WebGLLayerRenderer$$1.call(this, mapRenderer, tileLayer);\n        /**\n         * @private\n         * @type {import(\"../../webgl/Fragment.js\").default}\n         */\n\n        this.fragmentShader_ = fragment$5;\n        /**\n         * @private\n         * @type {import(\"../../webgl/Vertex.js\").default}\n         */\n\n        this.vertexShader_ = vertex$5;\n        /**\n         * @private\n         * @type {import(\"./tilelayershader/Locations.js\").default}\n         */\n\n        this.locations_ = null;\n        /**\n         * @private\n         * @type {import(\"../../webgl/Buffer.js\").default}\n         */\n\n        this.renderArrayBuffer_ = new WebGLBuffer([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]);\n        /**\n         * @private\n         * @type {import(\"../../TileRange.js\").default}\n         */\n\n        this.renderedTileRange_ = null;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.renderedFramebufferExtent_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.renderedRevision_ = -1;\n        /**\n         * @private\n         * @type {import(\"../../size.js\").Size}\n         */\n\n        this.tmpSize_ = [0, 0];\n      }\n\n      if (WebGLLayerRenderer$$1) WebGLTileLayerRenderer.__proto__ = WebGLLayerRenderer$$1;\n      WebGLTileLayerRenderer.prototype = Object.create(WebGLLayerRenderer$$1 && WebGLLayerRenderer$$1.prototype);\n      WebGLTileLayerRenderer.prototype.constructor = WebGLTileLayerRenderer;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLTileLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n        var context = this.mapRenderer.getContext();\n        context.deleteBuffer(this.renderArrayBuffer_);\n        WebGLLayerRenderer$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTileLayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder(source, projection, tiles) {\n        var mapRenderer = this.mapRenderer;\n        return (\n          /**\n           * @param {number} zoom Zoom level.\n           * @param {import(\"../../TileRange.js\").default} tileRange Tile range.\n           * @return {boolean} The tile range is fully loaded.\n           */\n          function (zoom, tileRange) {\n            function callback(tile) {\n              var loaded = mapRenderer.isTileTextureLoaded(tile);\n\n              if (loaded) {\n                if (!tiles[zoom]) {\n                  tiles[zoom] = {};\n                }\n\n                tiles[zoom][tile.tileCoord.toString()] = tile;\n              }\n\n              return loaded;\n            }\n\n            return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n          }\n        );\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTileLayerRenderer.prototype.handleWebGLContextLost = function handleWebGLContextLost() {\n        WebGLLayerRenderer$$1.prototype.handleWebGLContextLost.call(this);\n        this.locations_ = null;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState, context) {\n        var mapRenderer = this.mapRenderer;\n        var gl = context.getGL();\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var tileLayer =\n        /** @type {import(\"../../layer/Tile.js\").default} */\n        this.getLayer();\n        var tileSource = tileLayer.getSource();\n\n        if (!(tileSource instanceof TileSource)) {\n          return true;\n        }\n\n        var tileGrid = tileSource.getTileGridForProjection(projection);\n        var z = tileGrid.getZForResolution(viewState.resolution);\n        var tileResolution = tileGrid.getResolution(z);\n        var tilePixelSize = tileSource.getTilePixelSize(z, frameState.pixelRatio, projection);\n        var pixelRatio = tilePixelSize[0] / toSize(tileGrid.getTileSize(z), this.tmpSize_)[0];\n        var tilePixelResolution = tileResolution / pixelRatio;\n        var tileGutter = tileSource.getTilePixelRatio(pixelRatio) * tileSource.getGutterForProjection(projection);\n        var center = viewState.center;\n        var extent = frameState.extent;\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n        var framebufferExtent;\n\n        if (this.renderedTileRange_ && this.renderedTileRange_.equals(tileRange) && this.renderedRevision_ == tileSource.getRevision()) {\n          framebufferExtent = this.renderedFramebufferExtent_;\n        } else {\n          var tileRangeSize = tileRange.getSize();\n          var maxDimension = Math.max(tileRangeSize[0] * tilePixelSize[0], tileRangeSize[1] * tilePixelSize[1]);\n          var framebufferDimension = roundUpToPowerOfTwo(maxDimension);\n          var framebufferExtentDimension = tilePixelResolution * framebufferDimension;\n          var origin = tileGrid.getOrigin(z);\n          var minX = origin[0] + tileRange.minX * tilePixelSize[0] * tilePixelResolution;\n          var minY = origin[1] + tileRange.minY * tilePixelSize[1] * tilePixelResolution;\n          framebufferExtent = [minX, minY, minX + framebufferExtentDimension, minY + framebufferExtentDimension];\n          this.bindFramebuffer(frameState, framebufferDimension);\n          gl.viewport(0, 0, framebufferDimension, framebufferDimension);\n          gl.clearColor(0, 0, 0, 0);\n          gl.clear(COLOR_BUFFER_BIT);\n          gl.disable(BLEND);\n          var program = context.getProgram(this.fragmentShader_, this.vertexShader_);\n          context.useProgram(program);\n\n          if (!this.locations_) {\n            this.locations_ = new Locations$5(gl, program);\n          }\n\n          context.bindBuffer(ARRAY_BUFFER, this.renderArrayBuffer_);\n          gl.enableVertexAttribArray(this.locations_.a_position);\n          gl.vertexAttribPointer(this.locations_.a_position, 2, FLOAT, false, 16, 0);\n          gl.enableVertexAttribArray(this.locations_.a_texCoord);\n          gl.vertexAttribPointer(this.locations_.a_texCoord, 2, FLOAT, false, 16, 8);\n          gl.uniform1i(this.locations_.u_texture, 0);\n          /**\n           * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n           */\n\n          var tilesToDrawByZ = {};\n          tilesToDrawByZ[z] = {};\n          var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n          var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n          var allTilesLoaded = true;\n          var tmpExtent = createEmpty();\n          var tmpTileRange = new TileRange(0, 0, 0, 0);\n          var childTileRange, drawable, fullyLoaded, tile, tileState;\n          var x, y, tileExtent;\n\n          for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n              tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n              if (layerState.extent !== undefined) {\n                // ignore tiles outside layer extent\n                tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);\n\n                if (!intersects(tileExtent, layerState.extent)) {\n                  continue;\n                }\n              }\n\n              tileState = tile.getState();\n              drawable = tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n\n              if (!drawable) {\n                tile = tile.getInterimTile();\n              }\n\n              tileState = tile.getState();\n\n              if (tileState == TileState.LOADED) {\n                if (mapRenderer.isTileTextureLoaded(tile)) {\n                  tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n                  continue;\n                }\n              } else if (tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError) {\n                continue;\n              }\n\n              allTilesLoaded = false;\n              fullyLoaded = tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n\n              if (!fullyLoaded) {\n                childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n\n                if (childTileRange) {\n                  findLoadedTiles(z + 1, childTileRange);\n                }\n              }\n            }\n          }\n          /** @type {Array<number>} */\n\n\n          var zs = Object.keys(tilesToDrawByZ).map(Number);\n          zs.sort(numberSafeCompareFunction);\n          var u_tileOffset = new Float32Array(4);\n\n          for (var i = 0, ii = zs.length; i < ii; ++i) {\n            var tilesToDraw = tilesToDrawByZ[zs[i]];\n\n            for (var tileKey in tilesToDraw) {\n              tile = tilesToDraw[tileKey];\n\n              if (!(tile instanceof ImageTile)) {\n                continue;\n              }\n\n              tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);\n              u_tileOffset[0] = 2 * (tileExtent[2] - tileExtent[0]) / framebufferExtentDimension;\n              u_tileOffset[1] = 2 * (tileExtent[3] - tileExtent[1]) / framebufferExtentDimension;\n              u_tileOffset[2] = 2 * (tileExtent[0] - framebufferExtent[0]) / framebufferExtentDimension - 1;\n              u_tileOffset[3] = 2 * (tileExtent[1] - framebufferExtent[1]) / framebufferExtentDimension - 1;\n              gl.uniform4fv(this.locations_.u_tileOffset, u_tileOffset);\n              mapRenderer.bindTileTexture(tile, tilePixelSize, tileGutter * pixelRatio, LINEAR, LINEAR);\n              gl.drawArrays(TRIANGLE_STRIP, 0, 4);\n            }\n          }\n\n          if (allTilesLoaded) {\n            this.renderedTileRange_ = tileRange;\n            this.renderedFramebufferExtent_ = framebufferExtent;\n            this.renderedRevision_ = tileSource.getRevision();\n          } else {\n            this.renderedTileRange_ = null;\n            this.renderedFramebufferExtent_ = null;\n            this.renderedRevision_ = -1;\n            frameState.animate = true;\n          }\n        }\n\n        this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n        var tileTextureQueue = mapRenderer.getTileTextureQueue();\n        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload(),\n        /**\n         * @param {import(\"../../Tile.js\").default} tile Tile.\n         */\n        function (tile) {\n          if (tile.getState() == TileState.LOADED && !mapRenderer.isTileTextureLoaded(tile) && !tileTextureQueue.isKeyQueued(tile.getKey())) {\n            tileTextureQueue.enqueue([tile, tileGrid.getTileCoordCenter(tile.tileCoord), tileGrid.getResolution(tile.tileCoord[0]), tilePixelSize, tileGutter * pixelRatio]);\n          }\n        }, this);\n        this.scheduleExpireCache(frameState, tileSource);\n        var texCoordMatrix = this.texCoordMatrix;\n        reset(texCoordMatrix);\n        translate$1(texCoordMatrix, (Math.round(center[0] / tileResolution) * tileResolution - framebufferExtent[0]) / (framebufferExtent[2] - framebufferExtent[0]), (Math.round(center[1] / tileResolution) * tileResolution - framebufferExtent[1]) / (framebufferExtent[3] - framebufferExtent[1]));\n\n        if (viewState.rotation !== 0) {\n          rotate$2(texCoordMatrix, viewState.rotation);\n        }\n\n        scale$2(texCoordMatrix, frameState.size[0] * viewState.resolution / (framebufferExtent[2] - framebufferExtent[0]), frameState.size[1] * viewState.resolution / (framebufferExtent[3] - framebufferExtent[1]));\n        translate$1(texCoordMatrix, -0.5, -0.5);\n        return true;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLTileLayerRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, callback, thisArg) {\n        if (!this.framebuffer) {\n          return undefined;\n        }\n\n        var pixelOnMapScaled = [pixel[0] / frameState.size[0], (frameState.size[1] - pixel[1]) / frameState.size[1]];\n        var pixelOnFrameBufferScaled = apply(this.texCoordMatrix, pixelOnMapScaled.slice());\n        var pixelOnFrameBuffer = [pixelOnFrameBufferScaled[0] * this.framebufferDimension, pixelOnFrameBufferScaled[1] * this.framebufferDimension];\n        var gl = this.mapRenderer.getContext().getGL();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n        var imageData = new Uint8Array(4);\n        gl.readPixels(pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n\n        if (imageData[3] > 0) {\n          return callback.call(thisArg, this.getLayer(), imageData);\n        } else {\n          return undefined;\n        }\n      };\n\n      return WebGLTileLayerRenderer;\n    }(WebGLLayerRenderer);\n    /**\n     * Determine if this renderer handles the provided layer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n     * @return {boolean} The renderer can render the layer.\n     */\n\n\n    WebGLTileLayerRenderer['handles'] = function (layer) {\n      return layer.getType() === LayerType.TILE;\n    };\n    /**\n     * Create a layer renderer.\n     * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n     * @return {WebGLTileLayerRenderer} The layer renderer.\n     */\n\n\n    WebGLTileLayerRenderer['create'] = function (mapRenderer, layer) {\n      return new WebGLTileLayerRenderer(\n      /** @type {import(\"./Map.js\").default} */\n      mapRenderer,\n      /** @type {import(\"../../layer/Tile.js\").default} */\n      layer);\n    };\n    /**\n     * @module ol/renderer/webgl/VectorLayer\n     */\n\n    /**\n     * @classdesc\n     * WebGL renderer for vector layers.\n     * @api\n     */\n\n\n    var WebGLVectorLayerRenderer =\n    /*@__PURE__*/\n    function (WebGLLayerRenderer$$1) {\n      function WebGLVectorLayerRenderer(mapRenderer, vectorLayer) {\n        WebGLLayerRenderer$$1.call(this, mapRenderer, vectorLayer);\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.dirty_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.renderedRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.renderedResolution_ = NaN;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n\n        this.renderedExtent_ = createEmpty();\n        /**\n         * @private\n         * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n         */\n\n        this.renderedRenderOrder_ = null;\n        /**\n         * @private\n         * @type {import(\"../../render/webgl/ReplayGroup.js\").default}\n         */\n\n        this.replayGroup_ = null;\n        /**\n         * The last layer state.\n         * @private\n         * @type {?import(\"../../layer/Layer.js\").State}\n         */\n\n        this.layerState_ = null;\n      }\n\n      if (WebGLLayerRenderer$$1) WebGLVectorLayerRenderer.__proto__ = WebGLLayerRenderer$$1;\n      WebGLVectorLayerRenderer.prototype = Object.create(WebGLLayerRenderer$$1 && WebGLLayerRenderer$$1.prototype);\n      WebGLVectorLayerRenderer.prototype.constructor = WebGLVectorLayerRenderer;\n      /**\n       * @inheritDoc\n       */\n\n      WebGLVectorLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n        this.layerState_ = layerState;\n        var viewState = frameState.viewState;\n        var replayGroup = this.replayGroup_;\n        var size = frameState.size;\n        var pixelRatio = frameState.pixelRatio;\n        var gl = this.mapRenderer.getGL();\n\n        if (replayGroup && !replayGroup.isEmpty()) {\n          gl.enable(gl.SCISSOR_TEST);\n          gl.scissor(0, 0, size[0] * pixelRatio, size[1] * pixelRatio);\n          replayGroup.replay(context, viewState.center, viewState.resolution, viewState.rotation, size, pixelRatio, layerState.opacity, layerState.managed ? frameState.skippedFeatureUids : {});\n          gl.disable(gl.SCISSOR_TEST);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLVectorLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n        var replayGroup = this.replayGroup_;\n\n        if (replayGroup) {\n          var context = this.mapRenderer.getContext();\n          replayGroup.getDeleteResourcesFunction(context)();\n          this.replayGroup_ = null;\n        }\n\n        WebGLLayerRenderer$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n        if (!this.replayGroup_ || !this.layerState_) {\n          return undefined;\n        } else {\n          var context = this.mapRenderer.getContext();\n          var viewState = frameState.viewState;\n          var layer = this.getLayer();\n          var layerState = this.layerState_;\n          /** @type {!Object<string, boolean>} */\n\n          var features = {};\n          return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, {},\n          /**\n           * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n           * @return {?} Callback result.\n           */\n          function (feature) {\n            var key = getUid(feature);\n\n            if (!(key in features)) {\n              features[key] = true;\n              return callback.call(thisArg, feature, layer);\n            }\n          });\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLVectorLayerRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, frameState) {\n        if (!this.replayGroup_ || !this.layerState_) {\n          return false;\n        } else {\n          var context = this.mapRenderer.getContext();\n          var viewState = frameState.viewState;\n          var layerState = this.layerState_;\n          return this.replayGroup_.hasFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, frameState.skippedFeatureUids);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLVectorLayerRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, callback, thisArg) {\n        var coordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());\n        var hasFeature = this.hasFeatureAtCoordinate(coordinate, frameState);\n\n        if (hasFeature) {\n          return callback.call(thisArg, this.getLayer(), null);\n        } else {\n          return undefined;\n        }\n      };\n      /**\n       * Handle changes in image style state.\n       * @param {import(\"../../events/Event.js\").default} event Image style change event.\n       * @private\n       */\n\n\n      WebGLVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n        this.renderIfReadyAndVisible();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      WebGLVectorLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState, context) {\n        var vectorLayer =\n        /** @type {import(\"../../layer/Vector.js\").default} */\n        this.getLayer();\n        var vectorSource =\n        /** @type {import(\"../../source/Vector.js\").default} */\n        vectorLayer.getSource();\n        var animating = frameState.viewHints[ViewHint.ANIMATING];\n        var interacting = frameState.viewHints[ViewHint.INTERACTING];\n        var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n        var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n        if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {\n          return true;\n        }\n\n        var frameStateExtent = frameState.extent;\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var resolution = viewState.resolution;\n        var pixelRatio = frameState.pixelRatio;\n        var vectorLayerRevision = vectorLayer.getRevision();\n        var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n        var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n        if (vectorLayerRenderOrder === undefined) {\n          vectorLayerRenderOrder = defaultOrder;\n        }\n\n        var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);\n\n        if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.renderedExtent_, extent)) {\n          return true;\n        }\n\n        if (this.replayGroup_) {\n          frameState.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(context));\n        }\n\n        this.dirty_ = false;\n        var replayGroup = new WebGLReplayGroup(getTolerance(resolution, pixelRatio), extent, vectorLayer.getRenderBuffer());\n        vectorSource.loadFeatures(extent, resolution, projection);\n        /**\n         * @param {import(\"../../Feature.js\").default} feature Feature.\n         * @this {WebGLVectorLayerRenderer}\n         */\n\n        var render = function (feature) {\n          var styles;\n          var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n\n          if (styleFunction) {\n            styles = styleFunction(feature, resolution);\n          }\n\n          if (styles) {\n            var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);\n            this.dirty_ = this.dirty_ || dirty;\n          }\n        }.bind(this);\n\n        if (vectorLayerRenderOrder) {\n          /** @type {Array<import(\"../../Feature.js\").default>} */\n          var features = [];\n          vectorSource.forEachFeatureInExtent(extent,\n          /**\n           * @param {import(\"../../Feature.js\").default} feature Feature.\n           */\n          function (feature) {\n            features.push(feature);\n          });\n          features.sort(vectorLayerRenderOrder);\n          features.forEach(render.bind(this));\n        } else {\n          vectorSource.forEachFeatureInExtent(extent, render);\n        }\n\n        replayGroup.finish(context);\n        this.renderedResolution_ = resolution;\n        this.renderedRevision_ = vectorLayerRevision;\n        this.renderedRenderOrder_ = vectorLayerRenderOrder;\n        this.renderedExtent_ = extent;\n        this.replayGroup_ = replayGroup;\n        return true;\n      };\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       * @param {number} resolution Resolution.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of\n       *     styles.\n       * @param {import(\"../../render/webgl/ReplayGroup.js\").default} replayGroup Replay group.\n       * @return {boolean} `true` if an image is loading.\n       */\n\n\n      WebGLVectorLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, resolution, pixelRatio, styles, replayGroup) {\n        if (!styles) {\n          return false;\n        }\n\n        var loading = false;\n\n        if (Array.isArray(styles)) {\n          for (var i = styles.length - 1, ii = 0; i >= ii; --i) {\n            loading = renderFeature(replayGroup, feature, styles[i], getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;\n          }\n        } else {\n          loading = renderFeature(replayGroup, feature, styles, getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;\n        }\n\n        return loading;\n      };\n\n      return WebGLVectorLayerRenderer;\n    }(WebGLLayerRenderer);\n    /**\n     * Determine if this renderer handles the provided layer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n     * @return {boolean} The renderer can render the layer.\n     */\n\n\n    WebGLVectorLayerRenderer['handles'] = function (layer) {\n      return layer.getType() === LayerType.VECTOR;\n    };\n    /**\n     * Create a layer renderer.\n     * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n     * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n     * @return {WebGLVectorLayerRenderer} The layer renderer.\n     */\n\n\n    WebGLVectorLayerRenderer['create'] = function (mapRenderer, layer) {\n      return new WebGLVectorLayerRenderer(\n      /** @type {import(\"./Map.js\").default} */\n      mapRenderer,\n      /** @type {import(\"../../layer/Vector.js\").default} */\n      layer);\n    };\n    /**\n     * @module ol/WebGLMap\n     */\n\n    /**\n     * @classdesc\n     * The WebGLMap uses WebGL for rendering map layers.  This renderer has limited\n     * support for vector data and no support for vector tiles.\n     *\n     *     import WebGLMap from 'ol/WebGLMap';\n     *     import TileLayer from 'ol/layer/Tile';\n     *     import OSM from 'ol/source/OSM';\n     *     import View from 'ol/View';\n     *\n     *     var map = new WebGLMap({\n     *       view: new View({\n     *         center: [0, 0],\n     *         zoom: 1\n     *       }),\n     *       layers: [\n     *         new TileLayer({\n     *           source: new OSM()\n     *         })\n     *       ],\n     *       target: 'map'\n     *     });\n     *\n     * The above snippet creates a map using a {@link module:ol/layer/Tile~Tile} to\n     * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM\n     * element with the id `map`.\n     *\n     * The constructor places a viewport container (with CSS class name\n     * `ol-viewport`) in the target element (see `getViewport()`), and then two\n     * further elements within the viewport: one with CSS class name\n     * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\n     * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\n     * option of {@link module:ol/Overlay~Overlay} for the difference). The map\n     * itself is placed in a further element within the viewport.\n     *\n     * Layers are stored as a {@link module:ol/Collection~Collection} in\n     * layerGroups. A top-level group is provided by the library. This is what is\n     * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the\n     * options are added to this group, and `addLayer` and `removeLayer` change the\n     * layer collection in the group. `getLayers` is a convenience function for\n     * `getLayerGroup().getLayers()`.\n     * Note that {@link module:ol/layer/Group~Group} is a subclass of\n     * {@link module:ol/layer/Base}, so layers entered in the options or added\n     * with `addLayer` can be groups, which can contain further groups, and so on.\n     *\n     * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n     * @fires import(\"./MapEvent.js\").MapEvent\n     * @fires module:ol/render/Event~RenderEvent#postcompose\n     * @fires module:ol/render/Event~RenderEvent#precompose\n     * @api\n     */\n\n\n    var WebGLMap =\n    /*@__PURE__*/\n    function (PluggableMap$$1) {\n      function WebGLMap(options) {\n        options = assign({}, options);\n\n        if (!options.controls) {\n          options.controls = defaults();\n        }\n\n        if (!options.interactions) {\n          options.interactions = defaults$1();\n        }\n\n        PluggableMap$$1.call(this, options);\n      }\n\n      if (PluggableMap$$1) WebGLMap.__proto__ = PluggableMap$$1;\n      WebGLMap.prototype = Object.create(PluggableMap$$1 && PluggableMap$$1.prototype);\n      WebGLMap.prototype.constructor = WebGLMap;\n\n      WebGLMap.prototype.createRenderer = function createRenderer() {\n        var renderer = new WebGLMapRenderer(this);\n        renderer.registerLayerRenderers([WebGLImageLayerRenderer, WebGLTileLayerRenderer, WebGLVectorLayerRenderer]);\n        return renderer;\n      };\n\n      return WebGLMap;\n    }(PluggableMap);\n    /**\n     * @module ol/layer/TileProperty\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var TileProperty = {\n      PRELOAD: 'preload',\n      USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'\n    };\n    /**\n     * @module ol/layer/Tile\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {number} [opacity=1] Opacity (0, 1).\n     * @property {boolean} [visible=true] Visibility.\n     * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n     * rendered outside of this extent.\n     * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n     * method was used.\n     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n     * visible.\n     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n     * be visible.\n     * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n     * means no preloading.\n     * @property {import(\"../source/Tile.js\").default} [source] Source for this layer.\n     * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n     * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n     * use {@link module:ol/Map#addLayer}.\n     * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n     */\n\n    /**\n     * @classdesc\n     * For layer sources that provide pre-rendered, tiled images in grids that are\n     * organized by zoom levels for specific resolutions.\n     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n     * property on the layer object; for example, setting `title: 'My Title'` in the\n     * options means that `title` is observable, and has get/set accessors.\n     *\n     * @api\n     */\n\n    var TileLayer =\n    /*@__PURE__*/\n    function (Layer$$1) {\n      function TileLayer(opt_options) {\n        var options = opt_options ? opt_options : {};\n        var baseOptions = assign({}, options);\n        delete baseOptions.preload;\n        delete baseOptions.useInterimTilesOnError;\n        Layer$$1.call(this, baseOptions);\n        this.setPreload(options.preload !== undefined ? options.preload : 0);\n        this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);\n        /**\n        * The layer type.\n        * @protected\n        * @type {import(\"../LayerType.js\").default}\n        */\n\n        this.type = LayerType.TILE;\n      }\n\n      if (Layer$$1) TileLayer.__proto__ = Layer$$1;\n      TileLayer.prototype = Object.create(Layer$$1 && Layer$$1.prototype);\n      TileLayer.prototype.constructor = TileLayer;\n      /**\n      * Return the level as number to which we will preload tiles up to.\n      * @return {number} The level to preload tiles up to.\n      * @observable\n      * @api\n      */\n\n      TileLayer.prototype.getPreload = function getPreload() {\n        return (\n          /** @type {number} */\n          this.get(TileProperty.PRELOAD)\n        );\n      };\n      /**\n      * Set the level as number to which we will preload tiles up to.\n      * @param {number} preload The level to preload tiles up to.\n      * @observable\n      * @api\n      */\n\n\n      TileLayer.prototype.setPreload = function setPreload(preload) {\n        this.set(TileProperty.PRELOAD, preload);\n      };\n      /**\n      * Whether we use interim tiles on error.\n      * @return {boolean} Use interim tiles on error.\n      * @observable\n      * @api\n      */\n\n\n      TileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError() {\n        return (\n          /** @type {boolean} */\n          this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n        );\n      };\n      /**\n      * Set whether we use interim tiles on error.\n      * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n      * @observable\n      * @api\n      */\n\n\n      TileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError(useInterimTilesOnError) {\n        this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n      };\n\n      return TileLayer;\n    }(Layer);\n    /**\n     * Return the associated {@link module:ol/source/Tile tilesource} of the layer.\n     * @function\n     * @return {import(\"../source/Tile.js\").default} Source.\n     * @api\n     */\n\n\n    TileLayer.prototype.getSource;\n    /**\n     * @module ol/reproj\n     */\n\n    /**\n     * Calculates ideal resolution to use from the source in order to achieve\n     * pixel mapping as close as possible to 1:1 during reprojection.\n     * The resolution is calculated regardless of what resolutions\n     * are actually available in the dataset (TileGrid, Image, ...).\n     *\n     * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n     * @param {number} targetResolution Target resolution.\n     * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n     */\n\n    function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n      var sourceCenter = transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data\n\n      var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n      var targetMetersPerUnit = targetProj.getMetersPerUnit();\n\n      if (targetMetersPerUnit !== undefined) {\n        sourceResolution *= targetMetersPerUnit;\n      }\n\n      var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n\n      if (sourceMetersPerUnit !== undefined) {\n        sourceResolution /= sourceMetersPerUnit;\n      } // Based on the projection properties, the point resolution at the specified\n      // coordinates may be slightly different. We need to reverse-compensate this\n      // in order to achieve optimal results.\n\n\n      var sourceExtent = sourceProj.getExtent();\n\n      if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n        var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n\n        if (isFinite(compensationFactor) && compensationFactor > 0) {\n          sourceResolution /= compensationFactor;\n        }\n      }\n\n      return sourceResolution;\n    }\n    /**\n     * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n     * in order to mask gaps caused by antialiasing.\n     *\n     * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n     * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n     * @param {number} x X coordinate of the point (in pixels).\n     * @param {number} y Y coordinate of the point (in pixels).\n     * @return {import(\"./coordinate.js\").Coordinate} New point 1 px farther from the centroid.\n     */\n\n\n    function enlargeClipPoint(centroidX, centroidY, x, y) {\n      var dX = x - centroidX;\n      var dY = y - centroidY;\n      var distance = Math.sqrt(dX * dX + dY * dY);\n      return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n    }\n    /**\n     * Renders the source data into new canvas based on the triangulation.\n     *\n     * @param {number} width Width of the canvas.\n     * @param {number} height Height of the canvas.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} sourceResolution Source resolution.\n     * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n     * @param {number} targetResolution Target resolution.\n     * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n     * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n     * Calculated triangulation.\n     * @param {Array<{extent: import(\"./extent.js\").Extent,\n     *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n     * Array of sources.\n     * @param {number} gutter Gutter of the sources.\n     * @param {boolean=} opt_renderEdges Render reprojection edges.\n     * @return {HTMLCanvasElement} Canvas with reprojected data.\n     */\n\n\n    function render$6(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {\n      var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n\n      if (sources.length === 0) {\n        return context.canvas;\n      }\n\n      context.scale(pixelRatio, pixelRatio);\n      var sourceDataExtent = createEmpty();\n      sources.forEach(function (src, i, arr) {\n        extend$1(sourceDataExtent, src.extent);\n      });\n      var canvasWidthInUnits = getWidth(sourceDataExtent);\n      var canvasHeightInUnits = getHeight(sourceDataExtent);\n      var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n      var stitchScale = pixelRatio / sourceResolution;\n      sources.forEach(function (src, i, arr) {\n        var xPos = src.extent[0] - sourceDataExtent[0];\n        var yPos = -(src.extent[3] - sourceDataExtent[3]);\n        var srcWidth = getWidth(src.extent);\n        var srcHeight = getHeight(src.extent);\n        stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n      });\n      var targetTopLeft = getTopLeft(targetExtent);\n      triangulation.getTriangles().forEach(function (triangle, i, arr) {\n        /* Calculate affine transform (src -> dst)\n         * Resulting matrix can be used to transform coordinate\n         * from `sourceProjection` to destination pixels.\n         *\n         * To optimize number of context calls and increase numerical stability,\n         * we also do the following operations:\n         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n         * here before solving the linear system so [ui, vi] are pixel coordinates.\n         *\n         * Src points: xi, yi\n         * Dst points: ui, vi\n         * Affine coefficients: aij\n         *\n         * | x0 y0 1  0  0 0 |   |a00|   |u0|\n         * | x1 y1 1  0  0 0 |   |a01|   |u1|\n         * | x2 y2 1  0  0 0 | x |a02| = |u2|\n         * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n         * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n         * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n         */\n        var source = triangle.source;\n        var target = triangle.target;\n        var x0 = source[0][0],\n            y0 = source[0][1];\n        var x1 = source[1][0],\n            y1 = source[1][1];\n        var x2 = source[2][0],\n            y2 = source[2][1];\n        var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n        var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n        var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n        var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n        var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n        var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability\n        // of all the subsequent calculations. The [x0, y0] is used here.\n        // This is also used to simplify the linear system.\n\n        var sourceNumericalShiftX = x0;\n        var sourceNumericalShiftY = y0;\n        x0 = 0;\n        y0 = 0;\n        x1 -= sourceNumericalShiftX;\n        y1 -= sourceNumericalShiftY;\n        x2 -= sourceNumericalShiftX;\n        y2 -= sourceNumericalShiftY;\n        var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n        var affineCoefs = solveLinearSystem(augmentedMatrix);\n\n        if (!affineCoefs) {\n          return;\n        }\n\n        context.save();\n        context.beginPath();\n        var centroidX = (u0 + u1 + u2) / 3;\n        var centroidY = (v0 + v1 + v2) / 3;\n        var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n        var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n        var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n        context.moveTo(p1[0], p1[1]);\n        context.lineTo(p0[0], p0[1]);\n        context.lineTo(p2[0], p2[1]);\n        context.clip();\n        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n        context.drawImage(stitchContext.canvas, 0, 0);\n        context.restore();\n      });\n\n      if (opt_renderEdges) {\n        context.save();\n        context.strokeStyle = 'black';\n        context.lineWidth = 1;\n        triangulation.getTriangles().forEach(function (triangle, i, arr) {\n          var target = triangle.target;\n          var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n          var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n          var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n          var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n          var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n          var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n          context.beginPath();\n          context.moveTo(u1, v1);\n          context.lineTo(u0, v0);\n          context.lineTo(u2, v2);\n          context.closePath();\n          context.stroke();\n        });\n        context.restore();\n      }\n\n      return context.canvas;\n    }\n    /**\n     * @module ol/reproj/Triangulation\n     */\n\n    /**\n     * Single triangle; consists of 3 source points and 3 target points.\n     * @typedef {Object} Triangle\n     * @property {Array<import(\"../coordinate.js\").Coordinate>} source\n     * @property {Array<import(\"../coordinate.js\").Coordinate>} target\n     */\n\n    /**\n     * Maximum number of subdivision steps during raster reprojection triangulation.\n     * Prevents high memory usage and large number of proj4 calls (for certain\n     * transformations and areas). At most `2*(2^this)` triangles are created for\n     * each triangulated extent (tile/image).\n     * @type {number}\n     */\n\n\n    var MAX_SUBDIVISION = 10;\n    /**\n     * Maximum allowed size of triangle relative to world width. When transforming\n     * corners of world extent between certain projections, the resulting\n     * triangulation seems to have zero error and no subdivision is performed. If\n     * the triangle width is more than this (relative to world width; 0-1),\n     * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n     * @type {number}\n     */\n\n    var MAX_TRIANGLE_WIDTH = 0.25;\n    /**\n     * @classdesc\n     * Class containing triangulation of the given target extent.\n     * Used for determining source data and the reprojection itself.\n     */\n\n    var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       * @private\n       */\n      this.sourceProj_ = sourceProj;\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       * @private\n       */\n\n      this.targetProj_ = targetProj;\n      /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n\n      var transformInvCache = {};\n      var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n      /**\n       * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n       * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n       * @private\n       */\n\n      this.transformInv_ = function (c) {\n        var key = c[0] + '/' + c[1];\n\n        if (!transformInvCache[key]) {\n          transformInvCache[key] = transformInv(c);\n        }\n\n        return transformInvCache[key];\n      };\n      /**\n       * @type {import(\"../extent.js\").Extent}\n       * @private\n       */\n\n\n      this.maxSourceExtent_ = maxSourceExtent;\n      /**\n       * @type {number}\n       * @private\n       */\n\n      this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n      /**\n       * @type {Array<Triangle>}\n       * @private\n       */\n\n      this.triangles_ = [];\n      /**\n       * Indicates that the triangulation crosses edge of the source projection.\n       * @type {boolean}\n       * @private\n       */\n\n      this.wrapsXInSource_ = false;\n      /**\n       * @type {boolean}\n       * @private\n       */\n\n      this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n      /**\n       * @type {?number}\n       * @private\n       */\n\n      this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n      /**\n       * @type {?number}\n       * @private\n       */\n\n      this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n      var destinationTopLeft = getTopLeft(targetExtent);\n      var destinationTopRight = getTopRight(targetExtent);\n      var destinationBottomRight = getBottomRight(targetExtent);\n      var destinationBottomLeft = getBottomLeft(targetExtent);\n      var sourceTopLeft = this.transformInv_(destinationTopLeft);\n      var sourceTopRight = this.transformInv_(destinationTopRight);\n      var sourceBottomRight = this.transformInv_(destinationBottomRight);\n      var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n      this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, MAX_SUBDIVISION);\n\n      if (this.wrapsXInSource_) {\n        var leftBound = Infinity;\n        this.triangles_.forEach(function (triangle, i, arr) {\n          leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n        }); // Shift triangles to be as close to `leftBound` as possible\n        // (if the distance is more than `worldWidth / 2` it can be closer.\n\n        this.triangles_.forEach(function (triangle) {\n          if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n            var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n\n            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[0][0] -= this.sourceWorldWidth_;\n            }\n\n            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[1][0] -= this.sourceWorldWidth_;\n            }\n\n            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[2][0] -= this.sourceWorldWidth_;\n            } // Rarely (if the extent contains both the dateline and prime meridian)\n            // the shift can in turn break some triangles.\n            // Detect this here and don't shift in such cases.\n\n\n            var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n            var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n\n            if (maxX - minX < this.sourceWorldWidth_ / 2) {\n              triangle.source = newTriangle;\n            }\n          }\n        }.bind(this));\n      }\n\n      transformInvCache = {};\n    };\n    /**\n     * Adds triangle to the triangulation.\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @private\n     */\n\n\n    Triangulation.prototype.addTriangle_ = function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n      this.triangles_.push({\n        source: [aSrc, bSrc, cSrc],\n        target: [a, b, c]\n      });\n    };\n    /**\n     * Adds quad (points in clock-wise order) to the triangulation\n     * (and reprojects the vertices) if valid.\n     * Performs quad subdivision if needed to increase precision.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n     * @private\n     */\n\n\n    Triangulation.prototype.addQuad_ = function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n      var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n      var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n      var sourceWorldWidth =\n      /** @type {number} */\n      this.sourceWorldWidth_; // when the quad is wrapped in the source projection\n      // it covers most of the projection extent, but not fully\n\n      var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n      var needsSubdivision = false;\n\n      if (maxSubdivision > 0) {\n        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n          var targetQuadExtent = boundingExtent([a, b, c, d]);\n          var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n          needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n        }\n\n        if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n          needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n        }\n      }\n\n      if (!needsSubdivision && this.maxSourceExtent_) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n\n      if (!needsSubdivision) {\n        if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n          if (maxSubdivision > 0) {\n            needsSubdivision = true;\n          } else {\n            return;\n          }\n        }\n      }\n\n      if (maxSubdivision > 0) {\n        if (!needsSubdivision) {\n          var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n          var centerSrc = this.transformInv_(center);\n          var dx;\n\n          if (wrapsX) {\n            var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n            dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n          } else {\n            dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n          }\n\n          var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n          var centerSrcErrorSquared = dx * dx + dy * dy;\n          needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n        }\n\n        if (needsSubdivision) {\n          if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n            // split horizontally (top & bottom)\n            var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n            var bcSrc = this.transformInv_(bc);\n            var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n            var daSrc = this.transformInv_(da);\n            this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n            this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n          } else {\n            // split vertically (left & right)\n            var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n            var abSrc = this.transformInv_(ab);\n            var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n            var cdSrc = this.transformInv_(cd);\n            this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n            this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n          }\n\n          return;\n        }\n      }\n\n      if (wrapsX) {\n        if (!this.canWrapXInSource_) {\n          return;\n        }\n\n        this.wrapsXInSource_ = true;\n      }\n\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n      this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n    };\n    /**\n     * Calculates extent of the 'source' coordinates from all the triangles.\n     *\n     * @return {import(\"../extent.js\").Extent} Calculated extent.\n     */\n\n\n    Triangulation.prototype.calculateSourceExtent = function calculateSourceExtent() {\n      var extent = createEmpty();\n      this.triangles_.forEach(function (triangle, i, arr) {\n        var src = triangle.source;\n        extendCoordinate(extent, src[0]);\n        extendCoordinate(extent, src[1]);\n        extendCoordinate(extent, src[2]);\n      });\n      return extent;\n    };\n    /**\n     * @return {Array<Triangle>} Array of the calculated triangles.\n     */\n\n\n    Triangulation.prototype.getTriangles = function getTriangles() {\n      return this.triangles_;\n    };\n    /**\n     * @module ol/reproj/Tile\n     */\n\n    /**\n     * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n     */\n\n    /**\n     * @classdesc\n     * Class encapsulating single reprojected tile.\n     * See {@link module:ol/source/TileImage~TileImage}.\n     *\n     */\n\n\n    var ReprojTile =\n    /*@__PURE__*/\n    function (Tile$$1) {\n      function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n        Tile$$1.call(this, tileCoord, TileState.IDLE);\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n\n        this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n\n        this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n\n        this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n\n        this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n\n        this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         */\n\n        this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n\n        this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n        var maxTargetExtent = this.targetTileGrid_.getExtent();\n        var maxSourceExtent = this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n        if (getArea(limitedTargetExtent) === 0) {\n          // Tile is completely outside range -> EMPTY\n          // TODO: is it actually correct that the source even creates the tile ?\n          this.state = TileState.EMPTY;\n          return;\n        }\n\n        var sourceProjExtent = sourceProj.getExtent();\n\n        if (sourceProjExtent) {\n          if (!maxSourceExtent) {\n            maxSourceExtent = sourceProjExtent;\n          } else {\n            maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n          }\n        }\n\n        var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n        var targetCenter = getCenter(limitedTargetExtent);\n        var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n          // invalid sourceResolution -> EMPTY\n          // probably edges of the projections when no extent is defined\n          this.state = TileState.EMPTY;\n          return;\n        }\n\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n\n        this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n\n        if (this.triangulation_.getTriangles().length === 0) {\n          // no valid triangles -> EMPTY\n          this.state = TileState.EMPTY;\n          return;\n        }\n\n        this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n        if (maxSourceExtent) {\n          if (sourceProj.canWrapX()) {\n            sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n            sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n          } else {\n            sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n          }\n        }\n\n        if (!getArea(sourceExtent)) {\n          this.state = TileState.EMPTY;\n        } else {\n          var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);\n\n          for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n            for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n              var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n\n              if (tile) {\n                this.sourceTiles_.push(tile);\n              }\n            }\n          }\n\n          if (this.sourceTiles_.length === 0) {\n            this.state = TileState.EMPTY;\n          }\n        }\n      }\n\n      if (Tile$$1) ReprojTile.__proto__ = Tile$$1;\n      ReprojTile.prototype = Object.create(Tile$$1 && Tile$$1.prototype);\n      ReprojTile.prototype.constructor = ReprojTile;\n      /**\n       * @inheritDoc\n       */\n\n      ReprojTile.prototype.disposeInternal = function disposeInternal() {\n        if (this.state == TileState.LOADING) {\n          this.unlistenSources_();\n        }\n\n        Tile$$1.prototype.disposeInternal.call(this);\n      };\n      /**\n       * Get the HTML Canvas element for this tile.\n       * @return {HTMLCanvasElement} Canvas.\n       */\n\n\n      ReprojTile.prototype.getImage = function getImage() {\n        return this.canvas_;\n      };\n      /**\n       * @private\n       */\n\n\n      ReprojTile.prototype.reproject_ = function reproject_() {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          if (tile && tile.getState() == TileState.LOADED) {\n            sources.push({\n              extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n              image: tile.getImage()\n            });\n          }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n\n        if (sources.length === 0) {\n          this.state = TileState.ERROR;\n        } else {\n          var z = this.wrappedTileCoord_[0];\n          var size = this.targetTileGrid_.getTileSize(z);\n          var width = typeof size === 'number' ? size : size[0];\n          var height = typeof size === 'number' ? size : size[1];\n          var targetResolution = this.targetTileGrid_.getResolution(z);\n          var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n          var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n          this.canvas_ = render$6(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n          this.state = TileState.LOADED;\n        }\n\n        this.changed();\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      ReprojTile.prototype.load = function load() {\n        if (this.state == TileState.IDLE) {\n          this.state = TileState.LOADING;\n          this.changed();\n          var leftToLoad = 0;\n          this.sourcesListenerKeys_ = [];\n          this.sourceTiles_.forEach(function (tile, i, arr) {\n            var state = tile.getState();\n\n            if (state == TileState.IDLE || state == TileState.LOADING) {\n              leftToLoad++;\n              var sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n                var state = tile.getState();\n\n                if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n                  unlistenByKey(sourceListenKey);\n                  leftToLoad--;\n\n                  if (leftToLoad === 0) {\n                    this.unlistenSources_();\n                    this.reproject_();\n                  }\n                }\n              }, this);\n              this.sourcesListenerKeys_.push(sourceListenKey);\n            }\n          }.bind(this));\n          this.sourceTiles_.forEach(function (tile, i, arr) {\n            var state = tile.getState();\n\n            if (state == TileState.IDLE) {\n              tile.load();\n            }\n          });\n\n          if (leftToLoad === 0) {\n            setTimeout(this.reproject_.bind(this), 0);\n          }\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      ReprojTile.prototype.unlistenSources_ = function unlistenSources_() {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n      };\n\n      return ReprojTile;\n    }(Tile);\n    /**\n     * @module ol/tileurlfunction\n     */\n\n    /**\n     * @param {string} template Template.\n     * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n     */\n\n\n    function createFromTemplate(template, tileGrid) {\n      var zRegEx = /\\{z\\}/g;\n      var xRegEx = /\\{x\\}/g;\n      var yRegEx = /\\{y\\}/g;\n      var dashYRegEx = /\\{-y\\}/g;\n      return (\n        /**\n         * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n         * @param {number} pixelRatio Pixel ratio.\n         * @param {import(\"./proj/Projection.js\").default} projection Projection.\n         * @return {string|undefined} Tile URL.\n         */\n        function (tileCoord, pixelRatio, projection) {\n          if (!tileCoord) {\n            return undefined;\n          } else {\n            return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function () {\n              var y = -tileCoord[2] - 1;\n              return y.toString();\n            }).replace(dashYRegEx, function () {\n              var z = tileCoord[0];\n              var range = tileGrid.getFullTileRange(z);\n              assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n\n              var y = range.getHeight() + tileCoord[2];\n              return y.toString();\n            });\n          }\n        }\n      );\n    }\n    /**\n     * @param {Array<string>} templates Templates.\n     * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n     */\n\n\n    function createFromTemplates(templates, tileGrid) {\n      var len = templates.length;\n      var tileUrlFunctions = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n      }\n\n      return createFromTileUrlFunctions(tileUrlFunctions);\n    }\n    /**\n     * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n     * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n     */\n\n\n    function createFromTileUrlFunctions(tileUrlFunctions) {\n      if (tileUrlFunctions.length === 1) {\n        return tileUrlFunctions[0];\n      }\n\n      return (\n        /**\n         * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n         * @param {number} pixelRatio Pixel ratio.\n         * @param {import(\"./proj/Projection.js\").default} projection Projection.\n         * @return {string|undefined} Tile URL.\n         */\n        function (tileCoord, pixelRatio, projection) {\n          if (!tileCoord) {\n            return undefined;\n          } else {\n            var h = hash(tileCoord);\n            var index = modulo(h, tileUrlFunctions.length);\n            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n          }\n        }\n      );\n    }\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n\n\n    function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n      return undefined;\n    }\n    /**\n     * @param {string} url URL.\n     * @return {Array<string>} Array of urls.\n     */\n\n\n    function expandUrl(url) {\n      var urls = [];\n      var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n\n      if (match) {\n        // char range\n        var startCharCode = match[1].charCodeAt(0);\n        var stopCharCode = match[2].charCodeAt(0);\n        var charCode;\n\n        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n          urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n        }\n\n        return urls;\n      }\n\n      match = match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n\n      if (match) {\n        // number range\n        var stop = parseInt(match[2], 10);\n\n        for (var i = parseInt(match[1], 10); i <= stop; i++) {\n          urls.push(url.replace(match[0], i.toString()));\n        }\n\n        return urls;\n      }\n\n      urls.push(url);\n      return urls;\n    }\n    /**\n     * @module ol/source/TileEventType\n     */\n\n    /**\n     * @enum {string}\n     */\n\n\n    var TileEventType = {\n      /**\n       * Triggered when a tile starts loading.\n       * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n       * @api\n       */\n      TILELOADSTART: 'tileloadstart',\n\n      /**\n       * Triggered when a tile finishes loading, either when its data is loaded,\n       * or when loading was aborted because the tile is no longer needed.\n       * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n       * @api\n       */\n      TILELOADEND: 'tileloadend',\n\n      /**\n       * Triggered if tile loading results in an error.\n       * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n       * @api\n       */\n      TILELOADERROR: 'tileloaderror'\n    };\n    /**\n     * @module ol/source/UrlTile\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"./Source.js\").AttributionLike} [attributions]\n     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n     * @property {number} [cacheSize]\n     * @property {boolean} [opaque]\n     * @property {import(\"../proj.js\").ProjectionLike} [projection]\n     * @property {import(\"./State.js\").default} [state]\n     * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n     * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction\n     * @property {number} [tilePixelRatio]\n     * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction]\n     * @property {string} [url]\n     * @property {Array<string>} [urls]\n     * @property {boolean} [wrapX=true]\n     * @property {number} [transition]\n     * @property {string} [key]\n     */\n\n    /**\n     * @classdesc\n     * Base class for sources providing tiles divided into a tile grid over http.\n     *\n     * @fires import(\"./Tile.js\").TileSourceEvent\n     */\n\n    var UrlTile =\n    /*@__PURE__*/\n    function (TileSource$$1) {\n      function UrlTile(options) {\n        TileSource$$1.call(this, {\n          attributions: options.attributions,\n          cacheSize: options.cacheSize,\n          opaque: options.opaque,\n          projection: options.projection,\n          state: options.state,\n          tileGrid: options.tileGrid,\n          tilePixelRatio: options.tilePixelRatio,\n          wrapX: options.wrapX,\n          transition: options.transition,\n          key: options.key,\n          attributionsCollapsible: options.attributionsCollapsible\n        });\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.generateTileUrlFunction_ = !options.tileUrlFunction;\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").LoadFunction}\n         */\n\n        this.tileLoadFunction = options.tileLoadFunction;\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").UrlFunction}\n         */\n\n        this.tileUrlFunction = options.tileUrlFunction ? options.tileUrlFunction.bind(this) : nullTileUrlFunction;\n        /**\n         * @protected\n         * @type {!Array<string>|null}\n         */\n\n        this.urls = null;\n\n        if (options.urls) {\n          this.setUrls(options.urls);\n        } else if (options.url) {\n          this.setUrl(options.url);\n        }\n\n        if (options.tileUrlFunction) {\n          this.setTileUrlFunction(options.tileUrlFunction, this.key_);\n        }\n        /**\n         * @private\n         * @type {!Object<string, boolean>}\n         */\n\n\n        this.tileLoadingKeys_ = {};\n      }\n\n      if (TileSource$$1) UrlTile.__proto__ = TileSource$$1;\n      UrlTile.prototype = Object.create(TileSource$$1 && TileSource$$1.prototype);\n      UrlTile.prototype.constructor = UrlTile;\n      /**\n       * Return the tile load function of the source.\n       * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n       * @api\n       */\n\n      UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction() {\n        return this.tileLoadFunction;\n      };\n      /**\n       * Return the tile URL function of the source.\n       * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n       * @api\n       */\n\n\n      UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction() {\n        return this.tileUrlFunction;\n      };\n      /**\n       * Return the URLs used for this source.\n       * When a tileUrlFunction is used instead of url or urls,\n       * null will be returned.\n       * @return {!Array<string>|null} URLs.\n       * @api\n       */\n\n\n      UrlTile.prototype.getUrls = function getUrls() {\n        return this.urls;\n      };\n      /**\n       * Handle tile change events.\n       * @param {import(\"../events/Event.js\").default} event Event.\n       * @protected\n       */\n\n\n      UrlTile.prototype.handleTileChange = function handleTileChange(event) {\n        var tile =\n        /** @type {import(\"../Tile.js\").default} */\n        event.target;\n        var uid = getUid(tile);\n        var tileState = tile.getState();\n        var type;\n\n        if (tileState == TileState.LOADING) {\n          this.tileLoadingKeys_[uid] = true;\n          type = TileEventType.TILELOADSTART;\n        } else if (uid in this.tileLoadingKeys_) {\n          delete this.tileLoadingKeys_[uid];\n          type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED || tileState == TileState.ABORT ? TileEventType.TILELOADEND : undefined;\n        }\n\n        if (type != undefined) {\n          this.dispatchEvent(new TileSourceEvent(type, tile));\n        }\n      };\n      /**\n       * Set the tile load function of the source.\n       * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n       * @api\n       */\n\n\n      UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction(tileLoadFunction) {\n        this.tileCache.clear();\n        this.tileLoadFunction = tileLoadFunction;\n        this.changed();\n      };\n      /**\n       * Set the tile URL function of the source.\n       * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n       * @param {string=} key Optional new tile key for the source.\n       * @api\n       */\n\n\n      UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction(tileUrlFunction, key) {\n        this.tileUrlFunction = tileUrlFunction;\n        this.tileCache.pruneExceptNewestZ();\n\n        if (typeof key !== 'undefined') {\n          this.setKey(key);\n        } else {\n          this.changed();\n        }\n      };\n      /**\n       * Set the URL to use for requests.\n       * @param {string} url URL.\n       * @api\n       */\n\n\n      UrlTile.prototype.setUrl = function setUrl(url) {\n        var urls = this.urls = expandUrl(url);\n        this.setUrls(urls);\n      };\n      /**\n       * Set the URLs to use for requests.\n       * @param {Array<string>} urls URLs.\n       * @api\n       */\n\n\n      UrlTile.prototype.setUrls = function setUrls(urls) {\n        this.urls = urls;\n        var key = urls.join('\\n');\n\n        if (this.generateTileUrlFunction_) {\n          this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n        } else {\n          this.setKey(key);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      UrlTile.prototype.useTile = function useTile(z, x, y) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n\n        if (this.tileCache.containsKey(tileCoordKey)) {\n          this.tileCache.get(tileCoordKey);\n        }\n      };\n\n      return UrlTile;\n    }(TileSource);\n    /**\n     * @module ol/source/TileImage\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n     * @property {number} [cacheSize=2048] Cache size.\n     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n     * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n     * access pixel data with the Canvas renderer.  See\n     * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n     * @property {boolean} [opaque=true] Whether the layer is opaque.\n     * @property {import(\"../proj.js\").ProjectionLike} projection Projection.\n     * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n     * Higher values can increase reprojection performance, but decrease precision.\n     * @property {import(\"./State.js\").default} [state] Source state.\n     * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n     * Default is {@link module:ol/ImageTile~ImageTile}.\n     * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n     * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n     * ```js\n     * function(imageTile, src) {\n     *   imageTile.getImage().src = src;\n     * };\n     * ```\n     * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n     * service advertizes 256px by 256px tiles but actually sends 512px\n     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n     * should be set to `2`.\n     * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n     * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n     * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n     * used instead of defining each one separately in the `urls` option.\n     * @property {Array<string>} [urls] An array of URL templates.\n     * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n     * request out-of-bounds tiles from the server. When set to `false`, only one\n     * world will be rendered. When set to `true`, tiles will be requested for one\n     * world only, but they will be wrapped horizontally to render multiple worlds.\n     * @property {number} [transition] Duration of the opacity transition for rendering.\n     * To disable the opacity transition, pass `transition: 0`.\n     * @property {string} [key] Optional tile key for proper cache fetching\n     */\n\n    /**\n     * @classdesc\n     * Base class for sources providing images divided into a tile grid.\n     *\n     * @fires import(\"./Tile.js\").TileSourceEvent\n     * @api\n     */\n\n\n    var TileImage =\n    /*@__PURE__*/\n    function (UrlTile$$1) {\n      function TileImage(options) {\n        UrlTile$$1.call(this, {\n          attributions: options.attributions,\n          cacheSize: options.cacheSize,\n          opaque: options.opaque,\n          projection: options.projection,\n          state: options.state,\n          tileGrid: options.tileGrid,\n          tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,\n          tilePixelRatio: options.tilePixelRatio,\n          tileUrlFunction: options.tileUrlFunction,\n          url: options.url,\n          urls: options.urls,\n          wrapX: options.wrapX,\n          transition: options.transition,\n          key: options.key,\n          attributionsCollapsible: options.attributionsCollapsible\n        });\n        /**\n         * @protected\n         * @type {?string}\n         */\n\n        this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;\n        /**\n         * @protected\n         * @type {typeof ImageTile}\n         */\n\n        this.tileClass = options.tileClass !== undefined ? options.tileClass : ImageTile;\n        /**\n         * @protected\n         * @type {!Object<string, TileCache>}\n         */\n\n        this.tileCacheForProjection = {};\n        /**\n         * @protected\n         * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n         */\n\n        this.tileGridForProjection = {};\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n\n        this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n        /**\n         * @private\n         * @type {boolean}\n         */\n\n        this.renderReprojectionEdges_ = false;\n      }\n\n      if (UrlTile$$1) TileImage.__proto__ = UrlTile$$1;\n      TileImage.prototype = Object.create(UrlTile$$1 && UrlTile$$1.prototype);\n      TileImage.prototype.constructor = TileImage;\n      /**\n       * @inheritDoc\n       */\n\n      TileImage.prototype.canExpireCache = function canExpireCache() {\n        if (this.tileCache.canExpireCache()) {\n          return true;\n        } else {\n          for (var key in this.tileCacheForProjection) {\n            if (this.tileCacheForProjection[key].canExpireCache()) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileImage.prototype.expireCache = function expireCache(projection, usedTiles) {\n        var usedTileCache = this.getTileCacheForProjection(projection);\n        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n\n        for (var id in this.tileCacheForProjection) {\n          var tileCache = this.tileCacheForProjection[id];\n          tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileImage.prototype.getGutterForProjection = function getGutterForProjection(projection) {\n        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n          return 0;\n        } else {\n          return this.getGutter();\n        }\n      };\n      /**\n       * @return {number} Gutter.\n       */\n\n\n      TileImage.prototype.getGutter = function getGutter() {\n        return 0;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileImage.prototype.getOpaque = function getOpaque(projection) {\n        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n          return false;\n        } else {\n          return UrlTile$$1.prototype.getOpaque.call(this, projection);\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1(projection) {\n        var thisProj = this.getProjection();\n\n        if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n          return this.tileGrid;\n        } else {\n          var projKey = getUid(projection);\n\n          if (!(projKey in this.tileGridForProjection)) {\n            this.tileGridForProjection[projKey] = getForProjection(projection);\n          }\n\n          return (\n            /** @type {!import(\"../tilegrid/TileGrid.js\").default} */\n            this.tileGridForProjection[projKey]\n          );\n        }\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection(projection) {\n        var thisProj = this.getProjection();\n\n        if (!thisProj || equivalent(thisProj, projection)) {\n          return this.tileCache;\n        } else {\n          var projKey = getUid(projection);\n\n          if (!(projKey in this.tileCacheForProjection)) {\n            this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);\n          }\n\n          return this.tileCacheForProjection[projKey];\n        }\n      };\n      /**\n       * @param {number} z Tile coordinate z.\n       * @param {number} x Tile coordinate x.\n       * @param {number} y Tile coordinate y.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @param {string} key The key set on the tile.\n       * @return {!import(\"../Tile.js\").default} Tile.\n       * @private\n       */\n\n\n      TileImage.prototype.createTile_ = function createTile_(z, x, y, pixelRatio, projection, key) {\n        var tileCoord = [z, x, y];\n        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;\n        var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);\n        tile.key = key;\n        listen(tile, EventType.CHANGE, this.handleTileChange, this);\n        return tile;\n      };\n      /**\n       * @inheritDoc\n       */\n\n\n      TileImage.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n        var sourceProjection =\n        /** @type {!import(\"../proj/Projection.js\").default} */\n        this.getProjection();\n\n        if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {\n          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\n        } else {\n          var cache = this.getTileCacheForProjection(projection);\n          var tileCoord = [z, x, y];\n          var tile;\n          var tileCoordKey = getKey$1(tileCoord);\n\n          if (cache.containsKey(tileCoordKey)) {\n            tile =\n            /** @type {!import(\"../Tile.js\").default} */\n            cache.get(tileCoordKey);\n          }\n\n          var key = this.getKey();\n\n          if (tile && tile.key == key) {\n            return tile;\n          } else {\n            var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n            var targetTileGrid = this.getTileGridForProjection(projection);\n            var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n            var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {\n              return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n            }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);\n            newTile.key = key;\n\n            if (tile) {\n              newTile.interimTile = tile;\n              newTile.refreshInterimChain();\n              cache.replace(tileCoordKey, newTile);\n            } else {\n              cache.set(tileCoordKey, newTile);\n            }\n\n            return newTile;\n          }\n        }\n      };\n      /**\n       * @param {number} z Tile coordinate z.\n       * @param {number} x Tile coordinate x.\n       * @param {number} y Tile coordinate y.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {!import(\"../Tile.js\").default} Tile.\n       * @protected\n       */\n\n\n      TileImage.prototype.getTileInternal = function getTileInternal(z, x, y, pixelRatio, projection) {\n        var tile = null;\n        var tileCoordKey = getKeyZXY(z, x, y);\n        var key = this.getKey();\n\n        if (!this.tileCache.containsKey(tileCoordKey)) {\n          tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n          this.tileCache.set(tileCoordKey, tile);\n        } else {\n          tile = this.tileCache.get(tileCoordKey);\n\n          if (tile.key != key) {\n            // The source's params changed. If the tile has an interim tile and if we\n            // can use it then we use it. Otherwise we create a new tile.  In both\n            // cases we attempt to assign an interim tile to the new tile.\n            var interimTile = tile;\n            tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,\n\n            if (interimTile.getState() == TileState.IDLE) {\n              //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n              tile.interimTile = interimTile.interimTile;\n            } else {\n              tile.interimTile = interimTile;\n            }\n\n            tile.refreshInterimChain();\n            this.tileCache.replace(tileCoordKey, tile);\n          }\n        }\n\n        return tile;\n      };\n      /**\n       * Sets whether to render reprojection edges or not (usually for debugging).\n       * @param {boolean} render Render the edges.\n       * @api\n       */\n\n\n      TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges(render) {\n        if (this.renderReprojectionEdges_ == render) {\n          return;\n        }\n\n        this.renderReprojectionEdges_ = render;\n\n        for (var id in this.tileCacheForProjection) {\n          this.tileCacheForProjection[id].clear();\n        }\n\n        this.changed();\n      };\n      /**\n       * Sets the tile grid to use when reprojecting the tiles to the given\n       * projection instead of the default tile grid for the projection.\n       *\n       * This can be useful when the default tile grid cannot be created\n       * (e.g. projection has no extent defined) or\n       * for optimization reasons (custom tile size, resolutions, ...).\n       *\n       * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n       * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n       * @api\n       */\n\n\n      TileImage.prototype.setTileGridForProjection = function setTileGridForProjection(projection, tilegrid) {\n        {\n          var proj = get$2(projection);\n\n          if (proj) {\n            var projKey = getUid(proj);\n\n            if (!(projKey in this.tileGridForProjection)) {\n              this.tileGridForProjection[projKey] = tilegrid;\n            }\n          }\n        }\n      };\n\n      return TileImage;\n    }(UrlTile);\n    /**\n     * @param {ImageTile} imageTile Image tile.\n     * @param {string} src Source.\n     */\n\n\n    function defaultTileLoadFunction(imageTile, src) {\n      /** @type {HTMLImageElement|HTMLVideoElement} */\n      imageTile.getImage().src = src;\n    }\n    /**\n     * @module ol/source/XYZ\n     */\n\n    /**\n     * @typedef {Object} Options\n     * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n     * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n     * @property {number} [cacheSize=2048] Cache size.\n     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n     * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n     * access pixel data with the Canvas renderer.  See\n     * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n     * @property {boolean} [opaque=true] Whether the layer is opaque.\n     * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n     * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n     * Higher values can increase reprojection performance, but decrease precision.\n     * @property {number} [maxZoom=18] Optional max zoom level.\n     * @property {number} [minZoom=0] Optional min zoom level.\n     * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n     * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n     * ```js\n     * function(imageTile, src) {\n     *   imageTile.getImage().src = src;\n     * };\n     * ```\n     * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n     * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n     * should be set to `2`.\n     * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n     * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get\n     * tile URL given a tile coordinate and the projection.\n     * Required if url or urls are not provided.\n     * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n     * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n     * may be used instead of defining each one separately in the `urls` option.\n     * @property {Array<string>} [urls] An array of URL templates.\n     * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n     * @property {number} [transition] Duration of the opacity transition for rendering.\n     * To disable the opacity transition, pass `transition: 0`.\n     */\n\n    /**\n     * @classdesc\n     * Layer source for tile data with URLs in a set XYZ format that are\n     * defined in a URL template. By default, this follows the widely-used\n     * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n     * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n     * using the `{-y}` placeholder in the URL template, so long as the\n     * source does not have a custom tile grid. In this case,\n     * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`\n     * such as:\n     *\n     *  tileUrlFunction: function(coordinate) {\n     *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n     *        coordinate[1] + '/' + coordinate[2] + '.png';\n     *    }\n     *\n     * @api\n     */\n\n\n    var XYZ =\n    /*@__PURE__*/\n    function (TileImage$$1) {\n      function XYZ(opt_options) {\n        var options = opt_options || {};\n        var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';\n        var tileGrid = options.tileGrid !== undefined ? options.tileGrid : createXYZ({\n          extent: extentFromProjection(projection),\n          maxZoom: options.maxZoom,\n          minZoom: options.minZoom,\n          tileSize: options.tileSize\n        });\n        TileImage$$1.call(this, {\n          attributions: options.attributions,\n          cacheSize: options.cacheSize,\n          crossOrigin: options.crossOrigin,\n          opaque: options.opaque,\n          projection: projection,\n          reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n          tileGrid: tileGrid,\n          tileLoadFunction: options.tileLoadFunction,\n          tilePixelRatio: options.tilePixelRatio,\n          tileUrlFunction: options.tileUrlFunction,\n          url: options.url,\n          urls: options.urls,\n          wrapX: options.wrapX !== undefined ? options.wrapX : true,\n          transition: options.transition,\n          attributionsCollapsible: options.attributionsCollapsible\n        });\n      }\n\n      if (TileImage$$1) XYZ.__proto__ = TileImage$$1;\n      XYZ.prototype = Object.create(TileImage$$1 && TileImage$$1.prototype);\n      XYZ.prototype.constructor = XYZ;\n      return XYZ;\n    }(TileImage);\n    /**\n     * Trigger a CustomEvent\n     *\n     * @param {EventTarget} el The element or EventTarget to trigger the event upon\n     * @param {String} type The event type name\n     * @param {Object|null} payload=null The event data to be sent\n     * @returns {Boolean} The return value is false if at least one event listener called preventDefault(). Otherwise it returns true.\n     */\n\n\n    var publish = function publish(el, type) {\n      var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var event;\n      var detail = {\n        payload: payload,\n        time: new Date()\n      }; // This check is needed to polyfill CustomEvent on IE11-\n\n      if (typeof window.CustomEvent === 'function') {\n        event = new CustomEvent(type, {\n          detail: detail,\n          bubbles: true,\n          cancelable: true\n        });\n      } else {\n        event = document.createEvent('CustomEvent');\n        event.initCustomEvent(type, true, true, detail);\n      }\n\n      return el.dispatchEvent(event);\n    };\n    /**\n     *  Enumerates the events for dicom microscopy viewer. Events are captured,\n     *  normalized, and re-triggered with a `dicom-microscopy-viewer` prefix. This allows\n     *  us to handle events consistently across different browsers.\n     *\n     *  @enum {String}\n     *  @memberof dicom-microscopy-viewer\n     *  @readonly\n     */\n\n\n    var PROJECT_NAME = 'dicommicroscopyviewer';\n    var EVENTS = {\n      ROI_ADDED: \"\".concat(PROJECT_NAME, \"_roi_added\"),\n      ROI_REMOVED: \"\".concat(PROJECT_NAME, \"_roi_removed\"),\n      ROI_DRAWN: \"\".concat(PROJECT_NAME, \"_roi_drawn\"),\n      ROI_SELECTED: \"\".concat(PROJECT_NAME, \"_roi_selected\"),\n      ROI_MODIFIED: \"\".concat(PROJECT_NAME, \"_roi_modified\"),\n      MOVE_STARTED: \"\".concat(PROJECT_NAME, \"_move_started\"),\n      MOVE_ENDED: \"\".concat(PROJECT_NAME, \"_move_ended\")\n    };\n    var tagToKeyword = {\n      '00000000': 'CommandGroupLength',\n      '00000001': 'CommandLengthToEnd',\n      '00000002': 'AffectedSOPClassUID',\n      '00000003': 'RequestedSOPClassUID',\n      '00000010': 'CommandRecognitionCode',\n      '00000100': 'CommandField',\n      '00000110': 'MessageID',\n      '00000120': 'MessageIDBeingRespondedTo',\n      '00000200': 'Initiator',\n      '00000300': 'Receiver',\n      '00000400': 'FindLocation',\n      '00000600': 'MoveDestination',\n      '00000700': 'Priority',\n      '00000800': 'CommandDataSetType',\n      '00000850': 'NumberOfMatches',\n      '00000860': 'ResponseSequenceNumber',\n      '00000900': 'Status',\n      '00000901': 'OffendingElement',\n      '00000902': 'ErrorComment',\n      '00000903': 'ErrorID',\n      '00001000': 'AffectedSOPInstanceUID',\n      '00001001': 'RequestedSOPInstanceUID',\n      '00001002': 'EventTypeID',\n      '00001005': 'AttributeIdentifierList',\n      '00001008': 'ActionTypeID',\n      '00001020': 'NumberOfRemainingSuboperations',\n      '00001021': 'NumberOfCompletedSuboperations',\n      '00001022': 'NumberOfFailedSuboperations',\n      '00001023': 'NumberOfWarningSuboperations',\n      '00001030': 'MoveOriginatorApplicationEntityTitle',\n      '00001031': 'MoveOriginatorMessageID',\n      '00004000': 'DialogReceiver',\n      '00004010': 'TerminalType',\n      '00005010': 'MessageSetID',\n      '00005020': 'EndMessageID',\n      '00005110': 'DisplayFormat',\n      '00005120': 'PagePositionID',\n      '00005130': 'TextFormatID',\n      '00005140': 'NormalReverse',\n      '00005150': 'AddGrayScale',\n      '00005160': 'Borders',\n      '00005170': 'Copies',\n      '00005180': 'CommandMagnificationType',\n      '00005190': 'Erase',\n      '000051A0': 'Print',\n      '000051B0': 'Overlays',\n      '00020000': 'FileMetaInformationGroupLength',\n      '00020001': 'FileMetaInformationVersion',\n      '00020002': 'MediaStorageSOPClassUID',\n      '00020003': 'MediaStorageSOPInstanceUID',\n      '00020010': 'TransferSyntaxUID',\n      '00020012': 'ImplementationClassUID',\n      '00020013': 'ImplementationVersionName',\n      '00020016': 'SourceApplicationEntityTitle',\n      '00020017': 'SendingApplicationEntityTitle',\n      '00020018': 'ReceivingApplicationEntityTitle',\n      '00020100': 'PrivateInformationCreatorUID',\n      '00020102': 'PrivateInformation',\n      '00041130': 'FileSetID',\n      '00041141': 'FileSetDescriptorFileID',\n      '00041142': 'SpecificCharacterSetOfFileSetDescriptorFile',\n      '00041200': 'OffsetOfTheFirstDirectoryRecordOfTheRootDirectoryEntity',\n      '00041202': 'OffsetOfTheLastDirectoryRecordOfTheRootDirectoryEntity',\n      '00041212': 'FileSetConsistencyFlag',\n      '00041220': 'DirectoryRecordSequence',\n      '00041400': 'OffsetOfTheNextDirectoryRecord',\n      '00041410': 'RecordInUseFlag',\n      '00041420': 'OffsetOfReferencedLowerLevelDirectoryEntity',\n      '00041430': 'DirectoryRecordType',\n      '00041432': 'PrivateRecordUID',\n      '00041500': 'ReferencedFileID',\n      '00041504': 'MRDRDirectoryRecordOffset',\n      '00041510': 'ReferencedSOPClassUIDInFile',\n      '00041511': 'ReferencedSOPInstanceUIDInFile',\n      '00041512': 'ReferencedTransferSyntaxUIDInFile',\n      '0004151A': 'ReferencedRelatedGeneralSOPClassUIDInFile',\n      '00041600': 'NumberOfReferences',\n      '00080001': 'LengthToEnd',\n      '00080005': 'SpecificCharacterSet',\n      '00080006': 'LanguageCodeSequence',\n      '00080008': 'ImageType',\n      '00080010': 'RecognitionCode',\n      '00080012': 'InstanceCreationDate',\n      '00080013': 'InstanceCreationTime',\n      '00080014': 'InstanceCreatorUID',\n      '00080015': 'InstanceCoercionDateTime',\n      '00080016': 'SOPClassUID',\n      '00080018': 'SOPInstanceUID',\n      '0008001A': 'RelatedGeneralSOPClassUID',\n      '0008001B': 'OriginalSpecializedSOPClassUID',\n      '00080020': 'StudyDate',\n      '00080021': 'SeriesDate',\n      '00080022': 'AcquisitionDate',\n      '00080023': 'ContentDate',\n      '00080024': 'OverlayDate',\n      '00080025': 'CurveDate',\n      '0008002A': 'AcquisitionDateTime',\n      '00080030': 'StudyTime',\n      '00080031': 'SeriesTime',\n      '00080032': 'AcquisitionTime',\n      '00080033': 'ContentTime',\n      '00080034': 'OverlayTime',\n      '00080035': 'CurveTime',\n      '00080040': 'DataSetType',\n      '00080041': 'DataSetSubtype',\n      '00080042': 'NuclearMedicineSeriesType',\n      '00080050': 'AccessionNumber',\n      '00080051': 'IssuerOfAccessionNumberSequence',\n      '00080052': 'QueryRetrieveLevel',\n      '00080053': 'QueryRetrieveView',\n      '00080054': 'RetrieveAETitle',\n      '00080055': 'StationAETitle',\n      '00080056': 'InstanceAvailability',\n      '00080058': 'FailedSOPInstanceUIDList',\n      '00080060': 'Modality',\n      '00080061': 'ModalitiesInStudy',\n      '00080062': 'SOPClassesInStudy',\n      '00080063': 'AnatomicRegionsInStudyCodeSequence',\n      '00080064': 'ConversionType',\n      '00080068': 'PresentationIntentType',\n      '00080070': 'Manufacturer',\n      '00080080': 'InstitutionName',\n      '00080081': 'InstitutionAddress',\n      '00080082': 'InstitutionCodeSequence',\n      '00080090': 'ReferringPhysicianName',\n      '00080092': 'ReferringPhysicianAddress',\n      '00080094': 'ReferringPhysicianTelephoneNumbers',\n      '00080096': 'ReferringPhysicianIdentificationSequence',\n      '0008009C': 'ConsultingPhysicianName',\n      '0008009D': 'ConsultingPhysicianIdentificationSequence',\n      '00080100': 'CodeValue',\n      '00080101': 'ExtendedCodeValue',\n      '00080102': 'CodingSchemeDesignator',\n      '00080103': 'CodingSchemeVersion',\n      '00080104': 'CodeMeaning',\n      '00080105': 'MappingResource',\n      '00080106': 'ContextGroupVersion',\n      '00080107': 'ContextGroupLocalVersion',\n      '00080108': 'ExtendedCodeMeaning',\n      '00080109': 'CodingSchemeResourcesSequence',\n      '0008010A': 'CodingSchemeURLType',\n      '0008010B': 'ContextGroupExtensionFlag',\n      '0008010C': 'CodingSchemeUID',\n      '0008010D': 'ContextGroupExtensionCreatorUID',\n      '0008010E': 'CodingSchemeURL',\n      '0008010F': 'ContextIdentifier',\n      '00080110': 'CodingSchemeIdentificationSequence',\n      '00080112': 'CodingSchemeRegistry',\n      '00080114': 'CodingSchemeExternalID',\n      '00080115': 'CodingSchemeName',\n      '00080116': 'CodingSchemeResponsibleOrganization',\n      '00080117': 'ContextUID',\n      '00080118': 'MappingResourceUID',\n      '00080119': 'LongCodeValue',\n      '00080120': 'URNCodeValue',\n      '00080121': 'EquivalentCodeSequence',\n      '00080122': 'MappingResourceName',\n      '00080123': 'ContextGroupIdentificationSequence',\n      '00080124': 'MappingResourceIdentificationSequence',\n      '00080201': 'TimezoneOffsetFromUTC',\n      '00080220': 'ResponsibleGroupCodeSequence',\n      '00080221': 'EquipmentModality',\n      '00080222': 'ManufacturerRelatedModelGroup',\n      '00080300': 'PrivateDataElementCharacteristicsSequence',\n      '00080301': 'PrivateGroupReference',\n      '00080302': 'PrivateCreatorReference',\n      '00080303': 'BlockIdentifyingInformationStatus',\n      '00080304': 'NonidentifyingPrivateElements',\n      '00080305': 'DeidentificationActionSequence',\n      '00080306': 'IdentifyingPrivateElements',\n      '00080307': 'DeidentificationAction',\n      '00080308': 'PrivateDataElement',\n      '00080309': 'PrivateDataElementValueMultiplicity',\n      '0008030A': 'PrivateDataElementValueRepresentation',\n      '0008030B': 'PrivateDataElementNumberOfItems',\n      '0008030C': 'PrivateDataElementName',\n      '0008030D': 'PrivateDataElementKeyword',\n      '0008030E': 'PrivateDataElementDescription',\n      '0008030F': 'PrivateDataElementEncoding',\n      '00080310': 'PrivateDataElementDefinitionSequence',\n      '00081000': 'NetworkID',\n      '00081010': 'StationName',\n      '00081030': 'StudyDescription',\n      '00081032': 'ProcedureCodeSequence',\n      '0008103E': 'SeriesDescription',\n      '0008103F': 'SeriesDescriptionCodeSequence',\n      '00081040': 'InstitutionalDepartmentName',\n      '00081048': 'PhysiciansOfRecord',\n      '00081049': 'PhysiciansOfRecordIdentificationSequence',\n      '00081050': 'PerformingPhysicianName',\n      '00081052': 'PerformingPhysicianIdentificationSequence',\n      '00081060': 'NameOfPhysiciansReadingStudy',\n      '00081062': 'PhysiciansReadingStudyIdentificationSequence',\n      '00081070': 'OperatorsName',\n      '00081072': 'OperatorIdentificationSequence',\n      '00081080': 'AdmittingDiagnosesDescription',\n      '00081084': 'AdmittingDiagnosesCodeSequence',\n      '00081090': 'ManufacturerModelName',\n      '00081100': 'ReferencedResultsSequence',\n      '00081110': 'ReferencedStudySequence',\n      '00081111': 'ReferencedPerformedProcedureStepSequence',\n      '00081115': 'ReferencedSeriesSequence',\n      '00081120': 'ReferencedPatientSequence',\n      '00081125': 'ReferencedVisitSequence',\n      '00081130': 'ReferencedOverlaySequence',\n      '00081134': 'ReferencedStereometricInstanceSequence',\n      '0008113A': 'ReferencedWaveformSequence',\n      '00081140': 'ReferencedImageSequence',\n      '00081145': 'ReferencedCurveSequence',\n      '0008114A': 'ReferencedInstanceSequence',\n      '0008114B': 'ReferencedRealWorldValueMappingInstanceSequence',\n      '00081150': 'ReferencedSOPClassUID',\n      '00081155': 'ReferencedSOPInstanceUID',\n      '00081156': 'DefinitionSourceSequence',\n      '0008115A': 'SOPClassesSupported',\n      '00081160': 'ReferencedFrameNumber',\n      '00081161': 'SimpleFrameList',\n      '00081162': 'CalculatedFrameList',\n      '00081163': 'TimeRange',\n      '00081164': 'FrameExtractionSequence',\n      '00081167': 'MultiFrameSourceSOPInstanceUID',\n      '00081190': 'RetrieveURL',\n      '00081195': 'TransactionUID',\n      '00081196': 'WarningReason',\n      '00081197': 'FailureReason',\n      '00081198': 'FailedSOPSequence',\n      '00081199': 'ReferencedSOPSequence',\n      '0008119A': 'OtherFailuresSequence',\n      '00081200': 'StudiesContainingOtherReferencedInstancesSequence',\n      '00081250': 'RelatedSeriesSequence',\n      '00082110': 'LossyImageCompressionRetired',\n      '00082111': 'DerivationDescription',\n      '00082112': 'SourceImageSequence',\n      '00082120': 'StageName',\n      '00082122': 'StageNumber',\n      '00082124': 'NumberOfStages',\n      '00082127': 'ViewName',\n      '00082128': 'ViewNumber',\n      '00082129': 'NumberOfEventTimers',\n      '0008212A': 'NumberOfViewsInStage',\n      '00082130': 'EventElapsedTimes',\n      '00082132': 'EventTimerNames',\n      '00082133': 'EventTimerSequence',\n      '00082134': 'EventTimeOffset',\n      '00082135': 'EventCodeSequence',\n      '00082142': 'StartTrim',\n      '00082143': 'StopTrim',\n      '00082144': 'RecommendedDisplayFrameRate',\n      '00082200': 'TransducerPosition',\n      '00082204': 'TransducerOrientation',\n      '00082208': 'AnatomicStructure',\n      '00082218': 'AnatomicRegionSequence',\n      '00082220': 'AnatomicRegionModifierSequence',\n      '00082228': 'PrimaryAnatomicStructureSequence',\n      '00082229': 'AnatomicStructureSpaceOrRegionSequence',\n      '00082230': 'PrimaryAnatomicStructureModifierSequence',\n      '00082240': 'TransducerPositionSequence',\n      '00082242': 'TransducerPositionModifierSequence',\n      '00082244': 'TransducerOrientationSequence',\n      '00082246': 'TransducerOrientationModifierSequence',\n      '00082251': 'AnatomicStructureSpaceOrRegionCodeSequenceTrial',\n      '00082253': 'AnatomicPortalOfEntranceCodeSequenceTrial',\n      '00082255': 'AnatomicApproachDirectionCodeSequenceTrial',\n      '00082256': 'AnatomicPerspectiveDescriptionTrial',\n      '00082257': 'AnatomicPerspectiveCodeSequenceTrial',\n      '00082258': 'AnatomicLocationOfExaminingInstrumentDescriptionTrial',\n      '00082259': 'AnatomicLocationOfExaminingInstrumentCodeSequenceTrial',\n      '0008225A': 'AnatomicStructureSpaceOrRegionModifierCodeSequenceTrial',\n      '0008225C': 'OnAxisBackgroundAnatomicStructureCodeSequenceTrial',\n      '00083001': 'AlternateRepresentationSequence',\n      '00083010': 'IrradiationEventUID',\n      '00083011': 'SourceIrradiationEventSequence',\n      '00083012': 'RadiopharmaceuticalAdministrationEventUID',\n      '00084000': 'IdentifyingComments',\n      '00089007': 'FrameType',\n      '00089092': 'ReferencedImageEvidenceSequence',\n      '00089121': 'ReferencedRawDataSequence',\n      '00089123': 'CreatorVersionUID',\n      '00089124': 'DerivationImageSequence',\n      '00089154': 'SourceImageEvidenceSequence',\n      '00089205': 'PixelPresentation',\n      '00089206': 'VolumetricProperties',\n      '00089207': 'VolumeBasedCalculationTechnique',\n      '00089208': 'ComplexImageComponent',\n      '00089209': 'AcquisitionContrast',\n      '00089215': 'DerivationCodeSequence',\n      '00089237': 'ReferencedPresentationStateSequence',\n      '00089410': 'ReferencedOtherPlaneSequence',\n      '00089458': 'FrameDisplaySequence',\n      '00089459': 'RecommendedDisplayFrameRateInFloat',\n      '00089460': 'SkipFrameRangeFlag',\n      '00100010': 'PatientName',\n      '00100020': 'PatientID',\n      '00100021': 'IssuerOfPatientID',\n      '00100022': 'TypeOfPatientID',\n      '00100024': 'IssuerOfPatientIDQualifiersSequence',\n      '00100026': 'SourcePatientGroupIdentificationSequence',\n      '00100027': 'GroupOfPatientsIdentificationSequence',\n      '00100028': 'SubjectRelativePositionInImage',\n      '00100030': 'PatientBirthDate',\n      '00100032': 'PatientBirthTime',\n      '00100033': 'PatientBirthDateInAlternativeCalendar',\n      '00100034': 'PatientDeathDateInAlternativeCalendar',\n      '00100035': 'PatientAlternativeCalendar',\n      '00100040': 'PatientSex',\n      '00100050': 'PatientInsurancePlanCodeSequence',\n      '00100101': 'PatientPrimaryLanguageCodeSequence',\n      '00100102': 'PatientPrimaryLanguageModifierCodeSequence',\n      '00100200': 'QualityControlSubject',\n      '00100201': 'QualityControlSubjectTypeCodeSequence',\n      '00100212': 'StrainDescription',\n      '00100213': 'StrainNomenclature',\n      '00100214': 'StrainStockNumber',\n      '00100215': 'StrainSourceRegistryCodeSequence',\n      '00100216': 'StrainStockSequence',\n      '00100217': 'StrainSource',\n      '00100218': 'StrainAdditionalInformation',\n      '00100219': 'StrainCodeSequence',\n      '00100221': 'GeneticModificationsSequence',\n      '00100222': 'GeneticModificationsDescription',\n      '00100223': 'GeneticModificationsNomenclature',\n      '00100229': 'GeneticModificationsCodeSequence',\n      '00101000': 'OtherPatientIDs',\n      '00101001': 'OtherPatientNames',\n      '00101002': 'OtherPatientIDsSequence',\n      '00101005': 'PatientBirthName',\n      '00101010': 'PatientAge',\n      '00101020': 'PatientSize',\n      '00101021': 'PatientSizeCodeSequence',\n      '00101022': 'PatientBodyMassIndex',\n      '00101023': 'MeasuredAPDimension',\n      '00101024': 'MeasuredLateralDimension',\n      '00101030': 'PatientWeight',\n      '00101040': 'PatientAddress',\n      '00101050': 'InsurancePlanIdentification',\n      '00101060': 'PatientMotherBirthName',\n      '00101080': 'MilitaryRank',\n      '00101081': 'BranchOfService',\n      '00101090': 'MedicalRecordLocator',\n      '00101100': 'ReferencedPatientPhotoSequence',\n      '00102000': 'MedicalAlerts',\n      '00102110': 'Allergies',\n      '00102150': 'CountryOfResidence',\n      '00102152': 'RegionOfResidence',\n      '00102154': 'PatientTelephoneNumbers',\n      '00102155': 'PatientTelecomInformation',\n      '00102160': 'EthnicGroup',\n      '00102180': 'Occupation',\n      '001021A0': 'SmokingStatus',\n      '001021B0': 'AdditionalPatientHistory',\n      '001021C0': 'PregnancyStatus',\n      '001021D0': 'LastMenstrualDate',\n      '001021F0': 'PatientReligiousPreference',\n      '00102201': 'PatientSpeciesDescription',\n      '00102202': 'PatientSpeciesCodeSequence',\n      '00102203': 'PatientSexNeutered',\n      '00102210': 'AnatomicalOrientationType',\n      '00102292': 'PatientBreedDescription',\n      '00102293': 'PatientBreedCodeSequence',\n      '00102294': 'BreedRegistrationSequence',\n      '00102295': 'BreedRegistrationNumber',\n      '00102296': 'BreedRegistryCodeSequence',\n      '00102297': 'ResponsiblePerson',\n      '00102298': 'ResponsiblePersonRole',\n      '00102299': 'ResponsibleOrganization',\n      '00104000': 'PatientComments',\n      '00109431': 'ExaminedBodyThickness',\n      '00120010': 'ClinicalTrialSponsorName',\n      '00120020': 'ClinicalTrialProtocolID',\n      '00120021': 'ClinicalTrialProtocolName',\n      '00120030': 'ClinicalTrialSiteID',\n      '00120031': 'ClinicalTrialSiteName',\n      '00120040': 'ClinicalTrialSubjectID',\n      '00120042': 'ClinicalTrialSubjectReadingID',\n      '00120050': 'ClinicalTrialTimePointID',\n      '00120051': 'ClinicalTrialTimePointDescription',\n      '00120052': 'LongitudinalTemporalOffsetFromEvent',\n      '00120053': 'LongitudinalTemporalEventType',\n      '00120060': 'ClinicalTrialCoordinatingCenterName',\n      '00120062': 'PatientIdentityRemoved',\n      '00120063': 'DeidentificationMethod',\n      '00120064': 'DeidentificationMethodCodeSequence',\n      '00120071': 'ClinicalTrialSeriesID',\n      '00120072': 'ClinicalTrialSeriesDescription',\n      '00120081': 'ClinicalTrialProtocolEthicsCommitteeName',\n      '00120082': 'ClinicalTrialProtocolEthicsCommitteeApprovalNumber',\n      '00120083': 'ConsentForClinicalTrialUseSequence',\n      '00120084': 'DistributionType',\n      '00120085': 'ConsentForDistributionFlag',\n      '00120086': 'EthicsCommitteeApprovalEffectivenessStartDate',\n      '00120087': 'EthicsCommitteeApprovalEffectivenessEndDate',\n      '00140023': 'CADFileFormat',\n      '00140024': 'ComponentReferenceSystem',\n      '00140025': 'ComponentManufacturingProcedure',\n      '00140028': 'ComponentManufacturer',\n      '00140030': 'MaterialThickness',\n      '00140032': 'MaterialPipeDiameter',\n      '00140034': 'MaterialIsolationDiameter',\n      '00140042': 'MaterialGrade',\n      '00140044': 'MaterialPropertiesDescription',\n      '00140045': 'MaterialPropertiesFileFormatRetired',\n      '00140046': 'MaterialNotes',\n      '00140050': 'ComponentShape',\n      '00140052': 'CurvatureType',\n      '00140054': 'OuterDiameter',\n      '00140056': 'InnerDiameter',\n      '00140100': 'ComponentWelderIDs',\n      '00140101': 'SecondaryApprovalStatus',\n      '00140102': 'SecondaryReviewDate',\n      '00140103': 'SecondaryReviewTime',\n      '00140104': 'SecondaryReviewerName',\n      '00140105': 'RepairID',\n      '00140106': 'MultipleComponentApprovalSequence',\n      '00140107': 'OtherApprovalStatus',\n      '00140108': 'OtherSecondaryApprovalStatus',\n      '00141010': 'ActualEnvironmentalConditions',\n      '00141020': 'ExpiryDate',\n      '00141040': 'EnvironmentalConditions',\n      '00142002': 'EvaluatorSequence',\n      '00142004': 'EvaluatorNumber',\n      '00142006': 'EvaluatorName',\n      '00142008': 'EvaluationAttempt',\n      '00142012': 'IndicationSequence',\n      '00142014': 'IndicationNumber',\n      '00142016': 'IndicationLabel',\n      '00142018': 'IndicationDescription',\n      '0014201A': 'IndicationType',\n      '0014201C': 'IndicationDisposition',\n      '0014201E': 'IndicationROISequence',\n      '00142030': 'IndicationPhysicalPropertySequence',\n      '00142032': 'PropertyLabel',\n      '00142202': 'CoordinateSystemNumberOfAxes',\n      '00142204': 'CoordinateSystemAxesSequence',\n      '00142206': 'CoordinateSystemAxisDescription',\n      '00142208': 'CoordinateSystemDataSetMapping',\n      '0014220A': 'CoordinateSystemAxisNumber',\n      '0014220C': 'CoordinateSystemAxisType',\n      '0014220E': 'CoordinateSystemAxisUnits',\n      '00142210': 'CoordinateSystemAxisValues',\n      '00142220': 'CoordinateSystemTransformSequence',\n      '00142222': 'TransformDescription',\n      '00142224': 'TransformNumberOfAxes',\n      '00142226': 'TransformOrderOfAxes',\n      '00142228': 'TransformedAxisUnits',\n      '0014222A': 'CoordinateSystemTransformRotationAndScaleMatrix',\n      '0014222C': 'CoordinateSystemTransformTranslationMatrix',\n      '00143011': 'InternalDetectorFrameTime',\n      '00143012': 'NumberOfFramesIntegrated',\n      '00143020': 'DetectorTemperatureSequence',\n      '00143022': 'SensorName',\n      '00143024': 'HorizontalOffsetOfSensor',\n      '00143026': 'VerticalOffsetOfSensor',\n      '00143028': 'SensorTemperature',\n      '00143040': 'DarkCurrentSequence',\n      '00143050': 'DarkCurrentCounts',\n      '00143060': 'GainCorrectionReferenceSequence',\n      '00143070': 'AirCounts',\n      '00143071': 'KVUsedInGainCalibration',\n      '00143072': 'MAUsedInGainCalibration',\n      '00143073': 'NumberOfFramesUsedForIntegration',\n      '00143074': 'FilterMaterialUsedInGainCalibration',\n      '00143075': 'FilterThicknessUsedInGainCalibration',\n      '00143076': 'DateOfGainCalibration',\n      '00143077': 'TimeOfGainCalibration',\n      '00143080': 'BadPixelImage',\n      '00143099': 'CalibrationNotes',\n      '00144002': 'PulserEquipmentSequence',\n      '00144004': 'PulserType',\n      '00144006': 'PulserNotes',\n      '00144008': 'ReceiverEquipmentSequence',\n      '0014400A': 'AmplifierType',\n      '0014400C': 'ReceiverNotes',\n      '0014400E': 'PreAmplifierEquipmentSequence',\n      '0014400F': 'PreAmplifierNotes',\n      '00144010': 'TransmitTransducerSequence',\n      '00144011': 'ReceiveTransducerSequence',\n      '00144012': 'NumberOfElements',\n      '00144013': 'ElementShape',\n      '00144014': 'ElementDimensionA',\n      '00144015': 'ElementDimensionB',\n      '00144016': 'ElementPitchA',\n      '00144017': 'MeasuredBeamDimensionA',\n      '00144018': 'MeasuredBeamDimensionB',\n      '00144019': 'LocationOfMeasuredBeamDiameter',\n      '0014401A': 'NominalFrequency',\n      '0014401B': 'MeasuredCenterFrequency',\n      '0014401C': 'MeasuredBandwidth',\n      '0014401D': 'ElementPitchB',\n      '00144020': 'PulserSettingsSequence',\n      '00144022': 'PulseWidth',\n      '00144024': 'ExcitationFrequency',\n      '00144026': 'ModulationType',\n      '00144028': 'Damping',\n      '00144030': 'ReceiverSettingsSequence',\n      '00144031': 'AcquiredSoundpathLength',\n      '00144032': 'AcquisitionCompressionType',\n      '00144033': 'AcquisitionSampleSize',\n      '00144034': 'RectifierSmoothing',\n      '00144035': 'DACSequence',\n      '00144036': 'DACType',\n      '00144038': 'DACGainPoints',\n      '0014403A': 'DACTimePoints',\n      '0014403C': 'DACAmplitude',\n      '00144040': 'PreAmplifierSettingsSequence',\n      '00144050': 'TransmitTransducerSettingsSequence',\n      '00144051': 'ReceiveTransducerSettingsSequence',\n      '00144052': 'IncidentAngle',\n      '00144054': 'CouplingTechnique',\n      '00144056': 'CouplingMedium',\n      '00144057': 'CouplingVelocity',\n      '00144058': 'ProbeCenterLocationX',\n      '00144059': 'ProbeCenterLocationZ',\n      '0014405A': 'SoundPathLength',\n      '0014405C': 'DelayLawIdentifier',\n      '00144060': 'GateSettingsSequence',\n      '00144062': 'GateThreshold',\n      '00144064': 'VelocityOfSound',\n      '00144070': 'CalibrationSettingsSequence',\n      '00144072': 'CalibrationProcedure',\n      '00144074': 'ProcedureVersion',\n      '00144076': 'ProcedureCreationDate',\n      '00144078': 'ProcedureExpirationDate',\n      '0014407A': 'ProcedureLastModifiedDate',\n      '0014407C': 'CalibrationTime',\n      '0014407E': 'CalibrationDate',\n      '00144080': 'ProbeDriveEquipmentSequence',\n      '00144081': 'DriveType',\n      '00144082': 'ProbeDriveNotes',\n      '00144083': 'DriveProbeSequence',\n      '00144084': 'ProbeInductance',\n      '00144085': 'ProbeResistance',\n      '00144086': 'ReceiveProbeSequence',\n      '00144087': 'ProbeDriveSettingsSequence',\n      '00144088': 'BridgeResistors',\n      '00144089': 'ProbeOrientationAngle',\n      '0014408B': 'UserSelectedGainY',\n      '0014408C': 'UserSelectedPhase',\n      '0014408D': 'UserSelectedOffsetX',\n      '0014408E': 'UserSelectedOffsetY',\n      '00144091': 'ChannelSettingsSequence',\n      '00144092': 'ChannelThreshold',\n      '0014409A': 'ScannerSettingsSequence',\n      '0014409B': 'ScanProcedure',\n      '0014409C': 'TranslationRateX',\n      '0014409D': 'TranslationRateY',\n      '0014409F': 'ChannelOverlap',\n      '001440A0': 'ImageQualityIndicatorType',\n      '001440A1': 'ImageQualityIndicatorMaterial',\n      '001440A2': 'ImageQualityIndicatorSize',\n      '00145002': 'LINACEnergy',\n      '00145004': 'LINACOutput',\n      '00145100': 'ActiveAperture',\n      '00145101': 'TotalAperture',\n      '00145102': 'ApertureElevation',\n      '00145103': 'MainLobeAngle',\n      '00145104': 'MainRoofAngle',\n      '00145105': 'ConnectorType',\n      '00145106': 'WedgeModelNumber',\n      '00145107': 'WedgeAngleFloat',\n      '00145108': 'WedgeRoofAngle',\n      '00145109': 'WedgeElement1Position',\n      '0014510A': 'WedgeMaterialVelocity',\n      '0014510B': 'WedgeMaterial',\n      '0014510C': 'WedgeOffsetZ',\n      '0014510D': 'WedgeOriginOffsetX',\n      '0014510E': 'WedgeTimeDelay',\n      '0014510F': 'WedgeName',\n      '00145110': 'WedgeManufacturerName',\n      '00145111': 'WedgeDescription',\n      '00145112': 'NominalBeamAngle',\n      '00145113': 'WedgeOffsetX',\n      '00145114': 'WedgeOffsetY',\n      '00145115': 'WedgeTotalLength',\n      '00145116': 'WedgeInContactLength',\n      '00145117': 'WedgeFrontGap',\n      '00145118': 'WedgeTotalHeight',\n      '00145119': 'WedgeFrontHeight',\n      '0014511A': 'WedgeRearHeight',\n      '0014511B': 'WedgeTotalWidth',\n      '0014511C': 'WedgeInContactWidth',\n      '0014511D': 'WedgeChamferHeight',\n      '0014511E': 'WedgeCurve',\n      '0014511F': 'RadiusAlongWedge',\n      '00180010': 'ContrastBolusAgent',\n      '00180012': 'ContrastBolusAgentSequence',\n      '00180013': 'ContrastBolusT1Relaxivity',\n      '00180014': 'ContrastBolusAdministrationRouteSequence',\n      '00180015': 'BodyPartExamined',\n      '00180020': 'ScanningSequence',\n      '00180021': 'SequenceVariant',\n      '00180022': 'ScanOptions',\n      '00180023': 'MRAcquisitionType',\n      '00180024': 'SequenceName',\n      '00180025': 'AngioFlag',\n      '00180026': 'InterventionDrugInformationSequence',\n      '00180027': 'InterventionDrugStopTime',\n      '00180028': 'InterventionDrugDose',\n      '00180029': 'InterventionDrugCodeSequence',\n      '0018002A': 'AdditionalDrugSequence',\n      '00180030': 'Radionuclide',\n      '00180031': 'Radiopharmaceutical',\n      '00180032': 'EnergyWindowCenterline',\n      '00180033': 'EnergyWindowTotalWidth',\n      '00180034': 'InterventionDrugName',\n      '00180035': 'InterventionDrugStartTime',\n      '00180036': 'InterventionSequence',\n      '00180037': 'TherapyType',\n      '00180038': 'InterventionStatus',\n      '00180039': 'TherapyDescription',\n      '0018003A': 'InterventionDescription',\n      '00180040': 'CineRate',\n      '00180042': 'InitialCineRunState',\n      '00180050': 'SliceThickness',\n      '00180060': 'KVP',\n      '00180061': '',\n      '00180070': 'CountsAccumulated',\n      '00180071': 'AcquisitionTerminationCondition',\n      '00180072': 'EffectiveDuration',\n      '00180073': 'AcquisitionStartCondition',\n      '00180074': 'AcquisitionStartConditionData',\n      '00180075': 'AcquisitionTerminationConditionData',\n      '00180080': 'RepetitionTime',\n      '00180081': 'EchoTime',\n      '00180082': 'InversionTime',\n      '00180083': 'NumberOfAverages',\n      '00180084': 'ImagingFrequency',\n      '00180085': 'ImagedNucleus',\n      '00180086': 'EchoNumbers',\n      '00180087': 'MagneticFieldStrength',\n      '00180088': 'SpacingBetweenSlices',\n      '00180089': 'NumberOfPhaseEncodingSteps',\n      '00180090': 'DataCollectionDiameter',\n      '00180091': 'EchoTrainLength',\n      '00180093': 'PercentSampling',\n      '00180094': 'PercentPhaseFieldOfView',\n      '00180095': 'PixelBandwidth',\n      '00181000': 'DeviceSerialNumber',\n      '00181002': 'DeviceUID',\n      '00181003': 'DeviceID',\n      '00181004': 'PlateID',\n      '00181005': 'GeneratorID',\n      '00181006': 'GridID',\n      '00181007': 'CassetteID',\n      '00181008': 'GantryID',\n      '00181009': 'UniqueDeviceIdentifier',\n      '0018100A': 'UDISequence',\n      '00181010': 'SecondaryCaptureDeviceID',\n      '00181011': 'HardcopyCreationDeviceID',\n      '00181012': 'DateOfSecondaryCapture',\n      '00181014': 'TimeOfSecondaryCapture',\n      '00181016': 'SecondaryCaptureDeviceManufacturer',\n      '00181017': 'HardcopyDeviceManufacturer',\n      '00181018': 'SecondaryCaptureDeviceManufacturerModelName',\n      '00181019': 'SecondaryCaptureDeviceSoftwareVersions',\n      '0018101A': 'HardcopyDeviceSoftwareVersion',\n      '0018101B': 'HardcopyDeviceManufacturerModelName',\n      '00181020': 'SoftwareVersions',\n      '00181022': 'VideoImageFormatAcquired',\n      '00181023': 'DigitalImageFormatAcquired',\n      '00181030': 'ProtocolName',\n      '00181040': 'ContrastBolusRoute',\n      '00181041': 'ContrastBolusVolume',\n      '00181042': 'ContrastBolusStartTime',\n      '00181043': 'ContrastBolusStopTime',\n      '00181044': 'ContrastBolusTotalDose',\n      '00181045': 'SyringeCounts',\n      '00181046': 'ContrastFlowRate',\n      '00181047': 'ContrastFlowDuration',\n      '00181048': 'ContrastBolusIngredient',\n      '00181049': 'ContrastBolusIngredientConcentration',\n      '00181050': 'SpatialResolution',\n      '00181060': 'TriggerTime',\n      '00181061': 'TriggerSourceOrType',\n      '00181062': 'NominalInterval',\n      '00181063': 'FrameTime',\n      '00181064': 'CardiacFramingType',\n      '00181065': 'FrameTimeVector',\n      '00181066': 'FrameDelay',\n      '00181067': 'ImageTriggerDelay',\n      '00181068': 'MultiplexGroupTimeOffset',\n      '00181069': 'TriggerTimeOffset',\n      '0018106A': 'SynchronizationTrigger',\n      '0018106C': 'SynchronizationChannel',\n      '0018106E': 'TriggerSamplePosition',\n      '00181070': 'RadiopharmaceuticalRoute',\n      '00181071': 'RadiopharmaceuticalVolume',\n      '00181072': 'RadiopharmaceuticalStartTime',\n      '00181073': 'RadiopharmaceuticalStopTime',\n      '00181074': 'RadionuclideTotalDose',\n      '00181075': 'RadionuclideHalfLife',\n      '00181076': 'RadionuclidePositronFraction',\n      '00181077': 'RadiopharmaceuticalSpecificActivity',\n      '00181078': 'RadiopharmaceuticalStartDateTime',\n      '00181079': 'RadiopharmaceuticalStopDateTime',\n      '00181080': 'BeatRejectionFlag',\n      '00181081': 'LowRRValue',\n      '00181082': 'HighRRValue',\n      '00181083': 'IntervalsAcquired',\n      '00181084': 'IntervalsRejected',\n      '00181085': 'PVCRejection',\n      '00181086': 'SkipBeats',\n      '00181088': 'HeartRate',\n      '00181090': 'CardiacNumberOfImages',\n      '00181094': 'TriggerWindow',\n      '00181100': 'ReconstructionDiameter',\n      '00181110': 'DistanceSourceToDetector',\n      '00181111': 'DistanceSourceToPatient',\n      '00181114': 'EstimatedRadiographicMagnificationFactor',\n      '00181120': 'GantryDetectorTilt',\n      '00181121': 'GantryDetectorSlew',\n      '00181130': 'TableHeight',\n      '00181131': 'TableTraverse',\n      '00181134': 'TableMotion',\n      '00181135': 'TableVerticalIncrement',\n      '00181136': 'TableLateralIncrement',\n      '00181137': 'TableLongitudinalIncrement',\n      '00181138': 'TableAngle',\n      '0018113A': 'TableType',\n      '00181140': 'RotationDirection',\n      '00181141': 'AngularPosition',\n      '00181142': 'RadialPosition',\n      '00181143': 'ScanArc',\n      '00181144': 'AngularStep',\n      '00181145': 'CenterOfRotationOffset',\n      '00181146': 'RotationOffset',\n      '00181147': 'FieldOfViewShape',\n      '00181149': 'FieldOfViewDimensions',\n      '00181150': 'ExposureTime',\n      '00181151': 'XRayTubeCurrent',\n      '00181152': 'Exposure',\n      '00181153': 'ExposureInuAs',\n      '00181154': 'AveragePulseWidth',\n      '00181155': 'RadiationSetting',\n      '00181156': 'RectificationType',\n      '0018115A': 'RadiationMode',\n      '0018115E': 'ImageAndFluoroscopyAreaDoseProduct',\n      '00181160': 'FilterType',\n      '00181161': 'TypeOfFilters',\n      '00181162': 'IntensifierSize',\n      '00181164': 'ImagerPixelSpacing',\n      '00181166': 'Grid',\n      '00181170': 'GeneratorPower',\n      '00181180': 'CollimatorGridName',\n      '00181181': 'CollimatorType',\n      '00181182': 'FocalDistance',\n      '00181183': 'XFocusCenter',\n      '00181184': 'YFocusCenter',\n      '00181190': 'FocalSpots',\n      '00181191': 'AnodeTargetMaterial',\n      '001811A0': 'BodyPartThickness',\n      '001811A2': 'CompressionForce',\n      '001811A3': 'CompressionPressure',\n      '001811A4': 'PaddleDescription',\n      '001811A5': 'CompressionContactArea',\n      '00181200': 'DateOfLastCalibration',\n      '00181201': 'TimeOfLastCalibration',\n      '00181202': 'DateTimeOfLastCalibration',\n      '00181210': 'ConvolutionKernel',\n      '00181240': 'UpperLowerPixelValues',\n      '00181242': 'ActualFrameDuration',\n      '00181243': 'CountRate',\n      '00181244': 'PreferredPlaybackSequencing',\n      '00181250': 'ReceiveCoilName',\n      '00181251': 'TransmitCoilName',\n      '00181260': 'PlateType',\n      '00181261': 'PhosphorType',\n      '00181271': 'WaterEquivalentDiameter',\n      '00181272': 'WaterEquivalentDiameterCalculationMethodCodeSequence',\n      '00181300': 'ScanVelocity',\n      '00181301': 'WholeBodyTechnique',\n      '00181302': 'ScanLength',\n      '00181310': 'AcquisitionMatrix',\n      '00181312': 'InPlanePhaseEncodingDirection',\n      '00181314': 'FlipAngle',\n      '00181315': 'VariableFlipAngleFlag',\n      '00181316': 'SAR',\n      '00181318': 'dBdt',\n      '00181320': 'B1rms',\n      '00181400': 'AcquisitionDeviceProcessingDescription',\n      '00181401': 'AcquisitionDeviceProcessingCode',\n      '00181402': 'CassetteOrientation',\n      '00181403': 'CassetteSize',\n      '00181404': 'ExposuresOnPlate',\n      '00181405': 'RelativeXRayExposure',\n      '00181411': 'ExposureIndex',\n      '00181412': 'TargetExposureIndex',\n      '00181413': 'DeviationIndex',\n      '00181450': 'ColumnAngulation',\n      '00181460': 'TomoLayerHeight',\n      '00181470': 'TomoAngle',\n      '00181480': 'TomoTime',\n      '00181490': 'TomoType',\n      '00181491': 'TomoClass',\n      '00181495': 'NumberOfTomosynthesisSourceImages',\n      '00181500': 'PositionerMotion',\n      '00181508': 'PositionerType',\n      '00181510': 'PositionerPrimaryAngle',\n      '00181511': 'PositionerSecondaryAngle',\n      '00181520': 'PositionerPrimaryAngleIncrement',\n      '00181521': 'PositionerSecondaryAngleIncrement',\n      '00181530': 'DetectorPrimaryAngle',\n      '00181531': 'DetectorSecondaryAngle',\n      '00181600': 'ShutterShape',\n      '00181602': 'ShutterLeftVerticalEdge',\n      '00181604': 'ShutterRightVerticalEdge',\n      '00181606': 'ShutterUpperHorizontalEdge',\n      '00181608': 'ShutterLowerHorizontalEdge',\n      '00181610': 'CenterOfCircularShutter',\n      '00181612': 'RadiusOfCircularShutter',\n      '00181620': 'VerticesOfThePolygonalShutter',\n      '00181622': 'ShutterPresentationValue',\n      '00181623': 'ShutterOverlayGroup',\n      '00181624': 'ShutterPresentationColorCIELabValue',\n      '00181700': 'CollimatorShape',\n      '00181702': 'CollimatorLeftVerticalEdge',\n      '00181704': 'CollimatorRightVerticalEdge',\n      '00181706': 'CollimatorUpperHorizontalEdge',\n      '00181708': 'CollimatorLowerHorizontalEdge',\n      '00181710': 'CenterOfCircularCollimator',\n      '00181712': 'RadiusOfCircularCollimator',\n      '00181720': 'VerticesOfThePolygonalCollimator',\n      '00181800': 'AcquisitionTimeSynchronized',\n      '00181801': 'TimeSource',\n      '00181802': 'TimeDistributionProtocol',\n      '00181803': 'NTPSourceAddress',\n      '00182001': 'PageNumberVector',\n      '00182002': 'FrameLabelVector',\n      '00182003': 'FramePrimaryAngleVector',\n      '00182004': 'FrameSecondaryAngleVector',\n      '00182005': 'SliceLocationVector',\n      '00182006': 'DisplayWindowLabelVector',\n      '00182010': 'NominalScannedPixelSpacing',\n      '00182020': 'DigitizingDeviceTransportDirection',\n      '00182030': 'RotationOfScannedFilm',\n      '00182041': 'BiopsyTargetSequence',\n      '00182042': 'TargetUID',\n      '00182043': 'LocalizingCursorPosition',\n      '00182044': 'CalculatedTargetPosition',\n      '00182045': 'TargetLabel',\n      '00182046': 'DisplayedZValue',\n      '00183100': 'IVUSAcquisition',\n      '00183101': 'IVUSPullbackRate',\n      '00183102': 'IVUSGatedRate',\n      '00183103': 'IVUSPullbackStartFrameNumber',\n      '00183104': 'IVUSPullbackStopFrameNumber',\n      '00183105': 'LesionNumber',\n      '00184000': 'AcquisitionComments',\n      '00185000': 'OutputPower',\n      '00185010': 'TransducerData',\n      '00185012': 'FocusDepth',\n      '00185020': 'ProcessingFunction',\n      '00185021': 'PostprocessingFunction',\n      '00185022': 'MechanicalIndex',\n      '00185024': 'BoneThermalIndex',\n      '00185026': 'CranialThermalIndex',\n      '00185027': 'SoftTissueThermalIndex',\n      '00185028': 'SoftTissueFocusThermalIndex',\n      '00185029': 'SoftTissueSurfaceThermalIndex',\n      '00185030': 'DynamicRange',\n      '00185040': 'TotalGain',\n      '00185050': 'DepthOfScanField',\n      '00185100': 'PatientPosition',\n      '00185101': 'ViewPosition',\n      '00185104': 'ProjectionEponymousNameCodeSequence',\n      '00185210': 'ImageTransformationMatrix',\n      '00185212': 'ImageTranslationVector',\n      '00186000': 'Sensitivity',\n      '00186011': 'SequenceOfUltrasoundRegions',\n      '00186012': 'RegionSpatialFormat',\n      '00186014': 'RegionDataType',\n      '00186016': 'RegionFlags',\n      '00186018': 'RegionLocationMinX0',\n      '0018601A': 'RegionLocationMinY0',\n      '0018601C': 'RegionLocationMaxX1',\n      '0018601E': 'RegionLocationMaxY1',\n      '00186020': 'ReferencePixelX0',\n      '00186022': 'ReferencePixelY0',\n      '00186024': 'PhysicalUnitsXDirection',\n      '00186026': 'PhysicalUnitsYDirection',\n      '00186028': 'ReferencePixelPhysicalValueX',\n      '0018602A': 'ReferencePixelPhysicalValueY',\n      '0018602C': 'PhysicalDeltaX',\n      '0018602E': 'PhysicalDeltaY',\n      '00186030': 'TransducerFrequency',\n      '00186031': 'TransducerType',\n      '00186032': 'PulseRepetitionFrequency',\n      '00186034': 'DopplerCorrectionAngle',\n      '00186036': 'SteeringAngle',\n      '00186038': 'DopplerSampleVolumeXPositionRetired',\n      '00186039': 'DopplerSampleVolumeXPosition',\n      '0018603A': 'DopplerSampleVolumeYPositionRetired',\n      '0018603B': 'DopplerSampleVolumeYPosition',\n      '0018603C': 'TMLinePositionX0Retired',\n      '0018603D': 'TMLinePositionX0',\n      '0018603E': 'TMLinePositionY0Retired',\n      '0018603F': 'TMLinePositionY0',\n      '00186040': 'TMLinePositionX1Retired',\n      '00186041': 'TMLinePositionX1',\n      '00186042': 'TMLinePositionY1Retired',\n      '00186043': 'TMLinePositionY1',\n      '00186044': 'PixelComponentOrganization',\n      '00186046': 'PixelComponentMask',\n      '00186048': 'PixelComponentRangeStart',\n      '0018604A': 'PixelComponentRangeStop',\n      '0018604C': 'PixelComponentPhysicalUnits',\n      '0018604E': 'PixelComponentDataType',\n      '00186050': 'NumberOfTableBreakPoints',\n      '00186052': 'TableOfXBreakPoints',\n      '00186054': 'TableOfYBreakPoints',\n      '00186056': 'NumberOfTableEntries',\n      '00186058': 'TableOfPixelValues',\n      '0018605A': 'TableOfParameterValues',\n      '00186060': 'RWaveTimeVector',\n      '00187000': 'DetectorConditionsNominalFlag',\n      '00187001': 'DetectorTemperature',\n      '00187004': 'DetectorType',\n      '00187005': 'DetectorConfiguration',\n      '00187006': 'DetectorDescription',\n      '00187008': 'DetectorMode',\n      '0018700A': 'DetectorID',\n      '0018700C': 'DateOfLastDetectorCalibration',\n      '0018700E': 'TimeOfLastDetectorCalibration',\n      '00187010': 'ExposuresOnDetectorSinceLastCalibration',\n      '00187011': 'ExposuresOnDetectorSinceManufactured',\n      '00187012': 'DetectorTimeSinceLastExposure',\n      '00187014': 'DetectorActiveTime',\n      '00187016': 'DetectorActivationOffsetFromExposure',\n      '0018701A': 'DetectorBinning',\n      '00187020': 'DetectorElementPhysicalSize',\n      '00187022': 'DetectorElementSpacing',\n      '00187024': 'DetectorActiveShape',\n      '00187026': 'DetectorActiveDimensions',\n      '00187028': 'DetectorActiveOrigin',\n      '0018702A': 'DetectorManufacturerName',\n      '0018702B': 'DetectorManufacturerModelName',\n      '00187030': 'FieldOfViewOrigin',\n      '00187032': 'FieldOfViewRotation',\n      '00187034': 'FieldOfViewHorizontalFlip',\n      '00187036': 'PixelDataAreaOriginRelativeToFOV',\n      '00187038': 'PixelDataAreaRotationAngleRelativeToFOV',\n      '00187040': 'GridAbsorbingMaterial',\n      '00187041': 'GridSpacingMaterial',\n      '00187042': 'GridThickness',\n      '00187044': 'GridPitch',\n      '00187046': 'GridAspectRatio',\n      '00187048': 'GridPeriod',\n      '0018704C': 'GridFocalDistance',\n      '00187050': 'FilterMaterial',\n      '00187052': 'FilterThicknessMinimum',\n      '00187054': 'FilterThicknessMaximum',\n      '00187056': 'FilterBeamPathLengthMinimum',\n      '00187058': 'FilterBeamPathLengthMaximum',\n      '00187060': 'ExposureControlMode',\n      '00187062': 'ExposureControlModeDescription',\n      '00187064': 'ExposureStatus',\n      '00187065': 'PhototimerSetting',\n      '00188150': 'ExposureTimeInuS',\n      '00188151': 'XRayTubeCurrentInuA',\n      '00189004': 'ContentQualification',\n      '00189005': 'PulseSequenceName',\n      '00189006': 'MRImagingModifierSequence',\n      '00189008': 'EchoPulseSequence',\n      '00189009': 'InversionRecovery',\n      '00189010': 'FlowCompensation',\n      '00189011': 'MultipleSpinEcho',\n      '00189012': 'MultiPlanarExcitation',\n      '00189014': 'PhaseContrast',\n      '00189015': 'TimeOfFlightContrast',\n      '00189016': 'Spoiling',\n      '00189017': 'SteadyStatePulseSequence',\n      '00189018': 'EchoPlanarPulseSequence',\n      '00189019': 'TagAngleFirstAxis',\n      '00189020': 'MagnetizationTransfer',\n      '00189021': 'T2Preparation',\n      '00189022': 'BloodSignalNulling',\n      '00189024': 'SaturationRecovery',\n      '00189025': 'SpectrallySelectedSuppression',\n      '00189026': 'SpectrallySelectedExcitation',\n      '00189027': 'SpatialPresaturation',\n      '00189028': 'Tagging',\n      '00189029': 'OversamplingPhase',\n      '00189030': 'TagSpacingFirstDimension',\n      '00189032': 'GeometryOfKSpaceTraversal',\n      '00189033': 'SegmentedKSpaceTraversal',\n      '00189034': 'RectilinearPhaseEncodeReordering',\n      '00189035': 'TagThickness',\n      '00189036': 'PartialFourierDirection',\n      '00189037': 'CardiacSynchronizationTechnique',\n      '00189041': 'ReceiveCoilManufacturerName',\n      '00189042': 'MRReceiveCoilSequence',\n      '00189043': 'ReceiveCoilType',\n      '00189044': 'QuadratureReceiveCoil',\n      '00189045': 'MultiCoilDefinitionSequence',\n      '00189046': 'MultiCoilConfiguration',\n      '00189047': 'MultiCoilElementName',\n      '00189048': 'MultiCoilElementUsed',\n      '00189049': 'MRTransmitCoilSequence',\n      '00189050': 'TransmitCoilManufacturerName',\n      '00189051': 'TransmitCoilType',\n      '00189052': 'SpectralWidth',\n      '00189053': 'ChemicalShiftReference',\n      '00189054': 'VolumeLocalizationTechnique',\n      '00189058': 'MRAcquisitionFrequencyEncodingSteps',\n      '00189059': 'Decoupling',\n      '00189060': 'DecoupledNucleus',\n      '00189061': 'DecouplingFrequency',\n      '00189062': 'DecouplingMethod',\n      '00189063': 'DecouplingChemicalShiftReference',\n      '00189064': 'KSpaceFiltering',\n      '00189065': 'TimeDomainFiltering',\n      '00189066': 'NumberOfZeroFills',\n      '00189067': 'BaselineCorrection',\n      '00189069': 'ParallelReductionFactorInPlane',\n      '00189070': 'CardiacRRIntervalSpecified',\n      '00189073': 'AcquisitionDuration',\n      '00189074': 'FrameAcquisitionDateTime',\n      '00189075': 'DiffusionDirectionality',\n      '00189076': 'DiffusionGradientDirectionSequence',\n      '00189077': 'ParallelAcquisition',\n      '00189078': 'ParallelAcquisitionTechnique',\n      '00189079': 'InversionTimes',\n      '00189080': 'MetaboliteMapDescription',\n      '00189081': 'PartialFourier',\n      '00189082': 'EffectiveEchoTime',\n      '00189083': 'MetaboliteMapCodeSequence',\n      '00189084': 'ChemicalShiftSequence',\n      '00189085': 'CardiacSignalSource',\n      '00189087': 'DiffusionBValue',\n      '00189089': 'DiffusionGradientOrientation',\n      '00189090': 'VelocityEncodingDirection',\n      '00189091': 'VelocityEncodingMinimumValue',\n      '00189092': 'VelocityEncodingAcquisitionSequence',\n      '00189093': 'NumberOfKSpaceTrajectories',\n      '00189094': 'CoverageOfKSpace',\n      '00189095': 'SpectroscopyAcquisitionPhaseRows',\n      '00189096': 'ParallelReductionFactorInPlaneRetired',\n      '00189098': 'TransmitterFrequency',\n      '00189100': 'ResonantNucleus',\n      '00189101': 'FrequencyCorrection',\n      '00189103': 'MRSpectroscopyFOVGeometrySequence',\n      '00189104': 'SlabThickness',\n      '00189105': 'SlabOrientation',\n      '00189106': 'MidSlabPosition',\n      '00189107': 'MRSpatialSaturationSequence',\n      '00189112': 'MRTimingAndRelatedParametersSequence',\n      '00189114': 'MREchoSequence',\n      '00189115': 'MRModifierSequence',\n      '00189117': 'MRDiffusionSequence',\n      '00189118': 'CardiacSynchronizationSequence',\n      '00189119': 'MRAveragesSequence',\n      '00189125': 'MRFOVGeometrySequence',\n      '00189126': 'VolumeLocalizationSequence',\n      '00189127': 'SpectroscopyAcquisitionDataColumns',\n      '00189147': 'DiffusionAnisotropyType',\n      '00189151': 'FrameReferenceDateTime',\n      '00189152': 'MRMetaboliteMapSequence',\n      '00189155': 'ParallelReductionFactorOutOfPlane',\n      '00189159': 'SpectroscopyAcquisitionOutOfPlanePhaseSteps',\n      '00189166': 'BulkMotionStatus',\n      '00189168': 'ParallelReductionFactorSecondInPlane',\n      '00189169': 'CardiacBeatRejectionTechnique',\n      '00189170': 'RespiratoryMotionCompensationTechnique',\n      '00189171': 'RespiratorySignalSource',\n      '00189172': 'BulkMotionCompensationTechnique',\n      '00189173': 'BulkMotionSignalSource',\n      '00189174': 'ApplicableSafetyStandardAgency',\n      '00189175': 'ApplicableSafetyStandardDescription',\n      '00189176': 'OperatingModeSequence',\n      '00189177': 'OperatingModeType',\n      '00189178': 'OperatingMode',\n      '00189179': 'SpecificAbsorptionRateDefinition',\n      '00189180': 'GradientOutputType',\n      '00189181': 'SpecificAbsorptionRateValue',\n      '00189182': 'GradientOutput',\n      '00189183': 'FlowCompensationDirection',\n      '00189184': 'TaggingDelay',\n      '00189185': 'RespiratoryMotionCompensationTechniqueDescription',\n      '00189186': 'RespiratorySignalSourceID',\n      '00189195': 'ChemicalShiftMinimumIntegrationLimitInHz',\n      '00189196': 'ChemicalShiftMaximumIntegrationLimitInHz',\n      '00189197': 'MRVelocityEncodingSequence',\n      '00189198': 'FirstOrderPhaseCorrection',\n      '00189199': 'WaterReferencedPhaseCorrection',\n      '00189200': 'MRSpectroscopyAcquisitionType',\n      '00189214': 'RespiratoryCyclePosition',\n      '00189217': 'VelocityEncodingMaximumValue',\n      '00189218': 'TagSpacingSecondDimension',\n      '00189219': 'TagAngleSecondAxis',\n      '00189220': 'FrameAcquisitionDuration',\n      '00189226': 'MRImageFrameTypeSequence',\n      '00189227': 'MRSpectroscopyFrameTypeSequence',\n      '00189231': 'MRAcquisitionPhaseEncodingStepsInPlane',\n      '00189232': 'MRAcquisitionPhaseEncodingStepsOutOfPlane',\n      '00189234': 'SpectroscopyAcquisitionPhaseColumns',\n      '00189236': 'CardiacCyclePosition',\n      '00189239': 'SpecificAbsorptionRateSequence',\n      '00189240': 'RFEchoTrainLength',\n      '00189241': 'GradientEchoTrainLength',\n      '00189250': 'ArterialSpinLabelingContrast',\n      '00189251': 'MRArterialSpinLabelingSequence',\n      '00189252': 'ASLTechniqueDescription',\n      '00189253': 'ASLSlabNumber',\n      '00189254': 'ASLSlabThickness',\n      '00189255': 'ASLSlabOrientation',\n      '00189256': 'ASLMidSlabPosition',\n      '00189257': 'ASLContext',\n      '00189258': 'ASLPulseTrainDuration',\n      '00189259': 'ASLCrusherFlag',\n      '0018925A': 'ASLCrusherFlowLimit',\n      '0018925B': 'ASLCrusherDescription',\n      '0018925C': 'ASLBolusCutoffFlag',\n      '0018925D': 'ASLBolusCutoffTimingSequence',\n      '0018925E': 'ASLBolusCutoffTechnique',\n      '0018925F': 'ASLBolusCutoffDelayTime',\n      '00189260': 'ASLSlabSequence',\n      '00189295': 'ChemicalShiftMinimumIntegrationLimitInppm',\n      '00189296': 'ChemicalShiftMaximumIntegrationLimitInppm',\n      '00189297': 'WaterReferenceAcquisition',\n      '00189298': 'EchoPeakPosition',\n      '00189301': 'CTAcquisitionTypeSequence',\n      '00189302': 'AcquisitionType',\n      '00189303': 'TubeAngle',\n      '00189304': 'CTAcquisitionDetailsSequence',\n      '00189305': 'RevolutionTime',\n      '00189306': 'SingleCollimationWidth',\n      '00189307': 'TotalCollimationWidth',\n      '00189308': 'CTTableDynamicsSequence',\n      '00189309': 'TableSpeed',\n      '00189310': 'TableFeedPerRotation',\n      '00189311': 'SpiralPitchFactor',\n      '00189312': 'CTGeometrySequence',\n      '00189313': 'DataCollectionCenterPatient',\n      '00189314': 'CTReconstructionSequence',\n      '00189315': 'ReconstructionAlgorithm',\n      '00189316': 'ConvolutionKernelGroup',\n      '00189317': 'ReconstructionFieldOfView',\n      '00189318': 'ReconstructionTargetCenterPatient',\n      '00189319': 'ReconstructionAngle',\n      '00189320': 'ImageFilter',\n      '00189321': 'CTExposureSequence',\n      '00189322': 'ReconstructionPixelSpacing',\n      '00189323': 'ExposureModulationType',\n      '00189324': 'EstimatedDoseSaving',\n      '00189325': 'CTXRayDetailsSequence',\n      '00189326': 'CTPositionSequence',\n      '00189327': 'TablePosition',\n      '00189328': 'ExposureTimeInms',\n      '00189329': 'CTImageFrameTypeSequence',\n      '00189330': 'XRayTubeCurrentInmA',\n      '00189332': 'ExposureInmAs',\n      '00189333': 'ConstantVolumeFlag',\n      '00189334': 'FluoroscopyFlag',\n      '00189335': 'DistanceSourceToDataCollectionCenter',\n      '00189337': 'ContrastBolusAgentNumber',\n      '00189338': 'ContrastBolusIngredientCodeSequence',\n      '00189340': 'ContrastAdministrationProfileSequence',\n      '00189341': 'ContrastBolusUsageSequence',\n      '00189342': 'ContrastBolusAgentAdministered',\n      '00189343': 'ContrastBolusAgentDetected',\n      '00189344': 'ContrastBolusAgentPhase',\n      '00189345': 'CTDIvol',\n      '00189346': 'CTDIPhantomTypeCodeSequence',\n      '00189351': 'CalciumScoringMassFactorPatient',\n      '00189352': 'CalciumScoringMassFactorDevice',\n      '00189353': 'EnergyWeightingFactor',\n      '00189360': 'CTAdditionalXRaySourceSequence',\n      '00189401': 'ProjectionPixelCalibrationSequence',\n      '00189402': 'DistanceSourceToIsocenter',\n      '00189403': 'DistanceObjectToTableTop',\n      '00189404': 'ObjectPixelSpacingInCenterOfBeam',\n      '00189405': 'PositionerPositionSequence',\n      '00189406': 'TablePositionSequence',\n      '00189407': 'CollimatorShapeSequence',\n      '00189410': 'PlanesInAcquisition',\n      '00189412': 'XAXRFFrameCharacteristicsSequence',\n      '00189417': 'FrameAcquisitionSequence',\n      '00189420': 'XRayReceptorType',\n      '00189423': 'AcquisitionProtocolName',\n      '00189424': 'AcquisitionProtocolDescription',\n      '00189425': 'ContrastBolusIngredientOpaque',\n      '00189426': 'DistanceReceptorPlaneToDetectorHousing',\n      '00189427': 'IntensifierActiveShape',\n      '00189428': 'IntensifierActiveDimensions',\n      '00189429': 'PhysicalDetectorSize',\n      '00189430': 'PositionOfIsocenterProjection',\n      '00189432': 'FieldOfViewSequence',\n      '00189433': 'FieldOfViewDescription',\n      '00189434': 'ExposureControlSensingRegionsSequence',\n      '00189435': 'ExposureControlSensingRegionShape',\n      '00189436': 'ExposureControlSensingRegionLeftVerticalEdge',\n      '00189437': 'ExposureControlSensingRegionRightVerticalEdge',\n      '00189438': 'ExposureControlSensingRegionUpperHorizontalEdge',\n      '00189439': 'ExposureControlSensingRegionLowerHorizontalEdge',\n      '00189440': 'CenterOfCircularExposureControlSensingRegion',\n      '00189441': 'RadiusOfCircularExposureControlSensingRegion',\n      '00189442': 'VerticesOfThePolygonalExposureControlSensingRegion',\n      '00189445': '',\n      '00189447': 'ColumnAngulationPatient',\n      '00189449': 'BeamAngle',\n      '00189451': 'FrameDetectorParametersSequence',\n      '00189452': 'CalculatedAnatomyThickness',\n      '00189455': 'CalibrationSequence',\n      '00189456': 'ObjectThicknessSequence',\n      '00189457': 'PlaneIdentification',\n      '00189461': 'FieldOfViewDimensionsInFloat',\n      '00189462': 'IsocenterReferenceSystemSequence',\n      '00189463': 'PositionerIsocenterPrimaryAngle',\n      '00189464': 'PositionerIsocenterSecondaryAngle',\n      '00189465': 'PositionerIsocenterDetectorRotationAngle',\n      '00189466': 'TableXPositionToIsocenter',\n      '00189467': 'TableYPositionToIsocenter',\n      '00189468': 'TableZPositionToIsocenter',\n      '00189469': 'TableHorizontalRotationAngle',\n      '00189470': 'TableHeadTiltAngle',\n      '00189471': 'TableCradleTiltAngle',\n      '00189472': 'FrameDisplayShutterSequence',\n      '00189473': 'AcquiredImageAreaDoseProduct',\n      '00189474': 'CArmPositionerTabletopRelationship',\n      '00189476': 'XRayGeometrySequence',\n      '00189477': 'IrradiationEventIdentificationSequence',\n      '00189504': 'XRay3DFrameTypeSequence',\n      '00189506': 'ContributingSourcesSequence',\n      '00189507': 'XRay3DAcquisitionSequence',\n      '00189508': 'PrimaryPositionerScanArc',\n      '00189509': 'SecondaryPositionerScanArc',\n      '00189510': 'PrimaryPositionerScanStartAngle',\n      '00189511': 'SecondaryPositionerScanStartAngle',\n      '00189514': 'PrimaryPositionerIncrement',\n      '00189515': 'SecondaryPositionerIncrement',\n      '00189516': 'StartAcquisitionDateTime',\n      '00189517': 'EndAcquisitionDateTime',\n      '00189518': 'PrimaryPositionerIncrementSign',\n      '00189519': 'SecondaryPositionerIncrementSign',\n      '00189524': 'ApplicationName',\n      '00189525': 'ApplicationVersion',\n      '00189526': 'ApplicationManufacturer',\n      '00189527': 'AlgorithmType',\n      '00189528': 'AlgorithmDescription',\n      '00189530': 'XRay3DReconstructionSequence',\n      '00189531': 'ReconstructionDescription',\n      '00189538': 'PerProjectionAcquisitionSequence',\n      '00189541': 'DetectorPositionSequence',\n      '00189542': 'XRayAcquisitionDoseSequence',\n      '00189543': 'XRaySourceIsocenterPrimaryAngle',\n      '00189544': 'XRaySourceIsocenterSecondaryAngle',\n      '00189545': 'BreastSupportIsocenterPrimaryAngle',\n      '00189546': 'BreastSupportIsocenterSecondaryAngle',\n      '00189547': 'BreastSupportXPositionToIsocenter',\n      '00189548': 'BreastSupportYPositionToIsocenter',\n      '00189549': 'BreastSupportZPositionToIsocenter',\n      '00189550': 'DetectorIsocenterPrimaryAngle',\n      '00189551': 'DetectorIsocenterSecondaryAngle',\n      '00189552': 'DetectorXPositionToIsocenter',\n      '00189553': 'DetectorYPositionToIsocenter',\n      '00189554': 'DetectorZPositionToIsocenter',\n      '00189555': 'XRayGridSequence',\n      '00189556': 'XRayFilterSequence',\n      '00189557': 'DetectorActiveAreaTLHCPosition',\n      '00189558': 'DetectorActiveAreaOrientation',\n      '00189559': 'PositionerPrimaryAngleDirection',\n      '00189601': 'DiffusionBMatrixSequence',\n      '00189602': 'DiffusionBValueXX',\n      '00189603': 'DiffusionBValueXY',\n      '00189604': 'DiffusionBValueXZ',\n      '00189605': 'DiffusionBValueYY',\n      '00189606': 'DiffusionBValueYZ',\n      '00189607': 'DiffusionBValueZZ',\n      '00189621': 'FunctionalMRSequence',\n      '00189622': 'FunctionalSettlingPhaseFramesPresent',\n      '00189623': 'FunctionalSyncPulse',\n      '00189624': 'SettlingPhaseFrame',\n      '00189701': 'DecayCorrectionDateTime',\n      '00189715': 'StartDensityThreshold',\n      '00189716': 'StartRelativeDensityDifferenceThreshold',\n      '00189717': 'StartCardiacTriggerCountThreshold',\n      '00189718': 'StartRespiratoryTriggerCountThreshold',\n      '00189719': 'TerminationCountsThreshold',\n      '00189720': 'TerminationDensityThreshold',\n      '00189721': 'TerminationRelativeDensityThreshold',\n      '00189722': 'TerminationTimeThreshold',\n      '00189723': 'TerminationCardiacTriggerCountThreshold',\n      '00189724': 'TerminationRespiratoryTriggerCountThreshold',\n      '00189725': 'DetectorGeometry',\n      '00189726': 'TransverseDetectorSeparation',\n      '00189727': 'AxialDetectorDimension',\n      '00189729': 'RadiopharmaceuticalAgentNumber',\n      '00189732': 'PETFrameAcquisitionSequence',\n      '00189733': 'PETDetectorMotionDetailsSequence',\n      '00189734': 'PETTableDynamicsSequence',\n      '00189735': 'PETPositionSequence',\n      '00189736': 'PETFrameCorrectionFactorsSequence',\n      '00189737': 'RadiopharmaceuticalUsageSequence',\n      '00189738': 'AttenuationCorrectionSource',\n      '00189739': 'NumberOfIterations',\n      '00189740': 'NumberOfSubsets',\n      '00189749': 'PETReconstructionSequence',\n      '00189751': 'PETFrameTypeSequence',\n      '00189755': 'TimeOfFlightInformationUsed',\n      '00189756': 'ReconstructionType',\n      '00189758': 'DecayCorrected',\n      '00189759': 'AttenuationCorrected',\n      '00189760': 'ScatterCorrected',\n      '00189761': 'DeadTimeCorrected',\n      '00189762': 'GantryMotionCorrected',\n      '00189763': 'PatientMotionCorrected',\n      '00189764': 'CountLossNormalizationCorrected',\n      '00189765': 'RandomsCorrected',\n      '00189766': 'NonUniformRadialSamplingCorrected',\n      '00189767': 'SensitivityCalibrated',\n      '00189768': 'DetectorNormalizationCorrection',\n      '00189769': 'IterativeReconstructionMethod',\n      '00189770': 'AttenuationCorrectionTemporalRelationship',\n      '00189771': 'PatientPhysiologicalStateSequence',\n      '00189772': 'PatientPhysiologicalStateCodeSequence',\n      '00189801': 'DepthsOfFocus',\n      '00189803': 'ExcludedIntervalsSequence',\n      '00189804': 'ExclusionStartDateTime',\n      '00189805': 'ExclusionDuration',\n      '00189806': 'USImageDescriptionSequence',\n      '00189807': 'ImageDataTypeSequence',\n      '00189808': 'DataType',\n      '00189809': 'TransducerScanPatternCodeSequence',\n      '0018980B': 'AliasedDataType',\n      '0018980C': 'PositionMeasuringDeviceUsed',\n      '0018980D': 'TransducerGeometryCodeSequence',\n      '0018980E': 'TransducerBeamSteeringCodeSequence',\n      '0018980F': 'TransducerApplicationCodeSequence',\n      '00189810': 'ZeroVelocityPixelValue',\n      '00189900': 'ReferenceLocationLabel',\n      '00189901': 'ReferenceLocationDescription',\n      '00189902': 'ReferenceBasisCodeSequence',\n      '00189903': 'ReferenceGeometryCodeSequence',\n      '00189904': 'OffsetDistance',\n      '00189905': 'OffsetDirection',\n      '00189906': 'PotentialScheduledProtocolCodeSequence',\n      '00189907': 'PotentialRequestedProcedureCodeSequence',\n      '00189908': 'PotentialReasonsForProcedure',\n      '00189909': 'PotentialReasonsForProcedureCodeSequence',\n      '0018990A': 'PotentialDiagnosticTasks',\n      '0018990B': 'ContraindicationsCodeSequence',\n      '0018990C': 'ReferencedDefinedProtocolSequence',\n      '0018990D': 'ReferencedPerformedProtocolSequence',\n      '0018990E': 'PredecessorProtocolSequence',\n      '0018990F': 'ProtocolPlanningInformation',\n      '00189910': 'ProtocolDesignRationale',\n      '00189911': 'PatientSpecificationSequence',\n      '00189912': 'ModelSpecificationSequence',\n      '00189913': 'ParametersSpecificationSequence',\n      '00189914': 'InstructionSequence',\n      '00189915': 'InstructionIndex',\n      '00189916': 'InstructionText',\n      '00189917': 'InstructionDescription',\n      '00189918': 'InstructionPerformedFlag',\n      '00189919': 'InstructionPerformedDateTime',\n      '0018991A': 'InstructionPerformanceComment',\n      '0018991B': 'PatientPositioningInstructionSequence',\n      '0018991C': 'PositioningMethodCodeSequence',\n      '0018991D': 'PositioningLandmarkSequence',\n      '0018991E': 'TargetFrameOfReferenceUID',\n      '0018991F': 'AcquisitionProtocolElementSpecificationSequence',\n      '00189920': 'AcquisitionProtocolElementSequence',\n      '00189921': 'ProtocolElementNumber',\n      '00189922': 'ProtocolElementName',\n      '00189923': 'ProtocolElementCharacteristicsSummary',\n      '00189924': 'ProtocolElementPurpose',\n      '00189930': 'AcquisitionMotion',\n      '00189931': 'AcquisitionStartLocationSequence',\n      '00189932': 'AcquisitionEndLocationSequence',\n      '00189933': 'ReconstructionProtocolElementSpecificationSequence',\n      '00189934': 'ReconstructionProtocolElementSequence',\n      '00189935': 'StorageProtocolElementSpecificationSequence',\n      '00189936': 'StorageProtocolElementSequence',\n      '00189937': 'RequestedSeriesDescription',\n      '00189938': 'SourceAcquisitionProtocolElementNumber',\n      '00189939': 'SourceAcquisitionBeamNumber',\n      '0018993A': 'SourceReconstructionProtocolElementNumber',\n      '0018993B': 'ReconstructionStartLocationSequence',\n      '0018993C': 'ReconstructionEndLocationSequence',\n      '0018993D': 'ReconstructionAlgorithmSequence',\n      '0018993E': 'ReconstructionTargetCenterLocationSequence',\n      '00189941': 'ImageFilterDescription',\n      '00189942': 'CTDIvolNotificationTrigger',\n      '00189943': 'DLPNotificationTrigger',\n      '00189944': 'AutoKVPSelectionType',\n      '00189945': 'AutoKVPUpperBound',\n      '00189946': 'AutoKVPLowerBound',\n      '00189947': 'ProtocolDefinedPatientPosition',\n      '0018A001': 'ContributingEquipmentSequence',\n      '0018A002': 'ContributionDateTime',\n      '0018A003': 'ContributionDescription',\n      '0020000D': 'StudyInstanceUID',\n      '0020000E': 'SeriesInstanceUID',\n      '00200010': 'StudyID',\n      '00200011': 'SeriesNumber',\n      '00200012': 'AcquisitionNumber',\n      '00200013': 'InstanceNumber',\n      '00200014': 'IsotopeNumber',\n      '00200015': 'PhaseNumber',\n      '00200016': 'IntervalNumber',\n      '00200017': 'TimeSlotNumber',\n      '00200018': 'AngleNumber',\n      '00200019': 'ItemNumber',\n      '00200020': 'PatientOrientation',\n      '00200022': 'OverlayNumber',\n      '00200024': 'CurveNumber',\n      '00200026': 'LUTNumber',\n      '00200030': 'ImagePosition',\n      '00200032': 'ImagePositionPatient',\n      '00200035': 'ImageOrientation',\n      '00200037': 'ImageOrientationPatient',\n      '00200050': 'Location',\n      '00200052': 'FrameOfReferenceUID',\n      '00200060': 'Laterality',\n      '00200062': 'ImageLaterality',\n      '00200070': 'ImageGeometryType',\n      '00200080': 'MaskingImage',\n      '002000AA': 'ReportNumber',\n      '00200100': 'TemporalPositionIdentifier',\n      '00200105': 'NumberOfTemporalPositions',\n      '00200110': 'TemporalResolution',\n      '00200200': 'SynchronizationFrameOfReferenceUID',\n      '00200242': 'SOPInstanceUIDOfConcatenationSource',\n      '00201000': 'SeriesInStudy',\n      '00201001': 'AcquisitionsInSeries',\n      '00201002': 'ImagesInAcquisition',\n      '00201003': 'ImagesInSeries',\n      '00201004': 'AcquisitionsInStudy',\n      '00201005': 'ImagesInStudy',\n      '00201020': 'Reference',\n      '0020103F': 'TargetPositionReferenceIndicator',\n      '00201040': 'PositionReferenceIndicator',\n      '00201041': 'SliceLocation',\n      '00201070': 'OtherStudyNumbers',\n      '00201200': 'NumberOfPatientRelatedStudies',\n      '00201202': 'NumberOfPatientRelatedSeries',\n      '00201204': 'NumberOfPatientRelatedInstances',\n      '00201206': 'NumberOfStudyRelatedSeries',\n      '00201208': 'NumberOfStudyRelatedInstances',\n      '00201209': 'NumberOfSeriesRelatedInstances',\n      '00203401': 'ModifyingDeviceID',\n      '00203402': 'ModifiedImageID',\n      '00203403': 'ModifiedImageDate',\n      '00203404': 'ModifyingDeviceManufacturer',\n      '00203405': 'ModifiedImageTime',\n      '00203406': 'ModifiedImageDescription',\n      '00204000': 'ImageComments',\n      '00205000': 'OriginalImageIdentification',\n      '00205002': 'OriginalImageIdentificationNomenclature',\n      '00209056': 'StackID',\n      '00209057': 'InStackPositionNumber',\n      '00209071': 'FrameAnatomySequence',\n      '00209072': 'FrameLaterality',\n      '00209111': 'FrameContentSequence',\n      '00209113': 'PlanePositionSequence',\n      '00209116': 'PlaneOrientationSequence',\n      '00209128': 'TemporalPositionIndex',\n      '00209153': 'NominalCardiacTriggerDelayTime',\n      '00209154': 'NominalCardiacTriggerTimePriorToRPeak',\n      '00209155': 'ActualCardiacTriggerTimePriorToRPeak',\n      '00209156': 'FrameAcquisitionNumber',\n      '00209157': 'DimensionIndexValues',\n      '00209158': 'FrameComments',\n      '00209161': 'ConcatenationUID',\n      '00209162': 'InConcatenationNumber',\n      '00209163': 'InConcatenationTotalNumber',\n      '00209164': 'DimensionOrganizationUID',\n      '00209165': 'DimensionIndexPointer',\n      '00209167': 'FunctionalGroupPointer',\n      '00209170': 'UnassignedSharedConvertedAttributesSequence',\n      '00209171': 'UnassignedPerFrameConvertedAttributesSequence',\n      '00209172': 'ConversionSourceAttributesSequence',\n      '00209213': 'DimensionIndexPrivateCreator',\n      '00209221': 'DimensionOrganizationSequence',\n      '00209222': 'DimensionIndexSequence',\n      '00209228': 'ConcatenationFrameOffsetNumber',\n      '00209238': 'FunctionalGroupPrivateCreator',\n      '00209241': 'NominalPercentageOfCardiacPhase',\n      '00209245': 'NominalPercentageOfRespiratoryPhase',\n      '00209246': 'StartingRespiratoryAmplitude',\n      '00209247': 'StartingRespiratoryPhase',\n      '00209248': 'EndingRespiratoryAmplitude',\n      '00209249': 'EndingRespiratoryPhase',\n      '00209250': 'RespiratoryTriggerType',\n      '00209251': 'RRIntervalTimeNominal',\n      '00209252': 'ActualCardiacTriggerDelayTime',\n      '00209253': 'RespiratorySynchronizationSequence',\n      '00209254': 'RespiratoryIntervalTime',\n      '00209255': 'NominalRespiratoryTriggerDelayTime',\n      '00209256': 'RespiratoryTriggerDelayThreshold',\n      '00209257': 'ActualRespiratoryTriggerDelayTime',\n      '00209301': 'ImagePositionVolume',\n      '00209302': 'ImageOrientationVolume',\n      '00209307': 'UltrasoundAcquisitionGeometry',\n      '00209308': 'ApexPosition',\n      '00209309': 'VolumeToTransducerMappingMatrix',\n      '0020930A': 'VolumeToTableMappingMatrix',\n      '0020930B': 'VolumeToTransducerRelationship',\n      '0020930C': 'PatientFrameOfReferenceSource',\n      '0020930D': 'TemporalPositionTimeOffset',\n      '0020930E': 'PlanePositionVolumeSequence',\n      '0020930F': 'PlaneOrientationVolumeSequence',\n      '00209310': 'TemporalPositionSequence',\n      '00209311': 'DimensionOrganizationType',\n      '00209312': 'VolumeFrameOfReferenceUID',\n      '00209313': 'TableFrameOfReferenceUID',\n      '00209421': 'DimensionDescriptionLabel',\n      '00209450': 'PatientOrientationInFrameSequence',\n      '00209453': 'FrameLabel',\n      '00209518': 'AcquisitionIndex',\n      '00209529': 'ContributingSOPInstancesReferenceSequence',\n      '00209536': 'ReconstructionIndex',\n      '00220001': 'LightPathFilterPassThroughWavelength',\n      '00220002': 'LightPathFilterPassBand',\n      '00220003': 'ImagePathFilterPassThroughWavelength',\n      '00220004': 'ImagePathFilterPassBand',\n      '00220005': 'PatientEyeMovementCommanded',\n      '00220006': 'PatientEyeMovementCommandCodeSequence',\n      '00220007': 'SphericalLensPower',\n      '00220008': 'CylinderLensPower',\n      '00220009': 'CylinderAxis',\n      '0022000A': 'EmmetropicMagnification',\n      '0022000B': 'IntraOcularPressure',\n      '0022000C': 'HorizontalFieldOfView',\n      '0022000D': 'PupilDilated',\n      '0022000E': 'DegreeOfDilation',\n      '00220010': 'StereoBaselineAngle',\n      '00220011': 'StereoBaselineDisplacement',\n      '00220012': 'StereoHorizontalPixelOffset',\n      '00220013': 'StereoVerticalPixelOffset',\n      '00220014': 'StereoRotation',\n      '00220015': 'AcquisitionDeviceTypeCodeSequence',\n      '00220016': 'IlluminationTypeCodeSequence',\n      '00220017': 'LightPathFilterTypeStackCodeSequence',\n      '00220018': 'ImagePathFilterTypeStackCodeSequence',\n      '00220019': 'LensesCodeSequence',\n      '0022001A': 'ChannelDescriptionCodeSequence',\n      '0022001B': 'RefractiveStateSequence',\n      '0022001C': 'MydriaticAgentCodeSequence',\n      '0022001D': 'RelativeImagePositionCodeSequence',\n      '0022001E': 'CameraAngleOfView',\n      '00220020': 'StereoPairsSequence',\n      '00220021': 'LeftImageSequence',\n      '00220022': 'RightImageSequence',\n      '00220028': 'StereoPairsPresent',\n      '00220030': 'AxialLengthOfTheEye',\n      '00220031': 'OphthalmicFrameLocationSequence',\n      '00220032': 'ReferenceCoordinates',\n      '00220035': 'DepthSpatialResolution',\n      '00220036': 'MaximumDepthDistortion',\n      '00220037': 'AlongScanSpatialResolution',\n      '00220038': 'MaximumAlongScanDistortion',\n      '00220039': 'OphthalmicImageOrientation',\n      '00220041': 'DepthOfTransverseImage',\n      '00220042': 'MydriaticAgentConcentrationUnitsSequence',\n      '00220048': 'AcrossScanSpatialResolution',\n      '00220049': 'MaximumAcrossScanDistortion',\n      '0022004E': 'MydriaticAgentConcentration',\n      '00220055': 'IlluminationWaveLength',\n      '00220056': 'IlluminationPower',\n      '00220057': 'IlluminationBandwidth',\n      '00220058': 'MydriaticAgentSequence',\n      '00221007': 'OphthalmicAxialMeasurementsRightEyeSequence',\n      '00221008': 'OphthalmicAxialMeasurementsLeftEyeSequence',\n      '00221009': 'OphthalmicAxialMeasurementsDeviceType',\n      '00221010': 'OphthalmicAxialLengthMeasurementsType',\n      '00221012': 'OphthalmicAxialLengthSequence',\n      '00221019': 'OphthalmicAxialLength',\n      '00221024': 'LensStatusCodeSequence',\n      '00221025': 'VitreousStatusCodeSequence',\n      '00221028': 'IOLFormulaCodeSequence',\n      '00221029': 'IOLFormulaDetail',\n      '00221033': 'KeratometerIndex',\n      '00221035': 'SourceOfOphthalmicAxialLengthCodeSequence',\n      '00221037': 'TargetRefraction',\n      '00221039': 'RefractiveProcedureOccurred',\n      '00221040': 'RefractiveSurgeryTypeCodeSequence',\n      '00221044': 'OphthalmicUltrasoundMethodCodeSequence',\n      '00221050': 'OphthalmicAxialLengthMeasurementsSequence',\n      '00221053': 'IOLPower',\n      '00221054': 'PredictedRefractiveError',\n      '00221059': 'OphthalmicAxialLengthVelocity',\n      '00221065': 'LensStatusDescription',\n      '00221066': 'VitreousStatusDescription',\n      '00221090': 'IOLPowerSequence',\n      '00221092': 'LensConstantSequence',\n      '00221093': 'IOLManufacturer',\n      '00221094': 'LensConstantDescription',\n      '00221095': 'ImplantName',\n      '00221096': 'KeratometryMeasurementTypeCodeSequence',\n      '00221097': 'ImplantPartNumber',\n      '00221100': 'ReferencedOphthalmicAxialMeasurementsSequence',\n      '00221101': 'OphthalmicAxialLengthMeasurementsSegmentNameCodeSequence',\n      '00221103': 'RefractiveErrorBeforeRefractiveSurgeryCodeSequence',\n      '00221121': 'IOLPowerForExactEmmetropia',\n      '00221122': 'IOLPowerForExactTargetRefraction',\n      '00221125': 'AnteriorChamberDepthDefinitionCodeSequence',\n      '00221127': 'LensThicknessSequence',\n      '00221128': 'AnteriorChamberDepthSequence',\n      '00221130': 'LensThickness',\n      '00221131': 'AnteriorChamberDepth',\n      '00221132': 'SourceOfLensThicknessDataCodeSequence',\n      '00221133': 'SourceOfAnteriorChamberDepthDataCodeSequence',\n      '00221134': 'SourceOfRefractiveMeasurementsSequence',\n      '00221135': 'SourceOfRefractiveMeasurementsCodeSequence',\n      '00221140': 'OphthalmicAxialLengthMeasurementModified',\n      '00221150': 'OphthalmicAxialLengthDataSourceCodeSequence',\n      '00221153': 'OphthalmicAxialLengthAcquisitionMethodCodeSequence',\n      '00221155': 'SignalToNoiseRatio',\n      '00221159': 'OphthalmicAxialLengthDataSourceDescription',\n      '00221210': 'OphthalmicAxialLengthMeasurementsTotalLengthSequence',\n      '00221211': 'OphthalmicAxialLengthMeasurementsSegmentalLengthSequence',\n      '00221212': 'OphthalmicAxialLengthMeasurementsLengthSummationSequence',\n      '00221220': 'UltrasoundOphthalmicAxialLengthMeasurementsSequence',\n      '00221225': 'OpticalOphthalmicAxialLengthMeasurementsSequence',\n      '00221230': 'UltrasoundSelectedOphthalmicAxialLengthSequence',\n      '00221250': 'OphthalmicAxialLengthSelectionMethodCodeSequence',\n      '00221255': 'OpticalSelectedOphthalmicAxialLengthSequence',\n      '00221257': 'SelectedSegmentalOphthalmicAxialLengthSequence',\n      '00221260': 'SelectedTotalOphthalmicAxialLengthSequence',\n      '00221262': 'OphthalmicAxialLengthQualityMetricSequence',\n      '00221265': 'OphthalmicAxialLengthQualityMetricTypeCodeSequence',\n      '00221273': 'OphthalmicAxialLengthQualityMetricTypeDescription',\n      '00221300': 'IntraocularLensCalculationsRightEyeSequence',\n      '00221310': 'IntraocularLensCalculationsLeftEyeSequence',\n      '00221330': 'ReferencedOphthalmicAxialLengthMeasurementQCImageSequence',\n      '00221415': 'OphthalmicMappingDeviceType',\n      '00221420': 'AcquisitionMethodCodeSequence',\n      '00221423': 'AcquisitionMethodAlgorithmSequence',\n      '00221436': 'OphthalmicThicknessMapTypeCodeSequence',\n      '00221443': 'OphthalmicThicknessMappingNormalsSequence',\n      '00221445': 'RetinalThicknessDefinitionCodeSequence',\n      '00221450': 'PixelValueMappingToCodedConceptSequence',\n      '00221452': 'MappedPixelValue',\n      '00221454': 'PixelValueMappingExplanation',\n      '00221458': 'OphthalmicThicknessMapQualityThresholdSequence',\n      '00221460': 'OphthalmicThicknessMapThresholdQualityRating',\n      '00221463': 'AnatomicStructureReferencePoint',\n      '00221465': 'RegistrationToLocalizerSequence',\n      '00221466': 'RegisteredLocalizerUnits',\n      '00221467': 'RegisteredLocalizerTopLeftHandCorner',\n      '00221468': 'RegisteredLocalizerBottomRightHandCorner',\n      '00221470': 'OphthalmicThicknessMapQualityRatingSequence',\n      '00221472': 'RelevantOPTAttributesSequence',\n      '00221512': 'TransformationMethodCodeSequence',\n      '00221513': 'TransformationAlgorithmSequence',\n      '00221515': 'OphthalmicAxialLengthMethod',\n      '00221517': 'OphthalmicFOV',\n      '00221518': 'TwoDimensionalToThreeDimensionalMapSequence',\n      '00221525': 'WideFieldOphthalmicPhotographyQualityRatingSequence',\n      '00221526': 'WideFieldOphthalmicPhotographyQualityThresholdSequence',\n      '00221527': 'WideFieldOphthalmicPhotographyThresholdQualityRating',\n      '00221528': 'XCoordinatesCenterPixelViewAngle',\n      '00221529': 'YCoordinatesCenterPixelViewAngle',\n      '00221530': 'NumberOfMapPoints',\n      '00221531': 'TwoDimensionalToThreeDimensionalMapData',\n      '00221612': 'DerivationAlgorithmSequence',\n      '00221615': 'OphthalmicImageTypeCodeSequence',\n      '00221616': 'OphthalmicImageTypeDescription',\n      '00221618': 'ScanPatternTypeCodeSequence',\n      '00221620': 'ReferencedSurfaceMeshIdentificationSequence',\n      '00221622': 'OphthalmicVolumetricPropertiesFlag',\n      '00221624': 'OphthalmicAnatomicReferencePointXCoordinate',\n      '00221626': 'OphthalmicAnatomicReferencePointYCoordinate',\n      '00221628': 'OphthalmicEnFaceImageQualityRatingSequence',\n      '00221630': 'QualityThreshold',\n      '00221640': 'OCTBscanAnalysisAcquisitionParametersSequence',\n      '00221642': 'NumberofBscansPerFrame',\n      '00221643': 'BscanSlabThickness',\n      '00221644': 'DistanceBetweenBscanSlabs',\n      '00221645': 'BscanCycleTime',\n      '00221646': 'BscanCycleTimeVector',\n      '00221649': 'AscanRate',\n      '00221650': 'BscanRate',\n      '00221658': 'SurfaceMeshZPixelOffset',\n      '00240010': 'VisualFieldHorizontalExtent',\n      '00240011': 'VisualFieldVerticalExtent',\n      '00240012': 'VisualFieldShape',\n      '00240016': 'ScreeningTestModeCodeSequence',\n      '00240018': 'MaximumStimulusLuminance',\n      '00240020': 'BackgroundLuminance',\n      '00240021': 'StimulusColorCodeSequence',\n      '00240024': 'BackgroundIlluminationColorCodeSequence',\n      '00240025': 'StimulusArea',\n      '00240028': 'StimulusPresentationTime',\n      '00240032': 'FixationSequence',\n      '00240033': 'FixationMonitoringCodeSequence',\n      '00240034': 'VisualFieldCatchTrialSequence',\n      '00240035': 'FixationCheckedQuantity',\n      '00240036': 'PatientNotProperlyFixatedQuantity',\n      '00240037': 'PresentedVisualStimuliDataFlag',\n      '00240038': 'NumberOfVisualStimuli',\n      '00240039': 'ExcessiveFixationLossesDataFlag',\n      '00240040': 'ExcessiveFixationLosses',\n      '00240042': 'StimuliRetestingQuantity',\n      '00240044': 'CommentsOnPatientPerformanceOfVisualField',\n      '00240045': 'FalseNegativesEstimateFlag',\n      '00240046': 'FalseNegativesEstimate',\n      '00240048': 'NegativeCatchTrialsQuantity',\n      '00240050': 'FalseNegativesQuantity',\n      '00240051': 'ExcessiveFalseNegativesDataFlag',\n      '00240052': 'ExcessiveFalseNegatives',\n      '00240053': 'FalsePositivesEstimateFlag',\n      '00240054': 'FalsePositivesEstimate',\n      '00240055': 'CatchTrialsDataFlag',\n      '00240056': 'PositiveCatchTrialsQuantity',\n      '00240057': 'TestPointNormalsDataFlag',\n      '00240058': 'TestPointNormalsSequence',\n      '00240059': 'GlobalDeviationProbabilityNormalsFlag',\n      '00240060': 'FalsePositivesQuantity',\n      '00240061': 'ExcessiveFalsePositivesDataFlag',\n      '00240062': 'ExcessiveFalsePositives',\n      '00240063': 'VisualFieldTestNormalsFlag',\n      '00240064': 'ResultsNormalsSequence',\n      '00240065': 'AgeCorrectedSensitivityDeviationAlgorithmSequence',\n      '00240066': 'GlobalDeviationFromNormal',\n      '00240067': 'GeneralizedDefectSensitivityDeviationAlgorithmSequence',\n      '00240068': 'LocalizedDeviationFromNormal',\n      '00240069': 'PatientReliabilityIndicator',\n      '00240070': 'VisualFieldMeanSensitivity',\n      '00240071': 'GlobalDeviationProbability',\n      '00240072': 'LocalDeviationProbabilityNormalsFlag',\n      '00240073': 'LocalizedDeviationProbability',\n      '00240074': 'ShortTermFluctuationCalculated',\n      '00240075': 'ShortTermFluctuation',\n      '00240076': 'ShortTermFluctuationProbabilityCalculated',\n      '00240077': 'ShortTermFluctuationProbability',\n      '00240078': 'CorrectedLocalizedDeviationFromNormalCalculated',\n      '00240079': 'CorrectedLocalizedDeviationFromNormal',\n      '00240080': 'CorrectedLocalizedDeviationFromNormalProbabilityCalculated',\n      '00240081': 'CorrectedLocalizedDeviationFromNormalProbability',\n      '00240083': 'GlobalDeviationProbabilitySequence',\n      '00240085': 'LocalizedDeviationProbabilitySequence',\n      '00240086': 'FovealSensitivityMeasured',\n      '00240087': 'FovealSensitivity',\n      '00240088': 'VisualFieldTestDuration',\n      '00240089': 'VisualFieldTestPointSequence',\n      '00240090': 'VisualFieldTestPointXCoordinate',\n      '00240091': 'VisualFieldTestPointYCoordinate',\n      '00240092': 'AgeCorrectedSensitivityDeviationValue',\n      '00240093': 'StimulusResults',\n      '00240094': 'SensitivityValue',\n      '00240095': 'RetestStimulusSeen',\n      '00240096': 'RetestSensitivityValue',\n      '00240097': 'VisualFieldTestPointNormalsSequence',\n      '00240098': 'QuantifiedDefect',\n      '00240100': 'AgeCorrectedSensitivityDeviationProbabilityValue',\n      '00240102': 'GeneralizedDefectCorrectedSensitivityDeviationFlag',\n      '00240103': 'GeneralizedDefectCorrectedSensitivityDeviationValue',\n      '00240104': 'GeneralizedDefectCorrectedSensitivityDeviationProbabilityValue',\n      '00240105': 'MinimumSensitivityValue',\n      '00240106': 'BlindSpotLocalized',\n      '00240107': 'BlindSpotXCoordinate',\n      '00240108': 'BlindSpotYCoordinate',\n      '00240110': 'VisualAcuityMeasurementSequence',\n      '00240112': 'RefractiveParametersUsedOnPatientSequence',\n      '00240113': 'MeasurementLaterality',\n      '00240114': 'OphthalmicPatientClinicalInformationLeftEyeSequence',\n      '00240115': 'OphthalmicPatientClinicalInformationRightEyeSequence',\n      '00240117': 'FovealPointNormativeDataFlag',\n      '00240118': 'FovealPointProbabilityValue',\n      '00240120': 'ScreeningBaselineMeasured',\n      '00240122': 'ScreeningBaselineMeasuredSequence',\n      '00240124': 'ScreeningBaselineType',\n      '00240126': 'ScreeningBaselineValue',\n      '00240202': 'AlgorithmSource',\n      '00240306': 'DataSetName',\n      '00240307': 'DataSetVersion',\n      '00240308': 'DataSetSource',\n      '00240309': 'DataSetDescription',\n      '00240317': 'VisualFieldTestReliabilityGlobalIndexSequence',\n      '00240320': 'VisualFieldGlobalResultsIndexSequence',\n      '00240325': 'DataObservationSequence',\n      '00240338': 'IndexNormalsFlag',\n      '00240341': 'IndexProbability',\n      '00240344': 'IndexProbabilitySequence',\n      '00280002': 'SamplesPerPixel',\n      '00280003': 'SamplesPerPixelUsed',\n      '00280004': 'PhotometricInterpretation',\n      '00280005': 'ImageDimensions',\n      '00280006': 'PlanarConfiguration',\n      '00280008': 'NumberOfFrames',\n      '00280009': 'FrameIncrementPointer',\n      '0028000A': 'FrameDimensionPointer',\n      '00280010': 'Rows',\n      '00280011': 'Columns',\n      '00280012': 'Planes',\n      '00280014': 'UltrasoundColorDataPresent',\n      '00280020': '',\n      '00280030': 'PixelSpacing',\n      '00280031': 'ZoomFactor',\n      '00280032': 'ZoomCenter',\n      '00280034': 'PixelAspectRatio',\n      '00280040': 'ImageFormat',\n      '00280050': 'ManipulatedImage',\n      '00280051': 'CorrectedImage',\n      '0028005F': 'CompressionRecognitionCode',\n      '00280060': 'CompressionCode',\n      '00280061': 'CompressionOriginator',\n      '00280062': 'CompressionLabel',\n      '00280063': 'CompressionDescription',\n      '00280065': 'CompressionSequence',\n      '00280066': 'CompressionStepPointers',\n      '00280068': 'RepeatInterval',\n      '00280069': 'BitsGrouped',\n      '00280070': 'PerimeterTable',\n      '00280071': 'PerimeterValue',\n      '00280080': 'PredictorRows',\n      '00280081': 'PredictorColumns',\n      '00280082': 'PredictorConstants',\n      '00280090': 'BlockedPixels',\n      '00280091': 'BlockRows',\n      '00280092': 'BlockColumns',\n      '00280093': 'RowOverlap',\n      '00280094': 'ColumnOverlap',\n      '00280100': 'BitsAllocated',\n      '00280101': 'BitsStored',\n      '00280102': 'HighBit',\n      '00280103': 'PixelRepresentation',\n      '00280104': 'SmallestValidPixelValue',\n      '00280105': 'LargestValidPixelValue',\n      '00280106': 'SmallestImagePixelValue',\n      '00280107': 'LargestImagePixelValue',\n      '00280108': 'SmallestPixelValueInSeries',\n      '00280109': 'LargestPixelValueInSeries',\n      '00280110': 'SmallestImagePixelValueInPlane',\n      '00280111': 'LargestImagePixelValueInPlane',\n      '00280120': 'PixelPaddingValue',\n      '00280121': 'PixelPaddingRangeLimit',\n      '00280122': 'FloatPixelPaddingValue',\n      '00280123': 'DoubleFloatPixelPaddingValue',\n      '00280124': 'FloatPixelPaddingRangeLimit',\n      '00280125': 'DoubleFloatPixelPaddingRangeLimit',\n      '00280200': 'ImageLocation',\n      '00280300': 'QualityControlImage',\n      '00280301': 'BurnedInAnnotation',\n      '00280302': 'RecognizableVisualFeatures',\n      '00280303': 'LongitudinalTemporalInformationModified',\n      '00280304': 'ReferencedColorPaletteInstanceUID',\n      '00280400': 'TransformLabel',\n      '00280401': 'TransformVersionNumber',\n      '00280402': 'NumberOfTransformSteps',\n      '00280403': 'SequenceOfCompressedData',\n      '00280404': 'DetailsOfCoefficients',\n      '00280700': 'DCTLabel',\n      '00280701': 'DataBlockDescription',\n      '00280702': 'DataBlock',\n      '00280710': 'NormalizationFactorFormat',\n      '00280720': 'ZonalMapNumberFormat',\n      '00280721': 'ZonalMapLocation',\n      '00280722': 'ZonalMapFormat',\n      '00280730': 'AdaptiveMapFormat',\n      '00280740': 'CodeNumberFormat',\n      '00280A02': 'PixelSpacingCalibrationType',\n      '00280A04': 'PixelSpacingCalibrationDescription',\n      '00281040': 'PixelIntensityRelationship',\n      '00281041': 'PixelIntensityRelationshipSign',\n      '00281050': 'WindowCenter',\n      '00281051': 'WindowWidth',\n      '00281052': 'RescaleIntercept',\n      '00281053': 'RescaleSlope',\n      '00281054': 'RescaleType',\n      '00281055': 'WindowCenterWidthExplanation',\n      '00281056': 'VOILUTFunction',\n      '00281080': 'GrayScale',\n      '00281090': 'RecommendedViewingMode',\n      '00281100': 'GrayLookupTableDescriptor',\n      '00281101': 'RedPaletteColorLookupTableDescriptor',\n      '00281102': 'GreenPaletteColorLookupTableDescriptor',\n      '00281103': 'BluePaletteColorLookupTableDescriptor',\n      '00281104': 'AlphaPaletteColorLookupTableDescriptor',\n      '00281111': 'LargeRedPaletteColorLookupTableDescriptor',\n      '00281112': 'LargeGreenPaletteColorLookupTableDescriptor',\n      '00281113': 'LargeBluePaletteColorLookupTableDescriptor',\n      '00281199': 'PaletteColorLookupTableUID',\n      '00281200': 'GrayLookupTableData',\n      '00281201': 'RedPaletteColorLookupTableData',\n      '00281202': 'GreenPaletteColorLookupTableData',\n      '00281203': 'BluePaletteColorLookupTableData',\n      '00281204': 'AlphaPaletteColorLookupTableData',\n      '00281211': 'LargeRedPaletteColorLookupTableData',\n      '00281212': 'LargeGreenPaletteColorLookupTableData',\n      '00281213': 'LargeBluePaletteColorLookupTableData',\n      '00281214': 'LargePaletteColorLookupTableUID',\n      '00281221': 'SegmentedRedPaletteColorLookupTableData',\n      '00281222': 'SegmentedGreenPaletteColorLookupTableData',\n      '00281223': 'SegmentedBluePaletteColorLookupTableData',\n      '00281224': 'SegmentedAlphaPaletteColorLookupTableData',\n      '00281230': 'StoredValueColorRangeSequence',\n      '00281231': 'MinimumStoredValueMapped',\n      '00281232': 'MaximumStoredValueMapped',\n      '00281300': 'BreastImplantPresent',\n      '00281350': 'PartialView',\n      '00281351': 'PartialViewDescription',\n      '00281352': 'PartialViewCodeSequence',\n      '0028135A': 'SpatialLocationsPreserved',\n      '00281401': 'DataFrameAssignmentSequence',\n      '00281402': 'DataPathAssignment',\n      '00281403': 'BitsMappedToColorLookupTable',\n      '00281404': 'BlendingLUT1Sequence',\n      '00281405': 'BlendingLUT1TransferFunction',\n      '00281406': 'BlendingWeightConstant',\n      '00281407': 'BlendingLookupTableDescriptor',\n      '00281408': 'BlendingLookupTableData',\n      '0028140B': 'EnhancedPaletteColorLookupTableSequence',\n      '0028140C': 'BlendingLUT2Sequence',\n      '0028140D': 'BlendingLUT2TransferFunction',\n      '0028140E': 'DataPathID',\n      '0028140F': 'RGBLUTTransferFunction',\n      '00281410': 'AlphaLUTTransferFunction',\n      '00282000': 'ICCProfile',\n      '00282002': 'ColorSpace',\n      '00282110': 'LossyImageCompression',\n      '00282112': 'LossyImageCompressionRatio',\n      '00282114': 'LossyImageCompressionMethod',\n      '00283000': 'ModalityLUTSequence',\n      '00283002': 'LUTDescriptor',\n      '00283003': 'LUTExplanation',\n      '00283004': 'ModalityLUTType',\n      '00283006': 'LUTData',\n      '00283010': 'VOILUTSequence',\n      '00283110': 'SoftcopyVOILUTSequence',\n      '00284000': 'ImagePresentationComments',\n      '00285000': 'BiPlaneAcquisitionSequence',\n      '00286010': 'RepresentativeFrameNumber',\n      '00286020': 'FrameNumbersOfInterest',\n      '00286022': 'FrameOfInterestDescription',\n      '00286023': 'FrameOfInterestType',\n      '00286030': 'MaskPointers',\n      '00286040': 'RWavePointer',\n      '00286100': 'MaskSubtractionSequence',\n      '00286101': 'MaskOperation',\n      '00286102': 'ApplicableFrameRange',\n      '00286110': 'MaskFrameNumbers',\n      '00286112': 'ContrastFrameAveraging',\n      '00286114': 'MaskSubPixelShift',\n      '00286120': 'TIDOffset',\n      '00286190': 'MaskOperationExplanation',\n      '00287000': 'EquipmentAdministratorSequence',\n      '00287001': 'NumberOfDisplaySubsystems',\n      '00287002': 'CurrentConfigurationID',\n      '00287003': 'DisplaySubsystemID',\n      '00287004': 'DisplaySubsystemName',\n      '00287005': 'DisplaySubsystemDescription',\n      '00287006': 'SystemStatus',\n      '00287007': 'SystemStatusComment',\n      '00287008': 'TargetLuminanceCharacteristicsSequence',\n      '00287009': 'LuminanceCharacteristicsID',\n      '0028700A': 'DisplaySubsystemConfigurationSequence',\n      '0028700B': 'ConfigurationID',\n      '0028700C': 'ConfigurationName',\n      '0028700D': 'ConfigurationDescription',\n      '0028700E': 'ReferencedTargetLuminanceCharacteristicsID',\n      '0028700F': 'QAResultsSequence',\n      '00287010': 'DisplaySubsystemQAResultsSequence',\n      '00287011': 'ConfigurationQAResultsSequence',\n      '00287012': 'MeasurementEquipmentSequence',\n      '00287013': 'MeasurementFunctions',\n      '00287014': 'MeasurementEquipmentType',\n      '00287015': 'VisualEvaluationResultSequence',\n      '00287016': 'DisplayCalibrationResultSequence',\n      '00287017': 'DDLValue',\n      '00287018': 'CIExyWhitePoint',\n      '00287019': 'DisplayFunctionType',\n      '0028701A': 'GammaValue',\n      '0028701B': 'NumberOfLuminancePoints',\n      '0028701C': 'LuminanceResponseSequence',\n      '0028701D': 'TargetMinimumLuminance',\n      '0028701E': 'TargetMaximumLuminance',\n      '0028701F': 'LuminanceValue',\n      '00287020': 'LuminanceResponseDescription',\n      '00287021': 'WhitePointFlag',\n      '00287022': 'DisplayDeviceTypeCodeSequence',\n      '00287023': 'DisplaySubsystemSequence',\n      '00287024': 'LuminanceResultSequence',\n      '00287025': 'AmbientLightValueSource',\n      '00287026': 'MeasuredCharacteristics',\n      '00287027': 'LuminanceUniformityResultSequence',\n      '00287028': 'VisualEvaluationTestSequence',\n      '00287029': 'TestResult',\n      '0028702A': 'TestResultComment',\n      '0028702B': 'TestImageValidation',\n      '0028702C': 'TestPatternCodeSequence',\n      '0028702D': 'MeasurementPatternCodeSequence',\n      '0028702E': 'VisualEvaluationMethodCodeSequence',\n      '00287FE0': 'PixelDataProviderURL',\n      '00289001': 'DataPointRows',\n      '00289002': 'DataPointColumns',\n      '00289003': 'SignalDomainColumns',\n      '00289099': 'LargestMonochromePixelValue',\n      '00289108': 'DataRepresentation',\n      '00289110': 'PixelMeasuresSequence',\n      '00289132': 'FrameVOILUTSequence',\n      '00289145': 'PixelValueTransformationSequence',\n      '00289235': 'SignalDomainRows',\n      '00289411': 'DisplayFilterPercentage',\n      '00289415': 'FramePixelShiftSequence',\n      '00289416': 'SubtractionItemID',\n      '00289422': 'PixelIntensityRelationshipLUTSequence',\n      '00289443': 'FramePixelDataPropertiesSequence',\n      '00289444': 'GeometricalProperties',\n      '00289445': 'GeometricMaximumDistortion',\n      '00289446': 'ImageProcessingApplied',\n      '00289454': 'MaskSelectionMode',\n      '00289474': 'LUTFunction',\n      '00289478': 'MaskVisibilityPercentage',\n      '00289501': 'PixelShiftSequence',\n      '00289502': 'RegionPixelShiftSequence',\n      '00289503': 'VerticesOfTheRegion',\n      '00289505': 'MultiFramePresentationSequence',\n      '00289506': 'PixelShiftFrameRange',\n      '00289507': 'LUTFrameRange',\n      '00289520': 'ImageToEquipmentMappingMatrix',\n      '00289537': 'EquipmentCoordinateSystemIdentification',\n      '0032000A': 'StudyStatusID',\n      '0032000C': 'StudyPriorityID',\n      '00320012': 'StudyIDIssuer',\n      '00320032': 'StudyVerifiedDate',\n      '00320033': 'StudyVerifiedTime',\n      '00320034': 'StudyReadDate',\n      '00320035': 'StudyReadTime',\n      '00321000': 'ScheduledStudyStartDate',\n      '00321001': 'ScheduledStudyStartTime',\n      '00321010': 'ScheduledStudyStopDate',\n      '00321011': 'ScheduledStudyStopTime',\n      '00321020': 'ScheduledStudyLocation',\n      '00321021': 'ScheduledStudyLocationAETitle',\n      '00321030': 'ReasonForStudy',\n      '00321031': 'RequestingPhysicianIdentificationSequence',\n      '00321032': 'RequestingPhysician',\n      '00321033': 'RequestingService',\n      '00321034': 'RequestingServiceCodeSequence',\n      '00321040': 'StudyArrivalDate',\n      '00321041': 'StudyArrivalTime',\n      '00321050': 'StudyCompletionDate',\n      '00321051': 'StudyCompletionTime',\n      '00321055': 'StudyComponentStatusID',\n      '00321060': 'RequestedProcedureDescription',\n      '00321064': 'RequestedProcedureCodeSequence',\n      '00321070': 'RequestedContrastAgent',\n      '00324000': 'StudyComments',\n      '00380004': 'ReferencedPatientAliasSequence',\n      '00380008': 'VisitStatusID',\n      '00380010': 'AdmissionID',\n      '00380011': 'IssuerOfAdmissionID',\n      '00380014': 'IssuerOfAdmissionIDSequence',\n      '00380016': 'RouteOfAdmissions',\n      '0038001A': 'ScheduledAdmissionDate',\n      '0038001B': 'ScheduledAdmissionTime',\n      '0038001C': 'ScheduledDischargeDate',\n      '0038001D': 'ScheduledDischargeTime',\n      '0038001E': 'ScheduledPatientInstitutionResidence',\n      '00380020': 'AdmittingDate',\n      '00380021': 'AdmittingTime',\n      '00380030': 'DischargeDate',\n      '00380032': 'DischargeTime',\n      '00380040': 'DischargeDiagnosisDescription',\n      '00380044': 'DischargeDiagnosisCodeSequence',\n      '00380050': 'SpecialNeeds',\n      '00380060': 'ServiceEpisodeID',\n      '00380061': 'IssuerOfServiceEpisodeID',\n      '00380062': 'ServiceEpisodeDescription',\n      '00380064': 'IssuerOfServiceEpisodeIDSequence',\n      '00380100': 'PertinentDocumentsSequence',\n      '00380101': 'PertinentResourcesSequence',\n      '00380102': 'ResourceDescription',\n      '00380300': 'CurrentPatientLocation',\n      '00380400': 'PatientInstitutionResidence',\n      '00380500': 'PatientState',\n      '00380502': 'PatientClinicalTrialParticipationSequence',\n      '00384000': 'VisitComments',\n      '003A0004': 'WaveformOriginality',\n      '003A0005': 'NumberOfWaveformChannels',\n      '003A0010': 'NumberOfWaveformSamples',\n      '003A001A': 'SamplingFrequency',\n      '003A0020': 'MultiplexGroupLabel',\n      '003A0200': 'ChannelDefinitionSequence',\n      '003A0202': 'WaveformChannelNumber',\n      '003A0203': 'ChannelLabel',\n      '003A0205': 'ChannelStatus',\n      '003A0208': 'ChannelSourceSequence',\n      '003A0209': 'ChannelSourceModifiersSequence',\n      '003A020A': 'SourceWaveformSequence',\n      '003A020C': 'ChannelDerivationDescription',\n      '003A0210': 'ChannelSensitivity',\n      '003A0211': 'ChannelSensitivityUnitsSequence',\n      '003A0212': 'ChannelSensitivityCorrectionFactor',\n      '003A0213': 'ChannelBaseline',\n      '003A0214': 'ChannelTimeSkew',\n      '003A0215': 'ChannelSampleSkew',\n      '003A0218': 'ChannelOffset',\n      '003A021A': 'WaveformBitsStored',\n      '003A0220': 'FilterLowFrequency',\n      '003A0221': 'FilterHighFrequency',\n      '003A0222': 'NotchFilterFrequency',\n      '003A0223': 'NotchFilterBandwidth',\n      '003A0230': 'WaveformDataDisplayScale',\n      '003A0231': 'WaveformDisplayBackgroundCIELabValue',\n      '003A0240': 'WaveformPresentationGroupSequence',\n      '003A0241': 'PresentationGroupNumber',\n      '003A0242': 'ChannelDisplaySequence',\n      '003A0244': 'ChannelRecommendedDisplayCIELabValue',\n      '003A0245': 'ChannelPosition',\n      '003A0246': 'DisplayShadingFlag',\n      '003A0247': 'FractionalChannelDisplayScale',\n      '003A0248': 'AbsoluteChannelDisplayScale',\n      '003A0300': 'MultiplexedAudioChannelsDescriptionCodeSequence',\n      '003A0301': 'ChannelIdentificationCode',\n      '003A0302': 'ChannelMode',\n      '00400001': 'ScheduledStationAETitle',\n      '00400002': 'ScheduledProcedureStepStartDate',\n      '00400003': 'ScheduledProcedureStepStartTime',\n      '00400004': 'ScheduledProcedureStepEndDate',\n      '00400005': 'ScheduledProcedureStepEndTime',\n      '00400006': 'ScheduledPerformingPhysicianName',\n      '00400007': 'ScheduledProcedureStepDescription',\n      '00400008': 'ScheduledProtocolCodeSequence',\n      '00400009': 'ScheduledProcedureStepID',\n      '0040000A': 'StageCodeSequence',\n      '0040000B': 'ScheduledPerformingPhysicianIdentificationSequence',\n      '00400010': 'ScheduledStationName',\n      '00400011': 'ScheduledProcedureStepLocation',\n      '00400012': 'PreMedication',\n      '00400020': 'ScheduledProcedureStepStatus',\n      '00400026': 'OrderPlacerIdentifierSequence',\n      '00400027': 'OrderFillerIdentifierSequence',\n      '00400031': 'LocalNamespaceEntityID',\n      '00400032': 'UniversalEntityID',\n      '00400033': 'UniversalEntityIDType',\n      '00400035': 'IdentifierTypeCode',\n      '00400036': 'AssigningFacilitySequence',\n      '00400039': 'AssigningJurisdictionCodeSequence',\n      '0040003A': 'AssigningAgencyOrDepartmentCodeSequence',\n      '00400100': 'ScheduledProcedureStepSequence',\n      '00400220': 'ReferencedNonImageCompositeSOPInstanceSequence',\n      '00400241': 'PerformedStationAETitle',\n      '00400242': 'PerformedStationName',\n      '00400243': 'PerformedLocation',\n      '00400244': 'PerformedProcedureStepStartDate',\n      '00400245': 'PerformedProcedureStepStartTime',\n      '00400250': 'PerformedProcedureStepEndDate',\n      '00400251': 'PerformedProcedureStepEndTime',\n      '00400252': 'PerformedProcedureStepStatus',\n      '00400253': 'PerformedProcedureStepID',\n      '00400254': 'PerformedProcedureStepDescription',\n      '00400255': 'PerformedProcedureTypeDescription',\n      '00400260': 'PerformedProtocolCodeSequence',\n      '00400261': 'PerformedProtocolType',\n      '00400270': 'ScheduledStepAttributesSequence',\n      '00400275': 'RequestAttributesSequence',\n      '00400280': 'CommentsOnThePerformedProcedureStep',\n      '00400281': 'PerformedProcedureStepDiscontinuationReasonCodeSequence',\n      '00400293': 'QuantitySequence',\n      '00400294': 'Quantity',\n      '00400295': 'MeasuringUnitsSequence',\n      '00400296': 'BillingItemSequence',\n      '00400300': 'TotalTimeOfFluoroscopy',\n      '00400301': 'TotalNumberOfExposures',\n      '00400302': 'EntranceDose',\n      '00400303': 'ExposedArea',\n      '00400306': 'DistanceSourceToEntrance',\n      '00400307': 'DistanceSourceToSupport',\n      '0040030E': 'ExposureDoseSequence',\n      '00400310': 'CommentsOnRadiationDose',\n      '00400312': 'XRayOutput',\n      '00400314': 'HalfValueLayer',\n      '00400316': 'OrganDose',\n      '00400318': 'OrganExposed',\n      '00400320': 'BillingProcedureStepSequence',\n      '00400321': 'FilmConsumptionSequence',\n      '00400324': 'BillingSuppliesAndDevicesSequence',\n      '00400330': 'ReferencedProcedureStepSequence',\n      '00400340': 'PerformedSeriesSequence',\n      '00400400': 'CommentsOnTheScheduledProcedureStep',\n      '00400440': 'ProtocolContextSequence',\n      '00400441': 'ContentItemModifierSequence',\n      '00400500': 'ScheduledSpecimenSequence',\n      '0040050A': 'SpecimenAccessionNumber',\n      '00400512': 'ContainerIdentifier',\n      '00400513': 'IssuerOfTheContainerIdentifierSequence',\n      '00400515': 'AlternateContainerIdentifierSequence',\n      '00400518': 'ContainerTypeCodeSequence',\n      '0040051A': 'ContainerDescription',\n      '00400520': 'ContainerComponentSequence',\n      '00400550': 'SpecimenSequence',\n      '00400551': 'SpecimenIdentifier',\n      '00400552': 'SpecimenDescriptionSequenceTrial',\n      '00400553': 'SpecimenDescriptionTrial',\n      '00400554': 'SpecimenUID',\n      '00400555': 'AcquisitionContextSequence',\n      '00400556': 'AcquisitionContextDescription',\n      '00400560': 'SpecimenDescriptionSequence',\n      '00400562': 'IssuerOfTheSpecimenIdentifierSequence',\n      '0040059A': 'SpecimenTypeCodeSequence',\n      '00400600': 'SpecimenShortDescription',\n      '00400602': 'SpecimenDetailedDescription',\n      '00400610': 'SpecimenPreparationSequence',\n      '00400612': 'SpecimenPreparationStepContentItemSequence',\n      '00400620': 'SpecimenLocalizationContentItemSequence',\n      '004006FA': 'SlideIdentifier',\n      '00400710': 'WholeSlideMicroscopyImageFrameTypeSequence',\n      '0040071A': 'ImageCenterPointCoordinatesSequence',\n      '0040072A': 'XOffsetInSlideCoordinateSystem',\n      '0040073A': 'YOffsetInSlideCoordinateSystem',\n      '0040074A': 'ZOffsetInSlideCoordinateSystem',\n      '004008D8': 'PixelSpacingSequence',\n      '004008DA': 'CoordinateSystemAxisCodeSequence',\n      '004008EA': 'MeasurementUnitsCodeSequence',\n      '004009F8': 'VitalStainCodeSequenceTrial',\n      '00401001': 'RequestedProcedureID',\n      '00401002': 'ReasonForTheRequestedProcedure',\n      '00401003': 'RequestedProcedurePriority',\n      '00401004': 'PatientTransportArrangements',\n      '00401005': 'RequestedProcedureLocation',\n      '00401006': 'PlacerOrderNumberProcedure',\n      '00401007': 'FillerOrderNumberProcedure',\n      '00401008': 'ConfidentialityCode',\n      '00401009': 'ReportingPriority',\n      '0040100A': 'ReasonForRequestedProcedureCodeSequence',\n      '00401010': 'NamesOfIntendedRecipientsOfResults',\n      '00401011': 'IntendedRecipientsOfResultsIdentificationSequence',\n      '00401012': 'ReasonForPerformedProcedureCodeSequence',\n      '00401060': 'RequestedProcedureDescriptionTrial',\n      '00401101': 'PersonIdentificationCodeSequence',\n      '00401102': 'PersonAddress',\n      '00401103': 'PersonTelephoneNumbers',\n      '00401104': 'PersonTelecomInformation',\n      '00401400': 'RequestedProcedureComments',\n      '00402001': 'ReasonForTheImagingServiceRequest',\n      '00402004': 'IssueDateOfImagingServiceRequest',\n      '00402005': 'IssueTimeOfImagingServiceRequest',\n      '00402006': 'PlacerOrderNumberImagingServiceRequestRetired',\n      '00402007': 'FillerOrderNumberImagingServiceRequestRetired',\n      '00402008': 'OrderEnteredBy',\n      '00402009': 'OrderEntererLocation',\n      '00402010': 'OrderCallbackPhoneNumber',\n      '00402011': 'OrderCallbackTelecomInformation',\n      '00402016': 'PlacerOrderNumberImagingServiceRequest',\n      '00402017': 'FillerOrderNumberImagingServiceRequest',\n      '00402400': 'ImagingServiceRequestComments',\n      '00403001': 'ConfidentialityConstraintOnPatientDataDescription',\n      '00404001': 'GeneralPurposeScheduledProcedureStepStatus',\n      '00404002': 'GeneralPurposePerformedProcedureStepStatus',\n      '00404003': 'GeneralPurposeScheduledProcedureStepPriority',\n      '00404004': 'ScheduledProcessingApplicationsCodeSequence',\n      '00404005': 'ScheduledProcedureStepStartDateTime',\n      '00404006': 'MultipleCopiesFlag',\n      '00404007': 'PerformedProcessingApplicationsCodeSequence',\n      '00404008': 'ScheduledProcedureStepExpirationDateTime',\n      '00404009': 'HumanPerformerCodeSequence',\n      '00404010': 'ScheduledProcedureStepModificationDateTime',\n      '00404011': 'ExpectedCompletionDateTime',\n      '00404015': 'ResultingGeneralPurposePerformedProcedureStepsSequence',\n      '00404016': 'ReferencedGeneralPurposeScheduledProcedureStepSequence',\n      '00404018': 'ScheduledWorkitemCodeSequence',\n      '00404019': 'PerformedWorkitemCodeSequence',\n      '00404020': 'InputAvailabilityFlag',\n      '00404021': 'InputInformationSequence',\n      '00404022': 'RelevantInformationSequence',\n      '00404023': 'ReferencedGeneralPurposeScheduledProcedureStepTransactionUID',\n      '00404025': 'ScheduledStationNameCodeSequence',\n      '00404026': 'ScheduledStationClassCodeSequence',\n      '00404027': 'ScheduledStationGeographicLocationCodeSequence',\n      '00404028': 'PerformedStationNameCodeSequence',\n      '00404029': 'PerformedStationClassCodeSequence',\n      '00404030': 'PerformedStationGeographicLocationCodeSequence',\n      '00404031': 'RequestedSubsequentWorkitemCodeSequence',\n      '00404032': 'NonDICOMOutputCodeSequence',\n      '00404033': 'OutputInformationSequence',\n      '00404034': 'ScheduledHumanPerformersSequence',\n      '00404035': 'ActualHumanPerformersSequence',\n      '00404036': 'HumanPerformerOrganization',\n      '00404037': 'HumanPerformerName',\n      '00404040': 'RawDataHandling',\n      '00404041': 'InputReadinessState',\n      '00404050': 'PerformedProcedureStepStartDateTime',\n      '00404051': 'PerformedProcedureStepEndDateTime',\n      '00404052': 'ProcedureStepCancellationDateTime',\n      '00404070': 'OutputDestinationSequence',\n      '00404071': 'DICOMStorageSequence',\n      '00404072': 'STOWRSStorageSequence',\n      '00404073': 'StorageURL',\n      '00404074': 'XDSStorageSequence',\n      '00408302': 'EntranceDoseInmGy',\n      '00408303': 'EntranceDoseDerivation',\n      '00409092': 'ParametricMapFrameTypeSequence',\n      '00409094': 'ReferencedImageRealWorldValueMappingSequence',\n      '00409096': 'RealWorldValueMappingSequence',\n      '00409098': 'PixelValueMappingCodeSequence',\n      '00409210': 'LUTLabel',\n      '00409211': 'RealWorldValueLastValueMapped',\n      '00409212': 'RealWorldValueLUTData',\n      '00409213': 'DoubleFloatRealWorldValueLastValueMapped',\n      '00409214': 'DoubleFloatRealWorldValueFirstValueMapped',\n      '00409216': 'RealWorldValueFirstValueMapped',\n      '00409220': 'QuantityDefinitionSequence',\n      '00409224': 'RealWorldValueIntercept',\n      '00409225': 'RealWorldValueSlope',\n      '0040A007': 'FindingsFlagTrial',\n      '0040A010': 'RelationshipType',\n      '0040A020': 'FindingsSequenceTrial',\n      '0040A021': 'FindingsGroupUIDTrial',\n      '0040A022': 'ReferencedFindingsGroupUIDTrial',\n      '0040A023': 'FindingsGroupRecordingDateTrial',\n      '0040A024': 'FindingsGroupRecordingTimeTrial',\n      '0040A026': 'FindingsSourceCategoryCodeSequenceTrial',\n      '0040A027': 'VerifyingOrganization',\n      '0040A028': 'DocumentingOrganizationIdentifierCodeSequenceTrial',\n      '0040A030': 'VerificationDateTime',\n      '0040A032': 'ObservationDateTime',\n      '0040A040': 'ValueType',\n      '0040A043': 'ConceptNameCodeSequence',\n      '0040A047': 'MeasurementPrecisionDescriptionTrial',\n      '0040A050': 'ContinuityOfContent',\n      '0040A057': 'UrgencyOrPriorityAlertsTrial',\n      '0040A060': 'SequencingIndicatorTrial',\n      '0040A066': 'DocumentIdentifierCodeSequenceTrial',\n      '0040A067': 'DocumentAuthorTrial',\n      '0040A068': 'DocumentAuthorIdentifierCodeSequenceTrial',\n      '0040A070': 'IdentifierCodeSequenceTrial',\n      '0040A073': 'VerifyingObserverSequence',\n      '0040A074': 'ObjectBinaryIdentifierTrial',\n      '0040A075': 'VerifyingObserverName',\n      '0040A076': 'DocumentingObserverIdentifierCodeSequenceTrial',\n      '0040A078': 'AuthorObserverSequence',\n      '0040A07A': 'ParticipantSequence',\n      '0040A07C': 'CustodialOrganizationSequence',\n      '0040A080': 'ParticipationType',\n      '0040A082': 'ParticipationDateTime',\n      '0040A084': 'ObserverType',\n      '0040A085': 'ProcedureIdentifierCodeSequenceTrial',\n      '0040A088': 'VerifyingObserverIdentificationCodeSequence',\n      '0040A089': 'ObjectDirectoryBinaryIdentifierTrial',\n      '0040A090': 'EquivalentCDADocumentSequence',\n      '0040A0B0': 'ReferencedWaveformChannels',\n      '0040A110': 'DateOfDocumentOrVerbalTransactionTrial',\n      '0040A112': 'TimeOfDocumentCreationOrVerbalTransactionTrial',\n      '0040A120': 'DateTime',\n      '0040A121': 'Date',\n      '0040A122': 'Time',\n      '0040A123': 'PersonName',\n      '0040A124': 'UID',\n      '0040A125': 'ReportStatusIDTrial',\n      '0040A130': 'TemporalRangeType',\n      '0040A132': 'ReferencedSamplePositions',\n      '0040A136': 'ReferencedFrameNumbers',\n      '0040A138': 'ReferencedTimeOffsets',\n      '0040A13A': 'ReferencedDateTime',\n      '0040A160': 'TextValue',\n      '0040A161': 'FloatingPointValue',\n      '0040A162': 'RationalNumeratorValue',\n      '0040A163': 'RationalDenominatorValue',\n      '0040A167': 'ObservationCategoryCodeSequenceTrial',\n      '0040A168': 'ConceptCodeSequence',\n      '0040A16A': 'BibliographicCitationTrial',\n      '0040A170': 'PurposeOfReferenceCodeSequence',\n      '0040A171': 'ObservationUID',\n      '0040A172': 'ReferencedObservationUIDTrial',\n      '0040A173': 'ReferencedObservationClassTrial',\n      '0040A174': 'ReferencedObjectObservationClassTrial',\n      '0040A180': 'AnnotationGroupNumber',\n      '0040A192': 'ObservationDateTrial',\n      '0040A193': 'ObservationTimeTrial',\n      '0040A194': 'MeasurementAutomationTrial',\n      '0040A195': 'ModifierCodeSequence',\n      '0040A224': 'IdentificationDescriptionTrial',\n      '0040A290': 'CoordinatesSetGeometricTypeTrial',\n      '0040A296': 'AlgorithmCodeSequenceTrial',\n      '0040A297': 'AlgorithmDescriptionTrial',\n      '0040A29A': 'PixelCoordinatesSetTrial',\n      '0040A300': 'MeasuredValueSequence',\n      '0040A301': 'NumericValueQualifierCodeSequence',\n      '0040A307': 'CurrentObserverTrial',\n      '0040A30A': 'NumericValue',\n      '0040A313': 'ReferencedAccessionSequenceTrial',\n      '0040A33A': 'ReportStatusCommentTrial',\n      '0040A340': 'ProcedureContextSequenceTrial',\n      '0040A352': 'VerbalSourceTrial',\n      '0040A353': 'AddressTrial',\n      '0040A354': 'TelephoneNumberTrial',\n      '0040A358': 'VerbalSourceIdentifierCodeSequenceTrial',\n      '0040A360': 'PredecessorDocumentsSequence',\n      '0040A370': 'ReferencedRequestSequence',\n      '0040A372': 'PerformedProcedureCodeSequence',\n      '0040A375': 'CurrentRequestedProcedureEvidenceSequence',\n      '0040A380': 'ReportDetailSequenceTrial',\n      '0040A385': 'PertinentOtherEvidenceSequence',\n      '0040A390': 'HL7StructuredDocumentReferenceSequence',\n      '0040A402': 'ObservationSubjectUIDTrial',\n      '0040A403': 'ObservationSubjectClassTrial',\n      '0040A404': 'ObservationSubjectTypeCodeSequenceTrial',\n      '0040A491': 'CompletionFlag',\n      '0040A492': 'CompletionFlagDescription',\n      '0040A493': 'VerificationFlag',\n      '0040A494': 'ArchiveRequested',\n      '0040A496': 'PreliminaryFlag',\n      '0040A504': 'ContentTemplateSequence',\n      '0040A525': 'IdenticalDocumentsSequence',\n      '0040A600': 'ObservationSubjectContextFlagTrial',\n      '0040A601': 'ObserverContextFlagTrial',\n      '0040A603': 'ProcedureContextFlagTrial',\n      '0040A730': 'ContentSequence',\n      '0040A731': 'RelationshipSequenceTrial',\n      '0040A732': 'RelationshipTypeCodeSequenceTrial',\n      '0040A744': 'LanguageCodeSequenceTrial',\n      '0040A992': 'UniformResourceLocatorTrial',\n      '0040B020': 'WaveformAnnotationSequence',\n      '0040DB00': 'TemplateIdentifier',\n      '0040DB06': 'TemplateVersion',\n      '0040DB07': 'TemplateLocalVersion',\n      '0040DB0B': 'TemplateExtensionFlag',\n      '0040DB0C': 'TemplateExtensionOrganizationUID',\n      '0040DB0D': 'TemplateExtensionCreatorUID',\n      '0040DB73': 'ReferencedContentItemIdentifier',\n      '0040E001': 'HL7InstanceIdentifier',\n      '0040E004': 'HL7DocumentEffectiveTime',\n      '0040E006': 'HL7DocumentTypeCodeSequence',\n      '0040E008': 'DocumentClassCodeSequence',\n      '0040E010': 'RetrieveURI',\n      '0040E011': 'RetrieveLocationUID',\n      '0040E020': 'TypeOfInstances',\n      '0040E021': 'DICOMRetrievalSequence',\n      '0040E022': 'DICOMMediaRetrievalSequence',\n      '0040E023': 'WADORetrievalSequence',\n      '0040E024': 'XDSRetrievalSequence',\n      '0040E025': 'WADORSRetrievalSequence',\n      '0040E030': 'RepositoryUniqueID',\n      '0040E031': 'HomeCommunityID',\n      '00420010': 'DocumentTitle',\n      '00420011': 'EncapsulatedDocument',\n      '00420012': 'MIMETypeOfEncapsulatedDocument',\n      '00420013': 'SourceInstanceSequence',\n      '00420014': 'ListOfMIMETypes',\n      '00440001': 'ProductPackageIdentifier',\n      '00440002': 'SubstanceAdministrationApproval',\n      '00440003': 'ApprovalStatusFurtherDescription',\n      '00440004': 'ApprovalStatusDateTime',\n      '00440007': 'ProductTypeCodeSequence',\n      '00440008': 'ProductName',\n      '00440009': 'ProductDescription',\n      '0044000A': 'ProductLotIdentifier',\n      '0044000B': 'ProductExpirationDateTime',\n      '00440010': 'SubstanceAdministrationDateTime',\n      '00440011': 'SubstanceAdministrationNotes',\n      '00440012': 'SubstanceAdministrationDeviceID',\n      '00440013': 'ProductParameterSequence',\n      '00440019': 'SubstanceAdministrationParameterSequence',\n      '00440100': 'ApprovalSequence',\n      '00440101': 'AssertionCodeSequence',\n      '00440102': 'AssertionUID',\n      '00440103': 'AsserterIdentificationSequence',\n      '00440104': 'AssertionDateTime',\n      '00440105': 'AssertionExpirationDateTime',\n      '00440106': 'AssertionComments',\n      '00440107': 'RelatedAssertionSequence',\n      '00440108': 'ReferencedAssertionUID',\n      '00440109': 'ApprovalSubjectSequence',\n      '0044010A': 'OrganizationalRoleCodeSequence',\n      '00460012': 'LensDescription',\n      '00460014': 'RightLensSequence',\n      '00460015': 'LeftLensSequence',\n      '00460016': 'UnspecifiedLateralityLensSequence',\n      '00460018': 'CylinderSequence',\n      '00460028': 'PrismSequence',\n      '00460030': 'HorizontalPrismPower',\n      '00460032': 'HorizontalPrismBase',\n      '00460034': 'VerticalPrismPower',\n      '00460036': 'VerticalPrismBase',\n      '00460038': 'LensSegmentType',\n      '00460040': 'OpticalTransmittance',\n      '00460042': 'ChannelWidth',\n      '00460044': 'PupilSize',\n      '00460046': 'CornealSize',\n      '00460050': 'AutorefractionRightEyeSequence',\n      '00460052': 'AutorefractionLeftEyeSequence',\n      '00460060': 'DistancePupillaryDistance',\n      '00460062': 'NearPupillaryDistance',\n      '00460063': 'IntermediatePupillaryDistance',\n      '00460064': 'OtherPupillaryDistance',\n      '00460070': 'KeratometryRightEyeSequence',\n      '00460071': 'KeratometryLeftEyeSequence',\n      '00460074': 'SteepKeratometricAxisSequence',\n      '00460075': 'RadiusOfCurvature',\n      '00460076': 'KeratometricPower',\n      '00460077': 'KeratometricAxis',\n      '00460080': 'FlatKeratometricAxisSequence',\n      '00460092': 'BackgroundColor',\n      '00460094': 'Optotype',\n      '00460095': 'OptotypePresentation',\n      '00460097': 'SubjectiveRefractionRightEyeSequence',\n      '00460098': 'SubjectiveRefractionLeftEyeSequence',\n      '00460100': 'AddNearSequence',\n      '00460101': 'AddIntermediateSequence',\n      '00460102': 'AddOtherSequence',\n      '00460104': 'AddPower',\n      '00460106': 'ViewingDistance',\n      '00460121': 'VisualAcuityTypeCodeSequence',\n      '00460122': 'VisualAcuityRightEyeSequence',\n      '00460123': 'VisualAcuityLeftEyeSequence',\n      '00460124': 'VisualAcuityBothEyesOpenSequence',\n      '00460125': 'ViewingDistanceType',\n      '00460135': 'VisualAcuityModifiers',\n      '00460137': 'DecimalVisualAcuity',\n      '00460139': 'OptotypeDetailedDefinition',\n      '00460145': 'ReferencedRefractiveMeasurementsSequence',\n      '00460146': 'SpherePower',\n      '00460147': 'CylinderPower',\n      '00460201': 'CornealTopographySurface',\n      '00460202': 'CornealVertexLocation',\n      '00460203': 'PupilCentroidXCoordinate',\n      '00460204': 'PupilCentroidYCoordinate',\n      '00460205': 'EquivalentPupilRadius',\n      '00460207': 'CornealTopographyMapTypeCodeSequence',\n      '00460208': 'VerticesOfTheOutlineOfPupil',\n      '00460210': 'CornealTopographyMappingNormalsSequence',\n      '00460211': 'MaximumCornealCurvatureSequence',\n      '00460212': 'MaximumCornealCurvature',\n      '00460213': 'MaximumCornealCurvatureLocation',\n      '00460215': 'MinimumKeratometricSequence',\n      '00460218': 'SimulatedKeratometricCylinderSequence',\n      '00460220': 'AverageCornealPower',\n      '00460224': 'CornealISValue',\n      '00460227': 'AnalyzedArea',\n      '00460230': 'SurfaceRegularityIndex',\n      '00460232': 'SurfaceAsymmetryIndex',\n      '00460234': 'CornealEccentricityIndex',\n      '00460236': 'KeratoconusPredictionIndex',\n      '00460238': 'DecimalPotentialVisualAcuity',\n      '00460242': 'CornealTopographyMapQualityEvaluation',\n      '00460244': 'SourceImageCornealProcessedDataSequence',\n      '00460247': 'CornealPointLocation',\n      '00460248': 'CornealPointEstimated',\n      '00460249': 'AxialPower',\n      '00460250': 'TangentialPower',\n      '00460251': 'RefractivePower',\n      '00460252': 'RelativeElevation',\n      '00460253': 'CornealWavefront',\n      '00480001': 'ImagedVolumeWidth',\n      '00480002': 'ImagedVolumeHeight',\n      '00480003': 'ImagedVolumeDepth',\n      '00480006': 'TotalPixelMatrixColumns',\n      '00480007': 'TotalPixelMatrixRows',\n      '00480008': 'TotalPixelMatrixOriginSequence',\n      '00480010': 'SpecimenLabelInImage',\n      '00480011': 'FocusMethod',\n      '00480012': 'ExtendedDepthOfField',\n      '00480013': 'NumberOfFocalPlanes',\n      '00480014': 'DistanceBetweenFocalPlanes',\n      '00480015': 'RecommendedAbsentPixelCIELabValue',\n      '00480100': 'IlluminatorTypeCodeSequence',\n      '00480102': 'ImageOrientationSlide',\n      '00480105': 'OpticalPathSequence',\n      '00480106': 'OpticalPathIdentifier',\n      '00480107': 'OpticalPathDescription',\n      '00480108': 'IlluminationColorCodeSequence',\n      '00480110': 'SpecimenReferenceSequence',\n      '00480111': 'CondenserLensPower',\n      '00480112': 'ObjectiveLensPower',\n      '00480113': 'ObjectiveLensNumericalAperture',\n      '00480120': 'PaletteColorLookupTableSequence',\n      '00480200': 'ReferencedImageNavigationSequence',\n      '00480201': 'TopLeftHandCornerOfLocalizerArea',\n      '00480202': 'BottomRightHandCornerOfLocalizerArea',\n      '00480207': 'OpticalPathIdentificationSequence',\n      '0048021A': 'PlanePositionSlideSequence',\n      '0048021E': 'ColumnPositionInTotalImagePixelMatrix',\n      '0048021F': 'RowPositionInTotalImagePixelMatrix',\n      '00480301': 'PixelOriginInterpretation',\n      '00480302': 'NumberOfOpticalPaths',\n      '00480303': 'TotalPixelMatrixFocalPlanes',\n      '00500004': 'CalibrationImage',\n      '00500010': 'DeviceSequence',\n      '00500012': 'ContainerComponentTypeCodeSequence',\n      '00500013': 'ContainerComponentThickness',\n      '00500014': 'DeviceLength',\n      '00500015': 'ContainerComponentWidth',\n      '00500016': 'DeviceDiameter',\n      '00500017': 'DeviceDiameterUnits',\n      '00500018': 'DeviceVolume',\n      '00500019': 'InterMarkerDistance',\n      '0050001A': 'ContainerComponentMaterial',\n      '0050001B': 'ContainerComponentID',\n      '0050001C': 'ContainerComponentLength',\n      '0050001D': 'ContainerComponentDiameter',\n      '0050001E': 'ContainerComponentDescription',\n      '00500020': 'DeviceDescription',\n      '00520001': 'ContrastBolusIngredientPercentByVolume',\n      '00520002': 'OCTFocalDistance',\n      '00520003': 'BeamSpotSize',\n      '00520004': 'EffectiveRefractiveIndex',\n      '00520006': 'OCTAcquisitionDomain',\n      '00520007': 'OCTOpticalCenterWavelength',\n      '00520008': 'AxialResolution',\n      '00520009': 'RangingDepth',\n      '00520011': 'ALineRate',\n      '00520012': 'ALinesPerFrame',\n      '00520013': 'CatheterRotationalRate',\n      '00520014': 'ALinePixelSpacing',\n      '00520016': 'ModeOfPercutaneousAccessSequence',\n      '00520025': 'IntravascularOCTFrameTypeSequence',\n      '00520026': 'OCTZOffsetApplied',\n      '00520027': 'IntravascularFrameContentSequence',\n      '00520028': 'IntravascularLongitudinalDistance',\n      '00520029': 'IntravascularOCTFrameContentSequence',\n      '00520030': 'OCTZOffsetCorrection',\n      '00520031': 'CatheterDirectionOfRotation',\n      '00520033': 'SeamLineLocation',\n      '00520034': 'FirstALineLocation',\n      '00520036': 'SeamLineIndex',\n      '00520038': 'NumberOfPaddedALines',\n      '00520039': 'InterpolationType',\n      '0052003A': 'RefractiveIndexApplied',\n      '00540010': 'EnergyWindowVector',\n      '00540011': 'NumberOfEnergyWindows',\n      '00540012': 'EnergyWindowInformationSequence',\n      '00540013': 'EnergyWindowRangeSequence',\n      '00540014': 'EnergyWindowLowerLimit',\n      '00540015': 'EnergyWindowUpperLimit',\n      '00540016': 'RadiopharmaceuticalInformationSequence',\n      '00540017': 'ResidualSyringeCounts',\n      '00540018': 'EnergyWindowName',\n      '00540020': 'DetectorVector',\n      '00540021': 'NumberOfDetectors',\n      '00540022': 'DetectorInformationSequence',\n      '00540030': 'PhaseVector',\n      '00540031': 'NumberOfPhases',\n      '00540032': 'PhaseInformationSequence',\n      '00540033': 'NumberOfFramesInPhase',\n      '00540036': 'PhaseDelay',\n      '00540038': 'PauseBetweenFrames',\n      '00540039': 'PhaseDescription',\n      '00540050': 'RotationVector',\n      '00540051': 'NumberOfRotations',\n      '00540052': 'RotationInformationSequence',\n      '00540053': 'NumberOfFramesInRotation',\n      '00540060': 'RRIntervalVector',\n      '00540061': 'NumberOfRRIntervals',\n      '00540062': 'GatedInformationSequence',\n      '00540063': 'DataInformationSequence',\n      '00540070': 'TimeSlotVector',\n      '00540071': 'NumberOfTimeSlots',\n      '00540072': 'TimeSlotInformationSequence',\n      '00540073': 'TimeSlotTime',\n      '00540080': 'SliceVector',\n      '00540081': 'NumberOfSlices',\n      '00540090': 'AngularViewVector',\n      '00540100': 'TimeSliceVector',\n      '00540101': 'NumberOfTimeSlices',\n      '00540200': 'StartAngle',\n      '00540202': 'TypeOfDetectorMotion',\n      '00540210': 'TriggerVector',\n      '00540211': 'NumberOfTriggersInPhase',\n      '00540220': 'ViewCodeSequence',\n      '00540222': 'ViewModifierCodeSequence',\n      '00540300': 'RadionuclideCodeSequence',\n      '00540302': 'AdministrationRouteCodeSequence',\n      '00540304': 'RadiopharmaceuticalCodeSequence',\n      '00540306': 'CalibrationDataSequence',\n      '00540308': 'EnergyWindowNumber',\n      '00540400': 'ImageID',\n      '00540410': 'PatientOrientationCodeSequence',\n      '00540412': 'PatientOrientationModifierCodeSequence',\n      '00540414': 'PatientGantryRelationshipCodeSequence',\n      '00540500': 'SliceProgressionDirection',\n      '00540501': 'ScanProgressionDirection',\n      '00541000': 'SeriesType',\n      '00541001': 'Units',\n      '00541002': 'CountsSource',\n      '00541004': 'ReprojectionMethod',\n      '00541006': 'SUVType',\n      '00541100': 'RandomsCorrectionMethod',\n      '00541101': 'AttenuationCorrectionMethod',\n      '00541102': 'DecayCorrection',\n      '00541103': 'ReconstructionMethod',\n      '00541104': 'DetectorLinesOfResponseUsed',\n      '00541105': 'ScatterCorrectionMethod',\n      '00541200': 'AxialAcceptance',\n      '00541201': 'AxialMash',\n      '00541202': 'TransverseMash',\n      '00541203': 'DetectorElementSize',\n      '00541210': 'CoincidenceWindowWidth',\n      '00541220': 'SecondaryCountsType',\n      '00541300': 'FrameReferenceTime',\n      '00541310': 'PrimaryPromptsCountsAccumulated',\n      '00541311': 'SecondaryCountsAccumulated',\n      '00541320': 'SliceSensitivityFactor',\n      '00541321': 'DecayFactor',\n      '00541322': 'DoseCalibrationFactor',\n      '00541323': 'ScatterFractionFactor',\n      '00541324': 'DeadTimeFactor',\n      '00541330': 'ImageIndex',\n      '00541400': 'CountsIncluded',\n      '00541401': 'DeadTimeCorrectionFlag',\n      '00603000': 'HistogramSequence',\n      '00603002': 'HistogramNumberOfBins',\n      '00603004': 'HistogramFirstBinValue',\n      '00603006': 'HistogramLastBinValue',\n      '00603008': 'HistogramBinWidth',\n      '00603010': 'HistogramExplanation',\n      '00603020': 'HistogramData',\n      '00620001': 'SegmentationType',\n      '00620002': 'SegmentSequence',\n      '00620003': 'SegmentedPropertyCategoryCodeSequence',\n      '00620004': 'SegmentNumber',\n      '00620005': 'SegmentLabel',\n      '00620006': 'SegmentDescription',\n      '00620007': 'SegmentationAlgorithmIdentificationSequence',\n      '00620008': 'SegmentAlgorithmType',\n      '00620009': 'SegmentAlgorithmName',\n      '0062000A': 'SegmentIdentificationSequence',\n      '0062000B': 'ReferencedSegmentNumber',\n      '0062000C': 'RecommendedDisplayGrayscaleValue',\n      '0062000D': 'RecommendedDisplayCIELabValue',\n      '0062000E': 'MaximumFractionalValue',\n      '0062000F': 'SegmentedPropertyTypeCodeSequence',\n      '00620010': 'SegmentationFractionalType',\n      '00620011': 'SegmentedPropertyTypeModifierCodeSequence',\n      '00620012': 'UsedSegmentsSequence',\n      '00620020': 'TrackingID',\n      '00620021': 'TrackingUID',\n      '00640002': 'DeformableRegistrationSequence',\n      '00640003': 'SourceFrameOfReferenceUID',\n      '00640005': 'DeformableRegistrationGridSequence',\n      '00640007': 'GridDimensions',\n      '00640008': 'GridResolution',\n      '00640009': 'VectorGridData',\n      '0064000F': 'PreDeformationMatrixRegistrationSequence',\n      '00640010': 'PostDeformationMatrixRegistrationSequence',\n      '00660001': 'NumberOfSurfaces',\n      '00660002': 'SurfaceSequence',\n      '00660003': 'SurfaceNumber',\n      '00660004': 'SurfaceComments',\n      '00660009': 'SurfaceProcessing',\n      '0066000A': 'SurfaceProcessingRatio',\n      '0066000B': 'SurfaceProcessingDescription',\n      '0066000C': 'RecommendedPresentationOpacity',\n      '0066000D': 'RecommendedPresentationType',\n      '0066000E': 'FiniteVolume',\n      '00660010': 'Manifold',\n      '00660011': 'SurfacePointsSequence',\n      '00660012': 'SurfacePointsNormalsSequence',\n      '00660013': 'SurfaceMeshPrimitivesSequence',\n      '00660015': 'NumberOfSurfacePoints',\n      '00660016': 'PointCoordinatesData',\n      '00660017': 'PointPositionAccuracy',\n      '00660018': 'MeanPointDistance',\n      '00660019': 'MaximumPointDistance',\n      '0066001A': 'PointsBoundingBoxCoordinates',\n      '0066001B': 'AxisOfRotation',\n      '0066001C': 'CenterOfRotation',\n      '0066001E': 'NumberOfVectors',\n      '0066001F': 'VectorDimensionality',\n      '00660020': 'VectorAccuracy',\n      '00660021': 'VectorCoordinateData',\n      '00660023': 'TrianglePointIndexList',\n      '00660024': 'EdgePointIndexList',\n      '00660025': 'VertexPointIndexList',\n      '00660026': 'TriangleStripSequence',\n      '00660027': 'TriangleFanSequence',\n      '00660028': 'LineSequence',\n      '00660029': 'PrimitivePointIndexList',\n      '0066002A': 'SurfaceCount',\n      '0066002B': 'ReferencedSurfaceSequence',\n      '0066002C': 'ReferencedSurfaceNumber',\n      '0066002D': 'SegmentSurfaceGenerationAlgorithmIdentificationSequence',\n      '0066002E': 'SegmentSurfaceSourceInstanceSequence',\n      '0066002F': 'AlgorithmFamilyCodeSequence',\n      '00660030': 'AlgorithmNameCodeSequence',\n      '00660031': 'AlgorithmVersion',\n      '00660032': 'AlgorithmParameters',\n      '00660034': 'FacetSequence',\n      '00660035': 'SurfaceProcessingAlgorithmIdentificationSequence',\n      '00660036': 'AlgorithmName',\n      '00660037': 'RecommendedPointRadius',\n      '00660038': 'RecommendedLineThickness',\n      '00660040': 'LongPrimitivePointIndexList',\n      '00660041': 'LongTrianglePointIndexList',\n      '00660042': 'LongEdgePointIndexList',\n      '00660043': 'LongVertexPointIndexList',\n      '00660101': 'TrackSetSequence',\n      '00660102': 'TrackSequence',\n      '00660103': 'RecommendedDisplayCIELabValueList',\n      '00660104': 'TrackingAlgorithmIdentificationSequence',\n      '00660105': 'TrackSetNumber',\n      '00660106': 'TrackSetLabel',\n      '00660107': 'TrackSetDescription',\n      '00660108': 'TrackSetAnatomicalTypeCodeSequence',\n      '00660121': 'MeasurementsSequence',\n      '00660124': 'TrackSetStatisticsSequence',\n      '00660125': 'FloatingPointValues',\n      '00660129': 'TrackPointIndexList',\n      '00660130': 'TrackStatisticsSequence',\n      '00660132': 'MeasurementValuesSequence',\n      '00660133': 'DiffusionAcquisitionCodeSequence',\n      '00660134': 'DiffusionModelCodeSequence',\n      '00686210': 'ImplantSize',\n      '00686221': 'ImplantTemplateVersion',\n      '00686222': 'ReplacedImplantTemplateSequence',\n      '00686223': 'ImplantType',\n      '00686224': 'DerivationImplantTemplateSequence',\n      '00686225': 'OriginalImplantTemplateSequence',\n      '00686226': 'EffectiveDateTime',\n      '00686230': 'ImplantTargetAnatomySequence',\n      '00686260': 'InformationFromManufacturerSequence',\n      '00686265': 'NotificationFromManufacturerSequence',\n      '00686270': 'InformationIssueDateTime',\n      '00686280': 'InformationSummary',\n      '006862A0': 'ImplantRegulatoryDisapprovalCodeSequence',\n      '006862A5': 'OverallTemplateSpatialTolerance',\n      '006862C0': 'HPGLDocumentSequence',\n      '006862D0': 'HPGLDocumentID',\n      '006862D5': 'HPGLDocumentLabel',\n      '006862E0': 'ViewOrientationCodeSequence',\n      '006862F0': 'ViewOrientationModifierCodeSequence',\n      '006862F2': 'HPGLDocumentScaling',\n      '00686300': 'HPGLDocument',\n      '00686310': 'HPGLContourPenNumber',\n      '00686320': 'HPGLPenSequence',\n      '00686330': 'HPGLPenNumber',\n      '00686340': 'HPGLPenLabel',\n      '00686345': 'HPGLPenDescription',\n      '00686346': 'RecommendedRotationPoint',\n      '00686347': 'BoundingRectangle',\n      '00686350': 'ImplantTemplate3DModelSurfaceNumber',\n      '00686360': 'SurfaceModelDescriptionSequence',\n      '00686380': 'SurfaceModelLabel',\n      '00686390': 'SurfaceModelScalingFactor',\n      '006863A0': 'MaterialsCodeSequence',\n      '006863A4': 'CoatingMaterialsCodeSequence',\n      '006863A8': 'ImplantTypeCodeSequence',\n      '006863AC': 'FixationMethodCodeSequence',\n      '006863B0': 'MatingFeatureSetsSequence',\n      '006863C0': 'MatingFeatureSetID',\n      '006863D0': 'MatingFeatureSetLabel',\n      '006863E0': 'MatingFeatureSequence',\n      '006863F0': 'MatingFeatureID',\n      '00686400': 'MatingFeatureDegreeOfFreedomSequence',\n      '00686410': 'DegreeOfFreedomID',\n      '00686420': 'DegreeOfFreedomType',\n      '00686430': 'TwoDMatingFeatureCoordinatesSequence',\n      '00686440': 'ReferencedHPGLDocumentID',\n      '00686450': 'TwoDMatingPoint',\n      '00686460': 'TwoDMatingAxes',\n      '00686470': 'TwoDDegreeOfFreedomSequence',\n      '00686490': 'ThreeDDegreeOfFreedomAxis',\n      '006864A0': 'RangeOfFreedom',\n      '006864C0': 'ThreeDMatingPoint',\n      '006864D0': 'ThreeDMatingAxes',\n      '006864F0': 'TwoDDegreeOfFreedomAxis',\n      '00686500': 'PlanningLandmarkPointSequence',\n      '00686510': 'PlanningLandmarkLineSequence',\n      '00686520': 'PlanningLandmarkPlaneSequence',\n      '00686530': 'PlanningLandmarkID',\n      '00686540': 'PlanningLandmarkDescription',\n      '00686545': 'PlanningLandmarkIdentificationCodeSequence',\n      '00686550': 'TwoDPointCoordinatesSequence',\n      '00686560': 'TwoDPointCoordinates',\n      '00686590': 'ThreeDPointCoordinates',\n      '006865A0': 'TwoDLineCoordinatesSequence',\n      '006865B0': 'TwoDLineCoordinates',\n      '006865D0': 'ThreeDLineCoordinates',\n      '006865E0': 'TwoDPlaneCoordinatesSequence',\n      '006865F0': 'TwoDPlaneIntersection',\n      '00686610': 'ThreeDPlaneOrigin',\n      '00686620': 'ThreeDPlaneNormal',\n      '00687001': 'ModelModification',\n      '00687002': 'ModelMirroring',\n      '00687003': 'ModelUsageCodeSequence',\n      '00700001': 'GraphicAnnotationSequence',\n      '00700002': 'GraphicLayer',\n      '00700003': 'BoundingBoxAnnotationUnits',\n      '00700004': 'AnchorPointAnnotationUnits',\n      '00700005': 'GraphicAnnotationUnits',\n      '00700006': 'UnformattedTextValue',\n      '00700008': 'TextObjectSequence',\n      '00700009': 'GraphicObjectSequence',\n      '00700010': 'BoundingBoxTopLeftHandCorner',\n      '00700011': 'BoundingBoxBottomRightHandCorner',\n      '00700012': 'BoundingBoxTextHorizontalJustification',\n      '00700014': 'AnchorPoint',\n      '00700015': 'AnchorPointVisibility',\n      '00700020': 'GraphicDimensions',\n      '00700021': 'NumberOfGraphicPoints',\n      '00700022': 'GraphicData',\n      '00700023': 'GraphicType',\n      '00700024': 'GraphicFilled',\n      '00700040': 'ImageRotationRetired',\n      '00700041': 'ImageHorizontalFlip',\n      '00700042': 'ImageRotation',\n      '00700050': 'DisplayedAreaTopLeftHandCornerTrial',\n      '00700051': 'DisplayedAreaBottomRightHandCornerTrial',\n      '00700052': 'DisplayedAreaTopLeftHandCorner',\n      '00700053': 'DisplayedAreaBottomRightHandCorner',\n      '0070005A': 'DisplayedAreaSelectionSequence',\n      '00700060': 'GraphicLayerSequence',\n      '00700062': 'GraphicLayerOrder',\n      '00700066': 'GraphicLayerRecommendedDisplayGrayscaleValue',\n      '00700067': 'GraphicLayerRecommendedDisplayRGBValue',\n      '00700068': 'GraphicLayerDescription',\n      '00700080': 'ContentLabel',\n      '00700081': 'ContentDescription',\n      '00700082': 'PresentationCreationDate',\n      '00700083': 'PresentationCreationTime',\n      '00700084': 'ContentCreatorName',\n      '00700086': 'ContentCreatorIdentificationCodeSequence',\n      '00700087': 'AlternateContentDescriptionSequence',\n      '00700100': 'PresentationSizeMode',\n      '00700101': 'PresentationPixelSpacing',\n      '00700102': 'PresentationPixelAspectRatio',\n      '00700103': 'PresentationPixelMagnificationRatio',\n      '00700207': 'GraphicGroupLabel',\n      '00700208': 'GraphicGroupDescription',\n      '00700209': 'CompoundGraphicSequence',\n      '00700226': 'CompoundGraphicInstanceID',\n      '00700227': 'FontName',\n      '00700228': 'FontNameType',\n      '00700229': 'CSSFontName',\n      '00700230': 'RotationAngle',\n      '00700231': 'TextStyleSequence',\n      '00700232': 'LineStyleSequence',\n      '00700233': 'FillStyleSequence',\n      '00700234': 'GraphicGroupSequence',\n      '00700241': 'TextColorCIELabValue',\n      '00700242': 'HorizontalAlignment',\n      '00700243': 'VerticalAlignment',\n      '00700244': 'ShadowStyle',\n      '00700245': 'ShadowOffsetX',\n      '00700246': 'ShadowOffsetY',\n      '00700247': 'ShadowColorCIELabValue',\n      '00700248': 'Underlined',\n      '00700249': 'Bold',\n      '00700250': 'Italic',\n      '00700251': 'PatternOnColorCIELabValue',\n      '00700252': 'PatternOffColorCIELabValue',\n      '00700253': 'LineThickness',\n      '00700254': 'LineDashingStyle',\n      '00700255': 'LinePattern',\n      '00700256': 'FillPattern',\n      '00700257': 'FillMode',\n      '00700258': 'ShadowOpacity',\n      '00700261': 'GapLength',\n      '00700262': 'DiameterOfVisibility',\n      '00700273': 'RotationPoint',\n      '00700274': 'TickAlignment',\n      '00700278': 'ShowTickLabel',\n      '00700279': 'TickLabelAlignment',\n      '00700282': 'CompoundGraphicUnits',\n      '00700284': 'PatternOnOpacity',\n      '00700285': 'PatternOffOpacity',\n      '00700287': 'MajorTicksSequence',\n      '00700288': 'TickPosition',\n      '00700289': 'TickLabel',\n      '00700294': 'CompoundGraphicType',\n      '00700295': 'GraphicGroupID',\n      '00700306': 'ShapeType',\n      '00700308': 'RegistrationSequence',\n      '00700309': 'MatrixRegistrationSequence',\n      '0070030A': 'MatrixSequence',\n      '0070030B': 'FrameOfReferenceToDisplayedCoordinateSystemTransformationMatrix',\n      '0070030C': 'FrameOfReferenceTransformationMatrixType',\n      '0070030D': 'RegistrationTypeCodeSequence',\n      '0070030F': 'FiducialDescription',\n      '00700310': 'FiducialIdentifier',\n      '00700311': 'FiducialIdentifierCodeSequence',\n      '00700312': 'ContourUncertaintyRadius',\n      '00700314': 'UsedFiducialsSequence',\n      '00700318': 'GraphicCoordinatesDataSequence',\n      '0070031A': 'FiducialUID',\n      '0070031B': 'ReferencedFiducialUID',\n      '0070031C': 'FiducialSetSequence',\n      '0070031E': 'FiducialSequence',\n      '0070031F': 'FiducialsPropertyCategoryCodeSequence',\n      '00700401': 'GraphicLayerRecommendedDisplayCIELabValue',\n      '00700402': 'BlendingSequence',\n      '00700403': 'RelativeOpacity',\n      '00700404': 'ReferencedSpatialRegistrationSequence',\n      '00700405': 'BlendingPosition',\n      '00701101': 'PresentationDisplayCollectionUID',\n      '00701102': 'PresentationSequenceCollectionUID',\n      '00701103': 'PresentationSequencePositionIndex',\n      '00701104': 'RenderedImageReferenceSequence',\n      '00701201': 'VolumetricPresentationStateInputSequence',\n      '00701202': 'PresentationInputType',\n      '00701203': 'InputSequencePositionIndex',\n      '00701204': 'Crop',\n      '00701205': 'CroppingSpecificationIndex',\n      '00701206': 'CompositingMethod',\n      '00701207': 'VolumetricPresentationInputNumber',\n      '00701208': 'ImageVolumeGeometry',\n      '00701209': 'VolumetricPresentationInputSetUID',\n      '0070120A': 'VolumetricPresentationInputSetSequence',\n      '0070120B': 'GlobalCrop',\n      '0070120C': 'GlobalCroppingSpecificationIndex',\n      '0070120D': 'RenderingMethod',\n      '00701301': 'VolumeCroppingSequence',\n      '00701302': 'VolumeCroppingMethod',\n      '00701303': 'BoundingBoxCrop',\n      '00701304': 'ObliqueCroppingPlaneSequence',\n      '00701305': 'Plane',\n      '00701306': 'PlaneNormal',\n      '00701309': 'CroppingSpecificationNumber',\n      '00701501': 'MultiPlanarReconstructionStyle',\n      '00701502': 'MPRThicknessType',\n      '00701503': 'MPRSlabThickness',\n      '00701505': 'MPRTopLeftHandCorner',\n      '00701507': 'MPRViewWidthDirection',\n      '00701508': 'MPRViewWidth',\n      '0070150C': 'NumberOfVolumetricCurvePoints',\n      '0070150D': 'VolumetricCurvePoints',\n      '00701511': 'MPRViewHeightDirection',\n      '00701512': 'MPRViewHeight',\n      '00701602': 'RenderProjection',\n      '00701603': 'ViewpointPosition',\n      '00701604': 'ViewpointLookAtPoint',\n      '00701605': 'ViewpointUpDirection',\n      '00701606': 'RenderFieldOfView',\n      '00701607': 'SamplingStepSize',\n      '00701701': 'ShadingStyle',\n      '00701702': 'AmbientReflectionIntensity',\n      '00701703': 'LightDirection',\n      '00701704': 'DiffuseReflectionIntensity',\n      '00701705': 'SpecularReflectionIntensity',\n      '00701706': 'Shininess',\n      '00701801': 'PresentationStateClassificationComponentSequence',\n      '00701802': 'ComponentType',\n      '00701803': 'ComponentInputSequence',\n      '00701804': 'VolumetricPresentationInputIndex',\n      '00701805': 'PresentationStateCompositorComponentSequence',\n      '00701806': 'WeightingTransferFunctionSequence',\n      '00701807': 'WeightingLookupTableDescriptor',\n      '00701808': 'WeightingLookupTableData',\n      '00701901': 'VolumetricAnnotationSequence',\n      '00701903': 'ReferencedStructuredContextSequence',\n      '00701904': 'ReferencedContentItem',\n      '00701905': 'VolumetricPresentationInputAnnotationSequence',\n      '00701907': 'AnnotationClipping',\n      '00701A01': 'PresentationAnimationStyle',\n      '00701A03': 'RecommendedAnimationRate',\n      '00701A04': 'AnimationCurveSequence',\n      '00701A05': 'AnimationStepSize',\n      '00701A06': 'SwivelRange',\n      '00701A07': 'VolumetricCurveUpDirections',\n      '00701A08': 'VolumeStreamSequence',\n      '00701A09': 'RGBATransferFunctionDescription',\n      '00701B01': 'AdvancedBlendingSequence',\n      '00701B02': 'BlendingInputNumber',\n      '00701B03': 'BlendingDisplayInputSequence',\n      '00701B04': 'BlendingDisplaySequence',\n      '00701B06': 'BlendingMode',\n      '00701B07': 'TimeSeriesBlending',\n      '00701B08': 'GeometryForDisplay',\n      '00701B11': 'ThresholdSequence',\n      '00701B12': 'ThresholdValueSequence',\n      '00701B13': 'ThresholdType',\n      '00701B14': 'ThresholdValue',\n      '00720002': 'HangingProtocolName',\n      '00720004': 'HangingProtocolDescription',\n      '00720006': 'HangingProtocolLevel',\n      '00720008': 'HangingProtocolCreator',\n      '0072000A': 'HangingProtocolCreationDateTime',\n      '0072000C': 'HangingProtocolDefinitionSequence',\n      '0072000E': 'HangingProtocolUserIdentificationCodeSequence',\n      '00720010': 'HangingProtocolUserGroupName',\n      '00720012': 'SourceHangingProtocolSequence',\n      '00720014': 'NumberOfPriorsReferenced',\n      '00720020': 'ImageSetsSequence',\n      '00720022': 'ImageSetSelectorSequence',\n      '00720024': 'ImageSetSelectorUsageFlag',\n      '00720026': 'SelectorAttribute',\n      '00720028': 'SelectorValueNumber',\n      '00720030': 'TimeBasedImageSetsSequence',\n      '00720032': 'ImageSetNumber',\n      '00720034': 'ImageSetSelectorCategory',\n      '00720038': 'RelativeTime',\n      '0072003A': 'RelativeTimeUnits',\n      '0072003C': 'AbstractPriorValue',\n      '0072003E': 'AbstractPriorCodeSequence',\n      '00720040': 'ImageSetLabel',\n      '00720050': 'SelectorAttributeVR',\n      '00720052': 'SelectorSequencePointer',\n      '00720054': 'SelectorSequencePointerPrivateCreator',\n      '00720056': 'SelectorAttributePrivateCreator',\n      '0072005E': 'SelectorAEValue',\n      '0072005F': 'SelectorASValue',\n      '00720060': 'SelectorATValue',\n      '00720061': 'SelectorDAValue',\n      '00720062': 'SelectorCSValue',\n      '00720063': 'SelectorDTValue',\n      '00720064': 'SelectorISValue',\n      '00720065': 'SelectorOBValue',\n      '00720066': 'SelectorLOValue',\n      '00720067': 'SelectorOFValue',\n      '00720068': 'SelectorLTValue',\n      '00720069': 'SelectorOWValue',\n      '0072006A': 'SelectorPNValue',\n      '0072006B': 'SelectorTMValue',\n      '0072006C': 'SelectorSHValue',\n      '0072006D': 'SelectorUNValue',\n      '0072006E': 'SelectorSTValue',\n      '0072006F': 'SelectorUCValue',\n      '00720070': 'SelectorUTValue',\n      '00720071': 'SelectorURValue',\n      '00720072': 'SelectorDSValue',\n      '00720073': 'SelectorODValue',\n      '00720074': 'SelectorFDValue',\n      '00720075': 'SelectorOLValue',\n      '00720076': 'SelectorFLValue',\n      '00720078': 'SelectorULValue',\n      '0072007A': 'SelectorUSValue',\n      '0072007C': 'SelectorSLValue',\n      '0072007E': 'SelectorSSValue',\n      '0072007F': 'SelectorUIValue',\n      '00720080': 'SelectorCodeSequenceValue',\n      '00720100': 'NumberOfScreens',\n      '00720102': 'NominalScreenDefinitionSequence',\n      '00720104': 'NumberOfVerticalPixels',\n      '00720106': 'NumberOfHorizontalPixels',\n      '00720108': 'DisplayEnvironmentSpatialPosition',\n      '0072010A': 'ScreenMinimumGrayscaleBitDepth',\n      '0072010C': 'ScreenMinimumColorBitDepth',\n      '0072010E': 'ApplicationMaximumRepaintTime',\n      '00720200': 'DisplaySetsSequence',\n      '00720202': 'DisplaySetNumber',\n      '00720203': 'DisplaySetLabel',\n      '00720204': 'DisplaySetPresentationGroup',\n      '00720206': 'DisplaySetPresentationGroupDescription',\n      '00720208': 'PartialDataDisplayHandling',\n      '00720210': 'SynchronizedScrollingSequence',\n      '00720212': 'DisplaySetScrollingGroup',\n      '00720214': 'NavigationIndicatorSequence',\n      '00720216': 'NavigationDisplaySet',\n      '00720218': 'ReferenceDisplaySets',\n      '00720300': 'ImageBoxesSequence',\n      '00720302': 'ImageBoxNumber',\n      '00720304': 'ImageBoxLayoutType',\n      '00720306': 'ImageBoxTileHorizontalDimension',\n      '00720308': 'ImageBoxTileVerticalDimension',\n      '00720310': 'ImageBoxScrollDirection',\n      '00720312': 'ImageBoxSmallScrollType',\n      '00720314': 'ImageBoxSmallScrollAmount',\n      '00720316': 'ImageBoxLargeScrollType',\n      '00720318': 'ImageBoxLargeScrollAmount',\n      '00720320': 'ImageBoxOverlapPriority',\n      '00720330': 'CineRelativeToRealTime',\n      '00720400': 'FilterOperationsSequence',\n      '00720402': 'FilterByCategory',\n      '00720404': 'FilterByAttributePresence',\n      '00720406': 'FilterByOperator',\n      '00720420': 'StructuredDisplayBackgroundCIELabValue',\n      '00720421': 'EmptyImageBoxCIELabValue',\n      '00720422': 'StructuredDisplayImageBoxSequence',\n      '00720424': 'StructuredDisplayTextBoxSequence',\n      '00720427': 'ReferencedFirstFrameSequence',\n      '00720430': 'ImageBoxSynchronizationSequence',\n      '00720432': 'SynchronizedImageBoxList',\n      '00720434': 'TypeOfSynchronization',\n      '00720500': 'BlendingOperationType',\n      '00720510': 'ReformattingOperationType',\n      '00720512': 'ReformattingThickness',\n      '00720514': 'ReformattingInterval',\n      '00720516': 'ReformattingOperationInitialViewDirection',\n      '00720520': 'ThreeDRenderingType',\n      '00720600': 'SortingOperationsSequence',\n      '00720602': 'SortByCategory',\n      '00720604': 'SortingDirection',\n      '00720700': 'DisplaySetPatientOrientation',\n      '00720702': 'VOIType',\n      '00720704': 'PseudoColorType',\n      '00720705': 'PseudoColorPaletteInstanceReferenceSequence',\n      '00720706': 'ShowGrayscaleInverted',\n      '00720710': 'ShowImageTrueSizeFlag',\n      '00720712': 'ShowGraphicAnnotationFlag',\n      '00720714': 'ShowPatientDemographicsFlag',\n      '00720716': 'ShowAcquisitionTechniquesFlag',\n      '00720717': 'DisplaySetHorizontalJustification',\n      '00720718': 'DisplaySetVerticalJustification',\n      '00740120': 'ContinuationStartMeterset',\n      '00740121': 'ContinuationEndMeterset',\n      '00741000': 'ProcedureStepState',\n      '00741002': 'ProcedureStepProgressInformationSequence',\n      '00741004': 'ProcedureStepProgress',\n      '00741006': 'ProcedureStepProgressDescription',\n      '00741007': 'ProcedureStepProgressParametersSequence',\n      '00741008': 'ProcedureStepCommunicationsURISequence',\n      '0074100A': 'ContactURI',\n      '0074100C': 'ContactDisplayName',\n      '0074100E': 'ProcedureStepDiscontinuationReasonCodeSequence',\n      '00741020': 'BeamTaskSequence',\n      '00741022': 'BeamTaskType',\n      '00741024': 'BeamOrderIndexTrial',\n      '00741025': 'AutosequenceFlag',\n      '00741026': 'TableTopVerticalAdjustedPosition',\n      '00741027': 'TableTopLongitudinalAdjustedPosition',\n      '00741028': 'TableTopLateralAdjustedPosition',\n      '0074102A': 'PatientSupportAdjustedAngle',\n      '0074102B': 'TableTopEccentricAdjustedAngle',\n      '0074102C': 'TableTopPitchAdjustedAngle',\n      '0074102D': 'TableTopRollAdjustedAngle',\n      '00741030': 'DeliveryVerificationImageSequence',\n      '00741032': 'VerificationImageTiming',\n      '00741034': 'DoubleExposureFlag',\n      '00741036': 'DoubleExposureOrdering',\n      '00741038': 'DoubleExposureMetersetTrial',\n      '0074103A': 'DoubleExposureFieldDeltaTrial',\n      '00741040': 'RelatedReferenceRTImageSequence',\n      '00741042': 'GeneralMachineVerificationSequence',\n      '00741044': 'ConventionalMachineVerificationSequence',\n      '00741046': 'IonMachineVerificationSequence',\n      '00741048': 'FailedAttributesSequence',\n      '0074104A': 'OverriddenAttributesSequence',\n      '0074104C': 'ConventionalControlPointVerificationSequence',\n      '0074104E': 'IonControlPointVerificationSequence',\n      '00741050': 'AttributeOccurrenceSequence',\n      '00741052': 'AttributeOccurrencePointer',\n      '00741054': 'AttributeItemSelector',\n      '00741056': 'AttributeOccurrencePrivateCreator',\n      '00741057': 'SelectorSequencePointerItems',\n      '00741200': 'ScheduledProcedureStepPriority',\n      '00741202': 'WorklistLabel',\n      '00741204': 'ProcedureStepLabel',\n      '00741210': 'ScheduledProcessingParametersSequence',\n      '00741212': 'PerformedProcessingParametersSequence',\n      '00741216': 'UnifiedProcedureStepPerformedProcedureSequence',\n      '00741220': 'RelatedProcedureStepSequence',\n      '00741222': 'ProcedureStepRelationshipType',\n      '00741224': 'ReplacedProcedureStepSequence',\n      '00741230': 'DeletionLock',\n      '00741234': 'ReceivingAE',\n      '00741236': 'RequestingAE',\n      '00741238': 'ReasonForCancellation',\n      '00741242': 'SCPStatus',\n      '00741244': 'SubscriptionListStatus',\n      '00741246': 'UnifiedProcedureStepListStatus',\n      '00741324': 'BeamOrderIndex',\n      '00741338': 'DoubleExposureMeterset',\n      '0074133A': 'DoubleExposureFieldDelta',\n      '00741401': 'BrachyTaskSequence',\n      '00741402': 'ContinuationStartTotalReferenceAirKerma',\n      '00741403': 'ContinuationEndTotalReferenceAirKerma',\n      '00741404': 'ContinuationPulseNumber',\n      '00741405': 'ChannelDeliveryOrderSequence',\n      '00741406': 'ReferencedChannelNumber',\n      '00741407': 'StartCumulativeTimeWeight',\n      '00741408': 'EndCumulativeTimeWeight',\n      '00741409': 'OmittedChannelSequence',\n      '0074140A': 'ReasonForChannelOmission',\n      '0074140B': 'ReasonForChannelOmissionDescription',\n      '0074140C': 'ChannelDeliveryOrderIndex',\n      '0074140D': 'ChannelDeliveryContinuationSequence',\n      '0074140E': 'OmittedApplicationSetupSequence',\n      '00760001': 'ImplantAssemblyTemplateName',\n      '00760003': 'ImplantAssemblyTemplateIssuer',\n      '00760006': 'ImplantAssemblyTemplateVersion',\n      '00760008': 'ReplacedImplantAssemblyTemplateSequence',\n      '0076000A': 'ImplantAssemblyTemplateType',\n      '0076000C': 'OriginalImplantAssemblyTemplateSequence',\n      '0076000E': 'DerivationImplantAssemblyTemplateSequence',\n      '00760010': 'ImplantAssemblyTemplateTargetAnatomySequence',\n      '00760020': 'ProcedureTypeCodeSequence',\n      '00760030': 'SurgicalTechnique',\n      '00760032': 'ComponentTypesSequence',\n      '00760034': 'ComponentTypeCodeSequence',\n      '00760036': 'ExclusiveComponentType',\n      '00760038': 'MandatoryComponentType',\n      '00760040': 'ComponentSequence',\n      '00760055': 'ComponentID',\n      '00760060': 'ComponentAssemblySequence',\n      '00760070': 'Component1ReferencedID',\n      '00760080': 'Component1ReferencedMatingFeatureSetID',\n      '00760090': 'Component1ReferencedMatingFeatureID',\n      '007600A0': 'Component2ReferencedID',\n      '007600B0': 'Component2ReferencedMatingFeatureSetID',\n      '007600C0': 'Component2ReferencedMatingFeatureID',\n      '00780001': 'ImplantTemplateGroupName',\n      '00780010': 'ImplantTemplateGroupDescription',\n      '00780020': 'ImplantTemplateGroupIssuer',\n      '00780024': 'ImplantTemplateGroupVersion',\n      '00780026': 'ReplacedImplantTemplateGroupSequence',\n      '00780028': 'ImplantTemplateGroupTargetAnatomySequence',\n      '0078002A': 'ImplantTemplateGroupMembersSequence',\n      '0078002E': 'ImplantTemplateGroupMemberID',\n      '00780050': 'ThreeDImplantTemplateGroupMemberMatchingPoint',\n      '00780060': 'ThreeDImplantTemplateGroupMemberMatchingAxes',\n      '00780070': 'ImplantTemplateGroupMemberMatching2DCoordinatesSequence',\n      '00780090': 'TwoDImplantTemplateGroupMemberMatchingPoint',\n      '007800A0': 'TwoDImplantTemplateGroupMemberMatchingAxes',\n      '007800B0': 'ImplantTemplateGroupVariationDimensionSequence',\n      '007800B2': 'ImplantTemplateGroupVariationDimensionName',\n      '007800B4': 'ImplantTemplateGroupVariationDimensionRankSequence',\n      '007800B6': 'ReferencedImplantTemplateGroupMemberID',\n      '007800B8': 'ImplantTemplateGroupVariationDimensionRank',\n      '00800001': 'SurfaceScanAcquisitionTypeCodeSequence',\n      '00800002': 'SurfaceScanModeCodeSequence',\n      '00800003': 'RegistrationMethodCodeSequence',\n      '00800004': 'ShotDurationTime',\n      '00800005': 'ShotOffsetTime',\n      '00800006': 'SurfacePointPresentationValueData',\n      '00800007': 'SurfacePointColorCIELabValueData',\n      '00800008': 'UVMappingSequence',\n      '00800009': 'TextureLabel',\n      '00800010': 'UValueData',\n      '00800011': 'VValueData',\n      '00800012': 'ReferencedTextureSequence',\n      '00800013': 'ReferencedSurfaceDataSequence',\n      '00820001': 'AssessmentSummary',\n      '00820003': 'AssessmentSummaryDescription',\n      '00820004': 'AssessedSOPInstanceSequence',\n      '00820005': 'ReferencedComparisonSOPInstanceSequence',\n      '00820006': 'NumberOfAssessmentObservations',\n      '00820007': 'AssessmentObservationsSequence',\n      '00820008': 'ObservationSignificance',\n      '0082000A': 'ObservationDescription',\n      '0082000C': 'StructuredConstraintObservationSequence',\n      '00820010': 'AssessedAttributeValueSequence',\n      '00820016': 'AssessmentSetID',\n      '00820017': 'AssessmentRequesterSequence',\n      '00820018': 'SelectorAttributeName',\n      '00820019': 'SelectorAttributeKeyword',\n      '00820021': 'AssessmentTypeCodeSequence',\n      '00820022': 'ObservationBasisCodeSequence',\n      '00820023': 'AssessmentLabel',\n      '00820032': 'ConstraintType',\n      '00820033': 'SpecificationSelectionGuidance',\n      '00820034': 'ConstraintValueSequence',\n      '00820035': 'RecommendedDefaultValueSequence',\n      '00820036': 'ConstraintViolationSignificance',\n      '00820037': 'ConstraintViolationCondition',\n      '00820038': 'ModifiableConstraintFlag',\n      '00880130': 'StorageMediaFileSetID',\n      '00880140': 'StorageMediaFileSetUID',\n      '00880200': 'IconImageSequence',\n      '00880904': 'TopicTitle',\n      '00880906': 'TopicSubject',\n      '00880910': 'TopicAuthor',\n      '00880912': 'TopicKeywords',\n      '01000410': 'SOPInstanceStatus',\n      '01000420': 'SOPAuthorizationDateTime',\n      '01000424': 'SOPAuthorizationComment',\n      '01000426': 'AuthorizationEquipmentCertificationNumber',\n      '04000005': 'MACIDNumber',\n      '04000010': 'MACCalculationTransferSyntaxUID',\n      '04000015': 'MACAlgorithm',\n      '04000020': 'DataElementsSigned',\n      '04000100': 'DigitalSignatureUID',\n      '04000105': 'DigitalSignatureDateTime',\n      '04000110': 'CertificateType',\n      '04000115': 'CertificateOfSigner',\n      '04000120': 'Signature',\n      '04000305': 'CertifiedTimestampType',\n      '04000310': 'CertifiedTimestamp',\n      '04000315': '',\n      '04000401': 'DigitalSignaturePurposeCodeSequence',\n      '04000402': 'ReferencedDigitalSignatureSequence',\n      '04000403': 'ReferencedSOPInstanceMACSequence',\n      '04000404': 'MAC',\n      '04000500': 'EncryptedAttributesSequence',\n      '04000510': 'EncryptedContentTransferSyntaxUID',\n      '04000520': 'EncryptedContent',\n      '04000550': 'ModifiedAttributesSequence',\n      '04000561': 'OriginalAttributesSequence',\n      '04000562': 'AttributeModificationDateTime',\n      '04000563': 'ModifyingSystem',\n      '04000564': 'SourceOfPreviousValues',\n      '04000565': 'ReasonForTheAttributeModification',\n      '04000600': 'InstanceOriginStatus',\n      '20000010': 'NumberOfCopies',\n      '2000001E': 'PrinterConfigurationSequence',\n      '20000020': 'PrintPriority',\n      '20000030': 'MediumType',\n      '20000040': 'FilmDestination',\n      '20000050': 'FilmSessionLabel',\n      '20000060': 'MemoryAllocation',\n      '20000061': 'MaximumMemoryAllocation',\n      '20000062': 'ColorImagePrintingFlag',\n      '20000063': 'CollationFlag',\n      '20000065': 'AnnotationFlag',\n      '20000067': 'ImageOverlayFlag',\n      '20000069': 'PresentationLUTFlag',\n      '2000006A': 'ImageBoxPresentationLUTFlag',\n      '200000A0': 'MemoryBitDepth',\n      '200000A1': 'PrintingBitDepth',\n      '200000A2': 'MediaInstalledSequence',\n      '200000A4': 'OtherMediaAvailableSequence',\n      '200000A8': 'SupportedImageDisplayFormatsSequence',\n      '20000500': 'ReferencedFilmBoxSequence',\n      '20000510': 'ReferencedStoredPrintSequence',\n      '20100010': 'ImageDisplayFormat',\n      '20100030': 'AnnotationDisplayFormatID',\n      '20100040': 'FilmOrientation',\n      '20100050': 'FilmSizeID',\n      '20100052': 'PrinterResolutionID',\n      '20100054': 'DefaultPrinterResolutionID',\n      '20100060': 'MagnificationType',\n      '20100080': 'SmoothingType',\n      '201000A6': 'DefaultMagnificationType',\n      '201000A7': 'OtherMagnificationTypesAvailable',\n      '201000A8': 'DefaultSmoothingType',\n      '201000A9': 'OtherSmoothingTypesAvailable',\n      '20100100': 'BorderDensity',\n      '20100110': 'EmptyImageDensity',\n      '20100120': 'MinDensity',\n      '20100130': 'MaxDensity',\n      '20100140': 'Trim',\n      '20100150': 'ConfigurationInformation',\n      '20100152': 'ConfigurationInformationDescription',\n      '20100154': 'MaximumCollatedFilms',\n      '2010015E': 'Illumination',\n      '20100160': 'ReflectedAmbientLight',\n      '20100376': 'PrinterPixelSpacing',\n      '20100500': 'ReferencedFilmSessionSequence',\n      '20100510': 'ReferencedImageBoxSequence',\n      '20100520': 'ReferencedBasicAnnotationBoxSequence',\n      '20200010': 'ImageBoxPosition',\n      '20200020': 'Polarity',\n      '20200030': 'RequestedImageSize',\n      '20200040': 'RequestedDecimateCropBehavior',\n      '20200050': 'RequestedResolutionID',\n      '202000A0': 'RequestedImageSizeFlag',\n      '202000A2': 'DecimateCropResult',\n      '20200110': 'BasicGrayscaleImageSequence',\n      '20200111': 'BasicColorImageSequence',\n      '20200130': 'ReferencedImageOverlayBoxSequence',\n      '20200140': 'ReferencedVOILUTBoxSequence',\n      '20300010': 'AnnotationPosition',\n      '20300020': 'TextString',\n      '20400010': 'ReferencedOverlayPlaneSequence',\n      '20400011': 'ReferencedOverlayPlaneGroups',\n      '20400020': 'OverlayPixelDataSequence',\n      '20400060': 'OverlayMagnificationType',\n      '20400070': 'OverlaySmoothingType',\n      '20400072': 'OverlayOrImageMagnification',\n      '20400074': 'MagnifyToNumberOfColumns',\n      '20400080': 'OverlayForegroundDensity',\n      '20400082': 'OverlayBackgroundDensity',\n      '20400090': 'OverlayMode',\n      '20400100': 'ThresholdDensity',\n      '20400500': 'ReferencedImageBoxSequenceRetired',\n      '20500010': 'PresentationLUTSequence',\n      '20500020': 'PresentationLUTShape',\n      '20500500': 'ReferencedPresentationLUTSequence',\n      '21000010': 'PrintJobID',\n      '21000020': 'ExecutionStatus',\n      '21000030': 'ExecutionStatusInfo',\n      '21000040': 'CreationDate',\n      '21000050': 'CreationTime',\n      '21000070': 'Originator',\n      '21000140': 'DestinationAE',\n      '21000160': 'OwnerID',\n      '21000170': 'NumberOfFilms',\n      '21000500': 'ReferencedPrintJobSequencePullStoredPrint',\n      '21100010': 'PrinterStatus',\n      '21100020': 'PrinterStatusInfo',\n      '21100030': 'PrinterName',\n      '21100099': 'PrintQueueID',\n      '21200010': 'QueueStatus',\n      '21200050': 'PrintJobDescriptionSequence',\n      '21200070': 'ReferencedPrintJobSequence',\n      '21300010': 'PrintManagementCapabilitiesSequence',\n      '21300015': 'PrinterCharacteristicsSequence',\n      '21300030': 'FilmBoxContentSequence',\n      '21300040': 'ImageBoxContentSequence',\n      '21300050': 'AnnotationContentSequence',\n      '21300060': 'ImageOverlayBoxContentSequence',\n      '21300080': 'PresentationLUTContentSequence',\n      '213000A0': 'ProposedStudySequence',\n      '213000C0': 'OriginalImageSequence',\n      '22000001': 'LabelUsingInformationExtractedFromInstances',\n      '22000002': 'LabelText',\n      '22000003': 'LabelStyleSelection',\n      '22000004': 'MediaDisposition',\n      '22000005': 'BarcodeValue',\n      '22000006': 'BarcodeSymbology',\n      '22000007': 'AllowMediaSplitting',\n      '22000008': 'IncludeNonDICOMObjects',\n      '22000009': 'IncludeDisplayApplication',\n      '2200000A': 'PreserveCompositeInstancesAfterMediaCreation',\n      '2200000B': 'TotalNumberOfPiecesOfMediaCreated',\n      '2200000C': 'RequestedMediaApplicationProfile',\n      '2200000D': 'ReferencedStorageMediaSequence',\n      '2200000E': 'FailureAttributes',\n      '2200000F': 'AllowLossyCompression',\n      '22000020': 'RequestPriority',\n      '30020002': 'RTImageLabel',\n      '30020003': 'RTImageName',\n      '30020004': 'RTImageDescription',\n      '3002000A': 'ReportedValuesOrigin',\n      '3002000C': 'RTImagePlane',\n      '3002000D': 'XRayImageReceptorTranslation',\n      '3002000E': 'XRayImageReceptorAngle',\n      '30020010': 'RTImageOrientation',\n      '30020011': 'ImagePlanePixelSpacing',\n      '30020012': 'RTImagePosition',\n      '30020020': 'RadiationMachineName',\n      '30020022': 'RadiationMachineSAD',\n      '30020024': 'RadiationMachineSSD',\n      '30020026': 'RTImageSID',\n      '30020028': 'SourceToReferenceObjectDistance',\n      '30020029': 'FractionNumber',\n      '30020030': 'ExposureSequence',\n      '30020032': 'MetersetExposure',\n      '30020034': 'DiaphragmPosition',\n      '30020040': 'FluenceMapSequence',\n      '30020041': 'FluenceDataSource',\n      '30020042': 'FluenceDataScale',\n      '30020050': 'PrimaryFluenceModeSequence',\n      '30020051': 'FluenceMode',\n      '30020052': 'FluenceModeID',\n      '30040001': 'DVHType',\n      '30040002': 'DoseUnits',\n      '30040004': 'DoseType',\n      '30040005': 'SpatialTransformOfDose',\n      '30040006': 'DoseComment',\n      '30040008': 'NormalizationPoint',\n      '3004000A': 'DoseSummationType',\n      '3004000C': 'GridFrameOffsetVector',\n      '3004000E': 'DoseGridScaling',\n      '30040010': 'RTDoseROISequence',\n      '30040012': 'DoseValue',\n      '30040014': 'TissueHeterogeneityCorrection',\n      '30040040': 'DVHNormalizationPoint',\n      '30040042': 'DVHNormalizationDoseValue',\n      '30040050': 'DVHSequence',\n      '30040052': 'DVHDoseScaling',\n      '30040054': 'DVHVolumeUnits',\n      '30040056': 'DVHNumberOfBins',\n      '30040058': 'DVHData',\n      '30040060': 'DVHReferencedROISequence',\n      '30040062': 'DVHROIContributionType',\n      '30040070': 'DVHMinimumDose',\n      '30040072': 'DVHMaximumDose',\n      '30040074': 'DVHMeanDose',\n      '30060002': 'StructureSetLabel',\n      '30060004': 'StructureSetName',\n      '30060006': 'StructureSetDescription',\n      '30060008': 'StructureSetDate',\n      '30060009': 'StructureSetTime',\n      '30060010': 'ReferencedFrameOfReferenceSequence',\n      '30060012': 'RTReferencedStudySequence',\n      '30060014': 'RTReferencedSeriesSequence',\n      '30060016': 'ContourImageSequence',\n      '30060018': 'PredecessorStructureSetSequence',\n      '30060020': 'StructureSetROISequence',\n      '30060022': 'ROINumber',\n      '30060024': 'ReferencedFrameOfReferenceUID',\n      '30060026': 'ROIName',\n      '30060028': 'ROIDescription',\n      '3006002A': 'ROIDisplayColor',\n      '3006002C': 'ROIVolume',\n      '30060030': 'RTRelatedROISequence',\n      '30060033': 'RTROIRelationship',\n      '30060036': 'ROIGenerationAlgorithm',\n      '30060038': 'ROIGenerationDescription',\n      '30060039': 'ROIContourSequence',\n      '30060040': 'ContourSequence',\n      '30060042': 'ContourGeometricType',\n      '30060044': 'ContourSlabThickness',\n      '30060045': 'ContourOffsetVector',\n      '30060046': 'NumberOfContourPoints',\n      '30060048': 'ContourNumber',\n      '30060049': 'AttachedContours',\n      '30060050': 'ContourData',\n      '30060080': 'RTROIObservationsSequence',\n      '30060082': 'ObservationNumber',\n      '30060084': 'ReferencedROINumber',\n      '30060085': 'ROIObservationLabel',\n      '30060086': 'RTROIIdentificationCodeSequence',\n      '30060088': 'ROIObservationDescription',\n      '300600A0': 'RelatedRTROIObservationsSequence',\n      '300600A4': 'RTROIInterpretedType',\n      '300600A6': 'ROIInterpreter',\n      '300600B0': 'ROIPhysicalPropertiesSequence',\n      '300600B2': 'ROIPhysicalProperty',\n      '300600B4': 'ROIPhysicalPropertyValue',\n      '300600B6': 'ROIElementalCompositionSequence',\n      '300600B7': 'ROIElementalCompositionAtomicNumber',\n      '300600B8': 'ROIElementalCompositionAtomicMassFraction',\n      '300600B9': 'AdditionalRTROIIdentificationCodeSequence',\n      '300600C0': 'FrameOfReferenceRelationshipSequence',\n      '300600C2': 'RelatedFrameOfReferenceUID',\n      '300600C4': 'FrameOfReferenceTransformationType',\n      '300600C6': 'FrameOfReferenceTransformationMatrix',\n      '300600C8': 'FrameOfReferenceTransformationComment',\n      '30080010': 'MeasuredDoseReferenceSequence',\n      '30080012': 'MeasuredDoseDescription',\n      '30080014': 'MeasuredDoseType',\n      '30080016': 'MeasuredDoseValue',\n      '30080020': 'TreatmentSessionBeamSequence',\n      '30080021': 'TreatmentSessionIonBeamSequence',\n      '30080022': 'CurrentFractionNumber',\n      '30080024': 'TreatmentControlPointDate',\n      '30080025': 'TreatmentControlPointTime',\n      '3008002A': 'TreatmentTerminationStatus',\n      '3008002B': 'TreatmentTerminationCode',\n      '3008002C': 'TreatmentVerificationStatus',\n      '30080030': 'ReferencedTreatmentRecordSequence',\n      '30080032': 'SpecifiedPrimaryMeterset',\n      '30080033': 'SpecifiedSecondaryMeterset',\n      '30080036': 'DeliveredPrimaryMeterset',\n      '30080037': 'DeliveredSecondaryMeterset',\n      '3008003A': 'SpecifiedTreatmentTime',\n      '3008003B': 'DeliveredTreatmentTime',\n      '30080040': 'ControlPointDeliverySequence',\n      '30080041': 'IonControlPointDeliverySequence',\n      '30080042': 'SpecifiedMeterset',\n      '30080044': 'DeliveredMeterset',\n      '30080045': 'MetersetRateSet',\n      '30080046': 'MetersetRateDelivered',\n      '30080047': 'ScanSpotMetersetsDelivered',\n      '30080048': 'DoseRateDelivered',\n      '30080050': 'TreatmentSummaryCalculatedDoseReferenceSequence',\n      '30080052': 'CumulativeDoseToDoseReference',\n      '30080054': 'FirstTreatmentDate',\n      '30080056': 'MostRecentTreatmentDate',\n      '3008005A': 'NumberOfFractionsDelivered',\n      '30080060': 'OverrideSequence',\n      '30080061': 'ParameterSequencePointer',\n      '30080062': 'OverrideParameterPointer',\n      '30080063': 'ParameterItemIndex',\n      '30080064': 'MeasuredDoseReferenceNumber',\n      '30080065': 'ParameterPointer',\n      '30080066': 'OverrideReason',\n      '30080067': 'ParameterValueNumber',\n      '30080068': 'CorrectedParameterSequence',\n      '3008006A': 'CorrectionValue',\n      '30080070': 'CalculatedDoseReferenceSequence',\n      '30080072': 'CalculatedDoseReferenceNumber',\n      '30080074': 'CalculatedDoseReferenceDescription',\n      '30080076': 'CalculatedDoseReferenceDoseValue',\n      '30080078': 'StartMeterset',\n      '3008007A': 'EndMeterset',\n      '30080080': 'ReferencedMeasuredDoseReferenceSequence',\n      '30080082': 'ReferencedMeasuredDoseReferenceNumber',\n      '30080090': 'ReferencedCalculatedDoseReferenceSequence',\n      '30080092': 'ReferencedCalculatedDoseReferenceNumber',\n      '300800A0': 'BeamLimitingDeviceLeafPairsSequence',\n      '300800B0': 'RecordedWedgeSequence',\n      '300800C0': 'RecordedCompensatorSequence',\n      '300800D0': 'RecordedBlockSequence',\n      '300800E0': 'TreatmentSummaryMeasuredDoseReferenceSequence',\n      '300800F0': 'RecordedSnoutSequence',\n      '300800F2': 'RecordedRangeShifterSequence',\n      '300800F4': 'RecordedLateralSpreadingDeviceSequence',\n      '300800F6': 'RecordedRangeModulatorSequence',\n      '30080100': 'RecordedSourceSequence',\n      '30080105': 'SourceSerialNumber',\n      '30080110': 'TreatmentSessionApplicationSetupSequence',\n      '30080116': 'ApplicationSetupCheck',\n      '30080120': 'RecordedBrachyAccessoryDeviceSequence',\n      '30080122': 'ReferencedBrachyAccessoryDeviceNumber',\n      '30080130': 'RecordedChannelSequence',\n      '30080132': 'SpecifiedChannelTotalTime',\n      '30080134': 'DeliveredChannelTotalTime',\n      '30080136': 'SpecifiedNumberOfPulses',\n      '30080138': 'DeliveredNumberOfPulses',\n      '3008013A': 'SpecifiedPulseRepetitionInterval',\n      '3008013C': 'DeliveredPulseRepetitionInterval',\n      '30080140': 'RecordedSourceApplicatorSequence',\n      '30080142': 'ReferencedSourceApplicatorNumber',\n      '30080150': 'RecordedChannelShieldSequence',\n      '30080152': 'ReferencedChannelShieldNumber',\n      '30080160': 'BrachyControlPointDeliveredSequence',\n      '30080162': 'SafePositionExitDate',\n      '30080164': 'SafePositionExitTime',\n      '30080166': 'SafePositionReturnDate',\n      '30080168': 'SafePositionReturnTime',\n      '30080171': 'PulseSpecificBrachyControlPointDeliveredSequence',\n      '30080172': 'PulseNumber',\n      '30080173': 'BrachyPulseControlPointDeliveredSequence',\n      '30080200': 'CurrentTreatmentStatus',\n      '30080202': 'TreatmentStatusComment',\n      '30080220': 'FractionGroupSummarySequence',\n      '30080223': 'ReferencedFractionNumber',\n      '30080224': 'FractionGroupType',\n      '30080230': 'BeamStopperPosition',\n      '30080240': 'FractionStatusSummarySequence',\n      '30080250': 'TreatmentDate',\n      '30080251': 'TreatmentTime',\n      '300A0002': 'RTPlanLabel',\n      '300A0003': 'RTPlanName',\n      '300A0004': 'RTPlanDescription',\n      '300A0006': 'RTPlanDate',\n      '300A0007': 'RTPlanTime',\n      '300A0009': 'TreatmentProtocols',\n      '300A000A': 'PlanIntent',\n      '300A000B': 'TreatmentSites',\n      '300A000C': 'RTPlanGeometry',\n      '300A000E': 'PrescriptionDescription',\n      '300A0010': 'DoseReferenceSequence',\n      '300A0012': 'DoseReferenceNumber',\n      '300A0013': 'DoseReferenceUID',\n      '300A0014': 'DoseReferenceStructureType',\n      '300A0015': 'NominalBeamEnergyUnit',\n      '300A0016': 'DoseReferenceDescription',\n      '300A0018': 'DoseReferencePointCoordinates',\n      '300A001A': 'NominalPriorDose',\n      '300A0020': 'DoseReferenceType',\n      '300A0021': 'ConstraintWeight',\n      '300A0022': 'DeliveryWarningDose',\n      '300A0023': 'DeliveryMaximumDose',\n      '300A0025': 'TargetMinimumDose',\n      '300A0026': 'TargetPrescriptionDose',\n      '300A0027': 'TargetMaximumDose',\n      '300A0028': 'TargetUnderdoseVolumeFraction',\n      '300A002A': 'OrganAtRiskFullVolumeDose',\n      '300A002B': 'OrganAtRiskLimitDose',\n      '300A002C': 'OrganAtRiskMaximumDose',\n      '300A002D': 'OrganAtRiskOverdoseVolumeFraction',\n      '300A0040': 'ToleranceTableSequence',\n      '300A0042': 'ToleranceTableNumber',\n      '300A0043': 'ToleranceTableLabel',\n      '300A0044': 'GantryAngleTolerance',\n      '300A0046': 'BeamLimitingDeviceAngleTolerance',\n      '300A0048': 'BeamLimitingDeviceToleranceSequence',\n      '300A004A': 'BeamLimitingDevicePositionTolerance',\n      '300A004B': 'SnoutPositionTolerance',\n      '300A004C': 'PatientSupportAngleTolerance',\n      '300A004E': 'TableTopEccentricAngleTolerance',\n      '300A004F': 'TableTopPitchAngleTolerance',\n      '300A0050': 'TableTopRollAngleTolerance',\n      '300A0051': 'TableTopVerticalPositionTolerance',\n      '300A0052': 'TableTopLongitudinalPositionTolerance',\n      '300A0053': 'TableTopLateralPositionTolerance',\n      '300A0055': 'RTPlanRelationship',\n      '300A0070': 'FractionGroupSequence',\n      '300A0071': 'FractionGroupNumber',\n      '300A0072': 'FractionGroupDescription',\n      '300A0078': 'NumberOfFractionsPlanned',\n      '300A0079': 'NumberOfFractionPatternDigitsPerDay',\n      '300A007A': 'RepeatFractionCycleLength',\n      '300A007B': 'FractionPattern',\n      '300A0080': 'NumberOfBeams',\n      '300A0082': 'BeamDoseSpecificationPoint',\n      '300A0083': 'ReferencedDoseReferenceUID',\n      '300A0084': 'BeamDose',\n      '300A0086': 'BeamMeterset',\n      '300A0088': 'BeamDosePointDepth',\n      '300A0089': 'BeamDosePointEquivalentDepth',\n      '300A008A': 'BeamDosePointSSD',\n      '300A008B': 'BeamDoseMeaning',\n      '300A008C': 'BeamDoseVerificationControlPointSequence',\n      '300A008D': 'AverageBeamDosePointDepth',\n      '300A008E': 'AverageBeamDosePointEquivalentDepth',\n      '300A008F': 'AverageBeamDosePointSSD',\n      '300A0090': 'BeamDoseType',\n      '300A0091': 'AlternateBeamDose',\n      '300A0092': 'AlternateBeamDoseType',\n      '300A0093': 'DepthValueAveragingFlag',\n      '300A0094': 'BeamDosePointSourceToExternalContourDistance',\n      '300A00A0': 'NumberOfBrachyApplicationSetups',\n      '300A00A2': 'BrachyApplicationSetupDoseSpecificationPoint',\n      '300A00A4': 'BrachyApplicationSetupDose',\n      '300A00B0': 'BeamSequence',\n      '300A00B2': 'TreatmentMachineName',\n      '300A00B3': 'PrimaryDosimeterUnit',\n      '300A00B4': 'SourceAxisDistance',\n      '300A00B6': 'BeamLimitingDeviceSequence',\n      '300A00B8': 'RTBeamLimitingDeviceType',\n      '300A00BA': 'SourceToBeamLimitingDeviceDistance',\n      '300A00BB': 'IsocenterToBeamLimitingDeviceDistance',\n      '300A00BC': 'NumberOfLeafJawPairs',\n      '300A00BE': 'LeafPositionBoundaries',\n      '300A00C0': 'BeamNumber',\n      '300A00C2': 'BeamName',\n      '300A00C3': 'BeamDescription',\n      '300A00C4': 'BeamType',\n      '300A00C5': 'BeamDeliveryDurationLimit',\n      '300A00C6': 'RadiationType',\n      '300A00C7': 'HighDoseTechniqueType',\n      '300A00C8': 'ReferenceImageNumber',\n      '300A00CA': 'PlannedVerificationImageSequence',\n      '300A00CC': 'ImagingDeviceSpecificAcquisitionParameters',\n      '300A00CE': 'TreatmentDeliveryType',\n      '300A00D0': 'NumberOfWedges',\n      '300A00D1': 'WedgeSequence',\n      '300A00D2': 'WedgeNumber',\n      '300A00D3': 'WedgeType',\n      '300A00D4': 'WedgeID',\n      '300A00D5': 'WedgeAngle',\n      '300A00D6': 'WedgeFactor',\n      '300A00D7': 'TotalWedgeTrayWaterEquivalentThickness',\n      '300A00D8': 'WedgeOrientation',\n      '300A00D9': 'IsocenterToWedgeTrayDistance',\n      '300A00DA': 'SourceToWedgeTrayDistance',\n      '300A00DB': 'WedgeThinEdgePosition',\n      '300A00DC': 'BolusID',\n      '300A00DD': 'BolusDescription',\n      '300A00DE': 'EffectiveWedgeAngle',\n      '300A00E0': 'NumberOfCompensators',\n      '300A00E1': 'MaterialID',\n      '300A00E2': 'TotalCompensatorTrayFactor',\n      '300A00E3': 'CompensatorSequence',\n      '300A00E4': 'CompensatorNumber',\n      '300A00E5': 'CompensatorID',\n      '300A00E6': 'SourceToCompensatorTrayDistance',\n      '300A00E7': 'CompensatorRows',\n      '300A00E8': 'CompensatorColumns',\n      '300A00E9': 'CompensatorPixelSpacing',\n      '300A00EA': 'CompensatorPosition',\n      '300A00EB': 'CompensatorTransmissionData',\n      '300A00EC': 'CompensatorThicknessData',\n      '300A00ED': 'NumberOfBoli',\n      '300A00EE': 'CompensatorType',\n      '300A00EF': 'CompensatorTrayID',\n      '300A00F0': 'NumberOfBlocks',\n      '300A00F2': 'TotalBlockTrayFactor',\n      '300A00F3': 'TotalBlockTrayWaterEquivalentThickness',\n      '300A00F4': 'BlockSequence',\n      '300A00F5': 'BlockTrayID',\n      '300A00F6': 'SourceToBlockTrayDistance',\n      '300A00F7': 'IsocenterToBlockTrayDistance',\n      '300A00F8': 'BlockType',\n      '300A00F9': 'AccessoryCode',\n      '300A00FA': 'BlockDivergence',\n      '300A00FB': 'BlockMountingPosition',\n      '300A00FC': 'BlockNumber',\n      '300A00FE': 'BlockName',\n      '300A0100': 'BlockThickness',\n      '300A0102': 'BlockTransmission',\n      '300A0104': 'BlockNumberOfPoints',\n      '300A0106': 'BlockData',\n      '300A0107': 'ApplicatorSequence',\n      '300A0108': 'ApplicatorID',\n      '300A0109': 'ApplicatorType',\n      '300A010A': 'ApplicatorDescription',\n      '300A010C': 'CumulativeDoseReferenceCoefficient',\n      '300A010E': 'FinalCumulativeMetersetWeight',\n      '300A0110': 'NumberOfControlPoints',\n      '300A0111': 'ControlPointSequence',\n      '300A0112': 'ControlPointIndex',\n      '300A0114': 'NominalBeamEnergy',\n      '300A0115': 'DoseRateSet',\n      '300A0116': 'WedgePositionSequence',\n      '300A0118': 'WedgePosition',\n      '300A011A': 'BeamLimitingDevicePositionSequence',\n      '300A011C': 'LeafJawPositions',\n      '300A011E': 'GantryAngle',\n      '300A011F': 'GantryRotationDirection',\n      '300A0120': 'BeamLimitingDeviceAngle',\n      '300A0121': 'BeamLimitingDeviceRotationDirection',\n      '300A0122': 'PatientSupportAngle',\n      '300A0123': 'PatientSupportRotationDirection',\n      '300A0124': 'TableTopEccentricAxisDistance',\n      '300A0125': 'TableTopEccentricAngle',\n      '300A0126': 'TableTopEccentricRotationDirection',\n      '300A0128': 'TableTopVerticalPosition',\n      '300A0129': 'TableTopLongitudinalPosition',\n      '300A012A': 'TableTopLateralPosition',\n      '300A012C': 'IsocenterPosition',\n      '300A012E': 'SurfaceEntryPoint',\n      '300A0130': 'SourceToSurfaceDistance',\n      '300A0131': 'AverageBeamDosePointSourceToExternalContourDistance',\n      '300A0132': 'SourceToExternalContourDistance',\n      '300A0133': 'ExternalContourEntryPoint',\n      '300A0134': 'CumulativeMetersetWeight',\n      '300A0140': 'TableTopPitchAngle',\n      '300A0142': 'TableTopPitchRotationDirection',\n      '300A0144': 'TableTopRollAngle',\n      '300A0146': 'TableTopRollRotationDirection',\n      '300A0148': 'HeadFixationAngle',\n      '300A014A': 'GantryPitchAngle',\n      '300A014C': 'GantryPitchRotationDirection',\n      '300A014E': 'GantryPitchAngleTolerance',\n      '300A0150': 'FixationEye',\n      '300A0151': 'ChairHeadFramePosition',\n      '300A0152': 'HeadFixationAngleTolerance',\n      '300A0153': 'ChairHeadFramePositionTolerance',\n      '300A0154': 'FixationLightAzimuthalAngleTolerance',\n      '300A0155': 'FixationLightPolarAngleTolerance',\n      '300A0180': 'PatientSetupSequence',\n      '300A0182': 'PatientSetupNumber',\n      '300A0183': 'PatientSetupLabel',\n      '300A0184': 'PatientAdditionalPosition',\n      '300A0190': 'FixationDeviceSequence',\n      '300A0192': 'FixationDeviceType',\n      '300A0194': 'FixationDeviceLabel',\n      '300A0196': 'FixationDeviceDescription',\n      '300A0198': 'FixationDevicePosition',\n      '300A0199': 'FixationDevicePitchAngle',\n      '300A019A': 'FixationDeviceRollAngle',\n      '300A01A0': 'ShieldingDeviceSequence',\n      '300A01A2': 'ShieldingDeviceType',\n      '300A01A4': 'ShieldingDeviceLabel',\n      '300A01A6': 'ShieldingDeviceDescription',\n      '300A01A8': 'ShieldingDevicePosition',\n      '300A01B0': 'SetupTechnique',\n      '300A01B2': 'SetupTechniqueDescription',\n      '300A01B4': 'SetupDeviceSequence',\n      '300A01B6': 'SetupDeviceType',\n      '300A01B8': 'SetupDeviceLabel',\n      '300A01BA': 'SetupDeviceDescription',\n      '300A01BC': 'SetupDeviceParameter',\n      '300A01D0': 'SetupReferenceDescription',\n      '300A01D2': 'TableTopVerticalSetupDisplacement',\n      '300A01D4': 'TableTopLongitudinalSetupDisplacement',\n      '300A01D6': 'TableTopLateralSetupDisplacement',\n      '300A0200': 'BrachyTreatmentTechnique',\n      '300A0202': 'BrachyTreatmentType',\n      '300A0206': 'TreatmentMachineSequence',\n      '300A0210': 'SourceSequence',\n      '300A0212': 'SourceNumber',\n      '300A0214': 'SourceType',\n      '300A0216': 'SourceManufacturer',\n      '300A0218': 'ActiveSourceDiameter',\n      '300A021A': 'ActiveSourceLength',\n      '300A021B': 'SourceModelID',\n      '300A021C': 'SourceDescription',\n      '300A0222': 'SourceEncapsulationNominalThickness',\n      '300A0224': 'SourceEncapsulationNominalTransmission',\n      '300A0226': 'SourceIsotopeName',\n      '300A0228': 'SourceIsotopeHalfLife',\n      '300A0229': 'SourceStrengthUnits',\n      '300A022A': 'ReferenceAirKermaRate',\n      '300A022B': 'SourceStrength',\n      '300A022C': 'SourceStrengthReferenceDate',\n      '300A022E': 'SourceStrengthReferenceTime',\n      '300A0230': 'ApplicationSetupSequence',\n      '300A0232': 'ApplicationSetupType',\n      '300A0234': 'ApplicationSetupNumber',\n      '300A0236': 'ApplicationSetupName',\n      '300A0238': 'ApplicationSetupManufacturer',\n      '300A0240': 'TemplateNumber',\n      '300A0242': 'TemplateType',\n      '300A0244': 'TemplateName',\n      '300A0250': 'TotalReferenceAirKerma',\n      '300A0260': 'BrachyAccessoryDeviceSequence',\n      '300A0262': 'BrachyAccessoryDeviceNumber',\n      '300A0263': 'BrachyAccessoryDeviceID',\n      '300A0264': 'BrachyAccessoryDeviceType',\n      '300A0266': 'BrachyAccessoryDeviceName',\n      '300A026A': 'BrachyAccessoryDeviceNominalThickness',\n      '300A026C': 'BrachyAccessoryDeviceNominalTransmission',\n      '300A0271': 'ChannelEffectiveLength',\n      '300A0272': 'ChannelInnerLength',\n      '300A0273': 'AfterloaderChannelID',\n      '300A0274': 'SourceApplicatorTipLength',\n      '300A0280': 'ChannelSequence',\n      '300A0282': 'ChannelNumber',\n      '300A0284': 'ChannelLength',\n      '300A0286': 'ChannelTotalTime',\n      '300A0288': 'SourceMovementType',\n      '300A028A': 'NumberOfPulses',\n      '300A028C': 'PulseRepetitionInterval',\n      '300A0290': 'SourceApplicatorNumber',\n      '300A0291': 'SourceApplicatorID',\n      '300A0292': 'SourceApplicatorType',\n      '300A0294': 'SourceApplicatorName',\n      '300A0296': 'SourceApplicatorLength',\n      '300A0298': 'SourceApplicatorManufacturer',\n      '300A029C': 'SourceApplicatorWallNominalThickness',\n      '300A029E': 'SourceApplicatorWallNominalTransmission',\n      '300A02A0': 'SourceApplicatorStepSize',\n      '300A02A2': 'TransferTubeNumber',\n      '300A02A4': 'TransferTubeLength',\n      '300A02B0': 'ChannelShieldSequence',\n      '300A02B2': 'ChannelShieldNumber',\n      '300A02B3': 'ChannelShieldID',\n      '300A02B4': 'ChannelShieldName',\n      '300A02B8': 'ChannelShieldNominalThickness',\n      '300A02BA': 'ChannelShieldNominalTransmission',\n      '300A02C8': 'FinalCumulativeTimeWeight',\n      '300A02D0': 'BrachyControlPointSequence',\n      '300A02D2': 'ControlPointRelativePosition',\n      '300A02D4': 'ControlPoint3DPosition',\n      '300A02D6': 'CumulativeTimeWeight',\n      '300A02E0': 'CompensatorDivergence',\n      '300A02E1': 'CompensatorMountingPosition',\n      '300A02E2': 'SourceToCompensatorDistance',\n      '300A02E3': 'TotalCompensatorTrayWaterEquivalentThickness',\n      '300A02E4': 'IsocenterToCompensatorTrayDistance',\n      '300A02E5': 'CompensatorColumnOffset',\n      '300A02E6': 'IsocenterToCompensatorDistances',\n      '300A02E7': 'CompensatorRelativeStoppingPowerRatio',\n      '300A02E8': 'CompensatorMillingToolDiameter',\n      '300A02EA': 'IonRangeCompensatorSequence',\n      '300A02EB': 'CompensatorDescription',\n      '300A0302': 'RadiationMassNumber',\n      '300A0304': 'RadiationAtomicNumber',\n      '300A0306': 'RadiationChargeState',\n      '300A0308': 'ScanMode',\n      '300A0309': 'ModulatedScanModeType',\n      '300A030A': 'VirtualSourceAxisDistances',\n      '300A030C': 'SnoutSequence',\n      '300A030D': 'SnoutPosition',\n      '300A030F': 'SnoutID',\n      '300A0312': 'NumberOfRangeShifters',\n      '300A0314': 'RangeShifterSequence',\n      '300A0316': 'RangeShifterNumber',\n      '300A0318': 'RangeShifterID',\n      '300A0320': 'RangeShifterType',\n      '300A0322': 'RangeShifterDescription',\n      '300A0330': 'NumberOfLateralSpreadingDevices',\n      '300A0332': 'LateralSpreadingDeviceSequence',\n      '300A0334': 'LateralSpreadingDeviceNumber',\n      '300A0336': 'LateralSpreadingDeviceID',\n      '300A0338': 'LateralSpreadingDeviceType',\n      '300A033A': 'LateralSpreadingDeviceDescription',\n      '300A033C': 'LateralSpreadingDeviceWaterEquivalentThickness',\n      '300A0340': 'NumberOfRangeModulators',\n      '300A0342': 'RangeModulatorSequence',\n      '300A0344': 'RangeModulatorNumber',\n      '300A0346': 'RangeModulatorID',\n      '300A0348': 'RangeModulatorType',\n      '300A034A': 'RangeModulatorDescription',\n      '300A034C': 'BeamCurrentModulationID',\n      '300A0350': 'PatientSupportType',\n      '300A0352': 'PatientSupportID',\n      '300A0354': 'PatientSupportAccessoryCode',\n      '300A0355': 'TrayAccessoryCode',\n      '300A0356': 'FixationLightAzimuthalAngle',\n      '300A0358': 'FixationLightPolarAngle',\n      '300A035A': 'MetersetRate',\n      '300A0360': 'RangeShifterSettingsSequence',\n      '300A0362': 'RangeShifterSetting',\n      '300A0364': 'IsocenterToRangeShifterDistance',\n      '300A0366': 'RangeShifterWaterEquivalentThickness',\n      '300A0370': 'LateralSpreadingDeviceSettingsSequence',\n      '300A0372': 'LateralSpreadingDeviceSetting',\n      '300A0374': 'IsocenterToLateralSpreadingDeviceDistance',\n      '300A0380': 'RangeModulatorSettingsSequence',\n      '300A0382': 'RangeModulatorGatingStartValue',\n      '300A0384': 'RangeModulatorGatingStopValue',\n      '300A0386': 'RangeModulatorGatingStartWaterEquivalentThickness',\n      '300A0388': 'RangeModulatorGatingStopWaterEquivalentThickness',\n      '300A038A': 'IsocenterToRangeModulatorDistance',\n      '300A038F': 'ScanSpotTimeOffset',\n      '300A0390': 'ScanSpotTuneID',\n      '300A0391': 'ScanSpotPrescribedIndices',\n      '300A0392': 'NumberOfScanSpotPositions',\n      '300A0393': 'ScanSpotReordered',\n      '300A0394': 'ScanSpotPositionMap',\n      '300A0395': 'ScanSpotReorderingAllowed',\n      '300A0396': 'ScanSpotMetersetWeights',\n      '300A0398': 'ScanningSpotSize',\n      '300A039A': 'NumberOfPaintings',\n      '300A03A0': 'IonToleranceTableSequence',\n      '300A03A2': 'IonBeamSequence',\n      '300A03A4': 'IonBeamLimitingDeviceSequence',\n      '300A03A6': 'IonBlockSequence',\n      '300A03A8': 'IonControlPointSequence',\n      '300A03AA': 'IonWedgeSequence',\n      '300A03AC': 'IonWedgePositionSequence',\n      '300A0401': 'ReferencedSetupImageSequence',\n      '300A0402': 'SetupImageComment',\n      '300A0410': 'MotionSynchronizationSequence',\n      '300A0412': 'ControlPointOrientation',\n      '300A0420': 'GeneralAccessorySequence',\n      '300A0421': 'GeneralAccessoryID',\n      '300A0422': 'GeneralAccessoryDescription',\n      '300A0423': 'GeneralAccessoryType',\n      '300A0424': 'GeneralAccessoryNumber',\n      '300A0425': 'SourceToGeneralAccessoryDistance',\n      '300A0431': 'ApplicatorGeometrySequence',\n      '300A0432': 'ApplicatorApertureShape',\n      '300A0433': 'ApplicatorOpening',\n      '300A0434': 'ApplicatorOpeningX',\n      '300A0435': 'ApplicatorOpeningY',\n      '300A0436': 'SourceToApplicatorMountingPositionDistance',\n      '300A0440': 'NumberOfBlockSlabItems',\n      '300A0441': 'BlockSlabSequence',\n      '300A0442': 'BlockSlabThickness',\n      '300A0443': 'BlockSlabNumber',\n      '300A0450': 'DeviceMotionControlSequence',\n      '300A0451': 'DeviceMotionExecutionMode',\n      '300A0452': 'DeviceMotionObservationMode',\n      '300A0453': 'DeviceMotionParameterCodeSequence',\n      '300A0501': 'DistalDepthFraction',\n      '300A0502': 'DistalDepth',\n      '300A0503': 'NominalRangeModulationFractions',\n      '300A0504': 'NominalRangeModulatedRegionDepths',\n      '300A0505': 'DepthDoseParametersSequence',\n      '300A0506': 'DeliveredDepthDoseParametersSequence',\n      '300A0507': 'DeliveredDistalDepthFraction',\n      '300A0508': 'DeliveredDistalDepth',\n      '300A0509': 'DeliveredNominalRangeModulationFractions',\n      '300A0510': 'DeliveredNominalRangeModulatedRegionDepths',\n      '300A0511': 'DeliveredReferenceDoseDefinition',\n      '300A0512': 'ReferenceDoseDefinition',\n      '300C0002': 'ReferencedRTPlanSequence',\n      '300C0004': 'ReferencedBeamSequence',\n      '300C0006': 'ReferencedBeamNumber',\n      '300C0007': 'ReferencedReferenceImageNumber',\n      '300C0008': 'StartCumulativeMetersetWeight',\n      '300C0009': 'EndCumulativeMetersetWeight',\n      '300C000A': 'ReferencedBrachyApplicationSetupSequence',\n      '300C000C': 'ReferencedBrachyApplicationSetupNumber',\n      '300C000E': 'ReferencedSourceNumber',\n      '300C0020': 'ReferencedFractionGroupSequence',\n      '300C0022': 'ReferencedFractionGroupNumber',\n      '300C0040': 'ReferencedVerificationImageSequence',\n      '300C0042': 'ReferencedReferenceImageSequence',\n      '300C0050': 'ReferencedDoseReferenceSequence',\n      '300C0051': 'ReferencedDoseReferenceNumber',\n      '300C0055': 'BrachyReferencedDoseReferenceSequence',\n      '300C0060': 'ReferencedStructureSetSequence',\n      '300C006A': 'ReferencedPatientSetupNumber',\n      '300C0080': 'ReferencedDoseSequence',\n      '300C00A0': 'ReferencedToleranceTableNumber',\n      '300C00B0': 'ReferencedBolusSequence',\n      '300C00C0': 'ReferencedWedgeNumber',\n      '300C00D0': 'ReferencedCompensatorNumber',\n      '300C00E0': 'ReferencedBlockNumber',\n      '300C00F0': 'ReferencedControlPointIndex',\n      '300C00F2': 'ReferencedControlPointSequence',\n      '300C00F4': 'ReferencedStartControlPointIndex',\n      '300C00F6': 'ReferencedStopControlPointIndex',\n      '300C0100': 'ReferencedRangeShifterNumber',\n      '300C0102': 'ReferencedLateralSpreadingDeviceNumber',\n      '300C0104': 'ReferencedRangeModulatorNumber',\n      '300C0111': 'OmittedBeamTaskSequence',\n      '300C0112': 'ReasonForOmission',\n      '300C0113': 'ReasonForOmissionDescription',\n      '300E0002': 'ApprovalStatus',\n      '300E0004': 'ReviewDate',\n      '300E0005': 'ReviewTime',\n      '300E0008': 'ReviewerName',\n      '40000010': 'Arbitrary',\n      '40004000': 'TextComments',\n      '40080040': 'ResultsID',\n      '40080042': 'ResultsIDIssuer',\n      '40080050': 'ReferencedInterpretationSequence',\n      '400800FF': 'ReportProductionStatusTrial',\n      '40080100': 'InterpretationRecordedDate',\n      '40080101': 'InterpretationRecordedTime',\n      '40080102': 'InterpretationRecorder',\n      '40080103': 'ReferenceToRecordedSound',\n      '40080108': 'InterpretationTranscriptionDate',\n      '40080109': 'InterpretationTranscriptionTime',\n      '4008010A': 'InterpretationTranscriber',\n      '4008010B': 'InterpretationText',\n      '4008010C': 'InterpretationAuthor',\n      '40080111': 'InterpretationApproverSequence',\n      '40080112': 'InterpretationApprovalDate',\n      '40080113': 'InterpretationApprovalTime',\n      '40080114': 'PhysicianApprovingInterpretation',\n      '40080115': 'InterpretationDiagnosisDescription',\n      '40080117': 'InterpretationDiagnosisCodeSequence',\n      '40080118': 'ResultsDistributionListSequence',\n      '40080119': 'DistributionName',\n      '4008011A': 'DistributionAddress',\n      '40080200': 'InterpretationID',\n      '40080202': 'InterpretationIDIssuer',\n      '40080210': 'InterpretationTypeID',\n      '40080212': 'InterpretationStatusID',\n      '40080300': 'Impressions',\n      '40084000': 'ResultsComments',\n      '40100001': 'LowEnergyDetectors',\n      '40100002': 'HighEnergyDetectors',\n      '40100004': 'DetectorGeometrySequence',\n      '40101001': 'ThreatROIVoxelSequence',\n      '40101004': 'ThreatROIBase',\n      '40101005': 'ThreatROIExtents',\n      '40101006': 'ThreatROIBitmap',\n      '40101007': 'RouteSegmentID',\n      '40101008': 'GantryType',\n      '40101009': 'OOIOwnerType',\n      '4010100A': 'RouteSegmentSequence',\n      '40101010': 'PotentialThreatObjectID',\n      '40101011': 'ThreatSequence',\n      '40101012': 'ThreatCategory',\n      '40101013': 'ThreatCategoryDescription',\n      '40101014': 'ATDAbilityAssessment',\n      '40101015': 'ATDAssessmentFlag',\n      '40101016': 'ATDAssessmentProbability',\n      '40101017': 'Mass',\n      '40101018': 'Density',\n      '40101019': 'ZEffective',\n      '4010101A': 'BoardingPassID',\n      '4010101B': 'CenterOfMass',\n      '4010101C': 'CenterOfPTO',\n      '4010101D': 'BoundingPolygon',\n      '4010101E': 'RouteSegmentStartLocationID',\n      '4010101F': 'RouteSegmentEndLocationID',\n      '40101020': 'RouteSegmentLocationIDType',\n      '40101021': 'AbortReason',\n      '40101023': 'VolumeOfPTO',\n      '40101024': 'AbortFlag',\n      '40101025': 'RouteSegmentStartTime',\n      '40101026': 'RouteSegmentEndTime',\n      '40101027': 'TDRType',\n      '40101028': 'InternationalRouteSegment',\n      '40101029': 'ThreatDetectionAlgorithmandVersion',\n      '4010102A': 'AssignedLocation',\n      '4010102B': 'AlarmDecisionTime',\n      '40101031': 'AlarmDecision',\n      '40101033': 'NumberOfTotalObjects',\n      '40101034': 'NumberOfAlarmObjects',\n      '40101037': 'PTORepresentationSequence',\n      '40101038': 'ATDAssessmentSequence',\n      '40101039': 'TIPType',\n      '4010103A': 'DICOSVersion',\n      '40101041': 'OOIOwnerCreationTime',\n      '40101042': 'OOIType',\n      '40101043': 'OOISize',\n      '40101044': 'AcquisitionStatus',\n      '40101045': 'BasisMaterialsCodeSequence',\n      '40101046': 'PhantomType',\n      '40101047': 'OOIOwnerSequence',\n      '40101048': 'ScanType',\n      '40101051': 'ItineraryID',\n      '40101052': 'ItineraryIDType',\n      '40101053': 'ItineraryIDAssigningAuthority',\n      '40101054': 'RouteID',\n      '40101055': 'RouteIDAssigningAuthority',\n      '40101056': 'InboundArrivalType',\n      '40101058': 'CarrierID',\n      '40101059': 'CarrierIDAssigningAuthority',\n      '40101060': 'SourceOrientation',\n      '40101061': 'SourcePosition',\n      '40101062': 'BeltHeight',\n      '40101064': 'AlgorithmRoutingCodeSequence',\n      '40101067': 'TransportClassification',\n      '40101068': 'OOITypeDescriptor',\n      '40101069': 'TotalProcessingTime',\n      '4010106C': 'DetectorCalibrationData',\n      '4010106D': 'AdditionalScreeningPerformed',\n      '4010106E': 'AdditionalInspectionSelectionCriteria',\n      '4010106F': 'AdditionalInspectionMethodSequence',\n      '40101070': 'AITDeviceType',\n      '40101071': 'QRMeasurementsSequence',\n      '40101072': 'TargetMaterialSequence',\n      '40101073': 'SNRThreshold',\n      '40101075': 'ImageScaleRepresentation',\n      '40101076': 'ReferencedPTOSequence',\n      '40101077': 'ReferencedTDRInstanceSequence',\n      '40101078': 'PTOLocationDescription',\n      '40101079': 'AnomalyLocatorIndicatorSequence',\n      '4010107A': 'AnomalyLocatorIndicator',\n      '4010107B': 'PTORegionSequence',\n      '4010107C': 'InspectionSelectionCriteria',\n      '4010107D': 'SecondaryInspectionMethodSequence',\n      '4010107E': 'PRCSToRCSOrientation',\n      '4FFE0001': 'MACParametersSequence',\n      '52009229': 'SharedFunctionalGroupsSequence',\n      '52009230': 'PerFrameFunctionalGroupsSequence',\n      '54000100': 'WaveformSequence',\n      '54000110': 'ChannelMinimumValue',\n      '54000112': 'ChannelMaximumValue',\n      '54001004': 'WaveformBitsAllocated',\n      '54001006': 'WaveformSampleInterpretation',\n      '5400100A': 'WaveformPaddingValue',\n      '54001010': 'WaveformData',\n      '56000010': 'FirstOrderPhaseCorrectionAngle',\n      '56000020': 'SpectroscopyData',\n      '7FE00008': 'FloatPixelData',\n      '7FE00009': 'DoubleFloatPixelData',\n      '7FE00010': 'PixelData',\n      '7FE00020': 'CoefficientsSDVN',\n      '7FE00030': 'CoefficientsSDHN',\n      '7FE00040': 'CoefficientsSDDN',\n      'FFFAFFFA': 'DigitalSignaturesSequence',\n      'FFFCFFFC': 'DataSetTrailingPadding',\n      'FFFEE000': 'Item',\n      'FFFEE00D': 'ItemDelimitationItem',\n      'FFFEE0DD': 'SequenceDelimitationItem'\n    };\n    Object.freeze(tagToKeyword);\n    var keywordToTag = (_keywordToTag = {\n      'CommandGroupLength': '00000000',\n      'CommandLengthToEnd': '00000001',\n      'AffectedSOPClassUID': '00000002',\n      'RequestedSOPClassUID': '00000003',\n      'CommandRecognitionCode': '00000010',\n      'CommandField': '00000100',\n      'MessageID': '00000110',\n      'MessageIDBeingRespondedTo': '00000120',\n      'Initiator': '00000200',\n      'Receiver': '00000300',\n      'FindLocation': '00000400',\n      'MoveDestination': '00000600',\n      'Priority': '00000700',\n      'CommandDataSetType': '00000800',\n      'NumberOfMatches': '00000850',\n      'ResponseSequenceNumber': '00000860',\n      'Status': '00000900',\n      'OffendingElement': '00000901',\n      'ErrorComment': '00000902',\n      'ErrorID': '00000903',\n      'AffectedSOPInstanceUID': '00001000',\n      'RequestedSOPInstanceUID': '00001001',\n      'EventTypeID': '00001002',\n      'AttributeIdentifierList': '00001005',\n      'ActionTypeID': '00001008',\n      'NumberOfRemainingSuboperations': '00001020',\n      'NumberOfCompletedSuboperations': '00001021',\n      'NumberOfFailedSuboperations': '00001022',\n      'NumberOfWarningSuboperations': '00001023',\n      'MoveOriginatorApplicationEntityTitle': '00001030',\n      'MoveOriginatorMessageID': '00001031',\n      'DialogReceiver': '00004000',\n      'TerminalType': '00004010',\n      'MessageSetID': '00005010',\n      'EndMessageID': '00005020',\n      'DisplayFormat': '00005110',\n      'PagePositionID': '00005120',\n      'TextFormatID': '00005130',\n      'NormalReverse': '00005140',\n      'AddGrayScale': '00005150',\n      'Borders': '00005160',\n      'Copies': '00005170',\n      'CommandMagnificationType': '00005180',\n      'Erase': '00005190',\n      'Print': '000051A0',\n      'Overlays': '000051B0',\n      'FileMetaInformationGroupLength': '00020000',\n      'FileMetaInformationVersion': '00020001',\n      'MediaStorageSOPClassUID': '00020002',\n      'MediaStorageSOPInstanceUID': '00020003',\n      'TransferSyntaxUID': '00020010',\n      'ImplementationClassUID': '00020012',\n      'ImplementationVersionName': '00020013',\n      'SourceApplicationEntityTitle': '00020016',\n      'SendingApplicationEntityTitle': '00020017',\n      'ReceivingApplicationEntityTitle': '00020018',\n      'PrivateInformationCreatorUID': '00020100',\n      'PrivateInformation': '00020102',\n      'FileSetID': '00041130',\n      'FileSetDescriptorFileID': '00041141',\n      'SpecificCharacterSetOfFileSetDescriptorFile': '00041142',\n      'OffsetOfTheFirstDirectoryRecordOfTheRootDirectoryEntity': '00041200',\n      'OffsetOfTheLastDirectoryRecordOfTheRootDirectoryEntity': '00041202',\n      'FileSetConsistencyFlag': '00041212',\n      'DirectoryRecordSequence': '00041220',\n      'OffsetOfTheNextDirectoryRecord': '00041400',\n      'RecordInUseFlag': '00041410',\n      'OffsetOfReferencedLowerLevelDirectoryEntity': '00041420',\n      'DirectoryRecordType': '00041430',\n      'PrivateRecordUID': '00041432',\n      'ReferencedFileID': '00041500',\n      'MRDRDirectoryRecordOffset': '00041504',\n      'ReferencedSOPClassUIDInFile': '00041510',\n      'ReferencedSOPInstanceUIDInFile': '00041511',\n      'ReferencedTransferSyntaxUIDInFile': '00041512',\n      'ReferencedRelatedGeneralSOPClassUIDInFile': '0004151A',\n      'NumberOfReferences': '00041600',\n      'LengthToEnd': '00080001',\n      'SpecificCharacterSet': '00080005',\n      'LanguageCodeSequence': '00080006',\n      'ImageType': '00080008',\n      'RecognitionCode': '00080010',\n      'InstanceCreationDate': '00080012',\n      'InstanceCreationTime': '00080013',\n      'InstanceCreatorUID': '00080014',\n      'InstanceCoercionDateTime': '00080015',\n      'SOPClassUID': '00080016',\n      'SOPInstanceUID': '00080018',\n      'RelatedGeneralSOPClassUID': '0008001A',\n      'OriginalSpecializedSOPClassUID': '0008001B',\n      'StudyDate': '00080020',\n      'SeriesDate': '00080021',\n      'AcquisitionDate': '00080022',\n      'ContentDate': '00080023',\n      'OverlayDate': '00080024',\n      'CurveDate': '00080025',\n      'AcquisitionDateTime': '0008002A',\n      'StudyTime': '00080030',\n      'SeriesTime': '00080031',\n      'AcquisitionTime': '00080032',\n      'ContentTime': '00080033',\n      'OverlayTime': '00080034',\n      'CurveTime': '00080035',\n      'DataSetType': '00080040',\n      'DataSetSubtype': '00080041',\n      'NuclearMedicineSeriesType': '00080042',\n      'AccessionNumber': '00080050',\n      'IssuerOfAccessionNumberSequence': '00080051',\n      'QueryRetrieveLevel': '00080052',\n      'QueryRetrieveView': '00080053',\n      'RetrieveAETitle': '00080054',\n      'StationAETitle': '00080055',\n      'InstanceAvailability': '00080056',\n      'FailedSOPInstanceUIDList': '00080058',\n      'Modality': '00080060',\n      'ModalitiesInStudy': '00080061',\n      'SOPClassesInStudy': '00080062',\n      'AnatomicRegionsInStudyCodeSequence': '00080063',\n      'ConversionType': '00080064',\n      'PresentationIntentType': '00080068',\n      'Manufacturer': '00080070',\n      'InstitutionName': '00080080',\n      'InstitutionAddress': '00080081',\n      'InstitutionCodeSequence': '00080082',\n      'ReferringPhysicianName': '00080090',\n      'ReferringPhysicianAddress': '00080092',\n      'ReferringPhysicianTelephoneNumbers': '00080094',\n      'ReferringPhysicianIdentificationSequence': '00080096',\n      'ConsultingPhysicianName': '0008009C',\n      'ConsultingPhysicianIdentificationSequence': '0008009D',\n      'CodeValue': '00080100',\n      'ExtendedCodeValue': '00080101',\n      'CodingSchemeDesignator': '00080102',\n      'CodingSchemeVersion': '00080103',\n      'CodeMeaning': '00080104',\n      'MappingResource': '00080105',\n      'ContextGroupVersion': '00080106',\n      'ContextGroupLocalVersion': '00080107',\n      'ExtendedCodeMeaning': '00080108',\n      'CodingSchemeResourcesSequence': '00080109',\n      'CodingSchemeURLType': '0008010A',\n      'ContextGroupExtensionFlag': '0008010B',\n      'CodingSchemeUID': '0008010C',\n      'ContextGroupExtensionCreatorUID': '0008010D',\n      'CodingSchemeURL': '0008010E',\n      'ContextIdentifier': '0008010F',\n      'CodingSchemeIdentificationSequence': '00080110',\n      'CodingSchemeRegistry': '00080112',\n      'CodingSchemeExternalID': '00080114',\n      'CodingSchemeName': '00080115',\n      'CodingSchemeResponsibleOrganization': '00080116',\n      'ContextUID': '00080117',\n      'MappingResourceUID': '00080118',\n      'LongCodeValue': '00080119',\n      'URNCodeValue': '00080120',\n      'EquivalentCodeSequence': '00080121',\n      'MappingResourceName': '00080122',\n      'ContextGroupIdentificationSequence': '00080123',\n      'MappingResourceIdentificationSequence': '00080124',\n      'TimezoneOffsetFromUTC': '00080201',\n      'ResponsibleGroupCodeSequence': '00080220',\n      'EquipmentModality': '00080221',\n      'ManufacturerRelatedModelGroup': '00080222',\n      'PrivateDataElementCharacteristicsSequence': '00080300',\n      'PrivateGroupReference': '00080301',\n      'PrivateCreatorReference': '00080302',\n      'BlockIdentifyingInformationStatus': '00080303',\n      'NonidentifyingPrivateElements': '00080304',\n      'DeidentificationActionSequence': '00080305',\n      'IdentifyingPrivateElements': '00080306',\n      'DeidentificationAction': '00080307',\n      'PrivateDataElement': '00080308',\n      'PrivateDataElementValueMultiplicity': '00080309',\n      'PrivateDataElementValueRepresentation': '0008030A',\n      'PrivateDataElementNumberOfItems': '0008030B',\n      'PrivateDataElementName': '0008030C',\n      'PrivateDataElementKeyword': '0008030D',\n      'PrivateDataElementDescription': '0008030E',\n      'PrivateDataElementEncoding': '0008030F',\n      'PrivateDataElementDefinitionSequence': '00080310',\n      'NetworkID': '00081000',\n      'StationName': '00081010',\n      'StudyDescription': '00081030',\n      'ProcedureCodeSequence': '00081032',\n      'SeriesDescription': '0008103E',\n      'SeriesDescriptionCodeSequence': '0008103F',\n      'InstitutionalDepartmentName': '00081040',\n      'PhysiciansOfRecord': '00081048',\n      'PhysiciansOfRecordIdentificationSequence': '00081049',\n      'PerformingPhysicianName': '00081050',\n      'PerformingPhysicianIdentificationSequence': '00081052',\n      'NameOfPhysiciansReadingStudy': '00081060',\n      'PhysiciansReadingStudyIdentificationSequence': '00081062',\n      'OperatorsName': '00081070',\n      'OperatorIdentificationSequence': '00081072',\n      'AdmittingDiagnosesDescription': '00081080',\n      'AdmittingDiagnosesCodeSequence': '00081084',\n      'ManufacturerModelName': '00081090',\n      'ReferencedResultsSequence': '00081100',\n      'ReferencedStudySequence': '00081110',\n      'ReferencedPerformedProcedureStepSequence': '00081111',\n      'ReferencedSeriesSequence': '00081115',\n      'ReferencedPatientSequence': '00081120',\n      'ReferencedVisitSequence': '00081125',\n      'ReferencedOverlaySequence': '00081130',\n      'ReferencedStereometricInstanceSequence': '00081134',\n      'ReferencedWaveformSequence': '0008113A',\n      'ReferencedImageSequence': '00081140',\n      'ReferencedCurveSequence': '00081145',\n      'ReferencedInstanceSequence': '0008114A',\n      'ReferencedRealWorldValueMappingInstanceSequence': '0008114B',\n      'ReferencedSOPClassUID': '00081150',\n      'ReferencedSOPInstanceUID': '00081155',\n      'DefinitionSourceSequence': '00081156',\n      'SOPClassesSupported': '0008115A',\n      'ReferencedFrameNumber': '00081160',\n      'SimpleFrameList': '00081161',\n      'CalculatedFrameList': '00081162',\n      'TimeRange': '00081163',\n      'FrameExtractionSequence': '00081164',\n      'MultiFrameSourceSOPInstanceUID': '00081167',\n      'RetrieveURL': '00081190',\n      'TransactionUID': '00081195',\n      'WarningReason': '00081196',\n      'FailureReason': '00081197',\n      'FailedSOPSequence': '00081198',\n      'ReferencedSOPSequence': '00081199',\n      'OtherFailuresSequence': '0008119A',\n      'StudiesContainingOtherReferencedInstancesSequence': '00081200',\n      'RelatedSeriesSequence': '00081250',\n      'LossyImageCompressionRetired': '00082110',\n      'DerivationDescription': '00082111',\n      'SourceImageSequence': '00082112',\n      'StageName': '00082120',\n      'StageNumber': '00082122',\n      'NumberOfStages': '00082124',\n      'ViewName': '00082127',\n      'ViewNumber': '00082128',\n      'NumberOfEventTimers': '00082129',\n      'NumberOfViewsInStage': '0008212A',\n      'EventElapsedTimes': '00082130',\n      'EventTimerNames': '00082132',\n      'EventTimerSequence': '00082133',\n      'EventTimeOffset': '00082134',\n      'EventCodeSequence': '00082135',\n      'StartTrim': '00082142',\n      'StopTrim': '00082143',\n      'RecommendedDisplayFrameRate': '00082144',\n      'TransducerPosition': '00082200',\n      'TransducerOrientation': '00082204',\n      'AnatomicStructure': '00082208',\n      'AnatomicRegionSequence': '00082218',\n      'AnatomicRegionModifierSequence': '00082220',\n      'PrimaryAnatomicStructureSequence': '00082228',\n      'AnatomicStructureSpaceOrRegionSequence': '00082229',\n      'PrimaryAnatomicStructureModifierSequence': '00082230',\n      'TransducerPositionSequence': '00082240',\n      'TransducerPositionModifierSequence': '00082242',\n      'TransducerOrientationSequence': '00082244',\n      'TransducerOrientationModifierSequence': '00082246',\n      'AnatomicStructureSpaceOrRegionCodeSequenceTrial': '00082251',\n      'AnatomicPortalOfEntranceCodeSequenceTrial': '00082253',\n      'AnatomicApproachDirectionCodeSequenceTrial': '00082255',\n      'AnatomicPerspectiveDescriptionTrial': '00082256',\n      'AnatomicPerspectiveCodeSequenceTrial': '00082257',\n      'AnatomicLocationOfExaminingInstrumentDescriptionTrial': '00082258',\n      'AnatomicLocationOfExaminingInstrumentCodeSequenceTrial': '00082259',\n      'AnatomicStructureSpaceOrRegionModifierCodeSequenceTrial': '0008225A',\n      'OnAxisBackgroundAnatomicStructureCodeSequenceTrial': '0008225C',\n      'AlternateRepresentationSequence': '00083001',\n      'IrradiationEventUID': '00083010',\n      'SourceIrradiationEventSequence': '00083011',\n      'RadiopharmaceuticalAdministrationEventUID': '00083012',\n      'IdentifyingComments': '00084000',\n      'FrameType': '00089007',\n      'ReferencedImageEvidenceSequence': '00089092',\n      'ReferencedRawDataSequence': '00089121',\n      'CreatorVersionUID': '00089123',\n      'DerivationImageSequence': '00089124',\n      'SourceImageEvidenceSequence': '00089154',\n      'PixelPresentation': '00089205',\n      'VolumetricProperties': '00089206',\n      'VolumeBasedCalculationTechnique': '00089207',\n      'ComplexImageComponent': '00089208',\n      'AcquisitionContrast': '00089209',\n      'DerivationCodeSequence': '00089215',\n      'ReferencedPresentationStateSequence': '00089237',\n      'ReferencedOtherPlaneSequence': '00089410',\n      'FrameDisplaySequence': '00089458',\n      'RecommendedDisplayFrameRateInFloat': '00089459',\n      'SkipFrameRangeFlag': '00089460',\n      'PatientName': '00100010',\n      'PatientID': '00100020',\n      'IssuerOfPatientID': '00100021',\n      'TypeOfPatientID': '00100022',\n      'IssuerOfPatientIDQualifiersSequence': '00100024',\n      'SourcePatientGroupIdentificationSequence': '00100026',\n      'GroupOfPatientsIdentificationSequence': '00100027',\n      'SubjectRelativePositionInImage': '00100028',\n      'PatientBirthDate': '00100030',\n      'PatientBirthTime': '00100032',\n      'PatientBirthDateInAlternativeCalendar': '00100033',\n      'PatientDeathDateInAlternativeCalendar': '00100034',\n      'PatientAlternativeCalendar': '00100035',\n      'PatientSex': '00100040',\n      'PatientInsurancePlanCodeSequence': '00100050',\n      'PatientPrimaryLanguageCodeSequence': '00100101',\n      'PatientPrimaryLanguageModifierCodeSequence': '00100102',\n      'QualityControlSubject': '00100200',\n      'QualityControlSubjectTypeCodeSequence': '00100201',\n      'StrainDescription': '00100212',\n      'StrainNomenclature': '00100213',\n      'StrainStockNumber': '00100214',\n      'StrainSourceRegistryCodeSequence': '00100215',\n      'StrainStockSequence': '00100216',\n      'StrainSource': '00100217',\n      'StrainAdditionalInformation': '00100218',\n      'StrainCodeSequence': '00100219',\n      'GeneticModificationsSequence': '00100221',\n      'GeneticModificationsDescription': '00100222',\n      'GeneticModificationsNomenclature': '00100223',\n      'GeneticModificationsCodeSequence': '00100229',\n      'OtherPatientIDs': '00101000',\n      'OtherPatientNames': '00101001',\n      'OtherPatientIDsSequence': '00101002',\n      'PatientBirthName': '00101005',\n      'PatientAge': '00101010',\n      'PatientSize': '00101020',\n      'PatientSizeCodeSequence': '00101021',\n      'PatientBodyMassIndex': '00101022',\n      'MeasuredAPDimension': '00101023',\n      'MeasuredLateralDimension': '00101024',\n      'PatientWeight': '00101030',\n      'PatientAddress': '00101040',\n      'InsurancePlanIdentification': '00101050',\n      'PatientMotherBirthName': '00101060',\n      'MilitaryRank': '00101080',\n      'BranchOfService': '00101081',\n      'MedicalRecordLocator': '00101090',\n      'ReferencedPatientPhotoSequence': '00101100',\n      'MedicalAlerts': '00102000',\n      'Allergies': '00102110',\n      'CountryOfResidence': '00102150',\n      'RegionOfResidence': '00102152',\n      'PatientTelephoneNumbers': '00102154',\n      'PatientTelecomInformation': '00102155',\n      'EthnicGroup': '00102160',\n      'Occupation': '00102180',\n      'SmokingStatus': '001021A0',\n      'AdditionalPatientHistory': '001021B0',\n      'PregnancyStatus': '001021C0',\n      'LastMenstrualDate': '001021D0',\n      'PatientReligiousPreference': '001021F0',\n      'PatientSpeciesDescription': '00102201',\n      'PatientSpeciesCodeSequence': '00102202',\n      'PatientSexNeutered': '00102203',\n      'AnatomicalOrientationType': '00102210',\n      'PatientBreedDescription': '00102292',\n      'PatientBreedCodeSequence': '00102293',\n      'BreedRegistrationSequence': '00102294',\n      'BreedRegistrationNumber': '00102295',\n      'BreedRegistryCodeSequence': '00102296',\n      'ResponsiblePerson': '00102297',\n      'ResponsiblePersonRole': '00102298',\n      'ResponsibleOrganization': '00102299',\n      'PatientComments': '00104000',\n      'ExaminedBodyThickness': '00109431',\n      'ClinicalTrialSponsorName': '00120010',\n      'ClinicalTrialProtocolID': '00120020',\n      'ClinicalTrialProtocolName': '00120021',\n      'ClinicalTrialSiteID': '00120030',\n      'ClinicalTrialSiteName': '00120031',\n      'ClinicalTrialSubjectID': '00120040',\n      'ClinicalTrialSubjectReadingID': '00120042',\n      'ClinicalTrialTimePointID': '00120050',\n      'ClinicalTrialTimePointDescription': '00120051',\n      'LongitudinalTemporalOffsetFromEvent': '00120052',\n      'LongitudinalTemporalEventType': '00120053',\n      'ClinicalTrialCoordinatingCenterName': '00120060',\n      'PatientIdentityRemoved': '00120062',\n      'DeidentificationMethod': '00120063',\n      'DeidentificationMethodCodeSequence': '00120064',\n      'ClinicalTrialSeriesID': '00120071',\n      'ClinicalTrialSeriesDescription': '00120072',\n      'ClinicalTrialProtocolEthicsCommitteeName': '00120081',\n      'ClinicalTrialProtocolEthicsCommitteeApprovalNumber': '00120082',\n      'ConsentForClinicalTrialUseSequence': '00120083',\n      'DistributionType': '00120084',\n      'ConsentForDistributionFlag': '00120085',\n      'EthicsCommitteeApprovalEffectivenessStartDate': '00120086',\n      'EthicsCommitteeApprovalEffectivenessEndDate': '00120087',\n      'CADFileFormat': '00140023',\n      'ComponentReferenceSystem': '00140024',\n      'ComponentManufacturingProcedure': '00140025',\n      'ComponentManufacturer': '00140028',\n      'MaterialThickness': '00140030',\n      'MaterialPipeDiameter': '00140032',\n      'MaterialIsolationDiameter': '00140034',\n      'MaterialGrade': '00140042',\n      'MaterialPropertiesDescription': '00140044',\n      'MaterialPropertiesFileFormatRetired': '00140045',\n      'MaterialNotes': '00140046',\n      'ComponentShape': '00140050',\n      'CurvatureType': '00140052',\n      'OuterDiameter': '00140054',\n      'InnerDiameter': '00140056',\n      'ComponentWelderIDs': '00140100',\n      'SecondaryApprovalStatus': '00140101',\n      'SecondaryReviewDate': '00140102',\n      'SecondaryReviewTime': '00140103',\n      'SecondaryReviewerName': '00140104',\n      'RepairID': '00140105',\n      'MultipleComponentApprovalSequence': '00140106',\n      'OtherApprovalStatus': '00140107',\n      'OtherSecondaryApprovalStatus': '00140108',\n      'ActualEnvironmentalConditions': '00141010',\n      'ExpiryDate': '00141020',\n      'EnvironmentalConditions': '00141040',\n      'EvaluatorSequence': '00142002',\n      'EvaluatorNumber': '00142004',\n      'EvaluatorName': '00142006',\n      'EvaluationAttempt': '00142008',\n      'IndicationSequence': '00142012',\n      'IndicationNumber': '00142014',\n      'IndicationLabel': '00142016',\n      'IndicationDescription': '00142018',\n      'IndicationType': '0014201A',\n      'IndicationDisposition': '0014201C',\n      'IndicationROISequence': '0014201E',\n      'IndicationPhysicalPropertySequence': '00142030',\n      'PropertyLabel': '00142032',\n      'CoordinateSystemNumberOfAxes': '00142202',\n      'CoordinateSystemAxesSequence': '00142204',\n      'CoordinateSystemAxisDescription': '00142206',\n      'CoordinateSystemDataSetMapping': '00142208',\n      'CoordinateSystemAxisNumber': '0014220A',\n      'CoordinateSystemAxisType': '0014220C',\n      'CoordinateSystemAxisUnits': '0014220E',\n      'CoordinateSystemAxisValues': '00142210',\n      'CoordinateSystemTransformSequence': '00142220',\n      'TransformDescription': '00142222',\n      'TransformNumberOfAxes': '00142224',\n      'TransformOrderOfAxes': '00142226',\n      'TransformedAxisUnits': '00142228',\n      'CoordinateSystemTransformRotationAndScaleMatrix': '0014222A',\n      'CoordinateSystemTransformTranslationMatrix': '0014222C',\n      'InternalDetectorFrameTime': '00143011',\n      'NumberOfFramesIntegrated': '00143012',\n      'DetectorTemperatureSequence': '00143020',\n      'SensorName': '00143022',\n      'HorizontalOffsetOfSensor': '00143024',\n      'VerticalOffsetOfSensor': '00143026',\n      'SensorTemperature': '00143028',\n      'DarkCurrentSequence': '00143040',\n      'DarkCurrentCounts': '00143050',\n      'GainCorrectionReferenceSequence': '00143060',\n      'AirCounts': '00143070',\n      'KVUsedInGainCalibration': '00143071',\n      'MAUsedInGainCalibration': '00143072',\n      'NumberOfFramesUsedForIntegration': '00143073',\n      'FilterMaterialUsedInGainCalibration': '00143074',\n      'FilterThicknessUsedInGainCalibration': '00143075',\n      'DateOfGainCalibration': '00143076',\n      'TimeOfGainCalibration': '00143077',\n      'BadPixelImage': '00143080',\n      'CalibrationNotes': '00143099',\n      'PulserEquipmentSequence': '00144002',\n      'PulserType': '00144004',\n      'PulserNotes': '00144006',\n      'ReceiverEquipmentSequence': '00144008',\n      'AmplifierType': '0014400A',\n      'ReceiverNotes': '0014400C',\n      'PreAmplifierEquipmentSequence': '0014400E',\n      'PreAmplifierNotes': '0014400F',\n      'TransmitTransducerSequence': '00144010',\n      'ReceiveTransducerSequence': '00144011',\n      'NumberOfElements': '00144012',\n      'ElementShape': '00144013',\n      'ElementDimensionA': '00144014',\n      'ElementDimensionB': '00144015',\n      'ElementPitchA': '00144016',\n      'MeasuredBeamDimensionA': '00144017',\n      'MeasuredBeamDimensionB': '00144018',\n      'LocationOfMeasuredBeamDiameter': '00144019',\n      'NominalFrequency': '0014401A',\n      'MeasuredCenterFrequency': '0014401B',\n      'MeasuredBandwidth': '0014401C',\n      'ElementPitchB': '0014401D',\n      'PulserSettingsSequence': '00144020',\n      'PulseWidth': '00144022',\n      'ExcitationFrequency': '00144024',\n      'ModulationType': '00144026',\n      'Damping': '00144028',\n      'ReceiverSettingsSequence': '00144030',\n      'AcquiredSoundpathLength': '00144031',\n      'AcquisitionCompressionType': '00144032',\n      'AcquisitionSampleSize': '00144033',\n      'RectifierSmoothing': '00144034',\n      'DACSequence': '00144035',\n      'DACType': '00144036',\n      'DACGainPoints': '00144038',\n      'DACTimePoints': '0014403A',\n      'DACAmplitude': '0014403C',\n      'PreAmplifierSettingsSequence': '00144040',\n      'TransmitTransducerSettingsSequence': '00144050',\n      'ReceiveTransducerSettingsSequence': '00144051',\n      'IncidentAngle': '00144052',\n      'CouplingTechnique': '00144054',\n      'CouplingMedium': '00144056',\n      'CouplingVelocity': '00144057',\n      'ProbeCenterLocationX': '00144058',\n      'ProbeCenterLocationZ': '00144059',\n      'SoundPathLength': '0014405A',\n      'DelayLawIdentifier': '0014405C',\n      'GateSettingsSequence': '00144060',\n      'GateThreshold': '00144062',\n      'VelocityOfSound': '00144064',\n      'CalibrationSettingsSequence': '00144070',\n      'CalibrationProcedure': '00144072',\n      'ProcedureVersion': '00144074',\n      'ProcedureCreationDate': '00144076',\n      'ProcedureExpirationDate': '00144078',\n      'ProcedureLastModifiedDate': '0014407A',\n      'CalibrationTime': '0014407C',\n      'CalibrationDate': '0014407E',\n      'ProbeDriveEquipmentSequence': '00144080',\n      'DriveType': '00144081',\n      'ProbeDriveNotes': '00144082',\n      'DriveProbeSequence': '00144083',\n      'ProbeInductance': '00144084',\n      'ProbeResistance': '00144085',\n      'ReceiveProbeSequence': '00144086',\n      'ProbeDriveSettingsSequence': '00144087',\n      'BridgeResistors': '00144088',\n      'ProbeOrientationAngle': '00144089',\n      'UserSelectedGainY': '0014408B',\n      'UserSelectedPhase': '0014408C',\n      'UserSelectedOffsetX': '0014408D',\n      'UserSelectedOffsetY': '0014408E',\n      'ChannelSettingsSequence': '00144091',\n      'ChannelThreshold': '00144092',\n      'ScannerSettingsSequence': '0014409A',\n      'ScanProcedure': '0014409B',\n      'TranslationRateX': '0014409C',\n      'TranslationRateY': '0014409D',\n      'ChannelOverlap': '0014409F',\n      'ImageQualityIndicatorType': '001440A0',\n      'ImageQualityIndicatorMaterial': '001440A1',\n      'ImageQualityIndicatorSize': '001440A2',\n      'LINACEnergy': '00145002',\n      'LINACOutput': '00145004',\n      'ActiveAperture': '00145100',\n      'TotalAperture': '00145101',\n      'ApertureElevation': '00145102',\n      'MainLobeAngle': '00145103',\n      'MainRoofAngle': '00145104',\n      'ConnectorType': '00145105',\n      'WedgeModelNumber': '00145106',\n      'WedgeAngleFloat': '00145107',\n      'WedgeRoofAngle': '00145108',\n      '00145109': 'WedgeElement1Position',\n      'WedgeMaterialVelocity': '0014510A',\n      'WedgeMaterial': '0014510B',\n      'WedgeOffsetZ': '0014510C',\n      'WedgeOriginOffsetX': '0014510D',\n      'WedgeTimeDelay': '0014510E',\n      'WedgeName': '0014510F',\n      'WedgeManufacturerName': '00145110',\n      'WedgeDescription': '00145111',\n      'NominalBeamAngle': '00145112',\n      'WedgeOffsetX': '00145113',\n      'WedgeOffsetY': '00145114',\n      'WedgeTotalLength': '00145115',\n      'WedgeInContactLength': '00145116',\n      'WedgeFrontGap': '00145117',\n      'WedgeTotalHeight': '00145118',\n      'WedgeFrontHeight': '00145119',\n      'WedgeRearHeight': '0014511A',\n      'WedgeTotalWidth': '0014511B',\n      'WedgeInContactWidth': '0014511C',\n      'WedgeChamferHeight': '0014511D',\n      'WedgeCurve': '0014511E',\n      'RadiusAlongWedge': '0014511F',\n      'ContrastBolusAgent': '00180010',\n      'ContrastBolusAgentSequence': '00180012',\n      '00180013': 'ContrastBolusT1Relaxivity',\n      'ContrastBolusAdministrationRouteSequence': '00180014',\n      'BodyPartExamined': '00180015',\n      'ScanningSequence': '00180020',\n      'SequenceVariant': '00180021',\n      'ScanOptions': '00180022',\n      'MRAcquisitionType': '00180023',\n      'SequenceName': '00180024',\n      'AngioFlag': '00180025',\n      'InterventionDrugInformationSequence': '00180026',\n      'InterventionDrugStopTime': '00180027',\n      'InterventionDrugDose': '00180028',\n      'InterventionDrugCodeSequence': '00180029',\n      'AdditionalDrugSequence': '0018002A',\n      'Radionuclide': '00180030',\n      'Radiopharmaceutical': '00180031',\n      'EnergyWindowCenterline': '00180032',\n      'EnergyWindowTotalWidth': '00180033',\n      'InterventionDrugName': '00180034',\n      'InterventionDrugStartTime': '00180035',\n      'InterventionSequence': '00180036',\n      'TherapyType': '00180037',\n      'InterventionStatus': '00180038',\n      'TherapyDescription': '00180039',\n      'InterventionDescription': '0018003A',\n      'CineRate': '00180040',\n      'InitialCineRunState': '00180042',\n      'SliceThickness': '00180050',\n      'KVP': '00180060',\n      '': '00180061',\n      'CountsAccumulated': '00180070',\n      'AcquisitionTerminationCondition': '00180071',\n      'EffectiveDuration': '00180072',\n      'AcquisitionStartCondition': '00180073',\n      'AcquisitionStartConditionData': '00180074',\n      'AcquisitionTerminationConditionData': '00180075',\n      'RepetitionTime': '00180080',\n      'EchoTime': '00180081',\n      'InversionTime': '00180082',\n      'NumberOfAverages': '00180083',\n      'ImagingFrequency': '00180084',\n      'ImagedNucleus': '00180085',\n      'EchoNumbers': '00180086',\n      'MagneticFieldStrength': '00180087',\n      'SpacingBetweenSlices': '00180088',\n      'NumberOfPhaseEncodingSteps': '00180089',\n      'DataCollectionDiameter': '00180090',\n      'EchoTrainLength': '00180091',\n      'PercentSampling': '00180093',\n      'PercentPhaseFieldOfView': '00180094',\n      'PixelBandwidth': '00180095',\n      'DeviceSerialNumber': '00181000',\n      'DeviceUID': '00181002',\n      'DeviceID': '00181003',\n      'PlateID': '00181004',\n      'GeneratorID': '00181005',\n      'GridID': '00181006',\n      'CassetteID': '00181007',\n      'GantryID': '00181008',\n      'UniqueDeviceIdentifier': '00181009',\n      'UDISequence': '0018100A',\n      'SecondaryCaptureDeviceID': '00181010',\n      'HardcopyCreationDeviceID': '00181011',\n      'DateOfSecondaryCapture': '00181012',\n      'TimeOfSecondaryCapture': '00181014',\n      'SecondaryCaptureDeviceManufacturer': '00181016',\n      'HardcopyDeviceManufacturer': '00181017',\n      'SecondaryCaptureDeviceManufacturerModelName': '00181018',\n      'SecondaryCaptureDeviceSoftwareVersions': '00181019',\n      'HardcopyDeviceSoftwareVersion': '0018101A',\n      'HardcopyDeviceManufacturerModelName': '0018101B',\n      'SoftwareVersions': '00181020',\n      'VideoImageFormatAcquired': '00181022',\n      'DigitalImageFormatAcquired': '00181023',\n      'ProtocolName': '00181030',\n      'ContrastBolusRoute': '00181040',\n      'ContrastBolusVolume': '00181041',\n      'ContrastBolusStartTime': '00181042',\n      'ContrastBolusStopTime': '00181043',\n      'ContrastBolusTotalDose': '00181044',\n      'SyringeCounts': '00181045',\n      'ContrastFlowRate': '00181046',\n      'ContrastFlowDuration': '00181047',\n      'ContrastBolusIngredient': '00181048',\n      'ContrastBolusIngredientConcentration': '00181049',\n      'SpatialResolution': '00181050',\n      'TriggerTime': '00181060',\n      'TriggerSourceOrType': '00181061',\n      'NominalInterval': '00181062',\n      'FrameTime': '00181063',\n      'CardiacFramingType': '00181064',\n      'FrameTimeVector': '00181065',\n      'FrameDelay': '00181066',\n      'ImageTriggerDelay': '00181067',\n      'MultiplexGroupTimeOffset': '00181068',\n      'TriggerTimeOffset': '00181069',\n      'SynchronizationTrigger': '0018106A',\n      'SynchronizationChannel': '0018106C',\n      'TriggerSamplePosition': '0018106E',\n      'RadiopharmaceuticalRoute': '00181070',\n      'RadiopharmaceuticalVolume': '00181071',\n      'RadiopharmaceuticalStartTime': '00181072',\n      'RadiopharmaceuticalStopTime': '00181073',\n      'RadionuclideTotalDose': '00181074',\n      'RadionuclideHalfLife': '00181075',\n      'RadionuclidePositronFraction': '00181076',\n      'RadiopharmaceuticalSpecificActivity': '00181077',\n      'RadiopharmaceuticalStartDateTime': '00181078',\n      'RadiopharmaceuticalStopDateTime': '00181079',\n      'BeatRejectionFlag': '00181080',\n      'LowRRValue': '00181081',\n      'HighRRValue': '00181082',\n      'IntervalsAcquired': '00181083',\n      'IntervalsRejected': '00181084',\n      'PVCRejection': '00181085',\n      'SkipBeats': '00181086',\n      'HeartRate': '00181088',\n      'CardiacNumberOfImages': '00181090',\n      'TriggerWindow': '00181094',\n      'ReconstructionDiameter': '00181100',\n      'DistanceSourceToDetector': '00181110',\n      'DistanceSourceToPatient': '00181111',\n      'EstimatedRadiographicMagnificationFactor': '00181114',\n      'GantryDetectorTilt': '00181120',\n      'GantryDetectorSlew': '00181121',\n      'TableHeight': '00181130',\n      'TableTraverse': '00181131',\n      'TableMotion': '00181134',\n      'TableVerticalIncrement': '00181135',\n      'TableLateralIncrement': '00181136',\n      'TableLongitudinalIncrement': '00181137',\n      'TableAngle': '00181138',\n      'TableType': '0018113A',\n      'RotationDirection': '00181140',\n      'AngularPosition': '00181141',\n      'RadialPosition': '00181142',\n      'ScanArc': '00181143',\n      'AngularStep': '00181144',\n      'CenterOfRotationOffset': '00181145',\n      'RotationOffset': '00181146',\n      'FieldOfViewShape': '00181147',\n      'FieldOfViewDimensions': '00181149',\n      'ExposureTime': '00181150',\n      'XRayTubeCurrent': '00181151',\n      'Exposure': '00181152',\n      'ExposureInuAs': '00181153',\n      'AveragePulseWidth': '00181154',\n      'RadiationSetting': '00181155',\n      'RectificationType': '00181156',\n      'RadiationMode': '0018115A',\n      'ImageAndFluoroscopyAreaDoseProduct': '0018115E',\n      'FilterType': '00181160',\n      'TypeOfFilters': '00181161',\n      'IntensifierSize': '00181162',\n      'ImagerPixelSpacing': '00181164',\n      'Grid': '00181166',\n      'GeneratorPower': '00181170',\n      'CollimatorGridName': '00181180',\n      'CollimatorType': '00181181',\n      'FocalDistance': '00181182',\n      'XFocusCenter': '00181183',\n      'YFocusCenter': '00181184',\n      'FocalSpots': '00181190',\n      'AnodeTargetMaterial': '00181191',\n      'BodyPartThickness': '001811A0',\n      'CompressionForce': '001811A2',\n      'CompressionPressure': '001811A3',\n      'PaddleDescription': '001811A4',\n      'CompressionContactArea': '001811A5',\n      'DateOfLastCalibration': '00181200',\n      'TimeOfLastCalibration': '00181201',\n      'DateTimeOfLastCalibration': '00181202',\n      'ConvolutionKernel': '00181210',\n      'UpperLowerPixelValues': '00181240',\n      'ActualFrameDuration': '00181242',\n      'CountRate': '00181243',\n      'PreferredPlaybackSequencing': '00181244',\n      'ReceiveCoilName': '00181250',\n      'TransmitCoilName': '00181251',\n      'PlateType': '00181260',\n      'PhosphorType': '00181261',\n      'WaterEquivalentDiameter': '00181271',\n      'WaterEquivalentDiameterCalculationMethodCodeSequence': '00181272',\n      'ScanVelocity': '00181300',\n      'WholeBodyTechnique': '00181301',\n      'ScanLength': '00181302',\n      'AcquisitionMatrix': '00181310',\n      'InPlanePhaseEncodingDirection': '00181312',\n      'FlipAngle': '00181314',\n      'VariableFlipAngleFlag': '00181315',\n      'SAR': '00181316',\n      'dBdt': '00181318',\n      '00181320': 'B1rms',\n      'AcquisitionDeviceProcessingDescription': '00181400',\n      'AcquisitionDeviceProcessingCode': '00181401',\n      'CassetteOrientation': '00181402',\n      'CassetteSize': '00181403',\n      'ExposuresOnPlate': '00181404',\n      'RelativeXRayExposure': '00181405',\n      'ExposureIndex': '00181411',\n      'TargetExposureIndex': '00181412',\n      'DeviationIndex': '00181413',\n      'ColumnAngulation': '00181450',\n      'TomoLayerHeight': '00181460',\n      'TomoAngle': '00181470',\n      'TomoTime': '00181480',\n      'TomoType': '00181490',\n      'TomoClass': '00181491',\n      'NumberOfTomosynthesisSourceImages': '00181495',\n      'PositionerMotion': '00181500',\n      'PositionerType': '00181508',\n      'PositionerPrimaryAngle': '00181510',\n      'PositionerSecondaryAngle': '00181511',\n      'PositionerPrimaryAngleIncrement': '00181520',\n      'PositionerSecondaryAngleIncrement': '00181521',\n      'DetectorPrimaryAngle': '00181530',\n      'DetectorSecondaryAngle': '00181531',\n      'ShutterShape': '00181600',\n      'ShutterLeftVerticalEdge': '00181602',\n      'ShutterRightVerticalEdge': '00181604',\n      'ShutterUpperHorizontalEdge': '00181606',\n      'ShutterLowerHorizontalEdge': '00181608',\n      'CenterOfCircularShutter': '00181610',\n      'RadiusOfCircularShutter': '00181612',\n      'VerticesOfThePolygonalShutter': '00181620',\n      'ShutterPresentationValue': '00181622',\n      'ShutterOverlayGroup': '00181623',\n      'ShutterPresentationColorCIELabValue': '00181624',\n      'CollimatorShape': '00181700',\n      'CollimatorLeftVerticalEdge': '00181702',\n      'CollimatorRightVerticalEdge': '00181704',\n      'CollimatorUpperHorizontalEdge': '00181706',\n      'CollimatorLowerHorizontalEdge': '00181708',\n      'CenterOfCircularCollimator': '00181710',\n      'RadiusOfCircularCollimator': '00181712',\n      'VerticesOfThePolygonalCollimator': '00181720',\n      'AcquisitionTimeSynchronized': '00181800',\n      'TimeSource': '00181801',\n      'TimeDistributionProtocol': '00181802',\n      'NTPSourceAddress': '00181803',\n      'PageNumberVector': '00182001',\n      'FrameLabelVector': '00182002',\n      'FramePrimaryAngleVector': '00182003',\n      'FrameSecondaryAngleVector': '00182004',\n      'SliceLocationVector': '00182005',\n      'DisplayWindowLabelVector': '00182006',\n      'NominalScannedPixelSpacing': '00182010',\n      'DigitizingDeviceTransportDirection': '00182020',\n      'RotationOfScannedFilm': '00182030',\n      'BiopsyTargetSequence': '00182041',\n      'TargetUID': '00182042',\n      'LocalizingCursorPosition': '00182043',\n      'CalculatedTargetPosition': '00182044',\n      'TargetLabel': '00182045',\n      'DisplayedZValue': '00182046',\n      'IVUSAcquisition': '00183100',\n      'IVUSPullbackRate': '00183101',\n      'IVUSGatedRate': '00183102',\n      'IVUSPullbackStartFrameNumber': '00183103',\n      'IVUSPullbackStopFrameNumber': '00183104',\n      'LesionNumber': '00183105',\n      'AcquisitionComments': '00184000',\n      'OutputPower': '00185000',\n      'TransducerData': '00185010',\n      'FocusDepth': '00185012',\n      'ProcessingFunction': '00185020',\n      'PostprocessingFunction': '00185021',\n      'MechanicalIndex': '00185022',\n      'BoneThermalIndex': '00185024',\n      'CranialThermalIndex': '00185026',\n      'SoftTissueThermalIndex': '00185027',\n      'SoftTissueFocusThermalIndex': '00185028',\n      'SoftTissueSurfaceThermalIndex': '00185029',\n      'DynamicRange': '00185030',\n      'TotalGain': '00185040',\n      'DepthOfScanField': '00185050',\n      'PatientPosition': '00185100',\n      'ViewPosition': '00185101',\n      'ProjectionEponymousNameCodeSequence': '00185104',\n      'ImageTransformationMatrix': '00185210',\n      'ImageTranslationVector': '00185212',\n      'Sensitivity': '00186000',\n      'SequenceOfUltrasoundRegions': '00186011',\n      'RegionSpatialFormat': '00186012',\n      'RegionDataType': '00186014',\n      'RegionFlags': '00186016',\n      '00186018': 'RegionLocationMinX0',\n      '0018601A': 'RegionLocationMinY0',\n      '0018601C': 'RegionLocationMaxX1',\n      '0018601E': 'RegionLocationMaxY1',\n      '00186020': 'ReferencePixelX0',\n      '00186022': 'ReferencePixelY0',\n      'PhysicalUnitsXDirection': '00186024',\n      'PhysicalUnitsYDirection': '00186026',\n      'ReferencePixelPhysicalValueX': '00186028',\n      'ReferencePixelPhysicalValueY': '0018602A',\n      'PhysicalDeltaX': '0018602C',\n      'PhysicalDeltaY': '0018602E',\n      'TransducerFrequency': '00186030',\n      'TransducerType': '00186031',\n      'PulseRepetitionFrequency': '00186032',\n      'DopplerCorrectionAngle': '00186034',\n      'SteeringAngle': '00186036',\n      'DopplerSampleVolumeXPositionRetired': '00186038',\n      'DopplerSampleVolumeXPosition': '00186039',\n      'DopplerSampleVolumeYPositionRetired': '0018603A',\n      'DopplerSampleVolumeYPosition': '0018603B',\n      '0018603C': 'TMLinePositionX0Retired',\n      '0018603D': 'TMLinePositionX0',\n      '0018603E': 'TMLinePositionY0Retired',\n      '0018603F': 'TMLinePositionY0',\n      '00186040': 'TMLinePositionX1Retired',\n      '00186041': 'TMLinePositionX1',\n      '00186042': 'TMLinePositionY1Retired',\n      '00186043': 'TMLinePositionY1',\n      'PixelComponentOrganization': '00186044',\n      'PixelComponentMask': '00186046',\n      'PixelComponentRangeStart': '00186048',\n      'PixelComponentRangeStop': '0018604A',\n      'PixelComponentPhysicalUnits': '0018604C',\n      'PixelComponentDataType': '0018604E',\n      'NumberOfTableBreakPoints': '00186050',\n      'TableOfXBreakPoints': '00186052',\n      'TableOfYBreakPoints': '00186054',\n      'NumberOfTableEntries': '00186056',\n      'TableOfPixelValues': '00186058',\n      'TableOfParameterValues': '0018605A',\n      'RWaveTimeVector': '00186060',\n      'DetectorConditionsNominalFlag': '00187000',\n      'DetectorTemperature': '00187001',\n      'DetectorType': '00187004',\n      'DetectorConfiguration': '00187005',\n      'DetectorDescription': '00187006',\n      'DetectorMode': '00187008',\n      'DetectorID': '0018700A',\n      'DateOfLastDetectorCalibration': '0018700C',\n      'TimeOfLastDetectorCalibration': '0018700E',\n      'ExposuresOnDetectorSinceLastCalibration': '00187010',\n      'ExposuresOnDetectorSinceManufactured': '00187011',\n      'DetectorTimeSinceLastExposure': '00187012',\n      'DetectorActiveTime': '00187014',\n      'DetectorActivationOffsetFromExposure': '00187016',\n      'DetectorBinning': '0018701A',\n      'DetectorElementPhysicalSize': '00187020',\n      'DetectorElementSpacing': '00187022',\n      'DetectorActiveShape': '00187024',\n      'DetectorActiveDimensions': '00187026',\n      'DetectorActiveOrigin': '00187028',\n      'DetectorManufacturerName': '0018702A',\n      'DetectorManufacturerModelName': '0018702B',\n      'FieldOfViewOrigin': '00187030',\n      'FieldOfViewRotation': '00187032',\n      'FieldOfViewHorizontalFlip': '00187034',\n      'PixelDataAreaOriginRelativeToFOV': '00187036',\n      'PixelDataAreaRotationAngleRelativeToFOV': '00187038',\n      'GridAbsorbingMaterial': '00187040',\n      'GridSpacingMaterial': '00187041',\n      'GridThickness': '00187042',\n      'GridPitch': '00187044',\n      'GridAspectRatio': '00187046',\n      'GridPeriod': '00187048',\n      'GridFocalDistance': '0018704C',\n      'FilterMaterial': '00187050',\n      'FilterThicknessMinimum': '00187052',\n      'FilterThicknessMaximum': '00187054',\n      'FilterBeamPathLengthMinimum': '00187056',\n      'FilterBeamPathLengthMaximum': '00187058',\n      'ExposureControlMode': '00187060',\n      'ExposureControlModeDescription': '00187062',\n      'ExposureStatus': '00187064',\n      'PhototimerSetting': '00187065',\n      'ExposureTimeInuS': '00188150',\n      'XRayTubeCurrentInuA': '00188151',\n      'ContentQualification': '00189004',\n      'PulseSequenceName': '00189005',\n      'MRImagingModifierSequence': '00189006',\n      'EchoPulseSequence': '00189008',\n      'InversionRecovery': '00189009',\n      'FlowCompensation': '00189010',\n      'MultipleSpinEcho': '00189011',\n      'MultiPlanarExcitation': '00189012',\n      'PhaseContrast': '00189014',\n      'TimeOfFlightContrast': '00189015',\n      'Spoiling': '00189016',\n      'SteadyStatePulseSequence': '00189017',\n      'EchoPlanarPulseSequence': '00189018',\n      'TagAngleFirstAxis': '00189019',\n      'MagnetizationTransfer': '00189020',\n      '00189021': 'T2Preparation',\n      'BloodSignalNulling': '00189022',\n      'SaturationRecovery': '00189024',\n      'SpectrallySelectedSuppression': '00189025',\n      'SpectrallySelectedExcitation': '00189026',\n      'SpatialPresaturation': '00189027',\n      'Tagging': '00189028',\n      'OversamplingPhase': '00189029',\n      'TagSpacingFirstDimension': '00189030',\n      'GeometryOfKSpaceTraversal': '00189032',\n      'SegmentedKSpaceTraversal': '00189033',\n      'RectilinearPhaseEncodeReordering': '00189034',\n      'TagThickness': '00189035',\n      'PartialFourierDirection': '00189036',\n      'CardiacSynchronizationTechnique': '00189037',\n      'ReceiveCoilManufacturerName': '00189041',\n      'MRReceiveCoilSequence': '00189042',\n      'ReceiveCoilType': '00189043',\n      'QuadratureReceiveCoil': '00189044',\n      'MultiCoilDefinitionSequence': '00189045',\n      'MultiCoilConfiguration': '00189046',\n      'MultiCoilElementName': '00189047',\n      'MultiCoilElementUsed': '00189048',\n      'MRTransmitCoilSequence': '00189049',\n      'TransmitCoilManufacturerName': '00189050',\n      'TransmitCoilType': '00189051',\n      'SpectralWidth': '00189052',\n      'ChemicalShiftReference': '00189053',\n      'VolumeLocalizationTechnique': '00189054',\n      'MRAcquisitionFrequencyEncodingSteps': '00189058',\n      'Decoupling': '00189059',\n      'DecoupledNucleus': '00189060',\n      'DecouplingFrequency': '00189061',\n      'DecouplingMethod': '00189062',\n      'DecouplingChemicalShiftReference': '00189063',\n      'KSpaceFiltering': '00189064',\n      'TimeDomainFiltering': '00189065',\n      'NumberOfZeroFills': '00189066',\n      'BaselineCorrection': '00189067',\n      'ParallelReductionFactorInPlane': '00189069',\n      'CardiacRRIntervalSpecified': '00189070',\n      'AcquisitionDuration': '00189073',\n      'FrameAcquisitionDateTime': '00189074',\n      'DiffusionDirectionality': '00189075',\n      'DiffusionGradientDirectionSequence': '00189076',\n      'ParallelAcquisition': '00189077',\n      'ParallelAcquisitionTechnique': '00189078',\n      'InversionTimes': '00189079',\n      'MetaboliteMapDescription': '00189080',\n      'PartialFourier': '00189081',\n      'EffectiveEchoTime': '00189082',\n      'MetaboliteMapCodeSequence': '00189083',\n      'ChemicalShiftSequence': '00189084',\n      'CardiacSignalSource': '00189085',\n      'DiffusionBValue': '00189087',\n      'DiffusionGradientOrientation': '00189089',\n      'VelocityEncodingDirection': '00189090',\n      'VelocityEncodingMinimumValue': '00189091',\n      'VelocityEncodingAcquisitionSequence': '00189092',\n      'NumberOfKSpaceTrajectories': '00189093',\n      'CoverageOfKSpace': '00189094',\n      'SpectroscopyAcquisitionPhaseRows': '00189095',\n      'ParallelReductionFactorInPlaneRetired': '00189096',\n      'TransmitterFrequency': '00189098',\n      'ResonantNucleus': '00189100',\n      'FrequencyCorrection': '00189101',\n      'MRSpectroscopyFOVGeometrySequence': '00189103',\n      'SlabThickness': '00189104',\n      'SlabOrientation': '00189105',\n      'MidSlabPosition': '00189106',\n      'MRSpatialSaturationSequence': '00189107',\n      'MRTimingAndRelatedParametersSequence': '00189112',\n      'MREchoSequence': '00189114',\n      'MRModifierSequence': '00189115',\n      'MRDiffusionSequence': '00189117',\n      'CardiacSynchronizationSequence': '00189118',\n      'MRAveragesSequence': '00189119',\n      'MRFOVGeometrySequence': '00189125',\n      'VolumeLocalizationSequence': '00189126',\n      'SpectroscopyAcquisitionDataColumns': '00189127',\n      'DiffusionAnisotropyType': '00189147',\n      'FrameReferenceDateTime': '00189151',\n      'MRMetaboliteMapSequence': '00189152',\n      'ParallelReductionFactorOutOfPlane': '00189155',\n      'SpectroscopyAcquisitionOutOfPlanePhaseSteps': '00189159',\n      'BulkMotionStatus': '00189166',\n      'ParallelReductionFactorSecondInPlane': '00189168',\n      'CardiacBeatRejectionTechnique': '00189169',\n      'RespiratoryMotionCompensationTechnique': '00189170',\n      'RespiratorySignalSource': '00189171',\n      'BulkMotionCompensationTechnique': '00189172',\n      'BulkMotionSignalSource': '00189173',\n      'ApplicableSafetyStandardAgency': '00189174',\n      'ApplicableSafetyStandardDescription': '00189175',\n      'OperatingModeSequence': '00189176',\n      'OperatingModeType': '00189177',\n      'OperatingMode': '00189178',\n      'SpecificAbsorptionRateDefinition': '00189179',\n      'GradientOutputType': '00189180',\n      'SpecificAbsorptionRateValue': '00189181',\n      'GradientOutput': '00189182',\n      'FlowCompensationDirection': '00189183',\n      'TaggingDelay': '00189184',\n      'RespiratoryMotionCompensationTechniqueDescription': '00189185',\n      'RespiratorySignalSourceID': '00189186',\n      'ChemicalShiftMinimumIntegrationLimitInHz': '00189195',\n      'ChemicalShiftMaximumIntegrationLimitInHz': '00189196',\n      'MRVelocityEncodingSequence': '00189197',\n      'FirstOrderPhaseCorrection': '00189198',\n      'WaterReferencedPhaseCorrection': '00189199',\n      'MRSpectroscopyAcquisitionType': '00189200',\n      'RespiratoryCyclePosition': '00189214',\n      'VelocityEncodingMaximumValue': '00189217',\n      'TagSpacingSecondDimension': '00189218',\n      'TagAngleSecondAxis': '00189219',\n      'FrameAcquisitionDuration': '00189220',\n      'MRImageFrameTypeSequence': '00189226',\n      'MRSpectroscopyFrameTypeSequence': '00189227',\n      'MRAcquisitionPhaseEncodingStepsInPlane': '00189231',\n      'MRAcquisitionPhaseEncodingStepsOutOfPlane': '00189232',\n      'SpectroscopyAcquisitionPhaseColumns': '00189234',\n      'CardiacCyclePosition': '00189236',\n      'SpecificAbsorptionRateSequence': '00189239',\n      'RFEchoTrainLength': '00189240',\n      'GradientEchoTrainLength': '00189241',\n      'ArterialSpinLabelingContrast': '00189250',\n      'MRArterialSpinLabelingSequence': '00189251',\n      'ASLTechniqueDescription': '00189252',\n      'ASLSlabNumber': '00189253',\n      'ASLSlabThickness': '00189254',\n      'ASLSlabOrientation': '00189255',\n      'ASLMidSlabPosition': '00189256',\n      'ASLContext': '00189257',\n      'ASLPulseTrainDuration': '00189258',\n      'ASLCrusherFlag': '00189259',\n      'ASLCrusherFlowLimit': '0018925A',\n      'ASLCrusherDescription': '0018925B',\n      'ASLBolusCutoffFlag': '0018925C',\n      'ASLBolusCutoffTimingSequence': '0018925D',\n      'ASLBolusCutoffTechnique': '0018925E',\n      'ASLBolusCutoffDelayTime': '0018925F',\n      'ASLSlabSequence': '00189260',\n      'ChemicalShiftMinimumIntegrationLimitInppm': '00189295',\n      'ChemicalShiftMaximumIntegrationLimitInppm': '00189296',\n      'WaterReferenceAcquisition': '00189297',\n      'EchoPeakPosition': '00189298',\n      'CTAcquisitionTypeSequence': '00189301',\n      'AcquisitionType': '00189302',\n      'TubeAngle': '00189303',\n      'CTAcquisitionDetailsSequence': '00189304',\n      'RevolutionTime': '00189305',\n      'SingleCollimationWidth': '00189306',\n      'TotalCollimationWidth': '00189307',\n      'CTTableDynamicsSequence': '00189308',\n      'TableSpeed': '00189309',\n      'TableFeedPerRotation': '00189310',\n      'SpiralPitchFactor': '00189311',\n      'CTGeometrySequence': '00189312',\n      'DataCollectionCenterPatient': '00189313',\n      'CTReconstructionSequence': '00189314',\n      'ReconstructionAlgorithm': '00189315',\n      'ConvolutionKernelGroup': '00189316',\n      'ReconstructionFieldOfView': '00189317',\n      'ReconstructionTargetCenterPatient': '00189318',\n      'ReconstructionAngle': '00189319',\n      'ImageFilter': '00189320',\n      'CTExposureSequence': '00189321',\n      'ReconstructionPixelSpacing': '00189322',\n      'ExposureModulationType': '00189323',\n      'EstimatedDoseSaving': '00189324',\n      'CTXRayDetailsSequence': '00189325',\n      'CTPositionSequence': '00189326',\n      'TablePosition': '00189327',\n      'ExposureTimeInms': '00189328',\n      'CTImageFrameTypeSequence': '00189329',\n      'XRayTubeCurrentInmA': '00189330',\n      'ExposureInmAs': '00189332',\n      'ConstantVolumeFlag': '00189333',\n      'FluoroscopyFlag': '00189334',\n      'DistanceSourceToDataCollectionCenter': '00189335',\n      'ContrastBolusAgentNumber': '00189337',\n      'ContrastBolusIngredientCodeSequence': '00189338',\n      'ContrastAdministrationProfileSequence': '00189340',\n      'ContrastBolusUsageSequence': '00189341',\n      'ContrastBolusAgentAdministered': '00189342',\n      'ContrastBolusAgentDetected': '00189343',\n      'ContrastBolusAgentPhase': '00189344',\n      'CTDIvol': '00189345',\n      'CTDIPhantomTypeCodeSequence': '00189346',\n      'CalciumScoringMassFactorPatient': '00189351',\n      'CalciumScoringMassFactorDevice': '00189352',\n      'EnergyWeightingFactor': '00189353',\n      'CTAdditionalXRaySourceSequence': '00189360',\n      'ProjectionPixelCalibrationSequence': '00189401',\n      'DistanceSourceToIsocenter': '00189402',\n      'DistanceObjectToTableTop': '00189403',\n      'ObjectPixelSpacingInCenterOfBeam': '00189404',\n      'PositionerPositionSequence': '00189405',\n      'TablePositionSequence': '00189406',\n      'CollimatorShapeSequence': '00189407',\n      'PlanesInAcquisition': '00189410',\n      'XAXRFFrameCharacteristicsSequence': '00189412',\n      'FrameAcquisitionSequence': '00189417',\n      'XRayReceptorType': '00189420',\n      'AcquisitionProtocolName': '00189423',\n      'AcquisitionProtocolDescription': '00189424',\n      'ContrastBolusIngredientOpaque': '00189425',\n      'DistanceReceptorPlaneToDetectorHousing': '00189426',\n      'IntensifierActiveShape': '00189427',\n      'IntensifierActiveDimensions': '00189428',\n      'PhysicalDetectorSize': '00189429',\n      'PositionOfIsocenterProjection': '00189430',\n      'FieldOfViewSequence': '00189432',\n      'FieldOfViewDescription': '00189433',\n      'ExposureControlSensingRegionsSequence': '00189434',\n      'ExposureControlSensingRegionShape': '00189435',\n      'ExposureControlSensingRegionLeftVerticalEdge': '00189436',\n      'ExposureControlSensingRegionRightVerticalEdge': '00189437',\n      'ExposureControlSensingRegionUpperHorizontalEdge': '00189438',\n      'ExposureControlSensingRegionLowerHorizontalEdge': '00189439',\n      'CenterOfCircularExposureControlSensingRegion': '00189440',\n      'RadiusOfCircularExposureControlSensingRegion': '00189441',\n      'VerticesOfThePolygonalExposureControlSensingRegion': '00189442'\n    }, _defineProperty2(_keywordToTag, \"\", '00189445'), _defineProperty2(_keywordToTag, 'ColumnAngulationPatient', '00189447'), _defineProperty2(_keywordToTag, 'BeamAngle', '00189449'), _defineProperty2(_keywordToTag, 'FrameDetectorParametersSequence', '00189451'), _defineProperty2(_keywordToTag, 'CalculatedAnatomyThickness', '00189452'), _defineProperty2(_keywordToTag, 'CalibrationSequence', '00189455'), _defineProperty2(_keywordToTag, 'ObjectThicknessSequence', '00189456'), _defineProperty2(_keywordToTag, 'PlaneIdentification', '00189457'), _defineProperty2(_keywordToTag, 'FieldOfViewDimensionsInFloat', '00189461'), _defineProperty2(_keywordToTag, 'IsocenterReferenceSystemSequence', '00189462'), _defineProperty2(_keywordToTag, 'PositionerIsocenterPrimaryAngle', '00189463'), _defineProperty2(_keywordToTag, 'PositionerIsocenterSecondaryAngle', '00189464'), _defineProperty2(_keywordToTag, 'PositionerIsocenterDetectorRotationAngle', '00189465'), _defineProperty2(_keywordToTag, 'TableXPositionToIsocenter', '00189466'), _defineProperty2(_keywordToTag, 'TableYPositionToIsocenter', '00189467'), _defineProperty2(_keywordToTag, 'TableZPositionToIsocenter', '00189468'), _defineProperty2(_keywordToTag, 'TableHorizontalRotationAngle', '00189469'), _defineProperty2(_keywordToTag, 'TableHeadTiltAngle', '00189470'), _defineProperty2(_keywordToTag, 'TableCradleTiltAngle', '00189471'), _defineProperty2(_keywordToTag, 'FrameDisplayShutterSequence', '00189472'), _defineProperty2(_keywordToTag, 'AcquiredImageAreaDoseProduct', '00189473'), _defineProperty2(_keywordToTag, 'CArmPositionerTabletopRelationship', '00189474'), _defineProperty2(_keywordToTag, 'XRayGeometrySequence', '00189476'), _defineProperty2(_keywordToTag, 'IrradiationEventIdentificationSequence', '00189477'), _defineProperty2(_keywordToTag, '00189504', 'XRay3DFrameTypeSequence'), _defineProperty2(_keywordToTag, 'ContributingSourcesSequence', '00189506'), _defineProperty2(_keywordToTag, '00189507', 'XRay3DAcquisitionSequence'), _defineProperty2(_keywordToTag, 'PrimaryPositionerScanArc', '00189508'), _defineProperty2(_keywordToTag, 'SecondaryPositionerScanArc', '00189509'), _defineProperty2(_keywordToTag, 'PrimaryPositionerScanStartAngle', '00189510'), _defineProperty2(_keywordToTag, 'SecondaryPositionerScanStartAngle', '00189511'), _defineProperty2(_keywordToTag, 'PrimaryPositionerIncrement', '00189514'), _defineProperty2(_keywordToTag, 'SecondaryPositionerIncrement', '00189515'), _defineProperty2(_keywordToTag, 'StartAcquisitionDateTime', '00189516'), _defineProperty2(_keywordToTag, 'EndAcquisitionDateTime', '00189517'), _defineProperty2(_keywordToTag, 'PrimaryPositionerIncrementSign', '00189518'), _defineProperty2(_keywordToTag, 'SecondaryPositionerIncrementSign', '00189519'), _defineProperty2(_keywordToTag, 'ApplicationName', '00189524'), _defineProperty2(_keywordToTag, 'ApplicationVersion', '00189525'), _defineProperty2(_keywordToTag, 'ApplicationManufacturer', '00189526'), _defineProperty2(_keywordToTag, 'AlgorithmType', '00189527'), _defineProperty2(_keywordToTag, 'AlgorithmDescription', '00189528'), _defineProperty2(_keywordToTag, '00189530', 'XRay3DReconstructionSequence'), _defineProperty2(_keywordToTag, 'ReconstructionDescription', '00189531'), _defineProperty2(_keywordToTag, 'PerProjectionAcquisitionSequence', '00189538'), _defineProperty2(_keywordToTag, 'DetectorPositionSequence', '00189541'), _defineProperty2(_keywordToTag, 'XRayAcquisitionDoseSequence', '00189542'), _defineProperty2(_keywordToTag, 'XRaySourceIsocenterPrimaryAngle', '00189543'), _defineProperty2(_keywordToTag, 'XRaySourceIsocenterSecondaryAngle', '00189544'), _defineProperty2(_keywordToTag, 'BreastSupportIsocenterPrimaryAngle', '00189545'), _defineProperty2(_keywordToTag, 'BreastSupportIsocenterSecondaryAngle', '00189546'), _defineProperty2(_keywordToTag, 'BreastSupportXPositionToIsocenter', '00189547'), _defineProperty2(_keywordToTag, 'BreastSupportYPositionToIsocenter', '00189548'), _defineProperty2(_keywordToTag, 'BreastSupportZPositionToIsocenter', '00189549'), _defineProperty2(_keywordToTag, 'DetectorIsocenterPrimaryAngle', '00189550'), _defineProperty2(_keywordToTag, 'DetectorIsocenterSecondaryAngle', '00189551'), _defineProperty2(_keywordToTag, 'DetectorXPositionToIsocenter', '00189552'), _defineProperty2(_keywordToTag, 'DetectorYPositionToIsocenter', '00189553'), _defineProperty2(_keywordToTag, 'DetectorZPositionToIsocenter', '00189554'), _defineProperty2(_keywordToTag, 'XRayGridSequence', '00189555'), _defineProperty2(_keywordToTag, 'XRayFilterSequence', '00189556'), _defineProperty2(_keywordToTag, 'DetectorActiveAreaTLHCPosition', '00189557'), _defineProperty2(_keywordToTag, 'DetectorActiveAreaOrientation', '00189558'), _defineProperty2(_keywordToTag, 'PositionerPrimaryAngleDirection', '00189559'), _defineProperty2(_keywordToTag, 'DiffusionBMatrixSequence', '00189601'), _defineProperty2(_keywordToTag, 'DiffusionBValueXX', '00189602'), _defineProperty2(_keywordToTag, 'DiffusionBValueXY', '00189603'), _defineProperty2(_keywordToTag, 'DiffusionBValueXZ', '00189604'), _defineProperty2(_keywordToTag, 'DiffusionBValueYY', '00189605'), _defineProperty2(_keywordToTag, 'DiffusionBValueYZ', '00189606'), _defineProperty2(_keywordToTag, 'DiffusionBValueZZ', '00189607'), _defineProperty2(_keywordToTag, 'FunctionalMRSequence', '00189621'), _defineProperty2(_keywordToTag, 'FunctionalSettlingPhaseFramesPresent', '00189622'), _defineProperty2(_keywordToTag, 'FunctionalSyncPulse', '00189623'), _defineProperty2(_keywordToTag, 'SettlingPhaseFrame', '00189624'), _defineProperty2(_keywordToTag, 'DecayCorrectionDateTime', '00189701'), _defineProperty2(_keywordToTag, 'StartDensityThreshold', '00189715'), _defineProperty2(_keywordToTag, 'StartRelativeDensityDifferenceThreshold', '00189716'), _defineProperty2(_keywordToTag, 'StartCardiacTriggerCountThreshold', '00189717'), _defineProperty2(_keywordToTag, 'StartRespiratoryTriggerCountThreshold', '00189718'), _defineProperty2(_keywordToTag, 'TerminationCountsThreshold', '00189719'), _defineProperty2(_keywordToTag, 'TerminationDensityThreshold', '00189720'), _defineProperty2(_keywordToTag, 'TerminationRelativeDensityThreshold', '00189721'), _defineProperty2(_keywordToTag, 'TerminationTimeThreshold', '00189722'), _defineProperty2(_keywordToTag, 'TerminationCardiacTriggerCountThreshold', '00189723'), _defineProperty2(_keywordToTag, 'TerminationRespiratoryTriggerCountThreshold', '00189724'), _defineProperty2(_keywordToTag, 'DetectorGeometry', '00189725'), _defineProperty2(_keywordToTag, 'TransverseDetectorSeparation', '00189726'), _defineProperty2(_keywordToTag, 'AxialDetectorDimension', '00189727'), _defineProperty2(_keywordToTag, 'RadiopharmaceuticalAgentNumber', '00189729'), _defineProperty2(_keywordToTag, 'PETFrameAcquisitionSequence', '00189732'), _defineProperty2(_keywordToTag, 'PETDetectorMotionDetailsSequence', '00189733'), _defineProperty2(_keywordToTag, 'PETTableDynamicsSequence', '00189734'), _defineProperty2(_keywordToTag, 'PETPositionSequence', '00189735'), _defineProperty2(_keywordToTag, 'PETFrameCorrectionFactorsSequence', '00189736'), _defineProperty2(_keywordToTag, 'RadiopharmaceuticalUsageSequence', '00189737'), _defineProperty2(_keywordToTag, 'AttenuationCorrectionSource', '00189738'), _defineProperty2(_keywordToTag, 'NumberOfIterations', '00189739'), _defineProperty2(_keywordToTag, 'NumberOfSubsets', '00189740'), _defineProperty2(_keywordToTag, 'PETReconstructionSequence', '00189749'), _defineProperty2(_keywordToTag, 'PETFrameTypeSequence', '00189751'), _defineProperty2(_keywordToTag, 'TimeOfFlightInformationUsed', '00189755'), _defineProperty2(_keywordToTag, 'ReconstructionType', '00189756'), _defineProperty2(_keywordToTag, 'DecayCorrected', '00189758'), _defineProperty2(_keywordToTag, 'AttenuationCorrected', '00189759'), _defineProperty2(_keywordToTag, 'ScatterCorrected', '00189760'), _defineProperty2(_keywordToTag, 'DeadTimeCorrected', '00189761'), _defineProperty2(_keywordToTag, 'GantryMotionCorrected', '00189762'), _defineProperty2(_keywordToTag, 'PatientMotionCorrected', '00189763'), _defineProperty2(_keywordToTag, 'CountLossNormalizationCorrected', '00189764'), _defineProperty2(_keywordToTag, 'RandomsCorrected', '00189765'), _defineProperty2(_keywordToTag, 'NonUniformRadialSamplingCorrected', '00189766'), _defineProperty2(_keywordToTag, 'SensitivityCalibrated', '00189767'), _defineProperty2(_keywordToTag, 'DetectorNormalizationCorrection', '00189768'), _defineProperty2(_keywordToTag, 'IterativeReconstructionMethod', '00189769'), _defineProperty2(_keywordToTag, 'AttenuationCorrectionTemporalRelationship', '00189770'), _defineProperty2(_keywordToTag, 'PatientPhysiologicalStateSequence', '00189771'), _defineProperty2(_keywordToTag, 'PatientPhysiologicalStateCodeSequence', '00189772'), _defineProperty2(_keywordToTag, 'DepthsOfFocus', '00189801'), _defineProperty2(_keywordToTag, 'ExcludedIntervalsSequence', '00189803'), _defineProperty2(_keywordToTag, 'ExclusionStartDateTime', '00189804'), _defineProperty2(_keywordToTag, 'ExclusionDuration', '00189805'), _defineProperty2(_keywordToTag, 'USImageDescriptionSequence', '00189806'), _defineProperty2(_keywordToTag, 'ImageDataTypeSequence', '00189807'), _defineProperty2(_keywordToTag, 'DataType', '00189808'), _defineProperty2(_keywordToTag, 'TransducerScanPatternCodeSequence', '00189809'), _defineProperty2(_keywordToTag, 'AliasedDataType', '0018980B'), _defineProperty2(_keywordToTag, 'PositionMeasuringDeviceUsed', '0018980C'), _defineProperty2(_keywordToTag, 'TransducerGeometryCodeSequence', '0018980D'), _defineProperty2(_keywordToTag, 'TransducerBeamSteeringCodeSequence', '0018980E'), _defineProperty2(_keywordToTag, 'TransducerApplicationCodeSequence', '0018980F'), _defineProperty2(_keywordToTag, 'ZeroVelocityPixelValue', '00189810'), _defineProperty2(_keywordToTag, 'ReferenceLocationLabel', '00189900'), _defineProperty2(_keywordToTag, 'ReferenceLocationDescription', '00189901'), _defineProperty2(_keywordToTag, 'ReferenceBasisCodeSequence', '00189902'), _defineProperty2(_keywordToTag, 'ReferenceGeometryCodeSequence', '00189903'), _defineProperty2(_keywordToTag, 'OffsetDistance', '00189904'), _defineProperty2(_keywordToTag, 'OffsetDirection', '00189905'), _defineProperty2(_keywordToTag, 'PotentialScheduledProtocolCodeSequence', '00189906'), _defineProperty2(_keywordToTag, 'PotentialRequestedProcedureCodeSequence', '00189907'), _defineProperty2(_keywordToTag, 'PotentialReasonsForProcedure', '00189908'), _defineProperty2(_keywordToTag, 'PotentialReasonsForProcedureCodeSequence', '00189909'), _defineProperty2(_keywordToTag, 'PotentialDiagnosticTasks', '0018990A'), _defineProperty2(_keywordToTag, 'ContraindicationsCodeSequence', '0018990B'), _defineProperty2(_keywordToTag, 'ReferencedDefinedProtocolSequence', '0018990C'), _defineProperty2(_keywordToTag, 'ReferencedPerformedProtocolSequence', '0018990D'), _defineProperty2(_keywordToTag, 'PredecessorProtocolSequence', '0018990E'), _defineProperty2(_keywordToTag, 'ProtocolPlanningInformation', '0018990F'), _defineProperty2(_keywordToTag, 'ProtocolDesignRationale', '00189910'), _defineProperty2(_keywordToTag, 'PatientSpecificationSequence', '00189911'), _defineProperty2(_keywordToTag, 'ModelSpecificationSequence', '00189912'), _defineProperty2(_keywordToTag, 'ParametersSpecificationSequence', '00189913'), _defineProperty2(_keywordToTag, 'InstructionSequence', '00189914'), _defineProperty2(_keywordToTag, 'InstructionIndex', '00189915'), _defineProperty2(_keywordToTag, 'InstructionText', '00189916'), _defineProperty2(_keywordToTag, 'InstructionDescription', '00189917'), _defineProperty2(_keywordToTag, 'InstructionPerformedFlag', '00189918'), _defineProperty2(_keywordToTag, 'InstructionPerformedDateTime', '00189919'), _defineProperty2(_keywordToTag, 'InstructionPerformanceComment', '0018991A'), _defineProperty2(_keywordToTag, 'PatientPositioningInstructionSequence', '0018991B'), _defineProperty2(_keywordToTag, 'PositioningMethodCodeSequence', '0018991C'), _defineProperty2(_keywordToTag, 'PositioningLandmarkSequence', '0018991D'), _defineProperty2(_keywordToTag, 'TargetFrameOfReferenceUID', '0018991E'), _defineProperty2(_keywordToTag, 'AcquisitionProtocolElementSpecificationSequence', '0018991F'), _defineProperty2(_keywordToTag, 'AcquisitionProtocolElementSequence', '00189920'), _defineProperty2(_keywordToTag, 'ProtocolElementNumber', '00189921'), _defineProperty2(_keywordToTag, 'ProtocolElementName', '00189922'), _defineProperty2(_keywordToTag, 'ProtocolElementCharacteristicsSummary', '00189923'), _defineProperty2(_keywordToTag, 'ProtocolElementPurpose', '00189924'), _defineProperty2(_keywordToTag, 'AcquisitionMotion', '00189930'), _defineProperty2(_keywordToTag, 'AcquisitionStartLocationSequence', '00189931'), _defineProperty2(_keywordToTag, 'AcquisitionEndLocationSequence', '00189932'), _defineProperty2(_keywordToTag, 'ReconstructionProtocolElementSpecificationSequence', '00189933'), _defineProperty2(_keywordToTag, 'ReconstructionProtocolElementSequence', '00189934'), _defineProperty2(_keywordToTag, 'StorageProtocolElementSpecificationSequence', '00189935'), _defineProperty2(_keywordToTag, 'StorageProtocolElementSequence', '00189936'), _defineProperty2(_keywordToTag, 'RequestedSeriesDescription', '00189937'), _defineProperty2(_keywordToTag, 'SourceAcquisitionProtocolElementNumber', '00189938'), _defineProperty2(_keywordToTag, 'SourceAcquisitionBeamNumber', '00189939'), _defineProperty2(_keywordToTag, 'SourceReconstructionProtocolElementNumber', '0018993A'), _defineProperty2(_keywordToTag, 'ReconstructionStartLocationSequence', '0018993B'), _defineProperty2(_keywordToTag, 'ReconstructionEndLocationSequence', '0018993C'), _defineProperty2(_keywordToTag, 'ReconstructionAlgorithmSequence', '0018993D'), _defineProperty2(_keywordToTag, 'ReconstructionTargetCenterLocationSequence', '0018993E'), _defineProperty2(_keywordToTag, 'ImageFilterDescription', '00189941'), _defineProperty2(_keywordToTag, 'CTDIvolNotificationTrigger', '00189942'), _defineProperty2(_keywordToTag, 'DLPNotificationTrigger', '00189943'), _defineProperty2(_keywordToTag, 'AutoKVPSelectionType', '00189944'), _defineProperty2(_keywordToTag, 'AutoKVPUpperBound', '00189945'), _defineProperty2(_keywordToTag, 'AutoKVPLowerBound', '00189946'), _defineProperty2(_keywordToTag, 'ProtocolDefinedPatientPosition', '00189947'), _defineProperty2(_keywordToTag, 'ContributingEquipmentSequence', '0018A001'), _defineProperty2(_keywordToTag, 'ContributionDateTime', '0018A002'), _defineProperty2(_keywordToTag, 'ContributionDescription', '0018A003'), _defineProperty2(_keywordToTag, 'StudyInstanceUID', '0020000D'), _defineProperty2(_keywordToTag, 'SeriesInstanceUID', '0020000E'), _defineProperty2(_keywordToTag, 'StudyID', '00200010'), _defineProperty2(_keywordToTag, 'SeriesNumber', '00200011'), _defineProperty2(_keywordToTag, 'AcquisitionNumber', '00200012'), _defineProperty2(_keywordToTag, 'InstanceNumber', '00200013'), _defineProperty2(_keywordToTag, 'IsotopeNumber', '00200014'), _defineProperty2(_keywordToTag, 'PhaseNumber', '00200015'), _defineProperty2(_keywordToTag, 'IntervalNumber', '00200016'), _defineProperty2(_keywordToTag, 'TimeSlotNumber', '00200017'), _defineProperty2(_keywordToTag, 'AngleNumber', '00200018'), _defineProperty2(_keywordToTag, 'ItemNumber', '00200019'), _defineProperty2(_keywordToTag, 'PatientOrientation', '00200020'), _defineProperty2(_keywordToTag, 'OverlayNumber', '00200022'), _defineProperty2(_keywordToTag, 'CurveNumber', '00200024'), _defineProperty2(_keywordToTag, 'LUTNumber', '00200026'), _defineProperty2(_keywordToTag, 'ImagePosition', '00200030'), _defineProperty2(_keywordToTag, 'ImagePositionPatient', '00200032'), _defineProperty2(_keywordToTag, 'ImageOrientation', '00200035'), _defineProperty2(_keywordToTag, 'ImageOrientationPatient', '00200037'), _defineProperty2(_keywordToTag, 'Location', '00200050'), _defineProperty2(_keywordToTag, 'FrameOfReferenceUID', '00200052'), _defineProperty2(_keywordToTag, 'Laterality', '00200060'), _defineProperty2(_keywordToTag, 'ImageLaterality', '00200062'), _defineProperty2(_keywordToTag, 'ImageGeometryType', '00200070'), _defineProperty2(_keywordToTag, 'MaskingImage', '00200080'), _defineProperty2(_keywordToTag, 'ReportNumber', '002000AA'), _defineProperty2(_keywordToTag, 'TemporalPositionIdentifier', '00200100'), _defineProperty2(_keywordToTag, 'NumberOfTemporalPositions', '00200105'), _defineProperty2(_keywordToTag, 'TemporalResolution', '00200110'), _defineProperty2(_keywordToTag, 'SynchronizationFrameOfReferenceUID', '00200200'), _defineProperty2(_keywordToTag, 'SOPInstanceUIDOfConcatenationSource', '00200242'), _defineProperty2(_keywordToTag, 'SeriesInStudy', '00201000'), _defineProperty2(_keywordToTag, 'AcquisitionsInSeries', '00201001'), _defineProperty2(_keywordToTag, 'ImagesInAcquisition', '00201002'), _defineProperty2(_keywordToTag, 'ImagesInSeries', '00201003'), _defineProperty2(_keywordToTag, 'AcquisitionsInStudy', '00201004'), _defineProperty2(_keywordToTag, 'ImagesInStudy', '00201005'), _defineProperty2(_keywordToTag, 'Reference', '00201020'), _defineProperty2(_keywordToTag, 'TargetPositionReferenceIndicator', '0020103F'), _defineProperty2(_keywordToTag, 'PositionReferenceIndicator', '00201040'), _defineProperty2(_keywordToTag, 'SliceLocation', '00201041'), _defineProperty2(_keywordToTag, 'OtherStudyNumbers', '00201070'), _defineProperty2(_keywordToTag, 'NumberOfPatientRelatedStudies', '00201200'), _defineProperty2(_keywordToTag, 'NumberOfPatientRelatedSeries', '00201202'), _defineProperty2(_keywordToTag, 'NumberOfPatientRelatedInstances', '00201204'), _defineProperty2(_keywordToTag, 'NumberOfStudyRelatedSeries', '00201206'), _defineProperty2(_keywordToTag, 'NumberOfStudyRelatedInstances', '00201208'), _defineProperty2(_keywordToTag, 'NumberOfSeriesRelatedInstances', '00201209'), _defineProperty2(_keywordToTag, 'ModifyingDeviceID', '00203401'), _defineProperty2(_keywordToTag, 'ModifiedImageID', '00203402'), _defineProperty2(_keywordToTag, 'ModifiedImageDate', '00203403'), _defineProperty2(_keywordToTag, 'ModifyingDeviceManufacturer', '00203404'), _defineProperty2(_keywordToTag, 'ModifiedImageTime', '00203405'), _defineProperty2(_keywordToTag, 'ModifiedImageDescription', '00203406'), _defineProperty2(_keywordToTag, 'ImageComments', '00204000'), _defineProperty2(_keywordToTag, 'OriginalImageIdentification', '00205000'), _defineProperty2(_keywordToTag, 'OriginalImageIdentificationNomenclature', '00205002'), _defineProperty2(_keywordToTag, 'StackID', '00209056'), _defineProperty2(_keywordToTag, 'InStackPositionNumber', '00209057'), _defineProperty2(_keywordToTag, 'FrameAnatomySequence', '00209071'), _defineProperty2(_keywordToTag, 'FrameLaterality', '00209072'), _defineProperty2(_keywordToTag, 'FrameContentSequence', '00209111'), _defineProperty2(_keywordToTag, 'PlanePositionSequence', '00209113'), _defineProperty2(_keywordToTag, 'PlaneOrientationSequence', '00209116'), _defineProperty2(_keywordToTag, 'TemporalPositionIndex', '00209128'), _defineProperty2(_keywordToTag, 'NominalCardiacTriggerDelayTime', '00209153'), _defineProperty2(_keywordToTag, 'NominalCardiacTriggerTimePriorToRPeak', '00209154'), _defineProperty2(_keywordToTag, 'ActualCardiacTriggerTimePriorToRPeak', '00209155'), _defineProperty2(_keywordToTag, 'FrameAcquisitionNumber', '00209156'), _defineProperty2(_keywordToTag, 'DimensionIndexValues', '00209157'), _defineProperty2(_keywordToTag, 'FrameComments', '00209158'), _defineProperty2(_keywordToTag, 'ConcatenationUID', '00209161'), _defineProperty2(_keywordToTag, 'InConcatenationNumber', '00209162'), _defineProperty2(_keywordToTag, 'InConcatenationTotalNumber', '00209163'), _defineProperty2(_keywordToTag, 'DimensionOrganizationUID', '00209164'), _defineProperty2(_keywordToTag, 'DimensionIndexPointer', '00209165'), _defineProperty2(_keywordToTag, 'FunctionalGroupPointer', '00209167'), _defineProperty2(_keywordToTag, 'UnassignedSharedConvertedAttributesSequence', '00209170'), _defineProperty2(_keywordToTag, 'UnassignedPerFrameConvertedAttributesSequence', '00209171'), _defineProperty2(_keywordToTag, 'ConversionSourceAttributesSequence', '00209172'), _defineProperty2(_keywordToTag, 'DimensionIndexPrivateCreator', '00209213'), _defineProperty2(_keywordToTag, 'DimensionOrganizationSequence', '00209221'), _defineProperty2(_keywordToTag, 'DimensionIndexSequence', '00209222'), _defineProperty2(_keywordToTag, 'ConcatenationFrameOffsetNumber', '00209228'), _defineProperty2(_keywordToTag, 'FunctionalGroupPrivateCreator', '00209238'), _defineProperty2(_keywordToTag, 'NominalPercentageOfCardiacPhase', '00209241'), _defineProperty2(_keywordToTag, 'NominalPercentageOfRespiratoryPhase', '00209245'), _defineProperty2(_keywordToTag, 'StartingRespiratoryAmplitude', '00209246'), _defineProperty2(_keywordToTag, 'StartingRespiratoryPhase', '00209247'), _defineProperty2(_keywordToTag, 'EndingRespiratoryAmplitude', '00209248'), _defineProperty2(_keywordToTag, 'EndingRespiratoryPhase', '00209249'), _defineProperty2(_keywordToTag, 'RespiratoryTriggerType', '00209250'), _defineProperty2(_keywordToTag, 'RRIntervalTimeNominal', '00209251'), _defineProperty2(_keywordToTag, 'ActualCardiacTriggerDelayTime', '00209252'), _defineProperty2(_keywordToTag, 'RespiratorySynchronizationSequence', '00209253'), _defineProperty2(_keywordToTag, 'RespiratoryIntervalTime', '00209254'), _defineProperty2(_keywordToTag, 'NominalRespiratoryTriggerDelayTime', '00209255'), _defineProperty2(_keywordToTag, 'RespiratoryTriggerDelayThreshold', '00209256'), _defineProperty2(_keywordToTag, 'ActualRespiratoryTriggerDelayTime', '00209257'), _defineProperty2(_keywordToTag, 'ImagePositionVolume', '00209301'), _defineProperty2(_keywordToTag, 'ImageOrientationVolume', '00209302'), _defineProperty2(_keywordToTag, 'UltrasoundAcquisitionGeometry', '00209307'), _defineProperty2(_keywordToTag, 'ApexPosition', '00209308'), _defineProperty2(_keywordToTag, 'VolumeToTransducerMappingMatrix', '00209309'), _defineProperty2(_keywordToTag, 'VolumeToTableMappingMatrix', '0020930A'), _defineProperty2(_keywordToTag, 'VolumeToTransducerRelationship', '0020930B'), _defineProperty2(_keywordToTag, 'PatientFrameOfReferenceSource', '0020930C'), _defineProperty2(_keywordToTag, 'TemporalPositionTimeOffset', '0020930D'), _defineProperty2(_keywordToTag, 'PlanePositionVolumeSequence', '0020930E'), _defineProperty2(_keywordToTag, 'PlaneOrientationVolumeSequence', '0020930F'), _defineProperty2(_keywordToTag, 'TemporalPositionSequence', '00209310'), _defineProperty2(_keywordToTag, 'DimensionOrganizationType', '00209311'), _defineProperty2(_keywordToTag, 'VolumeFrameOfReferenceUID', '00209312'), _defineProperty2(_keywordToTag, 'TableFrameOfReferenceUID', '00209313'), _defineProperty2(_keywordToTag, 'DimensionDescriptionLabel', '00209421'), _defineProperty2(_keywordToTag, 'PatientOrientationInFrameSequence', '00209450'), _defineProperty2(_keywordToTag, 'FrameLabel', '00209453'), _defineProperty2(_keywordToTag, 'AcquisitionIndex', '00209518'), _defineProperty2(_keywordToTag, 'ContributingSOPInstancesReferenceSequence', '00209529'), _defineProperty2(_keywordToTag, 'ReconstructionIndex', '00209536'), _defineProperty2(_keywordToTag, 'LightPathFilterPassThroughWavelength', '00220001'), _defineProperty2(_keywordToTag, 'LightPathFilterPassBand', '00220002'), _defineProperty2(_keywordToTag, 'ImagePathFilterPassThroughWavelength', '00220003'), _defineProperty2(_keywordToTag, 'ImagePathFilterPassBand', '00220004'), _defineProperty2(_keywordToTag, 'PatientEyeMovementCommanded', '00220005'), _defineProperty2(_keywordToTag, 'PatientEyeMovementCommandCodeSequence', '00220006'), _defineProperty2(_keywordToTag, 'SphericalLensPower', '00220007'), _defineProperty2(_keywordToTag, 'CylinderLensPower', '00220008'), _defineProperty2(_keywordToTag, 'CylinderAxis', '00220009'), _defineProperty2(_keywordToTag, 'EmmetropicMagnification', '0022000A'), _defineProperty2(_keywordToTag, 'IntraOcularPressure', '0022000B'), _defineProperty2(_keywordToTag, 'HorizontalFieldOfView', '0022000C'), _defineProperty2(_keywordToTag, 'PupilDilated', '0022000D'), _defineProperty2(_keywordToTag, 'DegreeOfDilation', '0022000E'), _defineProperty2(_keywordToTag, 'StereoBaselineAngle', '00220010'), _defineProperty2(_keywordToTag, 'StereoBaselineDisplacement', '00220011'), _defineProperty2(_keywordToTag, 'StereoHorizontalPixelOffset', '00220012'), _defineProperty2(_keywordToTag, 'StereoVerticalPixelOffset', '00220013'), _defineProperty2(_keywordToTag, 'StereoRotation', '00220014'), _defineProperty2(_keywordToTag, 'AcquisitionDeviceTypeCodeSequence', '00220015'), _defineProperty2(_keywordToTag, 'IlluminationTypeCodeSequence', '00220016'), _defineProperty2(_keywordToTag, 'LightPathFilterTypeStackCodeSequence', '00220017'), _defineProperty2(_keywordToTag, 'ImagePathFilterTypeStackCodeSequence', '00220018'), _defineProperty2(_keywordToTag, 'LensesCodeSequence', '00220019'), _defineProperty2(_keywordToTag, 'ChannelDescriptionCodeSequence', '0022001A'), _defineProperty2(_keywordToTag, 'RefractiveStateSequence', '0022001B'), _defineProperty2(_keywordToTag, 'MydriaticAgentCodeSequence', '0022001C'), _defineProperty2(_keywordToTag, 'RelativeImagePositionCodeSequence', '0022001D'), _defineProperty2(_keywordToTag, 'CameraAngleOfView', '0022001E'), _defineProperty2(_keywordToTag, 'StereoPairsSequence', '00220020'), _defineProperty2(_keywordToTag, 'LeftImageSequence', '00220021'), _defineProperty2(_keywordToTag, 'RightImageSequence', '00220022'), _defineProperty2(_keywordToTag, 'StereoPairsPresent', '00220028'), _defineProperty2(_keywordToTag, 'AxialLengthOfTheEye', '00220030'), _defineProperty2(_keywordToTag, 'OphthalmicFrameLocationSequence', '00220031'), _defineProperty2(_keywordToTag, 'ReferenceCoordinates', '00220032'), _defineProperty2(_keywordToTag, 'DepthSpatialResolution', '00220035'), _defineProperty2(_keywordToTag, 'MaximumDepthDistortion', '00220036'), _defineProperty2(_keywordToTag, 'AlongScanSpatialResolution', '00220037'), _defineProperty2(_keywordToTag, 'MaximumAlongScanDistortion', '00220038'), _defineProperty2(_keywordToTag, 'OphthalmicImageOrientation', '00220039'), _defineProperty2(_keywordToTag, 'DepthOfTransverseImage', '00220041'), _defineProperty2(_keywordToTag, 'MydriaticAgentConcentrationUnitsSequence', '00220042'), _defineProperty2(_keywordToTag, 'AcrossScanSpatialResolution', '00220048'), _defineProperty2(_keywordToTag, 'MaximumAcrossScanDistortion', '00220049'), _defineProperty2(_keywordToTag, 'MydriaticAgentConcentration', '0022004E'), _defineProperty2(_keywordToTag, 'IlluminationWaveLength', '00220055'), _defineProperty2(_keywordToTag, 'IlluminationPower', '00220056'), _defineProperty2(_keywordToTag, 'IlluminationBandwidth', '00220057'), _defineProperty2(_keywordToTag, 'MydriaticAgentSequence', '00220058'), _defineProperty2(_keywordToTag, 'OphthalmicAxialMeasurementsRightEyeSequence', '00221007'), _defineProperty2(_keywordToTag, 'OphthalmicAxialMeasurementsLeftEyeSequence', '00221008'), _defineProperty2(_keywordToTag, 'OphthalmicAxialMeasurementsDeviceType', '00221009'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMeasurementsType', '00221010'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthSequence', '00221012'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLength', '00221019'), _defineProperty2(_keywordToTag, 'LensStatusCodeSequence', '00221024'), _defineProperty2(_keywordToTag, 'VitreousStatusCodeSequence', '00221025'), _defineProperty2(_keywordToTag, 'IOLFormulaCodeSequence', '00221028'), _defineProperty2(_keywordToTag, 'IOLFormulaDetail', '00221029'), _defineProperty2(_keywordToTag, 'KeratometerIndex', '00221033'), _defineProperty2(_keywordToTag, 'SourceOfOphthalmicAxialLengthCodeSequence', '00221035'), _defineProperty2(_keywordToTag, 'TargetRefraction', '00221037'), _defineProperty2(_keywordToTag, 'RefractiveProcedureOccurred', '00221039'), _defineProperty2(_keywordToTag, 'RefractiveSurgeryTypeCodeSequence', '00221040'), _defineProperty2(_keywordToTag, 'OphthalmicUltrasoundMethodCodeSequence', '00221044'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMeasurementsSequence', '00221050'), _defineProperty2(_keywordToTag, 'IOLPower', '00221053'), _defineProperty2(_keywordToTag, 'PredictedRefractiveError', '00221054'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthVelocity', '00221059'), _defineProperty2(_keywordToTag, 'LensStatusDescription', '00221065'), _defineProperty2(_keywordToTag, 'VitreousStatusDescription', '00221066'), _defineProperty2(_keywordToTag, 'IOLPowerSequence', '00221090'), _defineProperty2(_keywordToTag, 'LensConstantSequence', '00221092'), _defineProperty2(_keywordToTag, 'IOLManufacturer', '00221093'), _defineProperty2(_keywordToTag, 'LensConstantDescription', '00221094'), _defineProperty2(_keywordToTag, 'ImplantName', '00221095'), _defineProperty2(_keywordToTag, 'KeratometryMeasurementTypeCodeSequence', '00221096'), _defineProperty2(_keywordToTag, 'ImplantPartNumber', '00221097'), _defineProperty2(_keywordToTag, 'ReferencedOphthalmicAxialMeasurementsSequence', '00221100'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMeasurementsSegmentNameCodeSequence', '00221101'), _defineProperty2(_keywordToTag, 'RefractiveErrorBeforeRefractiveSurgeryCodeSequence', '00221103'), _defineProperty2(_keywordToTag, 'IOLPowerForExactEmmetropia', '00221121'), _defineProperty2(_keywordToTag, 'IOLPowerForExactTargetRefraction', '00221122'), _defineProperty2(_keywordToTag, 'AnteriorChamberDepthDefinitionCodeSequence', '00221125'), _defineProperty2(_keywordToTag, 'LensThicknessSequence', '00221127'), _defineProperty2(_keywordToTag, 'AnteriorChamberDepthSequence', '00221128'), _defineProperty2(_keywordToTag, 'LensThickness', '00221130'), _defineProperty2(_keywordToTag, 'AnteriorChamberDepth', '00221131'), _defineProperty2(_keywordToTag, 'SourceOfLensThicknessDataCodeSequence', '00221132'), _defineProperty2(_keywordToTag, 'SourceOfAnteriorChamberDepthDataCodeSequence', '00221133'), _defineProperty2(_keywordToTag, 'SourceOfRefractiveMeasurementsSequence', '00221134'), _defineProperty2(_keywordToTag, 'SourceOfRefractiveMeasurementsCodeSequence', '00221135'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMeasurementModified', '00221140'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthDataSourceCodeSequence', '00221150'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthAcquisitionMethodCodeSequence', '00221153'), _defineProperty2(_keywordToTag, 'SignalToNoiseRatio', '00221155'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthDataSourceDescription', '00221159'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMeasurementsTotalLengthSequence', '00221210'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMeasurementsSegmentalLengthSequence', '00221211'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMeasurementsLengthSummationSequence', '00221212'), _defineProperty2(_keywordToTag, 'UltrasoundOphthalmicAxialLengthMeasurementsSequence', '00221220'), _defineProperty2(_keywordToTag, 'OpticalOphthalmicAxialLengthMeasurementsSequence', '00221225'), _defineProperty2(_keywordToTag, 'UltrasoundSelectedOphthalmicAxialLengthSequence', '00221230'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthSelectionMethodCodeSequence', '00221250'), _defineProperty2(_keywordToTag, 'OpticalSelectedOphthalmicAxialLengthSequence', '00221255'), _defineProperty2(_keywordToTag, 'SelectedSegmentalOphthalmicAxialLengthSequence', '00221257'), _defineProperty2(_keywordToTag, 'SelectedTotalOphthalmicAxialLengthSequence', '00221260'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthQualityMetricSequence', '00221262'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthQualityMetricTypeCodeSequence', '00221265'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthQualityMetricTypeDescription', '00221273'), _defineProperty2(_keywordToTag, 'IntraocularLensCalculationsRightEyeSequence', '00221300'), _defineProperty2(_keywordToTag, 'IntraocularLensCalculationsLeftEyeSequence', '00221310'), _defineProperty2(_keywordToTag, 'ReferencedOphthalmicAxialLengthMeasurementQCImageSequence', '00221330'), _defineProperty2(_keywordToTag, 'OphthalmicMappingDeviceType', '00221415'), _defineProperty2(_keywordToTag, 'AcquisitionMethodCodeSequence', '00221420'), _defineProperty2(_keywordToTag, 'AcquisitionMethodAlgorithmSequence', '00221423'), _defineProperty2(_keywordToTag, 'OphthalmicThicknessMapTypeCodeSequence', '00221436'), _defineProperty2(_keywordToTag, 'OphthalmicThicknessMappingNormalsSequence', '00221443'), _defineProperty2(_keywordToTag, 'RetinalThicknessDefinitionCodeSequence', '00221445'), _defineProperty2(_keywordToTag, 'PixelValueMappingToCodedConceptSequence', '00221450'), _defineProperty2(_keywordToTag, 'MappedPixelValue', '00221452'), _defineProperty2(_keywordToTag, 'PixelValueMappingExplanation', '00221454'), _defineProperty2(_keywordToTag, 'OphthalmicThicknessMapQualityThresholdSequence', '00221458'), _defineProperty2(_keywordToTag, 'OphthalmicThicknessMapThresholdQualityRating', '00221460'), _defineProperty2(_keywordToTag, 'AnatomicStructureReferencePoint', '00221463'), _defineProperty2(_keywordToTag, 'RegistrationToLocalizerSequence', '00221465'), _defineProperty2(_keywordToTag, 'RegisteredLocalizerUnits', '00221466'), _defineProperty2(_keywordToTag, 'RegisteredLocalizerTopLeftHandCorner', '00221467'), _defineProperty2(_keywordToTag, 'RegisteredLocalizerBottomRightHandCorner', '00221468'), _defineProperty2(_keywordToTag, 'OphthalmicThicknessMapQualityRatingSequence', '00221470'), _defineProperty2(_keywordToTag, 'RelevantOPTAttributesSequence', '00221472'), _defineProperty2(_keywordToTag, 'TransformationMethodCodeSequence', '00221512'), _defineProperty2(_keywordToTag, 'TransformationAlgorithmSequence', '00221513'), _defineProperty2(_keywordToTag, 'OphthalmicAxialLengthMethod', '00221515'), _defineProperty2(_keywordToTag, 'OphthalmicFOV', '00221517'), _defineProperty2(_keywordToTag, 'TwoDimensionalToThreeDimensionalMapSequence', '00221518'), _defineProperty2(_keywordToTag, 'WideFieldOphthalmicPhotographyQualityRatingSequence', '00221525'), _defineProperty2(_keywordToTag, 'WideFieldOphthalmicPhotographyQualityThresholdSequence', '00221526'), _defineProperty2(_keywordToTag, 'WideFieldOphthalmicPhotographyThresholdQualityRating', '00221527'), _defineProperty2(_keywordToTag, 'XCoordinatesCenterPixelViewAngle', '00221528'), _defineProperty2(_keywordToTag, 'YCoordinatesCenterPixelViewAngle', '00221529'), _defineProperty2(_keywordToTag, 'NumberOfMapPoints', '00221530'), _defineProperty2(_keywordToTag, 'TwoDimensionalToThreeDimensionalMapData', '00221531'), _defineProperty2(_keywordToTag, 'DerivationAlgorithmSequence', '00221612'), _defineProperty2(_keywordToTag, 'OphthalmicImageTypeCodeSequence', '00221615'), _defineProperty2(_keywordToTag, 'OphthalmicImageTypeDescription', '00221616'), _defineProperty2(_keywordToTag, 'ScanPatternTypeCodeSequence', '00221618'), _defineProperty2(_keywordToTag, 'ReferencedSurfaceMeshIdentificationSequence', '00221620'), _defineProperty2(_keywordToTag, 'OphthalmicVolumetricPropertiesFlag', '00221622'), _defineProperty2(_keywordToTag, 'OphthalmicAnatomicReferencePointXCoordinate', '00221624'), _defineProperty2(_keywordToTag, 'OphthalmicAnatomicReferencePointYCoordinate', '00221626'), _defineProperty2(_keywordToTag, 'OphthalmicEnFaceImageQualityRatingSequence', '00221628'), _defineProperty2(_keywordToTag, 'QualityThreshold', '00221630'), _defineProperty2(_keywordToTag, 'OCTBscanAnalysisAcquisitionParametersSequence', '00221640'), _defineProperty2(_keywordToTag, 'NumberofBscansPerFrame', '00221642'), _defineProperty2(_keywordToTag, 'BscanSlabThickness', '00221643'), _defineProperty2(_keywordToTag, 'DistanceBetweenBscanSlabs', '00221644'), _defineProperty2(_keywordToTag, 'BscanCycleTime', '00221645'), _defineProperty2(_keywordToTag, 'BscanCycleTimeVector', '00221646'), _defineProperty2(_keywordToTag, 'AscanRate', '00221649'), _defineProperty2(_keywordToTag, 'BscanRate', '00221650'), _defineProperty2(_keywordToTag, 'SurfaceMeshZPixelOffset', '00221658'), _defineProperty2(_keywordToTag, 'VisualFieldHorizontalExtent', '00240010'), _defineProperty2(_keywordToTag, 'VisualFieldVerticalExtent', '00240011'), _defineProperty2(_keywordToTag, 'VisualFieldShape', '00240012'), _defineProperty2(_keywordToTag, 'ScreeningTestModeCodeSequence', '00240016'), _defineProperty2(_keywordToTag, 'MaximumStimulusLuminance', '00240018'), _defineProperty2(_keywordToTag, 'BackgroundLuminance', '00240020'), _defineProperty2(_keywordToTag, 'StimulusColorCodeSequence', '00240021'), _defineProperty2(_keywordToTag, 'BackgroundIlluminationColorCodeSequence', '00240024'), _defineProperty2(_keywordToTag, 'StimulusArea', '00240025'), _defineProperty2(_keywordToTag, 'StimulusPresentationTime', '00240028'), _defineProperty2(_keywordToTag, 'FixationSequence', '00240032'), _defineProperty2(_keywordToTag, 'FixationMonitoringCodeSequence', '00240033'), _defineProperty2(_keywordToTag, 'VisualFieldCatchTrialSequence', '00240034'), _defineProperty2(_keywordToTag, 'FixationCheckedQuantity', '00240035'), _defineProperty2(_keywordToTag, 'PatientNotProperlyFixatedQuantity', '00240036'), _defineProperty2(_keywordToTag, 'PresentedVisualStimuliDataFlag', '00240037'), _defineProperty2(_keywordToTag, 'NumberOfVisualStimuli', '00240038'), _defineProperty2(_keywordToTag, 'ExcessiveFixationLossesDataFlag', '00240039'), _defineProperty2(_keywordToTag, 'ExcessiveFixationLosses', '00240040'), _defineProperty2(_keywordToTag, 'StimuliRetestingQuantity', '00240042'), _defineProperty2(_keywordToTag, 'CommentsOnPatientPerformanceOfVisualField', '00240044'), _defineProperty2(_keywordToTag, 'FalseNegativesEstimateFlag', '00240045'), _defineProperty2(_keywordToTag, 'FalseNegativesEstimate', '00240046'), _defineProperty2(_keywordToTag, 'NegativeCatchTrialsQuantity', '00240048'), _defineProperty2(_keywordToTag, 'FalseNegativesQuantity', '00240050'), _defineProperty2(_keywordToTag, 'ExcessiveFalseNegativesDataFlag', '00240051'), _defineProperty2(_keywordToTag, 'ExcessiveFalseNegatives', '00240052'), _defineProperty2(_keywordToTag, 'FalsePositivesEstimateFlag', '00240053'), _defineProperty2(_keywordToTag, 'FalsePositivesEstimate', '00240054'), _defineProperty2(_keywordToTag, 'CatchTrialsDataFlag', '00240055'), _defineProperty2(_keywordToTag, 'PositiveCatchTrialsQuantity', '00240056'), _defineProperty2(_keywordToTag, 'TestPointNormalsDataFlag', '00240057'), _defineProperty2(_keywordToTag, 'TestPointNormalsSequence', '00240058'), _defineProperty2(_keywordToTag, 'GlobalDeviationProbabilityNormalsFlag', '00240059'), _defineProperty2(_keywordToTag, 'FalsePositivesQuantity', '00240060'), _defineProperty2(_keywordToTag, 'ExcessiveFalsePositivesDataFlag', '00240061'), _defineProperty2(_keywordToTag, 'ExcessiveFalsePositives', '00240062'), _defineProperty2(_keywordToTag, 'VisualFieldTestNormalsFlag', '00240063'), _defineProperty2(_keywordToTag, 'ResultsNormalsSequence', '00240064'), _defineProperty2(_keywordToTag, 'AgeCorrectedSensitivityDeviationAlgorithmSequence', '00240065'), _defineProperty2(_keywordToTag, 'GlobalDeviationFromNormal', '00240066'), _defineProperty2(_keywordToTag, 'GeneralizedDefectSensitivityDeviationAlgorithmSequence', '00240067'), _defineProperty2(_keywordToTag, 'LocalizedDeviationFromNormal', '00240068'), _defineProperty2(_keywordToTag, 'PatientReliabilityIndicator', '00240069'), _defineProperty2(_keywordToTag, 'VisualFieldMeanSensitivity', '00240070'), _defineProperty2(_keywordToTag, 'GlobalDeviationProbability', '00240071'), _defineProperty2(_keywordToTag, 'LocalDeviationProbabilityNormalsFlag', '00240072'), _defineProperty2(_keywordToTag, 'LocalizedDeviationProbability', '00240073'), _defineProperty2(_keywordToTag, 'ShortTermFluctuationCalculated', '00240074'), _defineProperty2(_keywordToTag, 'ShortTermFluctuation', '00240075'), _defineProperty2(_keywordToTag, 'ShortTermFluctuationProbabilityCalculated', '00240076'), _defineProperty2(_keywordToTag, 'ShortTermFluctuationProbability', '00240077'), _defineProperty2(_keywordToTag, 'CorrectedLocalizedDeviationFromNormalCalculated', '00240078'), _defineProperty2(_keywordToTag, 'CorrectedLocalizedDeviationFromNormal', '00240079'), _defineProperty2(_keywordToTag, 'CorrectedLocalizedDeviationFromNormalProbabilityCalculated', '00240080'), _defineProperty2(_keywordToTag, 'CorrectedLocalizedDeviationFromNormalProbability', '00240081'), _defineProperty2(_keywordToTag, 'GlobalDeviationProbabilitySequence', '00240083'), _defineProperty2(_keywordToTag, 'LocalizedDeviationProbabilitySequence', '00240085'), _defineProperty2(_keywordToTag, 'FovealSensitivityMeasured', '00240086'), _defineProperty2(_keywordToTag, 'FovealSensitivity', '00240087'), _defineProperty2(_keywordToTag, 'VisualFieldTestDuration', '00240088'), _defineProperty2(_keywordToTag, 'VisualFieldTestPointSequence', '00240089'), _defineProperty2(_keywordToTag, 'VisualFieldTestPointXCoordinate', '00240090'), _defineProperty2(_keywordToTag, 'VisualFieldTestPointYCoordinate', '00240091'), _defineProperty2(_keywordToTag, 'AgeCorrectedSensitivityDeviationValue', '00240092'), _defineProperty2(_keywordToTag, 'StimulusResults', '00240093'), _defineProperty2(_keywordToTag, 'SensitivityValue', '00240094'), _defineProperty2(_keywordToTag, 'RetestStimulusSeen', '00240095'), _defineProperty2(_keywordToTag, 'RetestSensitivityValue', '00240096'), _defineProperty2(_keywordToTag, 'VisualFieldTestPointNormalsSequence', '00240097'), _defineProperty2(_keywordToTag, 'QuantifiedDefect', '00240098'), _defineProperty2(_keywordToTag, 'AgeCorrectedSensitivityDeviationProbabilityValue', '00240100'), _defineProperty2(_keywordToTag, 'GeneralizedDefectCorrectedSensitivityDeviationFlag', '00240102'), _defineProperty2(_keywordToTag, 'GeneralizedDefectCorrectedSensitivityDeviationValue', '00240103'), _defineProperty2(_keywordToTag, 'GeneralizedDefectCorrectedSensitivityDeviationProbabilityValue', '00240104'), _defineProperty2(_keywordToTag, 'MinimumSensitivityValue', '00240105'), _defineProperty2(_keywordToTag, 'BlindSpotLocalized', '00240106'), _defineProperty2(_keywordToTag, 'BlindSpotXCoordinate', '00240107'), _defineProperty2(_keywordToTag, 'BlindSpotYCoordinate', '00240108'), _defineProperty2(_keywordToTag, 'VisualAcuityMeasurementSequence', '00240110'), _defineProperty2(_keywordToTag, 'RefractiveParametersUsedOnPatientSequence', '00240112'), _defineProperty2(_keywordToTag, 'MeasurementLaterality', '00240113'), _defineProperty2(_keywordToTag, 'OphthalmicPatientClinicalInformationLeftEyeSequence', '00240114'), _defineProperty2(_keywordToTag, 'OphthalmicPatientClinicalInformationRightEyeSequence', '00240115'), _defineProperty2(_keywordToTag, 'FovealPointNormativeDataFlag', '00240117'), _defineProperty2(_keywordToTag, 'FovealPointProbabilityValue', '00240118'), _defineProperty2(_keywordToTag, 'ScreeningBaselineMeasured', '00240120'), _defineProperty2(_keywordToTag, 'ScreeningBaselineMeasuredSequence', '00240122'), _defineProperty2(_keywordToTag, 'ScreeningBaselineType', '00240124'), _defineProperty2(_keywordToTag, 'ScreeningBaselineValue', '00240126'), _defineProperty2(_keywordToTag, 'AlgorithmSource', '00240202'), _defineProperty2(_keywordToTag, 'DataSetName', '00240306'), _defineProperty2(_keywordToTag, 'DataSetVersion', '00240307'), _defineProperty2(_keywordToTag, 'DataSetSource', '00240308'), _defineProperty2(_keywordToTag, 'DataSetDescription', '00240309'), _defineProperty2(_keywordToTag, 'VisualFieldTestReliabilityGlobalIndexSequence', '00240317'), _defineProperty2(_keywordToTag, 'VisualFieldGlobalResultsIndexSequence', '00240320'), _defineProperty2(_keywordToTag, 'DataObservationSequence', '00240325'), _defineProperty2(_keywordToTag, 'IndexNormalsFlag', '00240338'), _defineProperty2(_keywordToTag, 'IndexProbability', '00240341'), _defineProperty2(_keywordToTag, 'IndexProbabilitySequence', '00240344'), _defineProperty2(_keywordToTag, 'SamplesPerPixel', '00280002'), _defineProperty2(_keywordToTag, 'SamplesPerPixelUsed', '00280003'), _defineProperty2(_keywordToTag, 'PhotometricInterpretation', '00280004'), _defineProperty2(_keywordToTag, 'ImageDimensions', '00280005'), _defineProperty2(_keywordToTag, 'PlanarConfiguration', '00280006'), _defineProperty2(_keywordToTag, 'NumberOfFrames', '00280008'), _defineProperty2(_keywordToTag, 'FrameIncrementPointer', '00280009'), _defineProperty2(_keywordToTag, 'FrameDimensionPointer', '0028000A'), _defineProperty2(_keywordToTag, 'Rows', '00280010'), _defineProperty2(_keywordToTag, 'Columns', '00280011'), _defineProperty2(_keywordToTag, 'Planes', '00280012'), _defineProperty2(_keywordToTag, 'UltrasoundColorDataPresent', '00280014'), _defineProperty2(_keywordToTag, \"\", '00280020'), _defineProperty2(_keywordToTag, 'PixelSpacing', '00280030'), _defineProperty2(_keywordToTag, 'ZoomFactor', '00280031'), _defineProperty2(_keywordToTag, 'ZoomCenter', '00280032'), _defineProperty2(_keywordToTag, 'PixelAspectRatio', '00280034'), _defineProperty2(_keywordToTag, 'ImageFormat', '00280040'), _defineProperty2(_keywordToTag, 'ManipulatedImage', '00280050'), _defineProperty2(_keywordToTag, 'CorrectedImage', '00280051'), _defineProperty2(_keywordToTag, 'CompressionRecognitionCode', '0028005F'), _defineProperty2(_keywordToTag, 'CompressionCode', '00280060'), _defineProperty2(_keywordToTag, 'CompressionOriginator', '00280061'), _defineProperty2(_keywordToTag, 'CompressionLabel', '00280062'), _defineProperty2(_keywordToTag, 'CompressionDescription', '00280063'), _defineProperty2(_keywordToTag, 'CompressionSequence', '00280065'), _defineProperty2(_keywordToTag, 'CompressionStepPointers', '00280066'), _defineProperty2(_keywordToTag, 'RepeatInterval', '00280068'), _defineProperty2(_keywordToTag, 'BitsGrouped', '00280069'), _defineProperty2(_keywordToTag, 'PerimeterTable', '00280070'), _defineProperty2(_keywordToTag, 'PerimeterValue', '00280071'), _defineProperty2(_keywordToTag, 'PredictorRows', '00280080'), _defineProperty2(_keywordToTag, 'PredictorColumns', '00280081'), _defineProperty2(_keywordToTag, 'PredictorConstants', '00280082'), _defineProperty2(_keywordToTag, 'BlockedPixels', '00280090'), _defineProperty2(_keywordToTag, 'BlockRows', '00280091'), _defineProperty2(_keywordToTag, 'BlockColumns', '00280092'), _defineProperty2(_keywordToTag, 'RowOverlap', '00280093'), _defineProperty2(_keywordToTag, 'ColumnOverlap', '00280094'), _defineProperty2(_keywordToTag, 'BitsAllocated', '00280100'), _defineProperty2(_keywordToTag, 'BitsStored', '00280101'), _defineProperty2(_keywordToTag, 'HighBit', '00280102'), _defineProperty2(_keywordToTag, 'PixelRepresentation', '00280103'), _defineProperty2(_keywordToTag, 'SmallestValidPixelValue', '00280104'), _defineProperty2(_keywordToTag, 'LargestValidPixelValue', '00280105'), _defineProperty2(_keywordToTag, 'SmallestImagePixelValue', '00280106'), _defineProperty2(_keywordToTag, 'LargestImagePixelValue', '00280107'), _defineProperty2(_keywordToTag, 'SmallestPixelValueInSeries', '00280108'), _defineProperty2(_keywordToTag, 'LargestPixelValueInSeries', '00280109'), _defineProperty2(_keywordToTag, 'SmallestImagePixelValueInPlane', '00280110'), _defineProperty2(_keywordToTag, 'LargestImagePixelValueInPlane', '00280111'), _defineProperty2(_keywordToTag, 'PixelPaddingValue', '00280120'), _defineProperty2(_keywordToTag, 'PixelPaddingRangeLimit', '00280121'), _defineProperty2(_keywordToTag, 'FloatPixelPaddingValue', '00280122'), _defineProperty2(_keywordToTag, 'DoubleFloatPixelPaddingValue', '00280123'), _defineProperty2(_keywordToTag, 'FloatPixelPaddingRangeLimit', '00280124'), _defineProperty2(_keywordToTag, 'DoubleFloatPixelPaddingRangeLimit', '00280125'), _defineProperty2(_keywordToTag, 'ImageLocation', '00280200'), _defineProperty2(_keywordToTag, 'QualityControlImage', '00280300'), _defineProperty2(_keywordToTag, 'BurnedInAnnotation', '00280301'), _defineProperty2(_keywordToTag, 'RecognizableVisualFeatures', '00280302'), _defineProperty2(_keywordToTag, 'LongitudinalTemporalInformationModified', '00280303'), _defineProperty2(_keywordToTag, 'ReferencedColorPaletteInstanceUID', '00280304'), _defineProperty2(_keywordToTag, 'TransformLabel', '00280400'), _defineProperty2(_keywordToTag, 'TransformVersionNumber', '00280401'), _defineProperty2(_keywordToTag, 'NumberOfTransformSteps', '00280402'), _defineProperty2(_keywordToTag, 'SequenceOfCompressedData', '00280403'), _defineProperty2(_keywordToTag, 'DetailsOfCoefficients', '00280404'), _defineProperty2(_keywordToTag, 'DCTLabel', '00280700'), _defineProperty2(_keywordToTag, 'DataBlockDescription', '00280701'), _defineProperty2(_keywordToTag, 'DataBlock', '00280702'), _defineProperty2(_keywordToTag, 'NormalizationFactorFormat', '00280710'), _defineProperty2(_keywordToTag, 'ZonalMapNumberFormat', '00280720'), _defineProperty2(_keywordToTag, 'ZonalMapLocation', '00280721'), _defineProperty2(_keywordToTag, 'ZonalMapFormat', '00280722'), _defineProperty2(_keywordToTag, 'AdaptiveMapFormat', '00280730'), _defineProperty2(_keywordToTag, 'CodeNumberFormat', '00280740'), _defineProperty2(_keywordToTag, 'PixelSpacingCalibrationType', '00280A02'), _defineProperty2(_keywordToTag, 'PixelSpacingCalibrationDescription', '00280A04'), _defineProperty2(_keywordToTag, 'PixelIntensityRelationship', '00281040'), _defineProperty2(_keywordToTag, 'PixelIntensityRelationshipSign', '00281041'), _defineProperty2(_keywordToTag, 'WindowCenter', '00281050'), _defineProperty2(_keywordToTag, 'WindowWidth', '00281051'), _defineProperty2(_keywordToTag, 'RescaleIntercept', '00281052'), _defineProperty2(_keywordToTag, 'RescaleSlope', '00281053'), _defineProperty2(_keywordToTag, 'RescaleType', '00281054'), _defineProperty2(_keywordToTag, 'WindowCenterWidthExplanation', '00281055'), _defineProperty2(_keywordToTag, 'VOILUTFunction', '00281056'), _defineProperty2(_keywordToTag, 'GrayScale', '00281080'), _defineProperty2(_keywordToTag, 'RecommendedViewingMode', '00281090'), _defineProperty2(_keywordToTag, 'GrayLookupTableDescriptor', '00281100'), _defineProperty2(_keywordToTag, 'RedPaletteColorLookupTableDescriptor', '00281101'), _defineProperty2(_keywordToTag, 'GreenPaletteColorLookupTableDescriptor', '00281102'), _defineProperty2(_keywordToTag, 'BluePaletteColorLookupTableDescriptor', '00281103'), _defineProperty2(_keywordToTag, 'AlphaPaletteColorLookupTableDescriptor', '00281104'), _defineProperty2(_keywordToTag, 'LargeRedPaletteColorLookupTableDescriptor', '00281111'), _defineProperty2(_keywordToTag, 'LargeGreenPaletteColorLookupTableDescriptor', '00281112'), _defineProperty2(_keywordToTag, 'LargeBluePaletteColorLookupTableDescriptor', '00281113'), _defineProperty2(_keywordToTag, 'PaletteColorLookupTableUID', '00281199'), _defineProperty2(_keywordToTag, 'GrayLookupTableData', '00281200'), _defineProperty2(_keywordToTag, 'RedPaletteColorLookupTableData', '00281201'), _defineProperty2(_keywordToTag, 'GreenPaletteColorLookupTableData', '00281202'), _defineProperty2(_keywordToTag, 'BluePaletteColorLookupTableData', '00281203'), _defineProperty2(_keywordToTag, 'AlphaPaletteColorLookupTableData', '00281204'), _defineProperty2(_keywordToTag, 'LargeRedPaletteColorLookupTableData', '00281211'), _defineProperty2(_keywordToTag, 'LargeGreenPaletteColorLookupTableData', '00281212'), _defineProperty2(_keywordToTag, 'LargeBluePaletteColorLookupTableData', '00281213'), _defineProperty2(_keywordToTag, 'LargePaletteColorLookupTableUID', '00281214'), _defineProperty2(_keywordToTag, 'SegmentedRedPaletteColorLookupTableData', '00281221'), _defineProperty2(_keywordToTag, 'SegmentedGreenPaletteColorLookupTableData', '00281222'), _defineProperty2(_keywordToTag, 'SegmentedBluePaletteColorLookupTableData', '00281223'), _defineProperty2(_keywordToTag, 'SegmentedAlphaPaletteColorLookupTableData', '00281224'), _defineProperty2(_keywordToTag, 'StoredValueColorRangeSequence', '00281230'), _defineProperty2(_keywordToTag, 'MinimumStoredValueMapped', '00281231'), _defineProperty2(_keywordToTag, 'MaximumStoredValueMapped', '00281232'), _defineProperty2(_keywordToTag, 'BreastImplantPresent', '00281300'), _defineProperty2(_keywordToTag, 'PartialView', '00281350'), _defineProperty2(_keywordToTag, 'PartialViewDescription', '00281351'), _defineProperty2(_keywordToTag, 'PartialViewCodeSequence', '00281352'), _defineProperty2(_keywordToTag, 'SpatialLocationsPreserved', '0028135A'), _defineProperty2(_keywordToTag, 'DataFrameAssignmentSequence', '00281401'), _defineProperty2(_keywordToTag, 'DataPathAssignment', '00281402'), _defineProperty2(_keywordToTag, 'BitsMappedToColorLookupTable', '00281403'), _defineProperty2(_keywordToTag, '00281404', 'BlendingLUT1Sequence'), _defineProperty2(_keywordToTag, '00281405', 'BlendingLUT1TransferFunction'), _defineProperty2(_keywordToTag, 'BlendingWeightConstant', '00281406'), _defineProperty2(_keywordToTag, 'BlendingLookupTableDescriptor', '00281407'), _defineProperty2(_keywordToTag, 'BlendingLookupTableData', '00281408'), _defineProperty2(_keywordToTag, 'EnhancedPaletteColorLookupTableSequence', '0028140B'), _defineProperty2(_keywordToTag, '0028140C', 'BlendingLUT2Sequence'), _defineProperty2(_keywordToTag, '0028140D', 'BlendingLUT2TransferFunction'), _defineProperty2(_keywordToTag, 'DataPathID', '0028140E'), _defineProperty2(_keywordToTag, 'RGBLUTTransferFunction', '0028140F'), _defineProperty2(_keywordToTag, 'AlphaLUTTransferFunction', '00281410'), _defineProperty2(_keywordToTag, 'ICCProfile', '00282000'), _defineProperty2(_keywordToTag, 'ColorSpace', '00282002'), _defineProperty2(_keywordToTag, 'LossyImageCompression', '00282110'), _defineProperty2(_keywordToTag, 'LossyImageCompressionRatio', '00282112'), _defineProperty2(_keywordToTag, 'LossyImageCompressionMethod', '00282114'), _defineProperty2(_keywordToTag, 'ModalityLUTSequence', '00283000'), _defineProperty2(_keywordToTag, 'LUTDescriptor', '00283002'), _defineProperty2(_keywordToTag, 'LUTExplanation', '00283003'), _defineProperty2(_keywordToTag, 'ModalityLUTType', '00283004'), _defineProperty2(_keywordToTag, 'LUTData', '00283006'), _defineProperty2(_keywordToTag, 'VOILUTSequence', '00283010'), _defineProperty2(_keywordToTag, 'SoftcopyVOILUTSequence', '00283110'), _defineProperty2(_keywordToTag, 'ImagePresentationComments', '00284000'), _defineProperty2(_keywordToTag, 'BiPlaneAcquisitionSequence', '00285000'), _defineProperty2(_keywordToTag, 'RepresentativeFrameNumber', '00286010'), _defineProperty2(_keywordToTag, 'FrameNumbersOfInterest', '00286020'), _defineProperty2(_keywordToTag, 'FrameOfInterestDescription', '00286022'), _defineProperty2(_keywordToTag, 'FrameOfInterestType', '00286023'), _defineProperty2(_keywordToTag, 'MaskPointers', '00286030'), _defineProperty2(_keywordToTag, 'RWavePointer', '00286040'), _defineProperty2(_keywordToTag, 'MaskSubtractionSequence', '00286100'), _defineProperty2(_keywordToTag, 'MaskOperation', '00286101'), _defineProperty2(_keywordToTag, 'ApplicableFrameRange', '00286102'), _defineProperty2(_keywordToTag, 'MaskFrameNumbers', '00286110'), _defineProperty2(_keywordToTag, 'ContrastFrameAveraging', '00286112'), _defineProperty2(_keywordToTag, 'MaskSubPixelShift', '00286114'), _defineProperty2(_keywordToTag, 'TIDOffset', '00286120'), _defineProperty2(_keywordToTag, 'MaskOperationExplanation', '00286190'), _defineProperty2(_keywordToTag, 'EquipmentAdministratorSequence', '00287000'), _defineProperty2(_keywordToTag, 'NumberOfDisplaySubsystems', '00287001'), _defineProperty2(_keywordToTag, 'CurrentConfigurationID', '00287002'), _defineProperty2(_keywordToTag, 'DisplaySubsystemID', '00287003'), _defineProperty2(_keywordToTag, 'DisplaySubsystemName', '00287004'), _defineProperty2(_keywordToTag, 'DisplaySubsystemDescription', '00287005'), _defineProperty2(_keywordToTag, 'SystemStatus', '00287006'), _defineProperty2(_keywordToTag, 'SystemStatusComment', '00287007'), _defineProperty2(_keywordToTag, 'TargetLuminanceCharacteristicsSequence', '00287008'), _defineProperty2(_keywordToTag, 'LuminanceCharacteristicsID', '00287009'), _defineProperty2(_keywordToTag, 'DisplaySubsystemConfigurationSequence', '0028700A'), _defineProperty2(_keywordToTag, 'ConfigurationID', '0028700B'), _defineProperty2(_keywordToTag, 'ConfigurationName', '0028700C'), _defineProperty2(_keywordToTag, 'ConfigurationDescription', '0028700D'), _defineProperty2(_keywordToTag, 'ReferencedTargetLuminanceCharacteristicsID', '0028700E'), _defineProperty2(_keywordToTag, 'QAResultsSequence', '0028700F'), _defineProperty2(_keywordToTag, 'DisplaySubsystemQAResultsSequence', '00287010'), _defineProperty2(_keywordToTag, 'ConfigurationQAResultsSequence', '00287011'), _defineProperty2(_keywordToTag, 'MeasurementEquipmentSequence', '00287012'), _defineProperty2(_keywordToTag, 'MeasurementFunctions', '00287013'), _defineProperty2(_keywordToTag, 'MeasurementEquipmentType', '00287014'), _defineProperty2(_keywordToTag, 'VisualEvaluationResultSequence', '00287015'), _defineProperty2(_keywordToTag, 'DisplayCalibrationResultSequence', '00287016'), _defineProperty2(_keywordToTag, 'DDLValue', '00287017'), _defineProperty2(_keywordToTag, 'CIExyWhitePoint', '00287018'), _defineProperty2(_keywordToTag, 'DisplayFunctionType', '00287019'), _defineProperty2(_keywordToTag, 'GammaValue', '0028701A'), _defineProperty2(_keywordToTag, 'NumberOfLuminancePoints', '0028701B'), _defineProperty2(_keywordToTag, 'LuminanceResponseSequence', '0028701C'), _defineProperty2(_keywordToTag, 'TargetMinimumLuminance', '0028701D'), _defineProperty2(_keywordToTag, 'TargetMaximumLuminance', '0028701E'), _defineProperty2(_keywordToTag, 'LuminanceValue', '0028701F'), _defineProperty2(_keywordToTag, 'LuminanceResponseDescription', '00287020'), _defineProperty2(_keywordToTag, 'WhitePointFlag', '00287021'), _defineProperty2(_keywordToTag, 'DisplayDeviceTypeCodeSequence', '00287022'), _defineProperty2(_keywordToTag, 'DisplaySubsystemSequence', '00287023'), _defineProperty2(_keywordToTag, 'LuminanceResultSequence', '00287024'), _defineProperty2(_keywordToTag, 'AmbientLightValueSource', '00287025'), _defineProperty2(_keywordToTag, 'MeasuredCharacteristics', '00287026'), _defineProperty2(_keywordToTag, 'LuminanceUniformityResultSequence', '00287027'), _defineProperty2(_keywordToTag, 'VisualEvaluationTestSequence', '00287028'), _defineProperty2(_keywordToTag, 'TestResult', '00287029'), _defineProperty2(_keywordToTag, 'TestResultComment', '0028702A'), _defineProperty2(_keywordToTag, 'TestImageValidation', '0028702B'), _defineProperty2(_keywordToTag, 'TestPatternCodeSequence', '0028702C'), _defineProperty2(_keywordToTag, 'MeasurementPatternCodeSequence', '0028702D'), _defineProperty2(_keywordToTag, 'VisualEvaluationMethodCodeSequence', '0028702E'), _defineProperty2(_keywordToTag, 'PixelDataProviderURL', '00287FE0'), _defineProperty2(_keywordToTag, 'DataPointRows', '00289001'), _defineProperty2(_keywordToTag, 'DataPointColumns', '00289002'), _defineProperty2(_keywordToTag, 'SignalDomainColumns', '00289003'), _defineProperty2(_keywordToTag, 'LargestMonochromePixelValue', '00289099'), _defineProperty2(_keywordToTag, 'DataRepresentation', '00289108'), _defineProperty2(_keywordToTag, 'PixelMeasuresSequence', '00289110'), _defineProperty2(_keywordToTag, 'FrameVOILUTSequence', '00289132'), _defineProperty2(_keywordToTag, 'PixelValueTransformationSequence', '00289145'), _defineProperty2(_keywordToTag, 'SignalDomainRows', '00289235'), _defineProperty2(_keywordToTag, 'DisplayFilterPercentage', '00289411'), _defineProperty2(_keywordToTag, 'FramePixelShiftSequence', '00289415'), _defineProperty2(_keywordToTag, 'SubtractionItemID', '00289416'), _defineProperty2(_keywordToTag, 'PixelIntensityRelationshipLUTSequence', '00289422'), _defineProperty2(_keywordToTag, 'FramePixelDataPropertiesSequence', '00289443'), _defineProperty2(_keywordToTag, 'GeometricalProperties', '00289444'), _defineProperty2(_keywordToTag, 'GeometricMaximumDistortion', '00289445'), _defineProperty2(_keywordToTag, 'ImageProcessingApplied', '00289446'), _defineProperty2(_keywordToTag, 'MaskSelectionMode', '00289454'), _defineProperty2(_keywordToTag, 'LUTFunction', '00289474'), _defineProperty2(_keywordToTag, 'MaskVisibilityPercentage', '00289478'), _defineProperty2(_keywordToTag, 'PixelShiftSequence', '00289501'), _defineProperty2(_keywordToTag, 'RegionPixelShiftSequence', '00289502'), _defineProperty2(_keywordToTag, 'VerticesOfTheRegion', '00289503'), _defineProperty2(_keywordToTag, 'MultiFramePresentationSequence', '00289505'), _defineProperty2(_keywordToTag, 'PixelShiftFrameRange', '00289506'), _defineProperty2(_keywordToTag, 'LUTFrameRange', '00289507'), _defineProperty2(_keywordToTag, 'ImageToEquipmentMappingMatrix', '00289520'), _defineProperty2(_keywordToTag, 'EquipmentCoordinateSystemIdentification', '00289537'), _defineProperty2(_keywordToTag, 'StudyStatusID', '0032000A'), _defineProperty2(_keywordToTag, 'StudyPriorityID', '0032000C'), _defineProperty2(_keywordToTag, 'StudyIDIssuer', '00320012'), _defineProperty2(_keywordToTag, 'StudyVerifiedDate', '00320032'), _defineProperty2(_keywordToTag, 'StudyVerifiedTime', '00320033'), _defineProperty2(_keywordToTag, 'StudyReadDate', '00320034'), _defineProperty2(_keywordToTag, 'StudyReadTime', '00320035'), _defineProperty2(_keywordToTag, 'ScheduledStudyStartDate', '00321000'), _defineProperty2(_keywordToTag, 'ScheduledStudyStartTime', '00321001'), _defineProperty2(_keywordToTag, 'ScheduledStudyStopDate', '00321010'), _defineProperty2(_keywordToTag, 'ScheduledStudyStopTime', '00321011'), _defineProperty2(_keywordToTag, 'ScheduledStudyLocation', '00321020'), _defineProperty2(_keywordToTag, 'ScheduledStudyLocationAETitle', '00321021'), _defineProperty2(_keywordToTag, 'ReasonForStudy', '00321030'), _defineProperty2(_keywordToTag, 'RequestingPhysicianIdentificationSequence', '00321031'), _defineProperty2(_keywordToTag, 'RequestingPhysician', '00321032'), _defineProperty2(_keywordToTag, 'RequestingService', '00321033'), _defineProperty2(_keywordToTag, 'RequestingServiceCodeSequence', '00321034'), _defineProperty2(_keywordToTag, 'StudyArrivalDate', '00321040'), _defineProperty2(_keywordToTag, 'StudyArrivalTime', '00321041'), _defineProperty2(_keywordToTag, 'StudyCompletionDate', '00321050'), _defineProperty2(_keywordToTag, 'StudyCompletionTime', '00321051'), _defineProperty2(_keywordToTag, 'StudyComponentStatusID', '00321055'), _defineProperty2(_keywordToTag, 'RequestedProcedureDescription', '00321060'), _defineProperty2(_keywordToTag, 'RequestedProcedureCodeSequence', '00321064'), _defineProperty2(_keywordToTag, 'RequestedContrastAgent', '00321070'), _defineProperty2(_keywordToTag, 'StudyComments', '00324000'), _defineProperty2(_keywordToTag, 'ReferencedPatientAliasSequence', '00380004'), _defineProperty2(_keywordToTag, 'VisitStatusID', '00380008'), _defineProperty2(_keywordToTag, 'AdmissionID', '00380010'), _defineProperty2(_keywordToTag, 'IssuerOfAdmissionID', '00380011'), _defineProperty2(_keywordToTag, 'IssuerOfAdmissionIDSequence', '00380014'), _defineProperty2(_keywordToTag, 'RouteOfAdmissions', '00380016'), _defineProperty2(_keywordToTag, 'ScheduledAdmissionDate', '0038001A'), _defineProperty2(_keywordToTag, 'ScheduledAdmissionTime', '0038001B'), _defineProperty2(_keywordToTag, 'ScheduledDischargeDate', '0038001C'), _defineProperty2(_keywordToTag, 'ScheduledDischargeTime', '0038001D'), _defineProperty2(_keywordToTag, 'ScheduledPatientInstitutionResidence', '0038001E'), _defineProperty2(_keywordToTag, 'AdmittingDate', '00380020'), _defineProperty2(_keywordToTag, 'AdmittingTime', '00380021'), _defineProperty2(_keywordToTag, 'DischargeDate', '00380030'), _defineProperty2(_keywordToTag, 'DischargeTime', '00380032'), _defineProperty2(_keywordToTag, 'DischargeDiagnosisDescription', '00380040'), _defineProperty2(_keywordToTag, 'DischargeDiagnosisCodeSequence', '00380044'), _defineProperty2(_keywordToTag, 'SpecialNeeds', '00380050'), _defineProperty2(_keywordToTag, 'ServiceEpisodeID', '00380060'), _defineProperty2(_keywordToTag, 'IssuerOfServiceEpisodeID', '00380061'), _defineProperty2(_keywordToTag, 'ServiceEpisodeDescription', '00380062'), _defineProperty2(_keywordToTag, 'IssuerOfServiceEpisodeIDSequence', '00380064'), _defineProperty2(_keywordToTag, 'PertinentDocumentsSequence', '00380100'), _defineProperty2(_keywordToTag, 'PertinentResourcesSequence', '00380101'), _defineProperty2(_keywordToTag, 'ResourceDescription', '00380102'), _defineProperty2(_keywordToTag, 'CurrentPatientLocation', '00380300'), _defineProperty2(_keywordToTag, 'PatientInstitutionResidence', '00380400'), _defineProperty2(_keywordToTag, 'PatientState', '00380500'), _defineProperty2(_keywordToTag, 'PatientClinicalTrialParticipationSequence', '00380502'), _defineProperty2(_keywordToTag, 'VisitComments', '00384000'), _defineProperty2(_keywordToTag, 'WaveformOriginality', '003A0004'), _defineProperty2(_keywordToTag, 'NumberOfWaveformChannels', '003A0005'), _defineProperty2(_keywordToTag, 'NumberOfWaveformSamples', '003A0010'), _defineProperty2(_keywordToTag, 'SamplingFrequency', '003A001A'), _defineProperty2(_keywordToTag, 'MultiplexGroupLabel', '003A0020'), _defineProperty2(_keywordToTag, 'ChannelDefinitionSequence', '003A0200'), _defineProperty2(_keywordToTag, 'WaveformChannelNumber', '003A0202'), _defineProperty2(_keywordToTag, 'ChannelLabel', '003A0203'), _defineProperty2(_keywordToTag, 'ChannelStatus', '003A0205'), _defineProperty2(_keywordToTag, 'ChannelSourceSequence', '003A0208'), _defineProperty2(_keywordToTag, 'ChannelSourceModifiersSequence', '003A0209'), _defineProperty2(_keywordToTag, 'SourceWaveformSequence', '003A020A'), _defineProperty2(_keywordToTag, 'ChannelDerivationDescription', '003A020C'), _defineProperty2(_keywordToTag, 'ChannelSensitivity', '003A0210'), _defineProperty2(_keywordToTag, 'ChannelSensitivityUnitsSequence', '003A0211'), _defineProperty2(_keywordToTag, 'ChannelSensitivityCorrectionFactor', '003A0212'), _defineProperty2(_keywordToTag, 'ChannelBaseline', '003A0213'), _defineProperty2(_keywordToTag, 'ChannelTimeSkew', '003A0214'), _defineProperty2(_keywordToTag, 'ChannelSampleSkew', '003A0215'), _defineProperty2(_keywordToTag, 'ChannelOffset', '003A0218'), _defineProperty2(_keywordToTag, 'WaveformBitsStored', '003A021A'), _defineProperty2(_keywordToTag, 'FilterLowFrequency', '003A0220'), _defineProperty2(_keywordToTag, 'FilterHighFrequency', '003A0221'), _defineProperty2(_keywordToTag, 'NotchFilterFrequency', '003A0222'), _defineProperty2(_keywordToTag, 'NotchFilterBandwidth', '003A0223'), _defineProperty2(_keywordToTag, 'WaveformDataDisplayScale', '003A0230'), _defineProperty2(_keywordToTag, 'WaveformDisplayBackgroundCIELabValue', '003A0231'), _defineProperty2(_keywordToTag, 'WaveformPresentationGroupSequence', '003A0240'), _defineProperty2(_keywordToTag, 'PresentationGroupNumber', '003A0241'), _defineProperty2(_keywordToTag, 'ChannelDisplaySequence', '003A0242'), _defineProperty2(_keywordToTag, 'ChannelRecommendedDisplayCIELabValue', '003A0244'), _defineProperty2(_keywordToTag, 'ChannelPosition', '003A0245'), _defineProperty2(_keywordToTag, 'DisplayShadingFlag', '003A0246'), _defineProperty2(_keywordToTag, 'FractionalChannelDisplayScale', '003A0247'), _defineProperty2(_keywordToTag, 'AbsoluteChannelDisplayScale', '003A0248'), _defineProperty2(_keywordToTag, 'MultiplexedAudioChannelsDescriptionCodeSequence', '003A0300'), _defineProperty2(_keywordToTag, 'ChannelIdentificationCode', '003A0301'), _defineProperty2(_keywordToTag, 'ChannelMode', '003A0302'), _defineProperty2(_keywordToTag, 'ScheduledStationAETitle', '00400001'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepStartDate', '00400002'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepStartTime', '00400003'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepEndDate', '00400004'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepEndTime', '00400005'), _defineProperty2(_keywordToTag, 'ScheduledPerformingPhysicianName', '00400006'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepDescription', '00400007'), _defineProperty2(_keywordToTag, 'ScheduledProtocolCodeSequence', '00400008'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepID', '00400009'), _defineProperty2(_keywordToTag, 'StageCodeSequence', '0040000A'), _defineProperty2(_keywordToTag, 'ScheduledPerformingPhysicianIdentificationSequence', '0040000B'), _defineProperty2(_keywordToTag, 'ScheduledStationName', '00400010'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepLocation', '00400011'), _defineProperty2(_keywordToTag, 'PreMedication', '00400012'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepStatus', '00400020'), _defineProperty2(_keywordToTag, 'OrderPlacerIdentifierSequence', '00400026'), _defineProperty2(_keywordToTag, 'OrderFillerIdentifierSequence', '00400027'), _defineProperty2(_keywordToTag, 'LocalNamespaceEntityID', '00400031'), _defineProperty2(_keywordToTag, 'UniversalEntityID', '00400032'), _defineProperty2(_keywordToTag, 'UniversalEntityIDType', '00400033'), _defineProperty2(_keywordToTag, 'IdentifierTypeCode', '00400035'), _defineProperty2(_keywordToTag, 'AssigningFacilitySequence', '00400036'), _defineProperty2(_keywordToTag, 'AssigningJurisdictionCodeSequence', '00400039'), _defineProperty2(_keywordToTag, 'AssigningAgencyOrDepartmentCodeSequence', '0040003A'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepSequence', '00400100'), _defineProperty2(_keywordToTag, 'ReferencedNonImageCompositeSOPInstanceSequence', '00400220'), _defineProperty2(_keywordToTag, 'PerformedStationAETitle', '00400241'), _defineProperty2(_keywordToTag, 'PerformedStationName', '00400242'), _defineProperty2(_keywordToTag, 'PerformedLocation', '00400243'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepStartDate', '00400244'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepStartTime', '00400245'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepEndDate', '00400250'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepEndTime', '00400251'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepStatus', '00400252'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepID', '00400253'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepDescription', '00400254'), _defineProperty2(_keywordToTag, 'PerformedProcedureTypeDescription', '00400255'), _defineProperty2(_keywordToTag, 'PerformedProtocolCodeSequence', '00400260'), _defineProperty2(_keywordToTag, 'PerformedProtocolType', '00400261'), _defineProperty2(_keywordToTag, 'ScheduledStepAttributesSequence', '00400270'), _defineProperty2(_keywordToTag, 'RequestAttributesSequence', '00400275'), _defineProperty2(_keywordToTag, 'CommentsOnThePerformedProcedureStep', '00400280'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepDiscontinuationReasonCodeSequence', '00400281'), _defineProperty2(_keywordToTag, 'QuantitySequence', '00400293'), _defineProperty2(_keywordToTag, 'Quantity', '00400294'), _defineProperty2(_keywordToTag, 'MeasuringUnitsSequence', '00400295'), _defineProperty2(_keywordToTag, 'BillingItemSequence', '00400296'), _defineProperty2(_keywordToTag, 'TotalTimeOfFluoroscopy', '00400300'), _defineProperty2(_keywordToTag, 'TotalNumberOfExposures', '00400301'), _defineProperty2(_keywordToTag, 'EntranceDose', '00400302'), _defineProperty2(_keywordToTag, 'ExposedArea', '00400303'), _defineProperty2(_keywordToTag, 'DistanceSourceToEntrance', '00400306'), _defineProperty2(_keywordToTag, 'DistanceSourceToSupport', '00400307'), _defineProperty2(_keywordToTag, 'ExposureDoseSequence', '0040030E'), _defineProperty2(_keywordToTag, 'CommentsOnRadiationDose', '00400310'), _defineProperty2(_keywordToTag, 'XRayOutput', '00400312'), _defineProperty2(_keywordToTag, 'HalfValueLayer', '00400314'), _defineProperty2(_keywordToTag, 'OrganDose', '00400316'), _defineProperty2(_keywordToTag, 'OrganExposed', '00400318'), _defineProperty2(_keywordToTag, 'BillingProcedureStepSequence', '00400320'), _defineProperty2(_keywordToTag, 'FilmConsumptionSequence', '00400321'), _defineProperty2(_keywordToTag, 'BillingSuppliesAndDevicesSequence', '00400324'), _defineProperty2(_keywordToTag, 'ReferencedProcedureStepSequence', '00400330'), _defineProperty2(_keywordToTag, 'PerformedSeriesSequence', '00400340'), _defineProperty2(_keywordToTag, 'CommentsOnTheScheduledProcedureStep', '00400400'), _defineProperty2(_keywordToTag, 'ProtocolContextSequence', '00400440'), _defineProperty2(_keywordToTag, 'ContentItemModifierSequence', '00400441'), _defineProperty2(_keywordToTag, 'ScheduledSpecimenSequence', '00400500'), _defineProperty2(_keywordToTag, 'SpecimenAccessionNumber', '0040050A'), _defineProperty2(_keywordToTag, 'ContainerIdentifier', '00400512'), _defineProperty2(_keywordToTag, 'IssuerOfTheContainerIdentifierSequence', '00400513'), _defineProperty2(_keywordToTag, 'AlternateContainerIdentifierSequence', '00400515'), _defineProperty2(_keywordToTag, 'ContainerTypeCodeSequence', '00400518'), _defineProperty2(_keywordToTag, 'ContainerDescription', '0040051A'), _defineProperty2(_keywordToTag, 'ContainerComponentSequence', '00400520'), _defineProperty2(_keywordToTag, 'SpecimenSequence', '00400550'), _defineProperty2(_keywordToTag, 'SpecimenIdentifier', '00400551'), _defineProperty2(_keywordToTag, 'SpecimenDescriptionSequenceTrial', '00400552'), _defineProperty2(_keywordToTag, 'SpecimenDescriptionTrial', '00400553'), _defineProperty2(_keywordToTag, 'SpecimenUID', '00400554'), _defineProperty2(_keywordToTag, 'AcquisitionContextSequence', '00400555'), _defineProperty2(_keywordToTag, 'AcquisitionContextDescription', '00400556'), _defineProperty2(_keywordToTag, 'SpecimenDescriptionSequence', '00400560'), _defineProperty2(_keywordToTag, 'IssuerOfTheSpecimenIdentifierSequence', '00400562'), _defineProperty2(_keywordToTag, 'SpecimenTypeCodeSequence', '0040059A'), _defineProperty2(_keywordToTag, 'SpecimenShortDescription', '00400600'), _defineProperty2(_keywordToTag, 'SpecimenDetailedDescription', '00400602'), _defineProperty2(_keywordToTag, 'SpecimenPreparationSequence', '00400610'), _defineProperty2(_keywordToTag, 'SpecimenPreparationStepContentItemSequence', '00400612'), _defineProperty2(_keywordToTag, 'SpecimenLocalizationContentItemSequence', '00400620'), _defineProperty2(_keywordToTag, 'SlideIdentifier', '004006FA'), _defineProperty2(_keywordToTag, 'WholeSlideMicroscopyImageFrameTypeSequence', '00400710'), _defineProperty2(_keywordToTag, 'ImageCenterPointCoordinatesSequence', '0040071A'), _defineProperty2(_keywordToTag, 'XOffsetInSlideCoordinateSystem', '0040072A'), _defineProperty2(_keywordToTag, 'YOffsetInSlideCoordinateSystem', '0040073A'), _defineProperty2(_keywordToTag, 'ZOffsetInSlideCoordinateSystem', '0040074A'), _defineProperty2(_keywordToTag, 'PixelSpacingSequence', '004008D8'), _defineProperty2(_keywordToTag, 'CoordinateSystemAxisCodeSequence', '004008DA'), _defineProperty2(_keywordToTag, 'MeasurementUnitsCodeSequence', '004008EA'), _defineProperty2(_keywordToTag, 'VitalStainCodeSequenceTrial', '004009F8'), _defineProperty2(_keywordToTag, 'RequestedProcedureID', '00401001'), _defineProperty2(_keywordToTag, 'ReasonForTheRequestedProcedure', '00401002'), _defineProperty2(_keywordToTag, 'RequestedProcedurePriority', '00401003'), _defineProperty2(_keywordToTag, 'PatientTransportArrangements', '00401004'), _defineProperty2(_keywordToTag, 'RequestedProcedureLocation', '00401005'), _defineProperty2(_keywordToTag, 'PlacerOrderNumberProcedure', '00401006'), _defineProperty2(_keywordToTag, 'FillerOrderNumberProcedure', '00401007'), _defineProperty2(_keywordToTag, 'ConfidentialityCode', '00401008'), _defineProperty2(_keywordToTag, 'ReportingPriority', '00401009'), _defineProperty2(_keywordToTag, 'ReasonForRequestedProcedureCodeSequence', '0040100A'), _defineProperty2(_keywordToTag, 'NamesOfIntendedRecipientsOfResults', '00401010'), _defineProperty2(_keywordToTag, 'IntendedRecipientsOfResultsIdentificationSequence', '00401011'), _defineProperty2(_keywordToTag, 'ReasonForPerformedProcedureCodeSequence', '00401012'), _defineProperty2(_keywordToTag, 'RequestedProcedureDescriptionTrial', '00401060'), _defineProperty2(_keywordToTag, 'PersonIdentificationCodeSequence', '00401101'), _defineProperty2(_keywordToTag, 'PersonAddress', '00401102'), _defineProperty2(_keywordToTag, 'PersonTelephoneNumbers', '00401103'), _defineProperty2(_keywordToTag, 'PersonTelecomInformation', '00401104'), _defineProperty2(_keywordToTag, 'RequestedProcedureComments', '00401400'), _defineProperty2(_keywordToTag, 'ReasonForTheImagingServiceRequest', '00402001'), _defineProperty2(_keywordToTag, 'IssueDateOfImagingServiceRequest', '00402004'), _defineProperty2(_keywordToTag, 'IssueTimeOfImagingServiceRequest', '00402005'), _defineProperty2(_keywordToTag, 'PlacerOrderNumberImagingServiceRequestRetired', '00402006'), _defineProperty2(_keywordToTag, 'FillerOrderNumberImagingServiceRequestRetired', '00402007'), _defineProperty2(_keywordToTag, 'OrderEnteredBy', '00402008'), _defineProperty2(_keywordToTag, 'OrderEntererLocation', '00402009'), _defineProperty2(_keywordToTag, 'OrderCallbackPhoneNumber', '00402010'), _defineProperty2(_keywordToTag, 'OrderCallbackTelecomInformation', '00402011'), _defineProperty2(_keywordToTag, 'PlacerOrderNumberImagingServiceRequest', '00402016'), _defineProperty2(_keywordToTag, 'FillerOrderNumberImagingServiceRequest', '00402017'), _defineProperty2(_keywordToTag, 'ImagingServiceRequestComments', '00402400'), _defineProperty2(_keywordToTag, 'ConfidentialityConstraintOnPatientDataDescription', '00403001'), _defineProperty2(_keywordToTag, 'GeneralPurposeScheduledProcedureStepStatus', '00404001'), _defineProperty2(_keywordToTag, 'GeneralPurposePerformedProcedureStepStatus', '00404002'), _defineProperty2(_keywordToTag, 'GeneralPurposeScheduledProcedureStepPriority', '00404003'), _defineProperty2(_keywordToTag, 'ScheduledProcessingApplicationsCodeSequence', '00404004'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepStartDateTime', '00404005'), _defineProperty2(_keywordToTag, 'MultipleCopiesFlag', '00404006'), _defineProperty2(_keywordToTag, 'PerformedProcessingApplicationsCodeSequence', '00404007'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepExpirationDateTime', '00404008'), _defineProperty2(_keywordToTag, 'HumanPerformerCodeSequence', '00404009'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepModificationDateTime', '00404010'), _defineProperty2(_keywordToTag, 'ExpectedCompletionDateTime', '00404011'), _defineProperty2(_keywordToTag, 'ResultingGeneralPurposePerformedProcedureStepsSequence', '00404015'), _defineProperty2(_keywordToTag, 'ReferencedGeneralPurposeScheduledProcedureStepSequence', '00404016'), _defineProperty2(_keywordToTag, 'ScheduledWorkitemCodeSequence', '00404018'), _defineProperty2(_keywordToTag, 'PerformedWorkitemCodeSequence', '00404019'), _defineProperty2(_keywordToTag, 'InputAvailabilityFlag', '00404020'), _defineProperty2(_keywordToTag, 'InputInformationSequence', '00404021'), _defineProperty2(_keywordToTag, 'RelevantInformationSequence', '00404022'), _defineProperty2(_keywordToTag, 'ReferencedGeneralPurposeScheduledProcedureStepTransactionUID', '00404023'), _defineProperty2(_keywordToTag, 'ScheduledStationNameCodeSequence', '00404025'), _defineProperty2(_keywordToTag, 'ScheduledStationClassCodeSequence', '00404026'), _defineProperty2(_keywordToTag, 'ScheduledStationGeographicLocationCodeSequence', '00404027'), _defineProperty2(_keywordToTag, 'PerformedStationNameCodeSequence', '00404028'), _defineProperty2(_keywordToTag, 'PerformedStationClassCodeSequence', '00404029'), _defineProperty2(_keywordToTag, 'PerformedStationGeographicLocationCodeSequence', '00404030'), _defineProperty2(_keywordToTag, 'RequestedSubsequentWorkitemCodeSequence', '00404031'), _defineProperty2(_keywordToTag, 'NonDICOMOutputCodeSequence', '00404032'), _defineProperty2(_keywordToTag, 'OutputInformationSequence', '00404033'), _defineProperty2(_keywordToTag, 'ScheduledHumanPerformersSequence', '00404034'), _defineProperty2(_keywordToTag, 'ActualHumanPerformersSequence', '00404035'), _defineProperty2(_keywordToTag, 'HumanPerformerOrganization', '00404036'), _defineProperty2(_keywordToTag, 'HumanPerformerName', '00404037'), _defineProperty2(_keywordToTag, 'RawDataHandling', '00404040'), _defineProperty2(_keywordToTag, 'InputReadinessState', '00404041'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepStartDateTime', '00404050'), _defineProperty2(_keywordToTag, 'PerformedProcedureStepEndDateTime', '00404051'), _defineProperty2(_keywordToTag, 'ProcedureStepCancellationDateTime', '00404052'), _defineProperty2(_keywordToTag, 'OutputDestinationSequence', '00404070'), _defineProperty2(_keywordToTag, 'DICOMStorageSequence', '00404071'), _defineProperty2(_keywordToTag, 'STOWRSStorageSequence', '00404072'), _defineProperty2(_keywordToTag, 'StorageURL', '00404073'), _defineProperty2(_keywordToTag, 'XDSStorageSequence', '00404074'), _defineProperty2(_keywordToTag, 'EntranceDoseInmGy', '00408302'), _defineProperty2(_keywordToTag, 'EntranceDoseDerivation', '00408303'), _defineProperty2(_keywordToTag, 'ParametricMapFrameTypeSequence', '00409092'), _defineProperty2(_keywordToTag, 'ReferencedImageRealWorldValueMappingSequence', '00409094'), _defineProperty2(_keywordToTag, 'RealWorldValueMappingSequence', '00409096'), _defineProperty2(_keywordToTag, 'PixelValueMappingCodeSequence', '00409098'), _defineProperty2(_keywordToTag, 'LUTLabel', '00409210'), _defineProperty2(_keywordToTag, 'RealWorldValueLastValueMapped', '00409211'), _defineProperty2(_keywordToTag, 'RealWorldValueLUTData', '00409212'), _defineProperty2(_keywordToTag, 'DoubleFloatRealWorldValueLastValueMapped', '00409213'), _defineProperty2(_keywordToTag, 'DoubleFloatRealWorldValueFirstValueMapped', '00409214'), _defineProperty2(_keywordToTag, 'RealWorldValueFirstValueMapped', '00409216'), _defineProperty2(_keywordToTag, 'QuantityDefinitionSequence', '00409220'), _defineProperty2(_keywordToTag, 'RealWorldValueIntercept', '00409224'), _defineProperty2(_keywordToTag, 'RealWorldValueSlope', '00409225'), _defineProperty2(_keywordToTag, 'FindingsFlagTrial', '0040A007'), _defineProperty2(_keywordToTag, 'RelationshipType', '0040A010'), _defineProperty2(_keywordToTag, 'FindingsSequenceTrial', '0040A020'), _defineProperty2(_keywordToTag, 'FindingsGroupUIDTrial', '0040A021'), _defineProperty2(_keywordToTag, 'ReferencedFindingsGroupUIDTrial', '0040A022'), _defineProperty2(_keywordToTag, 'FindingsGroupRecordingDateTrial', '0040A023'), _defineProperty2(_keywordToTag, 'FindingsGroupRecordingTimeTrial', '0040A024'), _defineProperty2(_keywordToTag, 'FindingsSourceCategoryCodeSequenceTrial', '0040A026'), _defineProperty2(_keywordToTag, 'VerifyingOrganization', '0040A027'), _defineProperty2(_keywordToTag, 'DocumentingOrganizationIdentifierCodeSequenceTrial', '0040A028'), _defineProperty2(_keywordToTag, 'VerificationDateTime', '0040A030'), _defineProperty2(_keywordToTag, 'ObservationDateTime', '0040A032'), _defineProperty2(_keywordToTag, 'ValueType', '0040A040'), _defineProperty2(_keywordToTag, 'ConceptNameCodeSequence', '0040A043'), _defineProperty2(_keywordToTag, 'MeasurementPrecisionDescriptionTrial', '0040A047'), _defineProperty2(_keywordToTag, 'ContinuityOfContent', '0040A050'), _defineProperty2(_keywordToTag, 'UrgencyOrPriorityAlertsTrial', '0040A057'), _defineProperty2(_keywordToTag, 'SequencingIndicatorTrial', '0040A060'), _defineProperty2(_keywordToTag, 'DocumentIdentifierCodeSequenceTrial', '0040A066'), _defineProperty2(_keywordToTag, 'DocumentAuthorTrial', '0040A067'), _defineProperty2(_keywordToTag, 'DocumentAuthorIdentifierCodeSequenceTrial', '0040A068'), _defineProperty2(_keywordToTag, 'IdentifierCodeSequenceTrial', '0040A070'), _defineProperty2(_keywordToTag, 'VerifyingObserverSequence', '0040A073'), _defineProperty2(_keywordToTag, 'ObjectBinaryIdentifierTrial', '0040A074'), _defineProperty2(_keywordToTag, 'VerifyingObserverName', '0040A075'), _defineProperty2(_keywordToTag, 'DocumentingObserverIdentifierCodeSequenceTrial', '0040A076'), _defineProperty2(_keywordToTag, 'AuthorObserverSequence', '0040A078'), _defineProperty2(_keywordToTag, 'ParticipantSequence', '0040A07A'), _defineProperty2(_keywordToTag, 'CustodialOrganizationSequence', '0040A07C'), _defineProperty2(_keywordToTag, 'ParticipationType', '0040A080'), _defineProperty2(_keywordToTag, 'ParticipationDateTime', '0040A082'), _defineProperty2(_keywordToTag, 'ObserverType', '0040A084'), _defineProperty2(_keywordToTag, 'ProcedureIdentifierCodeSequenceTrial', '0040A085'), _defineProperty2(_keywordToTag, 'VerifyingObserverIdentificationCodeSequence', '0040A088'), _defineProperty2(_keywordToTag, 'ObjectDirectoryBinaryIdentifierTrial', '0040A089'), _defineProperty2(_keywordToTag, 'EquivalentCDADocumentSequence', '0040A090'), _defineProperty2(_keywordToTag, 'ReferencedWaveformChannels', '0040A0B0'), _defineProperty2(_keywordToTag, 'DateOfDocumentOrVerbalTransactionTrial', '0040A110'), _defineProperty2(_keywordToTag, 'TimeOfDocumentCreationOrVerbalTransactionTrial', '0040A112'), _defineProperty2(_keywordToTag, 'DateTime', '0040A120'), _defineProperty2(_keywordToTag, 'Date', '0040A121'), _defineProperty2(_keywordToTag, 'Time', '0040A122'), _defineProperty2(_keywordToTag, 'PersonName', '0040A123'), _defineProperty2(_keywordToTag, 'UID', '0040A124'), _defineProperty2(_keywordToTag, 'ReportStatusIDTrial', '0040A125'), _defineProperty2(_keywordToTag, 'TemporalRangeType', '0040A130'), _defineProperty2(_keywordToTag, 'ReferencedSamplePositions', '0040A132'), _defineProperty2(_keywordToTag, 'ReferencedFrameNumbers', '0040A136'), _defineProperty2(_keywordToTag, 'ReferencedTimeOffsets', '0040A138'), _defineProperty2(_keywordToTag, 'ReferencedDateTime', '0040A13A'), _defineProperty2(_keywordToTag, 'TextValue', '0040A160'), _defineProperty2(_keywordToTag, 'FloatingPointValue', '0040A161'), _defineProperty2(_keywordToTag, 'RationalNumeratorValue', '0040A162'), _defineProperty2(_keywordToTag, 'RationalDenominatorValue', '0040A163'), _defineProperty2(_keywordToTag, 'ObservationCategoryCodeSequenceTrial', '0040A167'), _defineProperty2(_keywordToTag, 'ConceptCodeSequence', '0040A168'), _defineProperty2(_keywordToTag, 'BibliographicCitationTrial', '0040A16A'), _defineProperty2(_keywordToTag, 'PurposeOfReferenceCodeSequence', '0040A170'), _defineProperty2(_keywordToTag, 'ObservationUID', '0040A171'), _defineProperty2(_keywordToTag, 'ReferencedObservationUIDTrial', '0040A172'), _defineProperty2(_keywordToTag, 'ReferencedObservationClassTrial', '0040A173'), _defineProperty2(_keywordToTag, 'ReferencedObjectObservationClassTrial', '0040A174'), _defineProperty2(_keywordToTag, 'AnnotationGroupNumber', '0040A180'), _defineProperty2(_keywordToTag, 'ObservationDateTrial', '0040A192'), _defineProperty2(_keywordToTag, 'ObservationTimeTrial', '0040A193'), _defineProperty2(_keywordToTag, 'MeasurementAutomationTrial', '0040A194'), _defineProperty2(_keywordToTag, 'ModifierCodeSequence', '0040A195'), _defineProperty2(_keywordToTag, 'IdentificationDescriptionTrial', '0040A224'), _defineProperty2(_keywordToTag, 'CoordinatesSetGeometricTypeTrial', '0040A290'), _defineProperty2(_keywordToTag, 'AlgorithmCodeSequenceTrial', '0040A296'), _defineProperty2(_keywordToTag, 'AlgorithmDescriptionTrial', '0040A297'), _defineProperty2(_keywordToTag, 'PixelCoordinatesSetTrial', '0040A29A'), _defineProperty2(_keywordToTag, 'MeasuredValueSequence', '0040A300'), _defineProperty2(_keywordToTag, 'NumericValueQualifierCodeSequence', '0040A301'), _defineProperty2(_keywordToTag, 'CurrentObserverTrial', '0040A307'), _defineProperty2(_keywordToTag, 'NumericValue', '0040A30A'), _defineProperty2(_keywordToTag, 'ReferencedAccessionSequenceTrial', '0040A313'), _defineProperty2(_keywordToTag, 'ReportStatusCommentTrial', '0040A33A'), _defineProperty2(_keywordToTag, 'ProcedureContextSequenceTrial', '0040A340'), _defineProperty2(_keywordToTag, 'VerbalSourceTrial', '0040A352'), _defineProperty2(_keywordToTag, 'AddressTrial', '0040A353'), _defineProperty2(_keywordToTag, 'TelephoneNumberTrial', '0040A354'), _defineProperty2(_keywordToTag, 'VerbalSourceIdentifierCodeSequenceTrial', '0040A358'), _defineProperty2(_keywordToTag, 'PredecessorDocumentsSequence', '0040A360'), _defineProperty2(_keywordToTag, 'ReferencedRequestSequence', '0040A370'), _defineProperty2(_keywordToTag, 'PerformedProcedureCodeSequence', '0040A372'), _defineProperty2(_keywordToTag, 'CurrentRequestedProcedureEvidenceSequence', '0040A375'), _defineProperty2(_keywordToTag, 'ReportDetailSequenceTrial', '0040A380'), _defineProperty2(_keywordToTag, 'PertinentOtherEvidenceSequence', '0040A385'), _defineProperty2(_keywordToTag, '0040A390', 'HL7StructuredDocumentReferenceSequence'), _defineProperty2(_keywordToTag, 'ObservationSubjectUIDTrial', '0040A402'), _defineProperty2(_keywordToTag, 'ObservationSubjectClassTrial', '0040A403'), _defineProperty2(_keywordToTag, 'ObservationSubjectTypeCodeSequenceTrial', '0040A404'), _defineProperty2(_keywordToTag, 'CompletionFlag', '0040A491'), _defineProperty2(_keywordToTag, 'CompletionFlagDescription', '0040A492'), _defineProperty2(_keywordToTag, 'VerificationFlag', '0040A493'), _defineProperty2(_keywordToTag, 'ArchiveRequested', '0040A494'), _defineProperty2(_keywordToTag, 'PreliminaryFlag', '0040A496'), _defineProperty2(_keywordToTag, 'ContentTemplateSequence', '0040A504'), _defineProperty2(_keywordToTag, 'IdenticalDocumentsSequence', '0040A525'), _defineProperty2(_keywordToTag, 'ObservationSubjectContextFlagTrial', '0040A600'), _defineProperty2(_keywordToTag, 'ObserverContextFlagTrial', '0040A601'), _defineProperty2(_keywordToTag, 'ProcedureContextFlagTrial', '0040A603'), _defineProperty2(_keywordToTag, 'ContentSequence', '0040A730'), _defineProperty2(_keywordToTag, 'RelationshipSequenceTrial', '0040A731'), _defineProperty2(_keywordToTag, 'RelationshipTypeCodeSequenceTrial', '0040A732'), _defineProperty2(_keywordToTag, 'LanguageCodeSequenceTrial', '0040A744'), _defineProperty2(_keywordToTag, 'UniformResourceLocatorTrial', '0040A992'), _defineProperty2(_keywordToTag, 'WaveformAnnotationSequence', '0040B020'), _defineProperty2(_keywordToTag, 'TemplateIdentifier', '0040DB00'), _defineProperty2(_keywordToTag, 'TemplateVersion', '0040DB06'), _defineProperty2(_keywordToTag, 'TemplateLocalVersion', '0040DB07'), _defineProperty2(_keywordToTag, 'TemplateExtensionFlag', '0040DB0B'), _defineProperty2(_keywordToTag, 'TemplateExtensionOrganizationUID', '0040DB0C'), _defineProperty2(_keywordToTag, 'TemplateExtensionCreatorUID', '0040DB0D'), _defineProperty2(_keywordToTag, 'ReferencedContentItemIdentifier', '0040DB73'), _defineProperty2(_keywordToTag, '0040E001', 'HL7InstanceIdentifier'), _defineProperty2(_keywordToTag, '0040E004', 'HL7DocumentEffectiveTime'), _defineProperty2(_keywordToTag, '0040E006', 'HL7DocumentTypeCodeSequence'), _defineProperty2(_keywordToTag, 'DocumentClassCodeSequence', '0040E008'), _defineProperty2(_keywordToTag, 'RetrieveURI', '0040E010'), _defineProperty2(_keywordToTag, 'RetrieveLocationUID', '0040E011'), _defineProperty2(_keywordToTag, 'TypeOfInstances', '0040E020'), _defineProperty2(_keywordToTag, 'DICOMRetrievalSequence', '0040E021'), _defineProperty2(_keywordToTag, 'DICOMMediaRetrievalSequence', '0040E022'), _defineProperty2(_keywordToTag, 'WADORetrievalSequence', '0040E023'), _defineProperty2(_keywordToTag, 'XDSRetrievalSequence', '0040E024'), _defineProperty2(_keywordToTag, 'WADORSRetrievalSequence', '0040E025'), _defineProperty2(_keywordToTag, 'RepositoryUniqueID', '0040E030'), _defineProperty2(_keywordToTag, 'HomeCommunityID', '0040E031'), _defineProperty2(_keywordToTag, 'DocumentTitle', '00420010'), _defineProperty2(_keywordToTag, 'EncapsulatedDocument', '00420011'), _defineProperty2(_keywordToTag, 'MIMETypeOfEncapsulatedDocument', '00420012'), _defineProperty2(_keywordToTag, 'SourceInstanceSequence', '00420013'), _defineProperty2(_keywordToTag, 'ListOfMIMETypes', '00420014'), _defineProperty2(_keywordToTag, 'ProductPackageIdentifier', '00440001'), _defineProperty2(_keywordToTag, 'SubstanceAdministrationApproval', '00440002'), _defineProperty2(_keywordToTag, 'ApprovalStatusFurtherDescription', '00440003'), _defineProperty2(_keywordToTag, 'ApprovalStatusDateTime', '00440004'), _defineProperty2(_keywordToTag, 'ProductTypeCodeSequence', '00440007'), _defineProperty2(_keywordToTag, 'ProductName', '00440008'), _defineProperty2(_keywordToTag, 'ProductDescription', '00440009'), _defineProperty2(_keywordToTag, 'ProductLotIdentifier', '0044000A'), _defineProperty2(_keywordToTag, 'ProductExpirationDateTime', '0044000B'), _defineProperty2(_keywordToTag, 'SubstanceAdministrationDateTime', '00440010'), _defineProperty2(_keywordToTag, 'SubstanceAdministrationNotes', '00440011'), _defineProperty2(_keywordToTag, 'SubstanceAdministrationDeviceID', '00440012'), _defineProperty2(_keywordToTag, 'ProductParameterSequence', '00440013'), _defineProperty2(_keywordToTag, 'SubstanceAdministrationParameterSequence', '00440019'), _defineProperty2(_keywordToTag, 'ApprovalSequence', '00440100'), _defineProperty2(_keywordToTag, 'AssertionCodeSequence', '00440101'), _defineProperty2(_keywordToTag, 'AssertionUID', '00440102'), _defineProperty2(_keywordToTag, 'AsserterIdentificationSequence', '00440103'), _defineProperty2(_keywordToTag, 'AssertionDateTime', '00440104'), _defineProperty2(_keywordToTag, 'AssertionExpirationDateTime', '00440105'), _defineProperty2(_keywordToTag, 'AssertionComments', '00440106'), _defineProperty2(_keywordToTag, 'RelatedAssertionSequence', '00440107'), _defineProperty2(_keywordToTag, 'ReferencedAssertionUID', '00440108'), _defineProperty2(_keywordToTag, 'ApprovalSubjectSequence', '00440109'), _defineProperty2(_keywordToTag, 'OrganizationalRoleCodeSequence', '0044010A'), _defineProperty2(_keywordToTag, 'LensDescription', '00460012'), _defineProperty2(_keywordToTag, 'RightLensSequence', '00460014'), _defineProperty2(_keywordToTag, 'LeftLensSequence', '00460015'), _defineProperty2(_keywordToTag, 'UnspecifiedLateralityLensSequence', '00460016'), _defineProperty2(_keywordToTag, 'CylinderSequence', '00460018'), _defineProperty2(_keywordToTag, 'PrismSequence', '00460028'), _defineProperty2(_keywordToTag, 'HorizontalPrismPower', '00460030'), _defineProperty2(_keywordToTag, 'HorizontalPrismBase', '00460032'), _defineProperty2(_keywordToTag, 'VerticalPrismPower', '00460034'), _defineProperty2(_keywordToTag, 'VerticalPrismBase', '00460036'), _defineProperty2(_keywordToTag, 'LensSegmentType', '00460038'), _defineProperty2(_keywordToTag, 'OpticalTransmittance', '00460040'), _defineProperty2(_keywordToTag, 'ChannelWidth', '00460042'), _defineProperty2(_keywordToTag, 'PupilSize', '00460044'), _defineProperty2(_keywordToTag, 'CornealSize', '00460046'), _defineProperty2(_keywordToTag, 'AutorefractionRightEyeSequence', '00460050'), _defineProperty2(_keywordToTag, 'AutorefractionLeftEyeSequence', '00460052'), _defineProperty2(_keywordToTag, 'DistancePupillaryDistance', '00460060'), _defineProperty2(_keywordToTag, 'NearPupillaryDistance', '00460062'), _defineProperty2(_keywordToTag, 'IntermediatePupillaryDistance', '00460063'), _defineProperty2(_keywordToTag, 'OtherPupillaryDistance', '00460064'), _defineProperty2(_keywordToTag, 'KeratometryRightEyeSequence', '00460070'), _defineProperty2(_keywordToTag, 'KeratometryLeftEyeSequence', '00460071'), _defineProperty2(_keywordToTag, 'SteepKeratometricAxisSequence', '00460074'), _defineProperty2(_keywordToTag, 'RadiusOfCurvature', '00460075'), _defineProperty2(_keywordToTag, 'KeratometricPower', '00460076'), _defineProperty2(_keywordToTag, 'KeratometricAxis', '00460077'), _defineProperty2(_keywordToTag, 'FlatKeratometricAxisSequence', '00460080'), _defineProperty2(_keywordToTag, 'BackgroundColor', '00460092'), _defineProperty2(_keywordToTag, 'Optotype', '00460094'), _defineProperty2(_keywordToTag, 'OptotypePresentation', '00460095'), _defineProperty2(_keywordToTag, 'SubjectiveRefractionRightEyeSequence', '00460097'), _defineProperty2(_keywordToTag, 'SubjectiveRefractionLeftEyeSequence', '00460098'), _defineProperty2(_keywordToTag, 'AddNearSequence', '00460100'), _defineProperty2(_keywordToTag, 'AddIntermediateSequence', '00460101'), _defineProperty2(_keywordToTag, 'AddOtherSequence', '00460102'), _defineProperty2(_keywordToTag, 'AddPower', '00460104'), _defineProperty2(_keywordToTag, 'ViewingDistance', '00460106'), _defineProperty2(_keywordToTag, 'VisualAcuityTypeCodeSequence', '00460121'), _defineProperty2(_keywordToTag, 'VisualAcuityRightEyeSequence', '00460122'), _defineProperty2(_keywordToTag, 'VisualAcuityLeftEyeSequence', '00460123'), _defineProperty2(_keywordToTag, 'VisualAcuityBothEyesOpenSequence', '00460124'), _defineProperty2(_keywordToTag, 'ViewingDistanceType', '00460125'), _defineProperty2(_keywordToTag, 'VisualAcuityModifiers', '00460135'), _defineProperty2(_keywordToTag, 'DecimalVisualAcuity', '00460137'), _defineProperty2(_keywordToTag, 'OptotypeDetailedDefinition', '00460139'), _defineProperty2(_keywordToTag, 'ReferencedRefractiveMeasurementsSequence', '00460145'), _defineProperty2(_keywordToTag, 'SpherePower', '00460146'), _defineProperty2(_keywordToTag, 'CylinderPower', '00460147'), _defineProperty2(_keywordToTag, 'CornealTopographySurface', '00460201'), _defineProperty2(_keywordToTag, 'CornealVertexLocation', '00460202'), _defineProperty2(_keywordToTag, 'PupilCentroidXCoordinate', '00460203'), _defineProperty2(_keywordToTag, 'PupilCentroidYCoordinate', '00460204'), _defineProperty2(_keywordToTag, 'EquivalentPupilRadius', '00460205'), _defineProperty2(_keywordToTag, 'CornealTopographyMapTypeCodeSequence', '00460207'), _defineProperty2(_keywordToTag, 'VerticesOfTheOutlineOfPupil', '00460208'), _defineProperty2(_keywordToTag, 'CornealTopographyMappingNormalsSequence', '00460210'), _defineProperty2(_keywordToTag, 'MaximumCornealCurvatureSequence', '00460211'), _defineProperty2(_keywordToTag, 'MaximumCornealCurvature', '00460212'), _defineProperty2(_keywordToTag, 'MaximumCornealCurvatureLocation', '00460213'), _defineProperty2(_keywordToTag, 'MinimumKeratometricSequence', '00460215'), _defineProperty2(_keywordToTag, 'SimulatedKeratometricCylinderSequence', '00460218'), _defineProperty2(_keywordToTag, 'AverageCornealPower', '00460220'), _defineProperty2(_keywordToTag, 'CornealISValue', '00460224'), _defineProperty2(_keywordToTag, 'AnalyzedArea', '00460227'), _defineProperty2(_keywordToTag, 'SurfaceRegularityIndex', '00460230'), _defineProperty2(_keywordToTag, 'SurfaceAsymmetryIndex', '00460232'), _defineProperty2(_keywordToTag, 'CornealEccentricityIndex', '00460234'), _defineProperty2(_keywordToTag, 'KeratoconusPredictionIndex', '00460236'), _defineProperty2(_keywordToTag, 'DecimalPotentialVisualAcuity', '00460238'), _defineProperty2(_keywordToTag, 'CornealTopographyMapQualityEvaluation', '00460242'), _defineProperty2(_keywordToTag, 'SourceImageCornealProcessedDataSequence', '00460244'), _defineProperty2(_keywordToTag, 'CornealPointLocation', '00460247'), _defineProperty2(_keywordToTag, 'CornealPointEstimated', '00460248'), _defineProperty2(_keywordToTag, 'AxialPower', '00460249'), _defineProperty2(_keywordToTag, 'TangentialPower', '00460250'), _defineProperty2(_keywordToTag, 'RefractivePower', '00460251'), _defineProperty2(_keywordToTag, 'RelativeElevation', '00460252'), _defineProperty2(_keywordToTag, 'CornealWavefront', '00460253'), _defineProperty2(_keywordToTag, 'ImagedVolumeWidth', '00480001'), _defineProperty2(_keywordToTag, 'ImagedVolumeHeight', '00480002'), _defineProperty2(_keywordToTag, 'ImagedVolumeDepth', '00480003'), _defineProperty2(_keywordToTag, 'TotalPixelMatrixColumns', '00480006'), _defineProperty2(_keywordToTag, 'TotalPixelMatrixRows', '00480007'), _defineProperty2(_keywordToTag, 'TotalPixelMatrixOriginSequence', '00480008'), _defineProperty2(_keywordToTag, 'SpecimenLabelInImage', '00480010'), _defineProperty2(_keywordToTag, 'FocusMethod', '00480011'), _defineProperty2(_keywordToTag, 'ExtendedDepthOfField', '00480012'), _defineProperty2(_keywordToTag, 'NumberOfFocalPlanes', '00480013'), _defineProperty2(_keywordToTag, 'DistanceBetweenFocalPlanes', '00480014'), _defineProperty2(_keywordToTag, 'RecommendedAbsentPixelCIELabValue', '00480015'), _defineProperty2(_keywordToTag, 'IlluminatorTypeCodeSequence', '00480100'), _defineProperty2(_keywordToTag, 'ImageOrientationSlide', '00480102'), _defineProperty2(_keywordToTag, 'OpticalPathSequence', '00480105'), _defineProperty2(_keywordToTag, 'OpticalPathIdentifier', '00480106'), _defineProperty2(_keywordToTag, 'OpticalPathDescription', '00480107'), _defineProperty2(_keywordToTag, 'IlluminationColorCodeSequence', '00480108'), _defineProperty2(_keywordToTag, 'SpecimenReferenceSequence', '00480110'), _defineProperty2(_keywordToTag, 'CondenserLensPower', '00480111'), _defineProperty2(_keywordToTag, 'ObjectiveLensPower', '00480112'), _defineProperty2(_keywordToTag, 'ObjectiveLensNumericalAperture', '00480113'), _defineProperty2(_keywordToTag, 'PaletteColorLookupTableSequence', '00480120'), _defineProperty2(_keywordToTag, 'ReferencedImageNavigationSequence', '00480200'), _defineProperty2(_keywordToTag, 'TopLeftHandCornerOfLocalizerArea', '00480201'), _defineProperty2(_keywordToTag, 'BottomRightHandCornerOfLocalizerArea', '00480202'), _defineProperty2(_keywordToTag, 'OpticalPathIdentificationSequence', '00480207'), _defineProperty2(_keywordToTag, 'PlanePositionSlideSequence', '0048021A'), _defineProperty2(_keywordToTag, 'ColumnPositionInTotalImagePixelMatrix', '0048021E'), _defineProperty2(_keywordToTag, 'RowPositionInTotalImagePixelMatrix', '0048021F'), _defineProperty2(_keywordToTag, 'PixelOriginInterpretation', '00480301'), _defineProperty2(_keywordToTag, 'NumberOfOpticalPaths', '00480302'), _defineProperty2(_keywordToTag, 'TotalPixelMatrixFocalPlanes', '00480303'), _defineProperty2(_keywordToTag, 'CalibrationImage', '00500004'), _defineProperty2(_keywordToTag, 'DeviceSequence', '00500010'), _defineProperty2(_keywordToTag, 'ContainerComponentTypeCodeSequence', '00500012'), _defineProperty2(_keywordToTag, 'ContainerComponentThickness', '00500013'), _defineProperty2(_keywordToTag, 'DeviceLength', '00500014'), _defineProperty2(_keywordToTag, 'ContainerComponentWidth', '00500015'), _defineProperty2(_keywordToTag, 'DeviceDiameter', '00500016'), _defineProperty2(_keywordToTag, 'DeviceDiameterUnits', '00500017'), _defineProperty2(_keywordToTag, 'DeviceVolume', '00500018'), _defineProperty2(_keywordToTag, 'InterMarkerDistance', '00500019'), _defineProperty2(_keywordToTag, 'ContainerComponentMaterial', '0050001A'), _defineProperty2(_keywordToTag, 'ContainerComponentID', '0050001B'), _defineProperty2(_keywordToTag, 'ContainerComponentLength', '0050001C'), _defineProperty2(_keywordToTag, 'ContainerComponentDiameter', '0050001D'), _defineProperty2(_keywordToTag, 'ContainerComponentDescription', '0050001E'), _defineProperty2(_keywordToTag, 'DeviceDescription', '00500020'), _defineProperty2(_keywordToTag, 'ContrastBolusIngredientPercentByVolume', '00520001'), _defineProperty2(_keywordToTag, 'OCTFocalDistance', '00520002'), _defineProperty2(_keywordToTag, 'BeamSpotSize', '00520003'), _defineProperty2(_keywordToTag, 'EffectiveRefractiveIndex', '00520004'), _defineProperty2(_keywordToTag, 'OCTAcquisitionDomain', '00520006'), _defineProperty2(_keywordToTag, 'OCTOpticalCenterWavelength', '00520007'), _defineProperty2(_keywordToTag, 'AxialResolution', '00520008'), _defineProperty2(_keywordToTag, 'RangingDepth', '00520009'), _defineProperty2(_keywordToTag, 'ALineRate', '00520011'), _defineProperty2(_keywordToTag, 'ALinesPerFrame', '00520012'), _defineProperty2(_keywordToTag, 'CatheterRotationalRate', '00520013'), _defineProperty2(_keywordToTag, 'ALinePixelSpacing', '00520014'), _defineProperty2(_keywordToTag, 'ModeOfPercutaneousAccessSequence', '00520016'), _defineProperty2(_keywordToTag, 'IntravascularOCTFrameTypeSequence', '00520025'), _defineProperty2(_keywordToTag, 'OCTZOffsetApplied', '00520026'), _defineProperty2(_keywordToTag, 'IntravascularFrameContentSequence', '00520027'), _defineProperty2(_keywordToTag, 'IntravascularLongitudinalDistance', '00520028'), _defineProperty2(_keywordToTag, 'IntravascularOCTFrameContentSequence', '00520029'), _defineProperty2(_keywordToTag, 'OCTZOffsetCorrection', '00520030'), _defineProperty2(_keywordToTag, 'CatheterDirectionOfRotation', '00520031'), _defineProperty2(_keywordToTag, 'SeamLineLocation', '00520033'), _defineProperty2(_keywordToTag, 'FirstALineLocation', '00520034'), _defineProperty2(_keywordToTag, 'SeamLineIndex', '00520036'), _defineProperty2(_keywordToTag, 'NumberOfPaddedALines', '00520038'), _defineProperty2(_keywordToTag, 'InterpolationType', '00520039'), _defineProperty2(_keywordToTag, 'RefractiveIndexApplied', '0052003A'), _defineProperty2(_keywordToTag, 'EnergyWindowVector', '00540010'), _defineProperty2(_keywordToTag, 'NumberOfEnergyWindows', '00540011'), _defineProperty2(_keywordToTag, 'EnergyWindowInformationSequence', '00540012'), _defineProperty2(_keywordToTag, 'EnergyWindowRangeSequence', '00540013'), _defineProperty2(_keywordToTag, 'EnergyWindowLowerLimit', '00540014'), _defineProperty2(_keywordToTag, 'EnergyWindowUpperLimit', '00540015'), _defineProperty2(_keywordToTag, 'RadiopharmaceuticalInformationSequence', '00540016'), _defineProperty2(_keywordToTag, 'ResidualSyringeCounts', '00540017'), _defineProperty2(_keywordToTag, 'EnergyWindowName', '00540018'), _defineProperty2(_keywordToTag, 'DetectorVector', '00540020'), _defineProperty2(_keywordToTag, 'NumberOfDetectors', '00540021'), _defineProperty2(_keywordToTag, 'DetectorInformationSequence', '00540022'), _defineProperty2(_keywordToTag, 'PhaseVector', '00540030'), _defineProperty2(_keywordToTag, 'NumberOfPhases', '00540031'), _defineProperty2(_keywordToTag, 'PhaseInformationSequence', '00540032'), _defineProperty2(_keywordToTag, 'NumberOfFramesInPhase', '00540033'), _defineProperty2(_keywordToTag, 'PhaseDelay', '00540036'), _defineProperty2(_keywordToTag, 'PauseBetweenFrames', '00540038'), _defineProperty2(_keywordToTag, 'PhaseDescription', '00540039'), _defineProperty2(_keywordToTag, 'RotationVector', '00540050'), _defineProperty2(_keywordToTag, 'NumberOfRotations', '00540051'), _defineProperty2(_keywordToTag, 'RotationInformationSequence', '00540052'), _defineProperty2(_keywordToTag, 'NumberOfFramesInRotation', '00540053'), _defineProperty2(_keywordToTag, 'RRIntervalVector', '00540060'), _defineProperty2(_keywordToTag, 'NumberOfRRIntervals', '00540061'), _defineProperty2(_keywordToTag, 'GatedInformationSequence', '00540062'), _defineProperty2(_keywordToTag, 'DataInformationSequence', '00540063'), _defineProperty2(_keywordToTag, 'TimeSlotVector', '00540070'), _defineProperty2(_keywordToTag, 'NumberOfTimeSlots', '00540071'), _defineProperty2(_keywordToTag, 'TimeSlotInformationSequence', '00540072'), _defineProperty2(_keywordToTag, 'TimeSlotTime', '00540073'), _defineProperty2(_keywordToTag, 'SliceVector', '00540080'), _defineProperty2(_keywordToTag, 'NumberOfSlices', '00540081'), _defineProperty2(_keywordToTag, 'AngularViewVector', '00540090'), _defineProperty2(_keywordToTag, 'TimeSliceVector', '00540100'), _defineProperty2(_keywordToTag, 'NumberOfTimeSlices', '00540101'), _defineProperty2(_keywordToTag, 'StartAngle', '00540200'), _defineProperty2(_keywordToTag, 'TypeOfDetectorMotion', '00540202'), _defineProperty2(_keywordToTag, 'TriggerVector', '00540210'), _defineProperty2(_keywordToTag, 'NumberOfTriggersInPhase', '00540211'), _defineProperty2(_keywordToTag, 'ViewCodeSequence', '00540220'), _defineProperty2(_keywordToTag, 'ViewModifierCodeSequence', '00540222'), _defineProperty2(_keywordToTag, 'RadionuclideCodeSequence', '00540300'), _defineProperty2(_keywordToTag, 'AdministrationRouteCodeSequence', '00540302'), _defineProperty2(_keywordToTag, 'RadiopharmaceuticalCodeSequence', '00540304'), _defineProperty2(_keywordToTag, 'CalibrationDataSequence', '00540306'), _defineProperty2(_keywordToTag, 'EnergyWindowNumber', '00540308'), _defineProperty2(_keywordToTag, 'ImageID', '00540400'), _defineProperty2(_keywordToTag, 'PatientOrientationCodeSequence', '00540410'), _defineProperty2(_keywordToTag, 'PatientOrientationModifierCodeSequence', '00540412'), _defineProperty2(_keywordToTag, 'PatientGantryRelationshipCodeSequence', '00540414'), _defineProperty2(_keywordToTag, 'SliceProgressionDirection', '00540500'), _defineProperty2(_keywordToTag, 'ScanProgressionDirection', '00540501'), _defineProperty2(_keywordToTag, 'SeriesType', '00541000'), _defineProperty2(_keywordToTag, 'Units', '00541001'), _defineProperty2(_keywordToTag, 'CountsSource', '00541002'), _defineProperty2(_keywordToTag, 'ReprojectionMethod', '00541004'), _defineProperty2(_keywordToTag, 'SUVType', '00541006'), _defineProperty2(_keywordToTag, 'RandomsCorrectionMethod', '00541100'), _defineProperty2(_keywordToTag, 'AttenuationCorrectionMethod', '00541101'), _defineProperty2(_keywordToTag, 'DecayCorrection', '00541102'), _defineProperty2(_keywordToTag, 'ReconstructionMethod', '00541103'), _defineProperty2(_keywordToTag, 'DetectorLinesOfResponseUsed', '00541104'), _defineProperty2(_keywordToTag, 'ScatterCorrectionMethod', '00541105'), _defineProperty2(_keywordToTag, 'AxialAcceptance', '00541200'), _defineProperty2(_keywordToTag, 'AxialMash', '00541201'), _defineProperty2(_keywordToTag, 'TransverseMash', '00541202'), _defineProperty2(_keywordToTag, 'DetectorElementSize', '00541203'), _defineProperty2(_keywordToTag, 'CoincidenceWindowWidth', '00541210'), _defineProperty2(_keywordToTag, 'SecondaryCountsType', '00541220'), _defineProperty2(_keywordToTag, 'FrameReferenceTime', '00541300'), _defineProperty2(_keywordToTag, 'PrimaryPromptsCountsAccumulated', '00541310'), _defineProperty2(_keywordToTag, 'SecondaryCountsAccumulated', '00541311'), _defineProperty2(_keywordToTag, 'SliceSensitivityFactor', '00541320'), _defineProperty2(_keywordToTag, 'DecayFactor', '00541321'), _defineProperty2(_keywordToTag, 'DoseCalibrationFactor', '00541322'), _defineProperty2(_keywordToTag, 'ScatterFractionFactor', '00541323'), _defineProperty2(_keywordToTag, 'DeadTimeFactor', '00541324'), _defineProperty2(_keywordToTag, 'ImageIndex', '00541330'), _defineProperty2(_keywordToTag, 'CountsIncluded', '00541400'), _defineProperty2(_keywordToTag, 'DeadTimeCorrectionFlag', '00541401'), _defineProperty2(_keywordToTag, 'HistogramSequence', '00603000'), _defineProperty2(_keywordToTag, 'HistogramNumberOfBins', '00603002'), _defineProperty2(_keywordToTag, 'HistogramFirstBinValue', '00603004'), _defineProperty2(_keywordToTag, 'HistogramLastBinValue', '00603006'), _defineProperty2(_keywordToTag, 'HistogramBinWidth', '00603008'), _defineProperty2(_keywordToTag, 'HistogramExplanation', '00603010'), _defineProperty2(_keywordToTag, 'HistogramData', '00603020'), _defineProperty2(_keywordToTag, 'SegmentationType', '00620001'), _defineProperty2(_keywordToTag, 'SegmentSequence', '00620002'), _defineProperty2(_keywordToTag, 'SegmentedPropertyCategoryCodeSequence', '00620003'), _defineProperty2(_keywordToTag, 'SegmentNumber', '00620004'), _defineProperty2(_keywordToTag, 'SegmentLabel', '00620005'), _defineProperty2(_keywordToTag, 'SegmentDescription', '00620006'), _defineProperty2(_keywordToTag, 'SegmentationAlgorithmIdentificationSequence', '00620007'), _defineProperty2(_keywordToTag, 'SegmentAlgorithmType', '00620008'), _defineProperty2(_keywordToTag, 'SegmentAlgorithmName', '00620009'), _defineProperty2(_keywordToTag, 'SegmentIdentificationSequence', '0062000A'), _defineProperty2(_keywordToTag, 'ReferencedSegmentNumber', '0062000B'), _defineProperty2(_keywordToTag, 'RecommendedDisplayGrayscaleValue', '0062000C'), _defineProperty2(_keywordToTag, 'RecommendedDisplayCIELabValue', '0062000D'), _defineProperty2(_keywordToTag, 'MaximumFractionalValue', '0062000E'), _defineProperty2(_keywordToTag, 'SegmentedPropertyTypeCodeSequence', '0062000F'), _defineProperty2(_keywordToTag, 'SegmentationFractionalType', '00620010'), _defineProperty2(_keywordToTag, 'SegmentedPropertyTypeModifierCodeSequence', '00620011'), _defineProperty2(_keywordToTag, 'UsedSegmentsSequence', '00620012'), _defineProperty2(_keywordToTag, 'TrackingID', '00620020'), _defineProperty2(_keywordToTag, 'TrackingUID', '00620021'), _defineProperty2(_keywordToTag, 'DeformableRegistrationSequence', '00640002'), _defineProperty2(_keywordToTag, 'SourceFrameOfReferenceUID', '00640003'), _defineProperty2(_keywordToTag, 'DeformableRegistrationGridSequence', '00640005'), _defineProperty2(_keywordToTag, 'GridDimensions', '00640007'), _defineProperty2(_keywordToTag, 'GridResolution', '00640008'), _defineProperty2(_keywordToTag, 'VectorGridData', '00640009'), _defineProperty2(_keywordToTag, 'PreDeformationMatrixRegistrationSequence', '0064000F'), _defineProperty2(_keywordToTag, 'PostDeformationMatrixRegistrationSequence', '00640010'), _defineProperty2(_keywordToTag, 'NumberOfSurfaces', '00660001'), _defineProperty2(_keywordToTag, 'SurfaceSequence', '00660002'), _defineProperty2(_keywordToTag, 'SurfaceNumber', '00660003'), _defineProperty2(_keywordToTag, 'SurfaceComments', '00660004'), _defineProperty2(_keywordToTag, 'SurfaceProcessing', '00660009'), _defineProperty2(_keywordToTag, 'SurfaceProcessingRatio', '0066000A'), _defineProperty2(_keywordToTag, 'SurfaceProcessingDescription', '0066000B'), _defineProperty2(_keywordToTag, 'RecommendedPresentationOpacity', '0066000C'), _defineProperty2(_keywordToTag, 'RecommendedPresentationType', '0066000D'), _defineProperty2(_keywordToTag, 'FiniteVolume', '0066000E'), _defineProperty2(_keywordToTag, 'Manifold', '00660010'), _defineProperty2(_keywordToTag, 'SurfacePointsSequence', '00660011'), _defineProperty2(_keywordToTag, 'SurfacePointsNormalsSequence', '00660012'), _defineProperty2(_keywordToTag, 'SurfaceMeshPrimitivesSequence', '00660013'), _defineProperty2(_keywordToTag, 'NumberOfSurfacePoints', '00660015'), _defineProperty2(_keywordToTag, 'PointCoordinatesData', '00660016'), _defineProperty2(_keywordToTag, 'PointPositionAccuracy', '00660017'), _defineProperty2(_keywordToTag, 'MeanPointDistance', '00660018'), _defineProperty2(_keywordToTag, 'MaximumPointDistance', '00660019'), _defineProperty2(_keywordToTag, 'PointsBoundingBoxCoordinates', '0066001A'), _defineProperty2(_keywordToTag, 'AxisOfRotation', '0066001B'), _defineProperty2(_keywordToTag, 'CenterOfRotation', '0066001C'), _defineProperty2(_keywordToTag, 'NumberOfVectors', '0066001E'), _defineProperty2(_keywordToTag, 'VectorDimensionality', '0066001F'), _defineProperty2(_keywordToTag, 'VectorAccuracy', '00660020'), _defineProperty2(_keywordToTag, 'VectorCoordinateData', '00660021'), _defineProperty2(_keywordToTag, 'TrianglePointIndexList', '00660023'), _defineProperty2(_keywordToTag, 'EdgePointIndexList', '00660024'), _defineProperty2(_keywordToTag, 'VertexPointIndexList', '00660025'), _defineProperty2(_keywordToTag, 'TriangleStripSequence', '00660026'), _defineProperty2(_keywordToTag, 'TriangleFanSequence', '00660027'), _defineProperty2(_keywordToTag, 'LineSequence', '00660028'), _defineProperty2(_keywordToTag, 'PrimitivePointIndexList', '00660029'), _defineProperty2(_keywordToTag, 'SurfaceCount', '0066002A'), _defineProperty2(_keywordToTag, 'ReferencedSurfaceSequence', '0066002B'), _defineProperty2(_keywordToTag, 'ReferencedSurfaceNumber', '0066002C'), _defineProperty2(_keywordToTag, 'SegmentSurfaceGenerationAlgorithmIdentificationSequence', '0066002D'), _defineProperty2(_keywordToTag, 'SegmentSurfaceSourceInstanceSequence', '0066002E'), _defineProperty2(_keywordToTag, 'AlgorithmFamilyCodeSequence', '0066002F'), _defineProperty2(_keywordToTag, 'AlgorithmNameCodeSequence', '00660030'), _defineProperty2(_keywordToTag, 'AlgorithmVersion', '00660031'), _defineProperty2(_keywordToTag, 'AlgorithmParameters', '00660032'), _defineProperty2(_keywordToTag, 'FacetSequence', '00660034'), _defineProperty2(_keywordToTag, 'SurfaceProcessingAlgorithmIdentificationSequence', '00660035'), _defineProperty2(_keywordToTag, 'AlgorithmName', '00660036'), _defineProperty2(_keywordToTag, 'RecommendedPointRadius', '00660037'), _defineProperty2(_keywordToTag, 'RecommendedLineThickness', '00660038'), _defineProperty2(_keywordToTag, 'LongPrimitivePointIndexList', '00660040'), _defineProperty2(_keywordToTag, 'LongTrianglePointIndexList', '00660041'), _defineProperty2(_keywordToTag, 'LongEdgePointIndexList', '00660042'), _defineProperty2(_keywordToTag, 'LongVertexPointIndexList', '00660043'), _defineProperty2(_keywordToTag, 'TrackSetSequence', '00660101'), _defineProperty2(_keywordToTag, 'TrackSequence', '00660102'), _defineProperty2(_keywordToTag, 'RecommendedDisplayCIELabValueList', '00660103'), _defineProperty2(_keywordToTag, 'TrackingAlgorithmIdentificationSequence', '00660104'), _defineProperty2(_keywordToTag, 'TrackSetNumber', '00660105'), _defineProperty2(_keywordToTag, 'TrackSetLabel', '00660106'), _defineProperty2(_keywordToTag, 'TrackSetDescription', '00660107'), _defineProperty2(_keywordToTag, 'TrackSetAnatomicalTypeCodeSequence', '00660108'), _defineProperty2(_keywordToTag, 'MeasurementsSequence', '00660121'), _defineProperty2(_keywordToTag, 'TrackSetStatisticsSequence', '00660124'), _defineProperty2(_keywordToTag, 'FloatingPointValues', '00660125'), _defineProperty2(_keywordToTag, 'TrackPointIndexList', '00660129'), _defineProperty2(_keywordToTag, 'TrackStatisticsSequence', '00660130'), _defineProperty2(_keywordToTag, 'MeasurementValuesSequence', '00660132'), _defineProperty2(_keywordToTag, 'DiffusionAcquisitionCodeSequence', '00660133'), _defineProperty2(_keywordToTag, 'DiffusionModelCodeSequence', '00660134'), _defineProperty2(_keywordToTag, 'ImplantSize', '00686210'), _defineProperty2(_keywordToTag, 'ImplantTemplateVersion', '00686221'), _defineProperty2(_keywordToTag, 'ReplacedImplantTemplateSequence', '00686222'), _defineProperty2(_keywordToTag, 'ImplantType', '00686223'), _defineProperty2(_keywordToTag, 'DerivationImplantTemplateSequence', '00686224'), _defineProperty2(_keywordToTag, 'OriginalImplantTemplateSequence', '00686225'), _defineProperty2(_keywordToTag, 'EffectiveDateTime', '00686226'), _defineProperty2(_keywordToTag, 'ImplantTargetAnatomySequence', '00686230'), _defineProperty2(_keywordToTag, 'InformationFromManufacturerSequence', '00686260'), _defineProperty2(_keywordToTag, 'NotificationFromManufacturerSequence', '00686265'), _defineProperty2(_keywordToTag, 'InformationIssueDateTime', '00686270'), _defineProperty2(_keywordToTag, 'InformationSummary', '00686280'), _defineProperty2(_keywordToTag, 'ImplantRegulatoryDisapprovalCodeSequence', '006862A0'), _defineProperty2(_keywordToTag, 'OverallTemplateSpatialTolerance', '006862A5'), _defineProperty2(_keywordToTag, 'HPGLDocumentSequence', '006862C0'), _defineProperty2(_keywordToTag, 'HPGLDocumentID', '006862D0'), _defineProperty2(_keywordToTag, 'HPGLDocumentLabel', '006862D5'), _defineProperty2(_keywordToTag, 'ViewOrientationCodeSequence', '006862E0'), _defineProperty2(_keywordToTag, 'ViewOrientationModifierCodeSequence', '006862F0'), _defineProperty2(_keywordToTag, 'HPGLDocumentScaling', '006862F2'), _defineProperty2(_keywordToTag, 'HPGLDocument', '00686300'), _defineProperty2(_keywordToTag, 'HPGLContourPenNumber', '00686310'), _defineProperty2(_keywordToTag, 'HPGLPenSequence', '00686320'), _defineProperty2(_keywordToTag, 'HPGLPenNumber', '00686330'), _defineProperty2(_keywordToTag, 'HPGLPenLabel', '00686340'), _defineProperty2(_keywordToTag, 'HPGLPenDescription', '00686345'), _defineProperty2(_keywordToTag, 'RecommendedRotationPoint', '00686346'), _defineProperty2(_keywordToTag, 'BoundingRectangle', '00686347'), _defineProperty2(_keywordToTag, '00686350', 'ImplantTemplate3DModelSurfaceNumber'), _defineProperty2(_keywordToTag, 'SurfaceModelDescriptionSequence', '00686360'), _defineProperty2(_keywordToTag, 'SurfaceModelLabel', '00686380'), _defineProperty2(_keywordToTag, 'SurfaceModelScalingFactor', '00686390'), _defineProperty2(_keywordToTag, 'MaterialsCodeSequence', '006863A0'), _defineProperty2(_keywordToTag, 'CoatingMaterialsCodeSequence', '006863A4'), _defineProperty2(_keywordToTag, 'ImplantTypeCodeSequence', '006863A8'), _defineProperty2(_keywordToTag, 'FixationMethodCodeSequence', '006863AC'), _defineProperty2(_keywordToTag, 'MatingFeatureSetsSequence', '006863B0'), _defineProperty2(_keywordToTag, 'MatingFeatureSetID', '006863C0'), _defineProperty2(_keywordToTag, 'MatingFeatureSetLabel', '006863D0'), _defineProperty2(_keywordToTag, 'MatingFeatureSequence', '006863E0'), _defineProperty2(_keywordToTag, 'MatingFeatureID', '006863F0'), _defineProperty2(_keywordToTag, 'MatingFeatureDegreeOfFreedomSequence', '00686400'), _defineProperty2(_keywordToTag, 'DegreeOfFreedomID', '00686410'), _defineProperty2(_keywordToTag, 'DegreeOfFreedomType', '00686420'), _defineProperty2(_keywordToTag, 'TwoDMatingFeatureCoordinatesSequence', '00686430'), _defineProperty2(_keywordToTag, 'ReferencedHPGLDocumentID', '00686440'), _defineProperty2(_keywordToTag, 'TwoDMatingPoint', '00686450'), _defineProperty2(_keywordToTag, 'TwoDMatingAxes', '00686460'), _defineProperty2(_keywordToTag, 'TwoDDegreeOfFreedomSequence', '00686470'), _defineProperty2(_keywordToTag, 'ThreeDDegreeOfFreedomAxis', '00686490'), _defineProperty2(_keywordToTag, 'RangeOfFreedom', '006864A0'), _defineProperty2(_keywordToTag, 'ThreeDMatingPoint', '006864C0'), _defineProperty2(_keywordToTag, 'ThreeDMatingAxes', '006864D0'), _defineProperty2(_keywordToTag, 'TwoDDegreeOfFreedomAxis', '006864F0'), _defineProperty2(_keywordToTag, 'PlanningLandmarkPointSequence', '00686500'), _defineProperty2(_keywordToTag, 'PlanningLandmarkLineSequence', '00686510'), _defineProperty2(_keywordToTag, 'PlanningLandmarkPlaneSequence', '00686520'), _defineProperty2(_keywordToTag, 'PlanningLandmarkID', '00686530'), _defineProperty2(_keywordToTag, 'PlanningLandmarkDescription', '00686540'), _defineProperty2(_keywordToTag, 'PlanningLandmarkIdentificationCodeSequence', '00686545'), _defineProperty2(_keywordToTag, 'TwoDPointCoordinatesSequence', '00686550'), _defineProperty2(_keywordToTag, 'TwoDPointCoordinates', '00686560'), _defineProperty2(_keywordToTag, 'ThreeDPointCoordinates', '00686590'), _defineProperty2(_keywordToTag, 'TwoDLineCoordinatesSequence', '006865A0'), _defineProperty2(_keywordToTag, 'TwoDLineCoordinates', '006865B0'), _defineProperty2(_keywordToTag, 'ThreeDLineCoordinates', '006865D0'), _defineProperty2(_keywordToTag, 'TwoDPlaneCoordinatesSequence', '006865E0'), _defineProperty2(_keywordToTag, 'TwoDPlaneIntersection', '006865F0'), _defineProperty2(_keywordToTag, 'ThreeDPlaneOrigin', '00686610'), _defineProperty2(_keywordToTag, 'ThreeDPlaneNormal', '00686620'), _defineProperty2(_keywordToTag, 'ModelModification', '00687001'), _defineProperty2(_keywordToTag, 'ModelMirroring', '00687002'), _defineProperty2(_keywordToTag, 'ModelUsageCodeSequence', '00687003'), _defineProperty2(_keywordToTag, 'GraphicAnnotationSequence', '00700001'), _defineProperty2(_keywordToTag, 'GraphicLayer', '00700002'), _defineProperty2(_keywordToTag, 'BoundingBoxAnnotationUnits', '00700003'), _defineProperty2(_keywordToTag, 'AnchorPointAnnotationUnits', '00700004'), _defineProperty2(_keywordToTag, 'GraphicAnnotationUnits', '00700005'), _defineProperty2(_keywordToTag, 'UnformattedTextValue', '00700006'), _defineProperty2(_keywordToTag, 'TextObjectSequence', '00700008'), _defineProperty2(_keywordToTag, 'GraphicObjectSequence', '00700009'), _defineProperty2(_keywordToTag, 'BoundingBoxTopLeftHandCorner', '00700010'), _defineProperty2(_keywordToTag, 'BoundingBoxBottomRightHandCorner', '00700011'), _defineProperty2(_keywordToTag, 'BoundingBoxTextHorizontalJustification', '00700012'), _defineProperty2(_keywordToTag, 'AnchorPoint', '00700014'), _defineProperty2(_keywordToTag, 'AnchorPointVisibility', '00700015'), _defineProperty2(_keywordToTag, 'GraphicDimensions', '00700020'), _defineProperty2(_keywordToTag, 'NumberOfGraphicPoints', '00700021'), _defineProperty2(_keywordToTag, 'GraphicData', '00700022'), _defineProperty2(_keywordToTag, 'GraphicType', '00700023'), _defineProperty2(_keywordToTag, 'GraphicFilled', '00700024'), _defineProperty2(_keywordToTag, 'ImageRotationRetired', '00700040'), _defineProperty2(_keywordToTag, 'ImageHorizontalFlip', '00700041'), _defineProperty2(_keywordToTag, 'ImageRotation', '00700042'), _defineProperty2(_keywordToTag, 'DisplayedAreaTopLeftHandCornerTrial', '00700050'), _defineProperty2(_keywordToTag, 'DisplayedAreaBottomRightHandCornerTrial', '00700051'), _defineProperty2(_keywordToTag, 'DisplayedAreaTopLeftHandCorner', '00700052'), _defineProperty2(_keywordToTag, 'DisplayedAreaBottomRightHandCorner', '00700053'), _defineProperty2(_keywordToTag, 'DisplayedAreaSelectionSequence', '0070005A'), _defineProperty2(_keywordToTag, 'GraphicLayerSequence', '00700060'), _defineProperty2(_keywordToTag, 'GraphicLayerOrder', '00700062'), _defineProperty2(_keywordToTag, 'GraphicLayerRecommendedDisplayGrayscaleValue', '00700066'), _defineProperty2(_keywordToTag, 'GraphicLayerRecommendedDisplayRGBValue', '00700067'), _defineProperty2(_keywordToTag, 'GraphicLayerDescription', '00700068'), _defineProperty2(_keywordToTag, 'ContentLabel', '00700080'), _defineProperty2(_keywordToTag, 'ContentDescription', '00700081'), _defineProperty2(_keywordToTag, 'PresentationCreationDate', '00700082'), _defineProperty2(_keywordToTag, 'PresentationCreationTime', '00700083'), _defineProperty2(_keywordToTag, 'ContentCreatorName', '00700084'), _defineProperty2(_keywordToTag, 'ContentCreatorIdentificationCodeSequence', '00700086'), _defineProperty2(_keywordToTag, 'AlternateContentDescriptionSequence', '00700087'), _defineProperty2(_keywordToTag, 'PresentationSizeMode', '00700100'), _defineProperty2(_keywordToTag, 'PresentationPixelSpacing', '00700101'), _defineProperty2(_keywordToTag, 'PresentationPixelAspectRatio', '00700102'), _defineProperty2(_keywordToTag, 'PresentationPixelMagnificationRatio', '00700103'), _defineProperty2(_keywordToTag, 'GraphicGroupLabel', '00700207'), _defineProperty2(_keywordToTag, 'GraphicGroupDescription', '00700208'), _defineProperty2(_keywordToTag, 'CompoundGraphicSequence', '00700209'), _defineProperty2(_keywordToTag, 'CompoundGraphicInstanceID', '00700226'), _defineProperty2(_keywordToTag, 'FontName', '00700227'), _defineProperty2(_keywordToTag, 'FontNameType', '00700228'), _defineProperty2(_keywordToTag, 'CSSFontName', '00700229'), _defineProperty2(_keywordToTag, 'RotationAngle', '00700230'), _defineProperty2(_keywordToTag, 'TextStyleSequence', '00700231'), _defineProperty2(_keywordToTag, 'LineStyleSequence', '00700232'), _defineProperty2(_keywordToTag, 'FillStyleSequence', '00700233'), _defineProperty2(_keywordToTag, 'GraphicGroupSequence', '00700234'), _defineProperty2(_keywordToTag, 'TextColorCIELabValue', '00700241'), _defineProperty2(_keywordToTag, 'HorizontalAlignment', '00700242'), _defineProperty2(_keywordToTag, 'VerticalAlignment', '00700243'), _defineProperty2(_keywordToTag, 'ShadowStyle', '00700244'), _defineProperty2(_keywordToTag, 'ShadowOffsetX', '00700245'), _defineProperty2(_keywordToTag, 'ShadowOffsetY', '00700246'), _defineProperty2(_keywordToTag, 'ShadowColorCIELabValue', '00700247'), _defineProperty2(_keywordToTag, 'Underlined', '00700248'), _defineProperty2(_keywordToTag, 'Bold', '00700249'), _defineProperty2(_keywordToTag, 'Italic', '00700250'), _defineProperty2(_keywordToTag, 'PatternOnColorCIELabValue', '00700251'), _defineProperty2(_keywordToTag, 'PatternOffColorCIELabValue', '00700252'), _defineProperty2(_keywordToTag, 'LineThickness', '00700253'), _defineProperty2(_keywordToTag, 'LineDashingStyle', '00700254'), _defineProperty2(_keywordToTag, 'LinePattern', '00700255'), _defineProperty2(_keywordToTag, 'FillPattern', '00700256'), _defineProperty2(_keywordToTag, 'FillMode', '00700257'), _defineProperty2(_keywordToTag, 'ShadowOpacity', '00700258'), _defineProperty2(_keywordToTag, 'GapLength', '00700261'), _defineProperty2(_keywordToTag, 'DiameterOfVisibility', '00700262'), _defineProperty2(_keywordToTag, 'RotationPoint', '00700273'), _defineProperty2(_keywordToTag, 'TickAlignment', '00700274'), _defineProperty2(_keywordToTag, 'ShowTickLabel', '00700278'), _defineProperty2(_keywordToTag, 'TickLabelAlignment', '00700279'), _defineProperty2(_keywordToTag, 'CompoundGraphicUnits', '00700282'), _defineProperty2(_keywordToTag, 'PatternOnOpacity', '00700284'), _defineProperty2(_keywordToTag, 'PatternOffOpacity', '00700285'), _defineProperty2(_keywordToTag, 'MajorTicksSequence', '00700287'), _defineProperty2(_keywordToTag, 'TickPosition', '00700288'), _defineProperty2(_keywordToTag, 'TickLabel', '00700289'), _defineProperty2(_keywordToTag, 'CompoundGraphicType', '00700294'), _defineProperty2(_keywordToTag, 'GraphicGroupID', '00700295'), _defineProperty2(_keywordToTag, 'ShapeType', '00700306'), _defineProperty2(_keywordToTag, 'RegistrationSequence', '00700308'), _defineProperty2(_keywordToTag, 'MatrixRegistrationSequence', '00700309'), _defineProperty2(_keywordToTag, 'MatrixSequence', '0070030A'), _defineProperty2(_keywordToTag, 'FrameOfReferenceToDisplayedCoordinateSystemTransformationMatrix', '0070030B'), _defineProperty2(_keywordToTag, 'FrameOfReferenceTransformationMatrixType', '0070030C'), _defineProperty2(_keywordToTag, 'RegistrationTypeCodeSequence', '0070030D'), _defineProperty2(_keywordToTag, 'FiducialDescription', '0070030F'), _defineProperty2(_keywordToTag, 'FiducialIdentifier', '00700310'), _defineProperty2(_keywordToTag, 'FiducialIdentifierCodeSequence', '00700311'), _defineProperty2(_keywordToTag, 'ContourUncertaintyRadius', '00700312'), _defineProperty2(_keywordToTag, 'UsedFiducialsSequence', '00700314'), _defineProperty2(_keywordToTag, 'GraphicCoordinatesDataSequence', '00700318'), _defineProperty2(_keywordToTag, 'FiducialUID', '0070031A'), _defineProperty2(_keywordToTag, 'ReferencedFiducialUID', '0070031B'), _defineProperty2(_keywordToTag, 'FiducialSetSequence', '0070031C'), _defineProperty2(_keywordToTag, 'FiducialSequence', '0070031E'), _defineProperty2(_keywordToTag, 'FiducialsPropertyCategoryCodeSequence', '0070031F'), _defineProperty2(_keywordToTag, 'GraphicLayerRecommendedDisplayCIELabValue', '00700401'), _defineProperty2(_keywordToTag, 'BlendingSequence', '00700402'), _defineProperty2(_keywordToTag, 'RelativeOpacity', '00700403'), _defineProperty2(_keywordToTag, 'ReferencedSpatialRegistrationSequence', '00700404'), _defineProperty2(_keywordToTag, 'BlendingPosition', '00700405'), _defineProperty2(_keywordToTag, 'PresentationDisplayCollectionUID', '00701101'), _defineProperty2(_keywordToTag, 'PresentationSequenceCollectionUID', '00701102'), _defineProperty2(_keywordToTag, 'PresentationSequencePositionIndex', '00701103'), _defineProperty2(_keywordToTag, 'RenderedImageReferenceSequence', '00701104'), _defineProperty2(_keywordToTag, 'VolumetricPresentationStateInputSequence', '00701201'), _defineProperty2(_keywordToTag, 'PresentationInputType', '00701202'), _defineProperty2(_keywordToTag, 'InputSequencePositionIndex', '00701203'), _defineProperty2(_keywordToTag, 'Crop', '00701204'), _defineProperty2(_keywordToTag, 'CroppingSpecificationIndex', '00701205'), _defineProperty2(_keywordToTag, 'CompositingMethod', '00701206'), _defineProperty2(_keywordToTag, 'VolumetricPresentationInputNumber', '00701207'), _defineProperty2(_keywordToTag, 'ImageVolumeGeometry', '00701208'), _defineProperty2(_keywordToTag, 'VolumetricPresentationInputSetUID', '00701209'), _defineProperty2(_keywordToTag, 'VolumetricPresentationInputSetSequence', '0070120A'), _defineProperty2(_keywordToTag, 'GlobalCrop', '0070120B'), _defineProperty2(_keywordToTag, 'GlobalCroppingSpecificationIndex', '0070120C'), _defineProperty2(_keywordToTag, 'RenderingMethod', '0070120D'), _defineProperty2(_keywordToTag, 'VolumeCroppingSequence', '00701301'), _defineProperty2(_keywordToTag, 'VolumeCroppingMethod', '00701302'), _defineProperty2(_keywordToTag, 'BoundingBoxCrop', '00701303'), _defineProperty2(_keywordToTag, 'ObliqueCroppingPlaneSequence', '00701304'), _defineProperty2(_keywordToTag, 'Plane', '00701305'), _defineProperty2(_keywordToTag, 'PlaneNormal', '00701306'), _defineProperty2(_keywordToTag, 'CroppingSpecificationNumber', '00701309'), _defineProperty2(_keywordToTag, 'MultiPlanarReconstructionStyle', '00701501'), _defineProperty2(_keywordToTag, 'MPRThicknessType', '00701502'), _defineProperty2(_keywordToTag, 'MPRSlabThickness', '00701503'), _defineProperty2(_keywordToTag, 'MPRTopLeftHandCorner', '00701505'), _defineProperty2(_keywordToTag, 'MPRViewWidthDirection', '00701507'), _defineProperty2(_keywordToTag, 'MPRViewWidth', '00701508'), _defineProperty2(_keywordToTag, 'NumberOfVolumetricCurvePoints', '0070150C'), _defineProperty2(_keywordToTag, 'VolumetricCurvePoints', '0070150D'), _defineProperty2(_keywordToTag, 'MPRViewHeightDirection', '00701511'), _defineProperty2(_keywordToTag, 'MPRViewHeight', '00701512'), _defineProperty2(_keywordToTag, 'RenderProjection', '00701602'), _defineProperty2(_keywordToTag, 'ViewpointPosition', '00701603'), _defineProperty2(_keywordToTag, 'ViewpointLookAtPoint', '00701604'), _defineProperty2(_keywordToTag, 'ViewpointUpDirection', '00701605'), _defineProperty2(_keywordToTag, 'RenderFieldOfView', '00701606'), _defineProperty2(_keywordToTag, 'SamplingStepSize', '00701607'), _defineProperty2(_keywordToTag, 'ShadingStyle', '00701701'), _defineProperty2(_keywordToTag, 'AmbientReflectionIntensity', '00701702'), _defineProperty2(_keywordToTag, 'LightDirection', '00701703'), _defineProperty2(_keywordToTag, 'DiffuseReflectionIntensity', '00701704'), _defineProperty2(_keywordToTag, 'SpecularReflectionIntensity', '00701705'), _defineProperty2(_keywordToTag, 'Shininess', '00701706'), _defineProperty2(_keywordToTag, 'PresentationStateClassificationComponentSequence', '00701801'), _defineProperty2(_keywordToTag, 'ComponentType', '00701802'), _defineProperty2(_keywordToTag, 'ComponentInputSequence', '00701803'), _defineProperty2(_keywordToTag, 'VolumetricPresentationInputIndex', '00701804'), _defineProperty2(_keywordToTag, 'PresentationStateCompositorComponentSequence', '00701805'), _defineProperty2(_keywordToTag, 'WeightingTransferFunctionSequence', '00701806'), _defineProperty2(_keywordToTag, 'WeightingLookupTableDescriptor', '00701807'), _defineProperty2(_keywordToTag, 'WeightingLookupTableData', '00701808'), _defineProperty2(_keywordToTag, 'VolumetricAnnotationSequence', '00701901'), _defineProperty2(_keywordToTag, 'ReferencedStructuredContextSequence', '00701903'), _defineProperty2(_keywordToTag, 'ReferencedContentItem', '00701904'), _defineProperty2(_keywordToTag, 'VolumetricPresentationInputAnnotationSequence', '00701905'), _defineProperty2(_keywordToTag, 'AnnotationClipping', '00701907'), _defineProperty2(_keywordToTag, 'PresentationAnimationStyle', '00701A01'), _defineProperty2(_keywordToTag, 'RecommendedAnimationRate', '00701A03'), _defineProperty2(_keywordToTag, 'AnimationCurveSequence', '00701A04'), _defineProperty2(_keywordToTag, 'AnimationStepSize', '00701A05'), _defineProperty2(_keywordToTag, 'SwivelRange', '00701A06'), _defineProperty2(_keywordToTag, 'VolumetricCurveUpDirections', '00701A07'), _defineProperty2(_keywordToTag, 'VolumeStreamSequence', '00701A08'), _defineProperty2(_keywordToTag, 'RGBATransferFunctionDescription', '00701A09'), _defineProperty2(_keywordToTag, 'AdvancedBlendingSequence', '00701B01'), _defineProperty2(_keywordToTag, 'BlendingInputNumber', '00701B02'), _defineProperty2(_keywordToTag, 'BlendingDisplayInputSequence', '00701B03'), _defineProperty2(_keywordToTag, 'BlendingDisplaySequence', '00701B04'), _defineProperty2(_keywordToTag, 'BlendingMode', '00701B06'), _defineProperty2(_keywordToTag, 'TimeSeriesBlending', '00701B07'), _defineProperty2(_keywordToTag, 'GeometryForDisplay', '00701B08'), _defineProperty2(_keywordToTag, 'ThresholdSequence', '00701B11'), _defineProperty2(_keywordToTag, 'ThresholdValueSequence', '00701B12'), _defineProperty2(_keywordToTag, 'ThresholdType', '00701B13'), _defineProperty2(_keywordToTag, 'ThresholdValue', '00701B14'), _defineProperty2(_keywordToTag, 'HangingProtocolName', '00720002'), _defineProperty2(_keywordToTag, 'HangingProtocolDescription', '00720004'), _defineProperty2(_keywordToTag, 'HangingProtocolLevel', '00720006'), _defineProperty2(_keywordToTag, 'HangingProtocolCreator', '00720008'), _defineProperty2(_keywordToTag, 'HangingProtocolCreationDateTime', '0072000A'), _defineProperty2(_keywordToTag, 'HangingProtocolDefinitionSequence', '0072000C'), _defineProperty2(_keywordToTag, 'HangingProtocolUserIdentificationCodeSequence', '0072000E'), _defineProperty2(_keywordToTag, 'HangingProtocolUserGroupName', '00720010'), _defineProperty2(_keywordToTag, 'SourceHangingProtocolSequence', '00720012'), _defineProperty2(_keywordToTag, 'NumberOfPriorsReferenced', '00720014'), _defineProperty2(_keywordToTag, 'ImageSetsSequence', '00720020'), _defineProperty2(_keywordToTag, 'ImageSetSelectorSequence', '00720022'), _defineProperty2(_keywordToTag, 'ImageSetSelectorUsageFlag', '00720024'), _defineProperty2(_keywordToTag, 'SelectorAttribute', '00720026'), _defineProperty2(_keywordToTag, 'SelectorValueNumber', '00720028'), _defineProperty2(_keywordToTag, 'TimeBasedImageSetsSequence', '00720030'), _defineProperty2(_keywordToTag, 'ImageSetNumber', '00720032'), _defineProperty2(_keywordToTag, 'ImageSetSelectorCategory', '00720034'), _defineProperty2(_keywordToTag, 'RelativeTime', '00720038'), _defineProperty2(_keywordToTag, 'RelativeTimeUnits', '0072003A'), _defineProperty2(_keywordToTag, 'AbstractPriorValue', '0072003C'), _defineProperty2(_keywordToTag, 'AbstractPriorCodeSequence', '0072003E'), _defineProperty2(_keywordToTag, 'ImageSetLabel', '00720040'), _defineProperty2(_keywordToTag, 'SelectorAttributeVR', '00720050'), _defineProperty2(_keywordToTag, 'SelectorSequencePointer', '00720052'), _defineProperty2(_keywordToTag, 'SelectorSequencePointerPrivateCreator', '00720054'), _defineProperty2(_keywordToTag, 'SelectorAttributePrivateCreator', '00720056'), _defineProperty2(_keywordToTag, 'SelectorAEValue', '0072005E'), _defineProperty2(_keywordToTag, 'SelectorASValue', '0072005F'), _defineProperty2(_keywordToTag, 'SelectorATValue', '00720060'), _defineProperty2(_keywordToTag, 'SelectorDAValue', '00720061'), _defineProperty2(_keywordToTag, 'SelectorCSValue', '00720062'), _defineProperty2(_keywordToTag, 'SelectorDTValue', '00720063'), _defineProperty2(_keywordToTag, 'SelectorISValue', '00720064'), _defineProperty2(_keywordToTag, 'SelectorOBValue', '00720065'), _defineProperty2(_keywordToTag, 'SelectorLOValue', '00720066'), _defineProperty2(_keywordToTag, 'SelectorOFValue', '00720067'), _defineProperty2(_keywordToTag, 'SelectorLTValue', '00720068'), _defineProperty2(_keywordToTag, 'SelectorOWValue', '00720069'), _defineProperty2(_keywordToTag, 'SelectorPNValue', '0072006A'), _defineProperty2(_keywordToTag, 'SelectorTMValue', '0072006B'), _defineProperty2(_keywordToTag, 'SelectorSHValue', '0072006C'), _defineProperty2(_keywordToTag, 'SelectorUNValue', '0072006D'), _defineProperty2(_keywordToTag, 'SelectorSTValue', '0072006E'), _defineProperty2(_keywordToTag, 'SelectorUCValue', '0072006F'), _defineProperty2(_keywordToTag, 'SelectorUTValue', '00720070'), _defineProperty2(_keywordToTag, 'SelectorURValue', '00720071'), _defineProperty2(_keywordToTag, 'SelectorDSValue', '00720072'), _defineProperty2(_keywordToTag, 'SelectorODValue', '00720073'), _defineProperty2(_keywordToTag, 'SelectorFDValue', '00720074'), _defineProperty2(_keywordToTag, 'SelectorOLValue', '00720075'), _defineProperty2(_keywordToTag, 'SelectorFLValue', '00720076'), _defineProperty2(_keywordToTag, 'SelectorULValue', '00720078'), _defineProperty2(_keywordToTag, 'SelectorUSValue', '0072007A'), _defineProperty2(_keywordToTag, 'SelectorSLValue', '0072007C'), _defineProperty2(_keywordToTag, 'SelectorSSValue', '0072007E'), _defineProperty2(_keywordToTag, 'SelectorUIValue', '0072007F'), _defineProperty2(_keywordToTag, 'SelectorCodeSequenceValue', '00720080'), _defineProperty2(_keywordToTag, 'NumberOfScreens', '00720100'), _defineProperty2(_keywordToTag, 'NominalScreenDefinitionSequence', '00720102'), _defineProperty2(_keywordToTag, 'NumberOfVerticalPixels', '00720104'), _defineProperty2(_keywordToTag, 'NumberOfHorizontalPixels', '00720106'), _defineProperty2(_keywordToTag, 'DisplayEnvironmentSpatialPosition', '00720108'), _defineProperty2(_keywordToTag, 'ScreenMinimumGrayscaleBitDepth', '0072010A'), _defineProperty2(_keywordToTag, 'ScreenMinimumColorBitDepth', '0072010C'), _defineProperty2(_keywordToTag, 'ApplicationMaximumRepaintTime', '0072010E'), _defineProperty2(_keywordToTag, 'DisplaySetsSequence', '00720200'), _defineProperty2(_keywordToTag, 'DisplaySetNumber', '00720202'), _defineProperty2(_keywordToTag, 'DisplaySetLabel', '00720203'), _defineProperty2(_keywordToTag, 'DisplaySetPresentationGroup', '00720204'), _defineProperty2(_keywordToTag, 'DisplaySetPresentationGroupDescription', '00720206'), _defineProperty2(_keywordToTag, 'PartialDataDisplayHandling', '00720208'), _defineProperty2(_keywordToTag, 'SynchronizedScrollingSequence', '00720210'), _defineProperty2(_keywordToTag, 'DisplaySetScrollingGroup', '00720212'), _defineProperty2(_keywordToTag, 'NavigationIndicatorSequence', '00720214'), _defineProperty2(_keywordToTag, 'NavigationDisplaySet', '00720216'), _defineProperty2(_keywordToTag, 'ReferenceDisplaySets', '00720218'), _defineProperty2(_keywordToTag, 'ImageBoxesSequence', '00720300'), _defineProperty2(_keywordToTag, 'ImageBoxNumber', '00720302'), _defineProperty2(_keywordToTag, 'ImageBoxLayoutType', '00720304'), _defineProperty2(_keywordToTag, 'ImageBoxTileHorizontalDimension', '00720306'), _defineProperty2(_keywordToTag, 'ImageBoxTileVerticalDimension', '00720308'), _defineProperty2(_keywordToTag, 'ImageBoxScrollDirection', '00720310'), _defineProperty2(_keywordToTag, 'ImageBoxSmallScrollType', '00720312'), _defineProperty2(_keywordToTag, 'ImageBoxSmallScrollAmount', '00720314'), _defineProperty2(_keywordToTag, 'ImageBoxLargeScrollType', '00720316'), _defineProperty2(_keywordToTag, 'ImageBoxLargeScrollAmount', '00720318'), _defineProperty2(_keywordToTag, 'ImageBoxOverlapPriority', '00720320'), _defineProperty2(_keywordToTag, 'CineRelativeToRealTime', '00720330'), _defineProperty2(_keywordToTag, 'FilterOperationsSequence', '00720400'), _defineProperty2(_keywordToTag, 'FilterByCategory', '00720402'), _defineProperty2(_keywordToTag, 'FilterByAttributePresence', '00720404'), _defineProperty2(_keywordToTag, 'FilterByOperator', '00720406'), _defineProperty2(_keywordToTag, 'StructuredDisplayBackgroundCIELabValue', '00720420'), _defineProperty2(_keywordToTag, 'EmptyImageBoxCIELabValue', '00720421'), _defineProperty2(_keywordToTag, 'StructuredDisplayImageBoxSequence', '00720422'), _defineProperty2(_keywordToTag, 'StructuredDisplayTextBoxSequence', '00720424'), _defineProperty2(_keywordToTag, 'ReferencedFirstFrameSequence', '00720427'), _defineProperty2(_keywordToTag, 'ImageBoxSynchronizationSequence', '00720430'), _defineProperty2(_keywordToTag, 'SynchronizedImageBoxList', '00720432'), _defineProperty2(_keywordToTag, 'TypeOfSynchronization', '00720434'), _defineProperty2(_keywordToTag, 'BlendingOperationType', '00720500'), _defineProperty2(_keywordToTag, 'ReformattingOperationType', '00720510'), _defineProperty2(_keywordToTag, 'ReformattingThickness', '00720512'), _defineProperty2(_keywordToTag, 'ReformattingInterval', '00720514'), _defineProperty2(_keywordToTag, 'ReformattingOperationInitialViewDirection', '00720516'), _defineProperty2(_keywordToTag, 'ThreeDRenderingType', '00720520'), _defineProperty2(_keywordToTag, 'SortingOperationsSequence', '00720600'), _defineProperty2(_keywordToTag, 'SortByCategory', '00720602'), _defineProperty2(_keywordToTag, 'SortingDirection', '00720604'), _defineProperty2(_keywordToTag, 'DisplaySetPatientOrientation', '00720700'), _defineProperty2(_keywordToTag, 'VOIType', '00720702'), _defineProperty2(_keywordToTag, 'PseudoColorType', '00720704'), _defineProperty2(_keywordToTag, 'PseudoColorPaletteInstanceReferenceSequence', '00720705'), _defineProperty2(_keywordToTag, 'ShowGrayscaleInverted', '00720706'), _defineProperty2(_keywordToTag, 'ShowImageTrueSizeFlag', '00720710'), _defineProperty2(_keywordToTag, 'ShowGraphicAnnotationFlag', '00720712'), _defineProperty2(_keywordToTag, 'ShowPatientDemographicsFlag', '00720714'), _defineProperty2(_keywordToTag, 'ShowAcquisitionTechniquesFlag', '00720716'), _defineProperty2(_keywordToTag, 'DisplaySetHorizontalJustification', '00720717'), _defineProperty2(_keywordToTag, 'DisplaySetVerticalJustification', '00720718'), _defineProperty2(_keywordToTag, 'ContinuationStartMeterset', '00740120'), _defineProperty2(_keywordToTag, 'ContinuationEndMeterset', '00740121'), _defineProperty2(_keywordToTag, 'ProcedureStepState', '00741000'), _defineProperty2(_keywordToTag, 'ProcedureStepProgressInformationSequence', '00741002'), _defineProperty2(_keywordToTag, 'ProcedureStepProgress', '00741004'), _defineProperty2(_keywordToTag, 'ProcedureStepProgressDescription', '00741006'), _defineProperty2(_keywordToTag, 'ProcedureStepProgressParametersSequence', '00741007'), _defineProperty2(_keywordToTag, 'ProcedureStepCommunicationsURISequence', '00741008'), _defineProperty2(_keywordToTag, 'ContactURI', '0074100A'), _defineProperty2(_keywordToTag, 'ContactDisplayName', '0074100C'), _defineProperty2(_keywordToTag, 'ProcedureStepDiscontinuationReasonCodeSequence', '0074100E'), _defineProperty2(_keywordToTag, 'BeamTaskSequence', '00741020'), _defineProperty2(_keywordToTag, 'BeamTaskType', '00741022'), _defineProperty2(_keywordToTag, 'BeamOrderIndexTrial', '00741024'), _defineProperty2(_keywordToTag, 'AutosequenceFlag', '00741025'), _defineProperty2(_keywordToTag, 'TableTopVerticalAdjustedPosition', '00741026'), _defineProperty2(_keywordToTag, 'TableTopLongitudinalAdjustedPosition', '00741027'), _defineProperty2(_keywordToTag, 'TableTopLateralAdjustedPosition', '00741028'), _defineProperty2(_keywordToTag, 'PatientSupportAdjustedAngle', '0074102A'), _defineProperty2(_keywordToTag, 'TableTopEccentricAdjustedAngle', '0074102B'), _defineProperty2(_keywordToTag, 'TableTopPitchAdjustedAngle', '0074102C'), _defineProperty2(_keywordToTag, 'TableTopRollAdjustedAngle', '0074102D'), _defineProperty2(_keywordToTag, 'DeliveryVerificationImageSequence', '00741030'), _defineProperty2(_keywordToTag, 'VerificationImageTiming', '00741032'), _defineProperty2(_keywordToTag, 'DoubleExposureFlag', '00741034'), _defineProperty2(_keywordToTag, 'DoubleExposureOrdering', '00741036'), _defineProperty2(_keywordToTag, 'DoubleExposureMetersetTrial', '00741038'), _defineProperty2(_keywordToTag, 'DoubleExposureFieldDeltaTrial', '0074103A'), _defineProperty2(_keywordToTag, 'RelatedReferenceRTImageSequence', '00741040'), _defineProperty2(_keywordToTag, 'GeneralMachineVerificationSequence', '00741042'), _defineProperty2(_keywordToTag, 'ConventionalMachineVerificationSequence', '00741044'), _defineProperty2(_keywordToTag, 'IonMachineVerificationSequence', '00741046'), _defineProperty2(_keywordToTag, 'FailedAttributesSequence', '00741048'), _defineProperty2(_keywordToTag, 'OverriddenAttributesSequence', '0074104A'), _defineProperty2(_keywordToTag, 'ConventionalControlPointVerificationSequence', '0074104C'), _defineProperty2(_keywordToTag, 'IonControlPointVerificationSequence', '0074104E'), _defineProperty2(_keywordToTag, 'AttributeOccurrenceSequence', '00741050'), _defineProperty2(_keywordToTag, 'AttributeOccurrencePointer', '00741052'), _defineProperty2(_keywordToTag, 'AttributeItemSelector', '00741054'), _defineProperty2(_keywordToTag, 'AttributeOccurrencePrivateCreator', '00741056'), _defineProperty2(_keywordToTag, 'SelectorSequencePointerItems', '00741057'), _defineProperty2(_keywordToTag, 'ScheduledProcedureStepPriority', '00741200'), _defineProperty2(_keywordToTag, 'WorklistLabel', '00741202'), _defineProperty2(_keywordToTag, 'ProcedureStepLabel', '00741204'), _defineProperty2(_keywordToTag, 'ScheduledProcessingParametersSequence', '00741210'), _defineProperty2(_keywordToTag, 'PerformedProcessingParametersSequence', '00741212'), _defineProperty2(_keywordToTag, 'UnifiedProcedureStepPerformedProcedureSequence', '00741216'), _defineProperty2(_keywordToTag, 'RelatedProcedureStepSequence', '00741220'), _defineProperty2(_keywordToTag, 'ProcedureStepRelationshipType', '00741222'), _defineProperty2(_keywordToTag, 'ReplacedProcedureStepSequence', '00741224'), _defineProperty2(_keywordToTag, 'DeletionLock', '00741230'), _defineProperty2(_keywordToTag, 'ReceivingAE', '00741234'), _defineProperty2(_keywordToTag, 'RequestingAE', '00741236'), _defineProperty2(_keywordToTag, 'ReasonForCancellation', '00741238'), _defineProperty2(_keywordToTag, 'SCPStatus', '00741242'), _defineProperty2(_keywordToTag, 'SubscriptionListStatus', '00741244'), _defineProperty2(_keywordToTag, 'UnifiedProcedureStepListStatus', '00741246'), _defineProperty2(_keywordToTag, 'BeamOrderIndex', '00741324'), _defineProperty2(_keywordToTag, 'DoubleExposureMeterset', '00741338'), _defineProperty2(_keywordToTag, 'DoubleExposureFieldDelta', '0074133A'), _defineProperty2(_keywordToTag, 'BrachyTaskSequence', '00741401'), _defineProperty2(_keywordToTag, 'ContinuationStartTotalReferenceAirKerma', '00741402'), _defineProperty2(_keywordToTag, 'ContinuationEndTotalReferenceAirKerma', '00741403'), _defineProperty2(_keywordToTag, 'ContinuationPulseNumber', '00741404'), _defineProperty2(_keywordToTag, 'ChannelDeliveryOrderSequence', '00741405'), _defineProperty2(_keywordToTag, 'ReferencedChannelNumber', '00741406'), _defineProperty2(_keywordToTag, 'StartCumulativeTimeWeight', '00741407'), _defineProperty2(_keywordToTag, 'EndCumulativeTimeWeight', '00741408'), _defineProperty2(_keywordToTag, 'OmittedChannelSequence', '00741409'), _defineProperty2(_keywordToTag, 'ReasonForChannelOmission', '0074140A'), _defineProperty2(_keywordToTag, 'ReasonForChannelOmissionDescription', '0074140B'), _defineProperty2(_keywordToTag, 'ChannelDeliveryOrderIndex', '0074140C'), _defineProperty2(_keywordToTag, 'ChannelDeliveryContinuationSequence', '0074140D'), _defineProperty2(_keywordToTag, 'OmittedApplicationSetupSequence', '0074140E'), _defineProperty2(_keywordToTag, 'ImplantAssemblyTemplateName', '00760001'), _defineProperty2(_keywordToTag, 'ImplantAssemblyTemplateIssuer', '00760003'), _defineProperty2(_keywordToTag, 'ImplantAssemblyTemplateVersion', '00760006'), _defineProperty2(_keywordToTag, 'ReplacedImplantAssemblyTemplateSequence', '00760008'), _defineProperty2(_keywordToTag, 'ImplantAssemblyTemplateType', '0076000A'), _defineProperty2(_keywordToTag, 'OriginalImplantAssemblyTemplateSequence', '0076000C'), _defineProperty2(_keywordToTag, 'DerivationImplantAssemblyTemplateSequence', '0076000E'), _defineProperty2(_keywordToTag, 'ImplantAssemblyTemplateTargetAnatomySequence', '00760010'), _defineProperty2(_keywordToTag, 'ProcedureTypeCodeSequence', '00760020'), _defineProperty2(_keywordToTag, 'SurgicalTechnique', '00760030'), _defineProperty2(_keywordToTag, 'ComponentTypesSequence', '00760032'), _defineProperty2(_keywordToTag, 'ComponentTypeCodeSequence', '00760034'), _defineProperty2(_keywordToTag, 'ExclusiveComponentType', '00760036'), _defineProperty2(_keywordToTag, 'MandatoryComponentType', '00760038'), _defineProperty2(_keywordToTag, 'ComponentSequence', '00760040'), _defineProperty2(_keywordToTag, 'ComponentID', '00760055'), _defineProperty2(_keywordToTag, 'ComponentAssemblySequence', '00760060'), _defineProperty2(_keywordToTag, '00760070', 'Component1ReferencedID'), _defineProperty2(_keywordToTag, '00760080', 'Component1ReferencedMatingFeatureSetID'), _defineProperty2(_keywordToTag, '00760090', 'Component1ReferencedMatingFeatureID'), _defineProperty2(_keywordToTag, '007600A0', 'Component2ReferencedID'), _defineProperty2(_keywordToTag, '007600B0', 'Component2ReferencedMatingFeatureSetID'), _defineProperty2(_keywordToTag, '007600C0', 'Component2ReferencedMatingFeatureID'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupName', '00780001'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupDescription', '00780010'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupIssuer', '00780020'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupVersion', '00780024'), _defineProperty2(_keywordToTag, 'ReplacedImplantTemplateGroupSequence', '00780026'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupTargetAnatomySequence', '00780028'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupMembersSequence', '0078002A'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupMemberID', '0078002E'), _defineProperty2(_keywordToTag, 'ThreeDImplantTemplateGroupMemberMatchingPoint', '00780050'), _defineProperty2(_keywordToTag, 'ThreeDImplantTemplateGroupMemberMatchingAxes', '00780060'), _defineProperty2(_keywordToTag, '00780070', 'ImplantTemplateGroupMemberMatching2DCoordinatesSequence'), _defineProperty2(_keywordToTag, 'TwoDImplantTemplateGroupMemberMatchingPoint', '00780090'), _defineProperty2(_keywordToTag, 'TwoDImplantTemplateGroupMemberMatchingAxes', '007800A0'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupVariationDimensionSequence', '007800B0'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupVariationDimensionName', '007800B2'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupVariationDimensionRankSequence', '007800B4'), _defineProperty2(_keywordToTag, 'ReferencedImplantTemplateGroupMemberID', '007800B6'), _defineProperty2(_keywordToTag, 'ImplantTemplateGroupVariationDimensionRank', '007800B8'), _defineProperty2(_keywordToTag, 'SurfaceScanAcquisitionTypeCodeSequence', '00800001'), _defineProperty2(_keywordToTag, 'SurfaceScanModeCodeSequence', '00800002'), _defineProperty2(_keywordToTag, 'RegistrationMethodCodeSequence', '00800003'), _defineProperty2(_keywordToTag, 'ShotDurationTime', '00800004'), _defineProperty2(_keywordToTag, 'ShotOffsetTime', '00800005'), _defineProperty2(_keywordToTag, 'SurfacePointPresentationValueData', '00800006'), _defineProperty2(_keywordToTag, 'SurfacePointColorCIELabValueData', '00800007'), _defineProperty2(_keywordToTag, 'UVMappingSequence', '00800008'), _defineProperty2(_keywordToTag, 'TextureLabel', '00800009'), _defineProperty2(_keywordToTag, 'UValueData', '00800010'), _defineProperty2(_keywordToTag, 'VValueData', '00800011'), _defineProperty2(_keywordToTag, 'ReferencedTextureSequence', '00800012'), _defineProperty2(_keywordToTag, 'ReferencedSurfaceDataSequence', '00800013'), _defineProperty2(_keywordToTag, 'AssessmentSummary', '00820001'), _defineProperty2(_keywordToTag, 'AssessmentSummaryDescription', '00820003'), _defineProperty2(_keywordToTag, 'AssessedSOPInstanceSequence', '00820004'), _defineProperty2(_keywordToTag, 'ReferencedComparisonSOPInstanceSequence', '00820005'), _defineProperty2(_keywordToTag, 'NumberOfAssessmentObservations', '00820006'), _defineProperty2(_keywordToTag, 'AssessmentObservationsSequence', '00820007'), _defineProperty2(_keywordToTag, 'ObservationSignificance', '00820008'), _defineProperty2(_keywordToTag, 'ObservationDescription', '0082000A'), _defineProperty2(_keywordToTag, 'StructuredConstraintObservationSequence', '0082000C'), _defineProperty2(_keywordToTag, 'AssessedAttributeValueSequence', '00820010'), _defineProperty2(_keywordToTag, 'AssessmentSetID', '00820016'), _defineProperty2(_keywordToTag, 'AssessmentRequesterSequence', '00820017'), _defineProperty2(_keywordToTag, 'SelectorAttributeName', '00820018'), _defineProperty2(_keywordToTag, 'SelectorAttributeKeyword', '00820019'), _defineProperty2(_keywordToTag, 'AssessmentTypeCodeSequence', '00820021'), _defineProperty2(_keywordToTag, 'ObservationBasisCodeSequence', '00820022'), _defineProperty2(_keywordToTag, 'AssessmentLabel', '00820023'), _defineProperty2(_keywordToTag, 'ConstraintType', '00820032'), _defineProperty2(_keywordToTag, 'SpecificationSelectionGuidance', '00820033'), _defineProperty2(_keywordToTag, 'ConstraintValueSequence', '00820034'), _defineProperty2(_keywordToTag, 'RecommendedDefaultValueSequence', '00820035'), _defineProperty2(_keywordToTag, 'ConstraintViolationSignificance', '00820036'), _defineProperty2(_keywordToTag, 'ConstraintViolationCondition', '00820037'), _defineProperty2(_keywordToTag, 'ModifiableConstraintFlag', '00820038'), _defineProperty2(_keywordToTag, 'StorageMediaFileSetID', '00880130'), _defineProperty2(_keywordToTag, 'StorageMediaFileSetUID', '00880140'), _defineProperty2(_keywordToTag, 'IconImageSequence', '00880200'), _defineProperty2(_keywordToTag, 'TopicTitle', '00880904'), _defineProperty2(_keywordToTag, 'TopicSubject', '00880906'), _defineProperty2(_keywordToTag, 'TopicAuthor', '00880910'), _defineProperty2(_keywordToTag, 'TopicKeywords', '00880912'), _defineProperty2(_keywordToTag, 'SOPInstanceStatus', '01000410'), _defineProperty2(_keywordToTag, 'SOPAuthorizationDateTime', '01000420'), _defineProperty2(_keywordToTag, 'SOPAuthorizationComment', '01000424'), _defineProperty2(_keywordToTag, 'AuthorizationEquipmentCertificationNumber', '01000426'), _defineProperty2(_keywordToTag, 'MACIDNumber', '04000005'), _defineProperty2(_keywordToTag, 'MACCalculationTransferSyntaxUID', '04000010'), _defineProperty2(_keywordToTag, 'MACAlgorithm', '04000015'), _defineProperty2(_keywordToTag, 'DataElementsSigned', '04000020'), _defineProperty2(_keywordToTag, 'DigitalSignatureUID', '04000100'), _defineProperty2(_keywordToTag, 'DigitalSignatureDateTime', '04000105'), _defineProperty2(_keywordToTag, 'CertificateType', '04000110'), _defineProperty2(_keywordToTag, 'CertificateOfSigner', '04000115'), _defineProperty2(_keywordToTag, 'Signature', '04000120'), _defineProperty2(_keywordToTag, 'CertifiedTimestampType', '04000305'), _defineProperty2(_keywordToTag, 'CertifiedTimestamp', '04000310'), _defineProperty2(_keywordToTag, \"\", '04000315'), _defineProperty2(_keywordToTag, 'DigitalSignaturePurposeCodeSequence', '04000401'), _defineProperty2(_keywordToTag, 'ReferencedDigitalSignatureSequence', '04000402'), _defineProperty2(_keywordToTag, 'ReferencedSOPInstanceMACSequence', '04000403'), _defineProperty2(_keywordToTag, 'MAC', '04000404'), _defineProperty2(_keywordToTag, 'EncryptedAttributesSequence', '04000500'), _defineProperty2(_keywordToTag, 'EncryptedContentTransferSyntaxUID', '04000510'), _defineProperty2(_keywordToTag, 'EncryptedContent', '04000520'), _defineProperty2(_keywordToTag, 'ModifiedAttributesSequence', '04000550'), _defineProperty2(_keywordToTag, 'OriginalAttributesSequence', '04000561'), _defineProperty2(_keywordToTag, 'AttributeModificationDateTime', '04000562'), _defineProperty2(_keywordToTag, 'ModifyingSystem', '04000563'), _defineProperty2(_keywordToTag, 'SourceOfPreviousValues', '04000564'), _defineProperty2(_keywordToTag, 'ReasonForTheAttributeModification', '04000565'), _defineProperty2(_keywordToTag, 'InstanceOriginStatus', '04000600'), _defineProperty2(_keywordToTag, 'NumberOfCopies', '20000010'), _defineProperty2(_keywordToTag, 'PrinterConfigurationSequence', '2000001E'), _defineProperty2(_keywordToTag, 'PrintPriority', '20000020'), _defineProperty2(_keywordToTag, 'MediumType', '20000030'), _defineProperty2(_keywordToTag, 'FilmDestination', '20000040'), _defineProperty2(_keywordToTag, 'FilmSessionLabel', '20000050'), _defineProperty2(_keywordToTag, 'MemoryAllocation', '20000060'), _defineProperty2(_keywordToTag, 'MaximumMemoryAllocation', '20000061'), _defineProperty2(_keywordToTag, 'ColorImagePrintingFlag', '20000062'), _defineProperty2(_keywordToTag, 'CollationFlag', '20000063'), _defineProperty2(_keywordToTag, 'AnnotationFlag', '20000065'), _defineProperty2(_keywordToTag, 'ImageOverlayFlag', '20000067'), _defineProperty2(_keywordToTag, 'PresentationLUTFlag', '20000069'), _defineProperty2(_keywordToTag, 'ImageBoxPresentationLUTFlag', '2000006A'), _defineProperty2(_keywordToTag, 'MemoryBitDepth', '200000A0'), _defineProperty2(_keywordToTag, 'PrintingBitDepth', '200000A1'), _defineProperty2(_keywordToTag, 'MediaInstalledSequence', '200000A2'), _defineProperty2(_keywordToTag, 'OtherMediaAvailableSequence', '200000A4'), _defineProperty2(_keywordToTag, 'SupportedImageDisplayFormatsSequence', '200000A8'), _defineProperty2(_keywordToTag, 'ReferencedFilmBoxSequence', '20000500'), _defineProperty2(_keywordToTag, 'ReferencedStoredPrintSequence', '20000510'), _defineProperty2(_keywordToTag, 'ImageDisplayFormat', '20100010'), _defineProperty2(_keywordToTag, 'AnnotationDisplayFormatID', '20100030'), _defineProperty2(_keywordToTag, 'FilmOrientation', '20100040'), _defineProperty2(_keywordToTag, 'FilmSizeID', '20100050'), _defineProperty2(_keywordToTag, 'PrinterResolutionID', '20100052'), _defineProperty2(_keywordToTag, 'DefaultPrinterResolutionID', '20100054'), _defineProperty2(_keywordToTag, 'MagnificationType', '20100060'), _defineProperty2(_keywordToTag, 'SmoothingType', '20100080'), _defineProperty2(_keywordToTag, 'DefaultMagnificationType', '201000A6'), _defineProperty2(_keywordToTag, 'OtherMagnificationTypesAvailable', '201000A7'), _defineProperty2(_keywordToTag, 'DefaultSmoothingType', '201000A8'), _defineProperty2(_keywordToTag, 'OtherSmoothingTypesAvailable', '201000A9'), _defineProperty2(_keywordToTag, 'BorderDensity', '20100100'), _defineProperty2(_keywordToTag, 'EmptyImageDensity', '20100110'), _defineProperty2(_keywordToTag, 'MinDensity', '20100120'), _defineProperty2(_keywordToTag, 'MaxDensity', '20100130'), _defineProperty2(_keywordToTag, 'Trim', '20100140'), _defineProperty2(_keywordToTag, 'ConfigurationInformation', '20100150'), _defineProperty2(_keywordToTag, 'ConfigurationInformationDescription', '20100152'), _defineProperty2(_keywordToTag, 'MaximumCollatedFilms', '20100154'), _defineProperty2(_keywordToTag, 'Illumination', '2010015E'), _defineProperty2(_keywordToTag, 'ReflectedAmbientLight', '20100160'), _defineProperty2(_keywordToTag, 'PrinterPixelSpacing', '20100376'), _defineProperty2(_keywordToTag, 'ReferencedFilmSessionSequence', '20100500'), _defineProperty2(_keywordToTag, 'ReferencedImageBoxSequence', '20100510'), _defineProperty2(_keywordToTag, 'ReferencedBasicAnnotationBoxSequence', '20100520'), _defineProperty2(_keywordToTag, 'ImageBoxPosition', '20200010'), _defineProperty2(_keywordToTag, 'Polarity', '20200020'), _defineProperty2(_keywordToTag, 'RequestedImageSize', '20200030'), _defineProperty2(_keywordToTag, 'RequestedDecimateCropBehavior', '20200040'), _defineProperty2(_keywordToTag, 'RequestedResolutionID', '20200050'), _defineProperty2(_keywordToTag, 'RequestedImageSizeFlag', '202000A0'), _defineProperty2(_keywordToTag, 'DecimateCropResult', '202000A2'), _defineProperty2(_keywordToTag, 'BasicGrayscaleImageSequence', '20200110'), _defineProperty2(_keywordToTag, 'BasicColorImageSequence', '20200111'), _defineProperty2(_keywordToTag, 'ReferencedImageOverlayBoxSequence', '20200130'), _defineProperty2(_keywordToTag, 'ReferencedVOILUTBoxSequence', '20200140'), _defineProperty2(_keywordToTag, 'AnnotationPosition', '20300010'), _defineProperty2(_keywordToTag, 'TextString', '20300020'), _defineProperty2(_keywordToTag, 'ReferencedOverlayPlaneSequence', '20400010'), _defineProperty2(_keywordToTag, 'ReferencedOverlayPlaneGroups', '20400011'), _defineProperty2(_keywordToTag, 'OverlayPixelDataSequence', '20400020'), _defineProperty2(_keywordToTag, 'OverlayMagnificationType', '20400060'), _defineProperty2(_keywordToTag, 'OverlaySmoothingType', '20400070'), _defineProperty2(_keywordToTag, 'OverlayOrImageMagnification', '20400072'), _defineProperty2(_keywordToTag, 'MagnifyToNumberOfColumns', '20400074'), _defineProperty2(_keywordToTag, 'OverlayForegroundDensity', '20400080'), _defineProperty2(_keywordToTag, 'OverlayBackgroundDensity', '20400082'), _defineProperty2(_keywordToTag, 'OverlayMode', '20400090'), _defineProperty2(_keywordToTag, 'ThresholdDensity', '20400100'), _defineProperty2(_keywordToTag, 'ReferencedImageBoxSequenceRetired', '20400500'), _defineProperty2(_keywordToTag, 'PresentationLUTSequence', '20500010'), _defineProperty2(_keywordToTag, 'PresentationLUTShape', '20500020'), _defineProperty2(_keywordToTag, 'ReferencedPresentationLUTSequence', '20500500'), _defineProperty2(_keywordToTag, 'PrintJobID', '21000010'), _defineProperty2(_keywordToTag, 'ExecutionStatus', '21000020'), _defineProperty2(_keywordToTag, 'ExecutionStatusInfo', '21000030'), _defineProperty2(_keywordToTag, 'CreationDate', '21000040'), _defineProperty2(_keywordToTag, 'CreationTime', '21000050'), _defineProperty2(_keywordToTag, 'Originator', '21000070'), _defineProperty2(_keywordToTag, 'DestinationAE', '21000140'), _defineProperty2(_keywordToTag, 'OwnerID', '21000160'), _defineProperty2(_keywordToTag, 'NumberOfFilms', '21000170'), _defineProperty2(_keywordToTag, 'ReferencedPrintJobSequencePullStoredPrint', '21000500'), _defineProperty2(_keywordToTag, 'PrinterStatus', '21100010'), _defineProperty2(_keywordToTag, 'PrinterStatusInfo', '21100020'), _defineProperty2(_keywordToTag, 'PrinterName', '21100030'), _defineProperty2(_keywordToTag, 'PrintQueueID', '21100099'), _defineProperty2(_keywordToTag, 'QueueStatus', '21200010'), _defineProperty2(_keywordToTag, 'PrintJobDescriptionSequence', '21200050'), _defineProperty2(_keywordToTag, 'ReferencedPrintJobSequence', '21200070'), _defineProperty2(_keywordToTag, 'PrintManagementCapabilitiesSequence', '21300010'), _defineProperty2(_keywordToTag, 'PrinterCharacteristicsSequence', '21300015'), _defineProperty2(_keywordToTag, 'FilmBoxContentSequence', '21300030'), _defineProperty2(_keywordToTag, 'ImageBoxContentSequence', '21300040'), _defineProperty2(_keywordToTag, 'AnnotationContentSequence', '21300050'), _defineProperty2(_keywordToTag, 'ImageOverlayBoxContentSequence', '21300060'), _defineProperty2(_keywordToTag, 'PresentationLUTContentSequence', '21300080'), _defineProperty2(_keywordToTag, 'ProposedStudySequence', '213000A0'), _defineProperty2(_keywordToTag, 'OriginalImageSequence', '213000C0'), _defineProperty2(_keywordToTag, 'LabelUsingInformationExtractedFromInstances', '22000001'), _defineProperty2(_keywordToTag, 'LabelText', '22000002'), _defineProperty2(_keywordToTag, 'LabelStyleSelection', '22000003'), _defineProperty2(_keywordToTag, 'MediaDisposition', '22000004'), _defineProperty2(_keywordToTag, 'BarcodeValue', '22000005'), _defineProperty2(_keywordToTag, 'BarcodeSymbology', '22000006'), _defineProperty2(_keywordToTag, 'AllowMediaSplitting', '22000007'), _defineProperty2(_keywordToTag, 'IncludeNonDICOMObjects', '22000008'), _defineProperty2(_keywordToTag, 'IncludeDisplayApplication', '22000009'), _defineProperty2(_keywordToTag, 'PreserveCompositeInstancesAfterMediaCreation', '2200000A'), _defineProperty2(_keywordToTag, 'TotalNumberOfPiecesOfMediaCreated', '2200000B'), _defineProperty2(_keywordToTag, 'RequestedMediaApplicationProfile', '2200000C'), _defineProperty2(_keywordToTag, 'ReferencedStorageMediaSequence', '2200000D'), _defineProperty2(_keywordToTag, 'FailureAttributes', '2200000E'), _defineProperty2(_keywordToTag, 'AllowLossyCompression', '2200000F'), _defineProperty2(_keywordToTag, 'RequestPriority', '22000020'), _defineProperty2(_keywordToTag, 'RTImageLabel', '30020002'), _defineProperty2(_keywordToTag, 'RTImageName', '30020003'), _defineProperty2(_keywordToTag, 'RTImageDescription', '30020004'), _defineProperty2(_keywordToTag, 'ReportedValuesOrigin', '3002000A'), _defineProperty2(_keywordToTag, 'RTImagePlane', '3002000C'), _defineProperty2(_keywordToTag, 'XRayImageReceptorTranslation', '3002000D'), _defineProperty2(_keywordToTag, 'XRayImageReceptorAngle', '3002000E'), _defineProperty2(_keywordToTag, 'RTImageOrientation', '30020010'), _defineProperty2(_keywordToTag, 'ImagePlanePixelSpacing', '30020011'), _defineProperty2(_keywordToTag, 'RTImagePosition', '30020012'), _defineProperty2(_keywordToTag, 'RadiationMachineName', '30020020'), _defineProperty2(_keywordToTag, 'RadiationMachineSAD', '30020022'), _defineProperty2(_keywordToTag, 'RadiationMachineSSD', '30020024'), _defineProperty2(_keywordToTag, 'RTImageSID', '30020026'), _defineProperty2(_keywordToTag, 'SourceToReferenceObjectDistance', '30020028'), _defineProperty2(_keywordToTag, 'FractionNumber', '30020029'), _defineProperty2(_keywordToTag, 'ExposureSequence', '30020030'), _defineProperty2(_keywordToTag, 'MetersetExposure', '30020032'), _defineProperty2(_keywordToTag, 'DiaphragmPosition', '30020034'), _defineProperty2(_keywordToTag, 'FluenceMapSequence', '30020040'), _defineProperty2(_keywordToTag, 'FluenceDataSource', '30020041'), _defineProperty2(_keywordToTag, 'FluenceDataScale', '30020042'), _defineProperty2(_keywordToTag, 'PrimaryFluenceModeSequence', '30020050'), _defineProperty2(_keywordToTag, 'FluenceMode', '30020051'), _defineProperty2(_keywordToTag, 'FluenceModeID', '30020052'), _defineProperty2(_keywordToTag, 'DVHType', '30040001'), _defineProperty2(_keywordToTag, 'DoseUnits', '30040002'), _defineProperty2(_keywordToTag, 'DoseType', '30040004'), _defineProperty2(_keywordToTag, 'SpatialTransformOfDose', '30040005'), _defineProperty2(_keywordToTag, 'DoseComment', '30040006'), _defineProperty2(_keywordToTag, 'NormalizationPoint', '30040008'), _defineProperty2(_keywordToTag, 'DoseSummationType', '3004000A'), _defineProperty2(_keywordToTag, 'GridFrameOffsetVector', '3004000C'), _defineProperty2(_keywordToTag, 'DoseGridScaling', '3004000E'), _defineProperty2(_keywordToTag, 'RTDoseROISequence', '30040010'), _defineProperty2(_keywordToTag, 'DoseValue', '30040012'), _defineProperty2(_keywordToTag, 'TissueHeterogeneityCorrection', '30040014'), _defineProperty2(_keywordToTag, 'DVHNormalizationPoint', '30040040'), _defineProperty2(_keywordToTag, 'DVHNormalizationDoseValue', '30040042'), _defineProperty2(_keywordToTag, 'DVHSequence', '30040050'), _defineProperty2(_keywordToTag, 'DVHDoseScaling', '30040052'), _defineProperty2(_keywordToTag, 'DVHVolumeUnits', '30040054'), _defineProperty2(_keywordToTag, 'DVHNumberOfBins', '30040056'), _defineProperty2(_keywordToTag, 'DVHData', '30040058'), _defineProperty2(_keywordToTag, 'DVHReferencedROISequence', '30040060'), _defineProperty2(_keywordToTag, 'DVHROIContributionType', '30040062'), _defineProperty2(_keywordToTag, 'DVHMinimumDose', '30040070'), _defineProperty2(_keywordToTag, 'DVHMaximumDose', '30040072'), _defineProperty2(_keywordToTag, 'DVHMeanDose', '30040074'), _defineProperty2(_keywordToTag, 'StructureSetLabel', '30060002'), _defineProperty2(_keywordToTag, 'StructureSetName', '30060004'), _defineProperty2(_keywordToTag, 'StructureSetDescription', '30060006'), _defineProperty2(_keywordToTag, 'StructureSetDate', '30060008'), _defineProperty2(_keywordToTag, 'StructureSetTime', '30060009'), _defineProperty2(_keywordToTag, 'ReferencedFrameOfReferenceSequence', '30060010'), _defineProperty2(_keywordToTag, 'RTReferencedStudySequence', '30060012'), _defineProperty2(_keywordToTag, 'RTReferencedSeriesSequence', '30060014'), _defineProperty2(_keywordToTag, 'ContourImageSequence', '30060016'), _defineProperty2(_keywordToTag, 'PredecessorStructureSetSequence', '30060018'), _defineProperty2(_keywordToTag, 'StructureSetROISequence', '30060020'), _defineProperty2(_keywordToTag, 'ROINumber', '30060022'), _defineProperty2(_keywordToTag, 'ReferencedFrameOfReferenceUID', '30060024'), _defineProperty2(_keywordToTag, 'ROIName', '30060026'), _defineProperty2(_keywordToTag, 'ROIDescription', '30060028'), _defineProperty2(_keywordToTag, 'ROIDisplayColor', '3006002A'), _defineProperty2(_keywordToTag, 'ROIVolume', '3006002C'), _defineProperty2(_keywordToTag, 'RTRelatedROISequence', '30060030'), _defineProperty2(_keywordToTag, 'RTROIRelationship', '30060033'), _defineProperty2(_keywordToTag, 'ROIGenerationAlgorithm', '30060036'), _defineProperty2(_keywordToTag, 'ROIGenerationDescription', '30060038'), _defineProperty2(_keywordToTag, 'ROIContourSequence', '30060039'), _defineProperty2(_keywordToTag, 'ContourSequence', '30060040'), _defineProperty2(_keywordToTag, 'ContourGeometricType', '30060042'), _defineProperty2(_keywordToTag, 'ContourSlabThickness', '30060044'), _defineProperty2(_keywordToTag, 'ContourOffsetVector', '30060045'), _defineProperty2(_keywordToTag, 'NumberOfContourPoints', '30060046'), _defineProperty2(_keywordToTag, 'ContourNumber', '30060048'), _defineProperty2(_keywordToTag, 'AttachedContours', '30060049'), _defineProperty2(_keywordToTag, 'ContourData', '30060050'), _defineProperty2(_keywordToTag, 'RTROIObservationsSequence', '30060080'), _defineProperty2(_keywordToTag, 'ObservationNumber', '30060082'), _defineProperty2(_keywordToTag, 'ReferencedROINumber', '30060084'), _defineProperty2(_keywordToTag, 'ROIObservationLabel', '30060085'), _defineProperty2(_keywordToTag, 'RTROIIdentificationCodeSequence', '30060086'), _defineProperty2(_keywordToTag, 'ROIObservationDescription', '30060088'), _defineProperty2(_keywordToTag, 'RelatedRTROIObservationsSequence', '300600A0'), _defineProperty2(_keywordToTag, 'RTROIInterpretedType', '300600A4'), _defineProperty2(_keywordToTag, 'ROIInterpreter', '300600A6'), _defineProperty2(_keywordToTag, 'ROIPhysicalPropertiesSequence', '300600B0'), _defineProperty2(_keywordToTag, 'ROIPhysicalProperty', '300600B2'), _defineProperty2(_keywordToTag, 'ROIPhysicalPropertyValue', '300600B4'), _defineProperty2(_keywordToTag, 'ROIElementalCompositionSequence', '300600B6'), _defineProperty2(_keywordToTag, 'ROIElementalCompositionAtomicNumber', '300600B7'), _defineProperty2(_keywordToTag, 'ROIElementalCompositionAtomicMassFraction', '300600B8'), _defineProperty2(_keywordToTag, 'AdditionalRTROIIdentificationCodeSequence', '300600B9'), _defineProperty2(_keywordToTag, 'FrameOfReferenceRelationshipSequence', '300600C0'), _defineProperty2(_keywordToTag, 'RelatedFrameOfReferenceUID', '300600C2'), _defineProperty2(_keywordToTag, 'FrameOfReferenceTransformationType', '300600C4'), _defineProperty2(_keywordToTag, 'FrameOfReferenceTransformationMatrix', '300600C6'), _defineProperty2(_keywordToTag, 'FrameOfReferenceTransformationComment', '300600C8'), _defineProperty2(_keywordToTag, 'MeasuredDoseReferenceSequence', '30080010'), _defineProperty2(_keywordToTag, 'MeasuredDoseDescription', '30080012'), _defineProperty2(_keywordToTag, 'MeasuredDoseType', '30080014'), _defineProperty2(_keywordToTag, 'MeasuredDoseValue', '30080016'), _defineProperty2(_keywordToTag, 'TreatmentSessionBeamSequence', '30080020'), _defineProperty2(_keywordToTag, 'TreatmentSessionIonBeamSequence', '30080021'), _defineProperty2(_keywordToTag, 'CurrentFractionNumber', '30080022'), _defineProperty2(_keywordToTag, 'TreatmentControlPointDate', '30080024'), _defineProperty2(_keywordToTag, 'TreatmentControlPointTime', '30080025'), _defineProperty2(_keywordToTag, 'TreatmentTerminationStatus', '3008002A'), _defineProperty2(_keywordToTag, 'TreatmentTerminationCode', '3008002B'), _defineProperty2(_keywordToTag, 'TreatmentVerificationStatus', '3008002C'), _defineProperty2(_keywordToTag, 'ReferencedTreatmentRecordSequence', '30080030'), _defineProperty2(_keywordToTag, 'SpecifiedPrimaryMeterset', '30080032'), _defineProperty2(_keywordToTag, 'SpecifiedSecondaryMeterset', '30080033'), _defineProperty2(_keywordToTag, 'DeliveredPrimaryMeterset', '30080036'), _defineProperty2(_keywordToTag, 'DeliveredSecondaryMeterset', '30080037'), _defineProperty2(_keywordToTag, 'SpecifiedTreatmentTime', '3008003A'), _defineProperty2(_keywordToTag, 'DeliveredTreatmentTime', '3008003B'), _defineProperty2(_keywordToTag, 'ControlPointDeliverySequence', '30080040'), _defineProperty2(_keywordToTag, 'IonControlPointDeliverySequence', '30080041'), _defineProperty2(_keywordToTag, 'SpecifiedMeterset', '30080042'), _defineProperty2(_keywordToTag, 'DeliveredMeterset', '30080044'), _defineProperty2(_keywordToTag, 'MetersetRateSet', '30080045'), _defineProperty2(_keywordToTag, 'MetersetRateDelivered', '30080046'), _defineProperty2(_keywordToTag, 'ScanSpotMetersetsDelivered', '30080047'), _defineProperty2(_keywordToTag, 'DoseRateDelivered', '30080048'), _defineProperty2(_keywordToTag, 'TreatmentSummaryCalculatedDoseReferenceSequence', '30080050'), _defineProperty2(_keywordToTag, 'CumulativeDoseToDoseReference', '30080052'), _defineProperty2(_keywordToTag, 'FirstTreatmentDate', '30080054'), _defineProperty2(_keywordToTag, 'MostRecentTreatmentDate', '30080056'), _defineProperty2(_keywordToTag, 'NumberOfFractionsDelivered', '3008005A'), _defineProperty2(_keywordToTag, 'OverrideSequence', '30080060'), _defineProperty2(_keywordToTag, 'ParameterSequencePointer', '30080061'), _defineProperty2(_keywordToTag, 'OverrideParameterPointer', '30080062'), _defineProperty2(_keywordToTag, 'ParameterItemIndex', '30080063'), _defineProperty2(_keywordToTag, 'MeasuredDoseReferenceNumber', '30080064'), _defineProperty2(_keywordToTag, 'ParameterPointer', '30080065'), _defineProperty2(_keywordToTag, 'OverrideReason', '30080066'), _defineProperty2(_keywordToTag, 'ParameterValueNumber', '30080067'), _defineProperty2(_keywordToTag, 'CorrectedParameterSequence', '30080068'), _defineProperty2(_keywordToTag, 'CorrectionValue', '3008006A'), _defineProperty2(_keywordToTag, 'CalculatedDoseReferenceSequence', '30080070'), _defineProperty2(_keywordToTag, 'CalculatedDoseReferenceNumber', '30080072'), _defineProperty2(_keywordToTag, 'CalculatedDoseReferenceDescription', '30080074'), _defineProperty2(_keywordToTag, 'CalculatedDoseReferenceDoseValue', '30080076'), _defineProperty2(_keywordToTag, 'StartMeterset', '30080078'), _defineProperty2(_keywordToTag, 'EndMeterset', '3008007A'), _defineProperty2(_keywordToTag, 'ReferencedMeasuredDoseReferenceSequence', '30080080'), _defineProperty2(_keywordToTag, 'ReferencedMeasuredDoseReferenceNumber', '30080082'), _defineProperty2(_keywordToTag, 'ReferencedCalculatedDoseReferenceSequence', '30080090'), _defineProperty2(_keywordToTag, 'ReferencedCalculatedDoseReferenceNumber', '30080092'), _defineProperty2(_keywordToTag, 'BeamLimitingDeviceLeafPairsSequence', '300800A0'), _defineProperty2(_keywordToTag, 'RecordedWedgeSequence', '300800B0'), _defineProperty2(_keywordToTag, 'RecordedCompensatorSequence', '300800C0'), _defineProperty2(_keywordToTag, 'RecordedBlockSequence', '300800D0'), _defineProperty2(_keywordToTag, 'TreatmentSummaryMeasuredDoseReferenceSequence', '300800E0'), _defineProperty2(_keywordToTag, 'RecordedSnoutSequence', '300800F0'), _defineProperty2(_keywordToTag, 'RecordedRangeShifterSequence', '300800F2'), _defineProperty2(_keywordToTag, 'RecordedLateralSpreadingDeviceSequence', '300800F4'), _defineProperty2(_keywordToTag, 'RecordedRangeModulatorSequence', '300800F6'), _defineProperty2(_keywordToTag, 'RecordedSourceSequence', '30080100'), _defineProperty2(_keywordToTag, 'SourceSerialNumber', '30080105'), _defineProperty2(_keywordToTag, 'TreatmentSessionApplicationSetupSequence', '30080110'), _defineProperty2(_keywordToTag, 'ApplicationSetupCheck', '30080116'), _defineProperty2(_keywordToTag, 'RecordedBrachyAccessoryDeviceSequence', '30080120'), _defineProperty2(_keywordToTag, 'ReferencedBrachyAccessoryDeviceNumber', '30080122'), _defineProperty2(_keywordToTag, 'RecordedChannelSequence', '30080130'), _defineProperty2(_keywordToTag, 'SpecifiedChannelTotalTime', '30080132'), _defineProperty2(_keywordToTag, 'DeliveredChannelTotalTime', '30080134'), _defineProperty2(_keywordToTag, 'SpecifiedNumberOfPulses', '30080136'), _defineProperty2(_keywordToTag, 'DeliveredNumberOfPulses', '30080138'), _defineProperty2(_keywordToTag, 'SpecifiedPulseRepetitionInterval', '3008013A'), _defineProperty2(_keywordToTag, 'DeliveredPulseRepetitionInterval', '3008013C'), _defineProperty2(_keywordToTag, 'RecordedSourceApplicatorSequence', '30080140'), _defineProperty2(_keywordToTag, 'ReferencedSourceApplicatorNumber', '30080142'), _defineProperty2(_keywordToTag, 'RecordedChannelShieldSequence', '30080150'), _defineProperty2(_keywordToTag, 'ReferencedChannelShieldNumber', '30080152'), _defineProperty2(_keywordToTag, 'BrachyControlPointDeliveredSequence', '30080160'), _defineProperty2(_keywordToTag, 'SafePositionExitDate', '30080162'), _defineProperty2(_keywordToTag, 'SafePositionExitTime', '30080164'), _defineProperty2(_keywordToTag, 'SafePositionReturnDate', '30080166'), _defineProperty2(_keywordToTag, 'SafePositionReturnTime', '30080168'), _defineProperty2(_keywordToTag, 'PulseSpecificBrachyControlPointDeliveredSequence', '30080171'), _defineProperty2(_keywordToTag, 'PulseNumber', '30080172'), _defineProperty2(_keywordToTag, 'BrachyPulseControlPointDeliveredSequence', '30080173'), _defineProperty2(_keywordToTag, 'CurrentTreatmentStatus', '30080200'), _defineProperty2(_keywordToTag, 'TreatmentStatusComment', '30080202'), _defineProperty2(_keywordToTag, 'FractionGroupSummarySequence', '30080220'), _defineProperty2(_keywordToTag, 'ReferencedFractionNumber', '30080223'), _defineProperty2(_keywordToTag, 'FractionGroupType', '30080224'), _defineProperty2(_keywordToTag, 'BeamStopperPosition', '30080230'), _defineProperty2(_keywordToTag, 'FractionStatusSummarySequence', '30080240'), _defineProperty2(_keywordToTag, 'TreatmentDate', '30080250'), _defineProperty2(_keywordToTag, 'TreatmentTime', '30080251'), _defineProperty2(_keywordToTag, 'RTPlanLabel', '300A0002'), _defineProperty2(_keywordToTag, 'RTPlanName', '300A0003'), _defineProperty2(_keywordToTag, 'RTPlanDescription', '300A0004'), _defineProperty2(_keywordToTag, 'RTPlanDate', '300A0006'), _defineProperty2(_keywordToTag, 'RTPlanTime', '300A0007'), _defineProperty2(_keywordToTag, 'TreatmentProtocols', '300A0009'), _defineProperty2(_keywordToTag, 'PlanIntent', '300A000A'), _defineProperty2(_keywordToTag, 'TreatmentSites', '300A000B'), _defineProperty2(_keywordToTag, 'RTPlanGeometry', '300A000C'), _defineProperty2(_keywordToTag, 'PrescriptionDescription', '300A000E'), _defineProperty2(_keywordToTag, 'DoseReferenceSequence', '300A0010'), _defineProperty2(_keywordToTag, 'DoseReferenceNumber', '300A0012'), _defineProperty2(_keywordToTag, 'DoseReferenceUID', '300A0013'), _defineProperty2(_keywordToTag, 'DoseReferenceStructureType', '300A0014'), _defineProperty2(_keywordToTag, 'NominalBeamEnergyUnit', '300A0015'), _defineProperty2(_keywordToTag, 'DoseReferenceDescription', '300A0016'), _defineProperty2(_keywordToTag, 'DoseReferencePointCoordinates', '300A0018'), _defineProperty2(_keywordToTag, 'NominalPriorDose', '300A001A'), _defineProperty2(_keywordToTag, 'DoseReferenceType', '300A0020'), _defineProperty2(_keywordToTag, 'ConstraintWeight', '300A0021'), _defineProperty2(_keywordToTag, 'DeliveryWarningDose', '300A0022'), _defineProperty2(_keywordToTag, 'DeliveryMaximumDose', '300A0023'), _defineProperty2(_keywordToTag, 'TargetMinimumDose', '300A0025'), _defineProperty2(_keywordToTag, 'TargetPrescriptionDose', '300A0026'), _defineProperty2(_keywordToTag, 'TargetMaximumDose', '300A0027'), _defineProperty2(_keywordToTag, 'TargetUnderdoseVolumeFraction', '300A0028'), _defineProperty2(_keywordToTag, 'OrganAtRiskFullVolumeDose', '300A002A'), _defineProperty2(_keywordToTag, 'OrganAtRiskLimitDose', '300A002B'), _defineProperty2(_keywordToTag, 'OrganAtRiskMaximumDose', '300A002C'), _defineProperty2(_keywordToTag, 'OrganAtRiskOverdoseVolumeFraction', '300A002D'), _defineProperty2(_keywordToTag, 'ToleranceTableSequence', '300A0040'), _defineProperty2(_keywordToTag, 'ToleranceTableNumber', '300A0042'), _defineProperty2(_keywordToTag, 'ToleranceTableLabel', '300A0043'), _defineProperty2(_keywordToTag, 'GantryAngleTolerance', '300A0044'), _defineProperty2(_keywordToTag, 'BeamLimitingDeviceAngleTolerance', '300A0046'), _defineProperty2(_keywordToTag, 'BeamLimitingDeviceToleranceSequence', '300A0048'), _defineProperty2(_keywordToTag, 'BeamLimitingDevicePositionTolerance', '300A004A'), _defineProperty2(_keywordToTag, 'SnoutPositionTolerance', '300A004B'), _defineProperty2(_keywordToTag, 'PatientSupportAngleTolerance', '300A004C'), _defineProperty2(_keywordToTag, 'TableTopEccentricAngleTolerance', '300A004E'), _defineProperty2(_keywordToTag, 'TableTopPitchAngleTolerance', '300A004F'), _defineProperty2(_keywordToTag, 'TableTopRollAngleTolerance', '300A0050'), _defineProperty2(_keywordToTag, 'TableTopVerticalPositionTolerance', '300A0051'), _defineProperty2(_keywordToTag, 'TableTopLongitudinalPositionTolerance', '300A0052'), _defineProperty2(_keywordToTag, 'TableTopLateralPositionTolerance', '300A0053'), _defineProperty2(_keywordToTag, 'RTPlanRelationship', '300A0055'), _defineProperty2(_keywordToTag, 'FractionGroupSequence', '300A0070'), _defineProperty2(_keywordToTag, 'FractionGroupNumber', '300A0071'), _defineProperty2(_keywordToTag, 'FractionGroupDescription', '300A0072'), _defineProperty2(_keywordToTag, 'NumberOfFractionsPlanned', '300A0078'), _defineProperty2(_keywordToTag, 'NumberOfFractionPatternDigitsPerDay', '300A0079'), _defineProperty2(_keywordToTag, 'RepeatFractionCycleLength', '300A007A'), _defineProperty2(_keywordToTag, 'FractionPattern', '300A007B'), _defineProperty2(_keywordToTag, 'NumberOfBeams', '300A0080'), _defineProperty2(_keywordToTag, 'BeamDoseSpecificationPoint', '300A0082'), _defineProperty2(_keywordToTag, 'ReferencedDoseReferenceUID', '300A0083'), _defineProperty2(_keywordToTag, 'BeamDose', '300A0084'), _defineProperty2(_keywordToTag, 'BeamMeterset', '300A0086'), _defineProperty2(_keywordToTag, 'BeamDosePointDepth', '300A0088'), _defineProperty2(_keywordToTag, 'BeamDosePointEquivalentDepth', '300A0089'), _defineProperty2(_keywordToTag, 'BeamDosePointSSD', '300A008A'), _defineProperty2(_keywordToTag, 'BeamDoseMeaning', '300A008B'), _defineProperty2(_keywordToTag, 'BeamDoseVerificationControlPointSequence', '300A008C'), _defineProperty2(_keywordToTag, 'AverageBeamDosePointDepth', '300A008D'), _defineProperty2(_keywordToTag, 'AverageBeamDosePointEquivalentDepth', '300A008E'), _defineProperty2(_keywordToTag, 'AverageBeamDosePointSSD', '300A008F'), _defineProperty2(_keywordToTag, 'BeamDoseType', '300A0090'), _defineProperty2(_keywordToTag, 'AlternateBeamDose', '300A0091'), _defineProperty2(_keywordToTag, 'AlternateBeamDoseType', '300A0092'), _defineProperty2(_keywordToTag, 'DepthValueAveragingFlag', '300A0093'), _defineProperty2(_keywordToTag, 'BeamDosePointSourceToExternalContourDistance', '300A0094'), _defineProperty2(_keywordToTag, 'NumberOfBrachyApplicationSetups', '300A00A0'), _defineProperty2(_keywordToTag, 'BrachyApplicationSetupDoseSpecificationPoint', '300A00A2'), _defineProperty2(_keywordToTag, 'BrachyApplicationSetupDose', '300A00A4'), _defineProperty2(_keywordToTag, 'BeamSequence', '300A00B0'), _defineProperty2(_keywordToTag, 'TreatmentMachineName', '300A00B2'), _defineProperty2(_keywordToTag, 'PrimaryDosimeterUnit', '300A00B3'), _defineProperty2(_keywordToTag, 'SourceAxisDistance', '300A00B4'), _defineProperty2(_keywordToTag, 'BeamLimitingDeviceSequence', '300A00B6'), _defineProperty2(_keywordToTag, 'RTBeamLimitingDeviceType', '300A00B8'), _defineProperty2(_keywordToTag, 'SourceToBeamLimitingDeviceDistance', '300A00BA'), _defineProperty2(_keywordToTag, 'IsocenterToBeamLimitingDeviceDistance', '300A00BB'), _defineProperty2(_keywordToTag, 'NumberOfLeafJawPairs', '300A00BC'), _defineProperty2(_keywordToTag, 'LeafPositionBoundaries', '300A00BE'), _defineProperty2(_keywordToTag, 'BeamNumber', '300A00C0'), _defineProperty2(_keywordToTag, 'BeamName', '300A00C2'), _defineProperty2(_keywordToTag, 'BeamDescription', '300A00C3'), _defineProperty2(_keywordToTag, 'BeamType', '300A00C4'), _defineProperty2(_keywordToTag, 'BeamDeliveryDurationLimit', '300A00C5'), _defineProperty2(_keywordToTag, 'RadiationType', '300A00C6'), _defineProperty2(_keywordToTag, 'HighDoseTechniqueType', '300A00C7'), _defineProperty2(_keywordToTag, 'ReferenceImageNumber', '300A00C8'), _defineProperty2(_keywordToTag, 'PlannedVerificationImageSequence', '300A00CA'), _defineProperty2(_keywordToTag, 'ImagingDeviceSpecificAcquisitionParameters', '300A00CC'), _defineProperty2(_keywordToTag, 'TreatmentDeliveryType', '300A00CE'), _defineProperty2(_keywordToTag, 'NumberOfWedges', '300A00D0'), _defineProperty2(_keywordToTag, 'WedgeSequence', '300A00D1'), _defineProperty2(_keywordToTag, 'WedgeNumber', '300A00D2'), _defineProperty2(_keywordToTag, 'WedgeType', '300A00D3'), _defineProperty2(_keywordToTag, 'WedgeID', '300A00D4'), _defineProperty2(_keywordToTag, 'WedgeAngle', '300A00D5'), _defineProperty2(_keywordToTag, 'WedgeFactor', '300A00D6'), _defineProperty2(_keywordToTag, 'TotalWedgeTrayWaterEquivalentThickness', '300A00D7'), _defineProperty2(_keywordToTag, 'WedgeOrientation', '300A00D8'), _defineProperty2(_keywordToTag, 'IsocenterToWedgeTrayDistance', '300A00D9'), _defineProperty2(_keywordToTag, 'SourceToWedgeTrayDistance', '300A00DA'), _defineProperty2(_keywordToTag, 'WedgeThinEdgePosition', '300A00DB'), _defineProperty2(_keywordToTag, 'BolusID', '300A00DC'), _defineProperty2(_keywordToTag, 'BolusDescription', '300A00DD'), _defineProperty2(_keywordToTag, 'EffectiveWedgeAngle', '300A00DE'), _defineProperty2(_keywordToTag, 'NumberOfCompensators', '300A00E0'), _defineProperty2(_keywordToTag, 'MaterialID', '300A00E1'), _defineProperty2(_keywordToTag, 'TotalCompensatorTrayFactor', '300A00E2'), _defineProperty2(_keywordToTag, 'CompensatorSequence', '300A00E3'), _defineProperty2(_keywordToTag, 'CompensatorNumber', '300A00E4'), _defineProperty2(_keywordToTag, 'CompensatorID', '300A00E5'), _defineProperty2(_keywordToTag, 'SourceToCompensatorTrayDistance', '300A00E6'), _defineProperty2(_keywordToTag, 'CompensatorRows', '300A00E7'), _defineProperty2(_keywordToTag, 'CompensatorColumns', '300A00E8'), _defineProperty2(_keywordToTag, 'CompensatorPixelSpacing', '300A00E9'), _defineProperty2(_keywordToTag, 'CompensatorPosition', '300A00EA'), _defineProperty2(_keywordToTag, 'CompensatorTransmissionData', '300A00EB'), _defineProperty2(_keywordToTag, 'CompensatorThicknessData', '300A00EC'), _defineProperty2(_keywordToTag, 'NumberOfBoli', '300A00ED'), _defineProperty2(_keywordToTag, 'CompensatorType', '300A00EE'), _defineProperty2(_keywordToTag, 'CompensatorTrayID', '300A00EF'), _defineProperty2(_keywordToTag, 'NumberOfBlocks', '300A00F0'), _defineProperty2(_keywordToTag, 'TotalBlockTrayFactor', '300A00F2'), _defineProperty2(_keywordToTag, 'TotalBlockTrayWaterEquivalentThickness', '300A00F3'), _defineProperty2(_keywordToTag, 'BlockSequence', '300A00F4'), _defineProperty2(_keywordToTag, 'BlockTrayID', '300A00F5'), _defineProperty2(_keywordToTag, 'SourceToBlockTrayDistance', '300A00F6'), _defineProperty2(_keywordToTag, 'IsocenterToBlockTrayDistance', '300A00F7'), _defineProperty2(_keywordToTag, 'BlockType', '300A00F8'), _defineProperty2(_keywordToTag, 'AccessoryCode', '300A00F9'), _defineProperty2(_keywordToTag, 'BlockDivergence', '300A00FA'), _defineProperty2(_keywordToTag, 'BlockMountingPosition', '300A00FB'), _defineProperty2(_keywordToTag, 'BlockNumber', '300A00FC'), _defineProperty2(_keywordToTag, 'BlockName', '300A00FE'), _defineProperty2(_keywordToTag, 'BlockThickness', '300A0100'), _defineProperty2(_keywordToTag, 'BlockTransmission', '300A0102'), _defineProperty2(_keywordToTag, 'BlockNumberOfPoints', '300A0104'), _defineProperty2(_keywordToTag, 'BlockData', '300A0106'), _defineProperty2(_keywordToTag, 'ApplicatorSequence', '300A0107'), _defineProperty2(_keywordToTag, 'ApplicatorID', '300A0108'), _defineProperty2(_keywordToTag, 'ApplicatorType', '300A0109'), _defineProperty2(_keywordToTag, 'ApplicatorDescription', '300A010A'), _defineProperty2(_keywordToTag, 'CumulativeDoseReferenceCoefficient', '300A010C'), _defineProperty2(_keywordToTag, 'FinalCumulativeMetersetWeight', '300A010E'), _defineProperty2(_keywordToTag, 'NumberOfControlPoints', '300A0110'), _defineProperty2(_keywordToTag, 'ControlPointSequence', '300A0111'), _defineProperty2(_keywordToTag, 'ControlPointIndex', '300A0112'), _defineProperty2(_keywordToTag, 'NominalBeamEnergy', '300A0114'), _defineProperty2(_keywordToTag, 'DoseRateSet', '300A0115'), _defineProperty2(_keywordToTag, 'WedgePositionSequence', '300A0116'), _defineProperty2(_keywordToTag, 'WedgePosition', '300A0118'), _defineProperty2(_keywordToTag, 'BeamLimitingDevicePositionSequence', '300A011A'), _defineProperty2(_keywordToTag, 'LeafJawPositions', '300A011C'), _defineProperty2(_keywordToTag, 'GantryAngle', '300A011E'), _defineProperty2(_keywordToTag, 'GantryRotationDirection', '300A011F'), _defineProperty2(_keywordToTag, 'BeamLimitingDeviceAngle', '300A0120'), _defineProperty2(_keywordToTag, 'BeamLimitingDeviceRotationDirection', '300A0121'), _defineProperty2(_keywordToTag, 'PatientSupportAngle', '300A0122'), _defineProperty2(_keywordToTag, 'PatientSupportRotationDirection', '300A0123'), _defineProperty2(_keywordToTag, 'TableTopEccentricAxisDistance', '300A0124'), _defineProperty2(_keywordToTag, 'TableTopEccentricAngle', '300A0125'), _defineProperty2(_keywordToTag, 'TableTopEccentricRotationDirection', '300A0126'), _defineProperty2(_keywordToTag, 'TableTopVerticalPosition', '300A0128'), _defineProperty2(_keywordToTag, 'TableTopLongitudinalPosition', '300A0129'), _defineProperty2(_keywordToTag, 'TableTopLateralPosition', '300A012A'), _defineProperty2(_keywordToTag, 'IsocenterPosition', '300A012C'), _defineProperty2(_keywordToTag, 'SurfaceEntryPoint', '300A012E'), _defineProperty2(_keywordToTag, 'SourceToSurfaceDistance', '300A0130'), _defineProperty2(_keywordToTag, 'AverageBeamDosePointSourceToExternalContourDistance', '300A0131'), _defineProperty2(_keywordToTag, 'SourceToExternalContourDistance', '300A0132'), _defineProperty2(_keywordToTag, 'ExternalContourEntryPoint', '300A0133'), _defineProperty2(_keywordToTag, 'CumulativeMetersetWeight', '300A0134'), _defineProperty2(_keywordToTag, 'TableTopPitchAngle', '300A0140'), _defineProperty2(_keywordToTag, 'TableTopPitchRotationDirection', '300A0142'), _defineProperty2(_keywordToTag, 'TableTopRollAngle', '300A0144'), _defineProperty2(_keywordToTag, 'TableTopRollRotationDirection', '300A0146'), _defineProperty2(_keywordToTag, 'HeadFixationAngle', '300A0148'), _defineProperty2(_keywordToTag, 'GantryPitchAngle', '300A014A'), _defineProperty2(_keywordToTag, 'GantryPitchRotationDirection', '300A014C'), _defineProperty2(_keywordToTag, 'GantryPitchAngleTolerance', '300A014E'), _defineProperty2(_keywordToTag, 'FixationEye', '300A0150'), _defineProperty2(_keywordToTag, 'ChairHeadFramePosition', '300A0151'), _defineProperty2(_keywordToTag, 'HeadFixationAngleTolerance', '300A0152'), _defineProperty2(_keywordToTag, 'ChairHeadFramePositionTolerance', '300A0153'), _defineProperty2(_keywordToTag, 'FixationLightAzimuthalAngleTolerance', '300A0154'), _defineProperty2(_keywordToTag, 'FixationLightPolarAngleTolerance', '300A0155'), _defineProperty2(_keywordToTag, 'PatientSetupSequence', '300A0180'), _defineProperty2(_keywordToTag, 'PatientSetupNumber', '300A0182'), _defineProperty2(_keywordToTag, 'PatientSetupLabel', '300A0183'), _defineProperty2(_keywordToTag, 'PatientAdditionalPosition', '300A0184'), _defineProperty2(_keywordToTag, 'FixationDeviceSequence', '300A0190'), _defineProperty2(_keywordToTag, 'FixationDeviceType', '300A0192'), _defineProperty2(_keywordToTag, 'FixationDeviceLabel', '300A0194'), _defineProperty2(_keywordToTag, 'FixationDeviceDescription', '300A0196'), _defineProperty2(_keywordToTag, 'FixationDevicePosition', '300A0198'), _defineProperty2(_keywordToTag, 'FixationDevicePitchAngle', '300A0199'), _defineProperty2(_keywordToTag, 'FixationDeviceRollAngle', '300A019A'), _defineProperty2(_keywordToTag, 'ShieldingDeviceSequence', '300A01A0'), _defineProperty2(_keywordToTag, 'ShieldingDeviceType', '300A01A2'), _defineProperty2(_keywordToTag, 'ShieldingDeviceLabel', '300A01A4'), _defineProperty2(_keywordToTag, 'ShieldingDeviceDescription', '300A01A6'), _defineProperty2(_keywordToTag, 'ShieldingDevicePosition', '300A01A8'), _defineProperty2(_keywordToTag, 'SetupTechnique', '300A01B0'), _defineProperty2(_keywordToTag, 'SetupTechniqueDescription', '300A01B2'), _defineProperty2(_keywordToTag, 'SetupDeviceSequence', '300A01B4'), _defineProperty2(_keywordToTag, 'SetupDeviceType', '300A01B6'), _defineProperty2(_keywordToTag, 'SetupDeviceLabel', '300A01B8'), _defineProperty2(_keywordToTag, 'SetupDeviceDescription', '300A01BA'), _defineProperty2(_keywordToTag, 'SetupDeviceParameter', '300A01BC'), _defineProperty2(_keywordToTag, 'SetupReferenceDescription', '300A01D0'), _defineProperty2(_keywordToTag, 'TableTopVerticalSetupDisplacement', '300A01D2'), _defineProperty2(_keywordToTag, 'TableTopLongitudinalSetupDisplacement', '300A01D4'), _defineProperty2(_keywordToTag, 'TableTopLateralSetupDisplacement', '300A01D6'), _defineProperty2(_keywordToTag, 'BrachyTreatmentTechnique', '300A0200'), _defineProperty2(_keywordToTag, 'BrachyTreatmentType', '300A0202'), _defineProperty2(_keywordToTag, 'TreatmentMachineSequence', '300A0206'), _defineProperty2(_keywordToTag, 'SourceSequence', '300A0210'), _defineProperty2(_keywordToTag, 'SourceNumber', '300A0212'), _defineProperty2(_keywordToTag, 'SourceType', '300A0214'), _defineProperty2(_keywordToTag, 'SourceManufacturer', '300A0216'), _defineProperty2(_keywordToTag, 'ActiveSourceDiameter', '300A0218'), _defineProperty2(_keywordToTag, 'ActiveSourceLength', '300A021A'), _defineProperty2(_keywordToTag, 'SourceModelID', '300A021B'), _defineProperty2(_keywordToTag, 'SourceDescription', '300A021C'), _defineProperty2(_keywordToTag, 'SourceEncapsulationNominalThickness', '300A0222'), _defineProperty2(_keywordToTag, 'SourceEncapsulationNominalTransmission', '300A0224'), _defineProperty2(_keywordToTag, 'SourceIsotopeName', '300A0226'), _defineProperty2(_keywordToTag, 'SourceIsotopeHalfLife', '300A0228'), _defineProperty2(_keywordToTag, 'SourceStrengthUnits', '300A0229'), _defineProperty2(_keywordToTag, 'ReferenceAirKermaRate', '300A022A'), _defineProperty2(_keywordToTag, 'SourceStrength', '300A022B'), _defineProperty2(_keywordToTag, 'SourceStrengthReferenceDate', '300A022C'), _defineProperty2(_keywordToTag, 'SourceStrengthReferenceTime', '300A022E'), _defineProperty2(_keywordToTag, 'ApplicationSetupSequence', '300A0230'), _defineProperty2(_keywordToTag, 'ApplicationSetupType', '300A0232'), _defineProperty2(_keywordToTag, 'ApplicationSetupNumber', '300A0234'), _defineProperty2(_keywordToTag, 'ApplicationSetupName', '300A0236'), _defineProperty2(_keywordToTag, 'ApplicationSetupManufacturer', '300A0238'), _defineProperty2(_keywordToTag, 'TemplateNumber', '300A0240'), _defineProperty2(_keywordToTag, 'TemplateType', '300A0242'), _defineProperty2(_keywordToTag, 'TemplateName', '300A0244'), _defineProperty2(_keywordToTag, 'TotalReferenceAirKerma', '300A0250'), _defineProperty2(_keywordToTag, 'BrachyAccessoryDeviceSequence', '300A0260'), _defineProperty2(_keywordToTag, 'BrachyAccessoryDeviceNumber', '300A0262'), _defineProperty2(_keywordToTag, 'BrachyAccessoryDeviceID', '300A0263'), _defineProperty2(_keywordToTag, 'BrachyAccessoryDeviceType', '300A0264'), _defineProperty2(_keywordToTag, 'BrachyAccessoryDeviceName', '300A0266'), _defineProperty2(_keywordToTag, 'BrachyAccessoryDeviceNominalThickness', '300A026A'), _defineProperty2(_keywordToTag, 'BrachyAccessoryDeviceNominalTransmission', '300A026C'), _defineProperty2(_keywordToTag, 'ChannelEffectiveLength', '300A0271'), _defineProperty2(_keywordToTag, 'ChannelInnerLength', '300A0272'), _defineProperty2(_keywordToTag, 'AfterloaderChannelID', '300A0273'), _defineProperty2(_keywordToTag, 'SourceApplicatorTipLength', '300A0274'), _defineProperty2(_keywordToTag, 'ChannelSequence', '300A0280'), _defineProperty2(_keywordToTag, 'ChannelNumber', '300A0282'), _defineProperty2(_keywordToTag, 'ChannelLength', '300A0284'), _defineProperty2(_keywordToTag, 'ChannelTotalTime', '300A0286'), _defineProperty2(_keywordToTag, 'SourceMovementType', '300A0288'), _defineProperty2(_keywordToTag, 'NumberOfPulses', '300A028A'), _defineProperty2(_keywordToTag, 'PulseRepetitionInterval', '300A028C'), _defineProperty2(_keywordToTag, 'SourceApplicatorNumber', '300A0290'), _defineProperty2(_keywordToTag, 'SourceApplicatorID', '300A0291'), _defineProperty2(_keywordToTag, 'SourceApplicatorType', '300A0292'), _defineProperty2(_keywordToTag, 'SourceApplicatorName', '300A0294'), _defineProperty2(_keywordToTag, 'SourceApplicatorLength', '300A0296'), _defineProperty2(_keywordToTag, 'SourceApplicatorManufacturer', '300A0298'), _defineProperty2(_keywordToTag, 'SourceApplicatorWallNominalThickness', '300A029C'), _defineProperty2(_keywordToTag, 'SourceApplicatorWallNominalTransmission', '300A029E'), _defineProperty2(_keywordToTag, 'SourceApplicatorStepSize', '300A02A0'), _defineProperty2(_keywordToTag, 'TransferTubeNumber', '300A02A2'), _defineProperty2(_keywordToTag, 'TransferTubeLength', '300A02A4'), _defineProperty2(_keywordToTag, 'ChannelShieldSequence', '300A02B0'), _defineProperty2(_keywordToTag, 'ChannelShieldNumber', '300A02B2'), _defineProperty2(_keywordToTag, 'ChannelShieldID', '300A02B3'), _defineProperty2(_keywordToTag, 'ChannelShieldName', '300A02B4'), _defineProperty2(_keywordToTag, 'ChannelShieldNominalThickness', '300A02B8'), _defineProperty2(_keywordToTag, 'ChannelShieldNominalTransmission', '300A02BA'), _defineProperty2(_keywordToTag, 'FinalCumulativeTimeWeight', '300A02C8'), _defineProperty2(_keywordToTag, 'BrachyControlPointSequence', '300A02D0'), _defineProperty2(_keywordToTag, 'ControlPointRelativePosition', '300A02D2'), _defineProperty2(_keywordToTag, '300A02D4', 'ControlPoint3DPosition'), _defineProperty2(_keywordToTag, 'CumulativeTimeWeight', '300A02D6'), _defineProperty2(_keywordToTag, 'CompensatorDivergence', '300A02E0'), _defineProperty2(_keywordToTag, 'CompensatorMountingPosition', '300A02E1'), _defineProperty2(_keywordToTag, 'SourceToCompensatorDistance', '300A02E2'), _defineProperty2(_keywordToTag, 'TotalCompensatorTrayWaterEquivalentThickness', '300A02E3'), _defineProperty2(_keywordToTag, 'IsocenterToCompensatorTrayDistance', '300A02E4'), _defineProperty2(_keywordToTag, 'CompensatorColumnOffset', '300A02E5'), _defineProperty2(_keywordToTag, 'IsocenterToCompensatorDistances', '300A02E6'), _defineProperty2(_keywordToTag, 'CompensatorRelativeStoppingPowerRatio', '300A02E7'), _defineProperty2(_keywordToTag, 'CompensatorMillingToolDiameter', '300A02E8'), _defineProperty2(_keywordToTag, 'IonRangeCompensatorSequence', '300A02EA'), _defineProperty2(_keywordToTag, 'CompensatorDescription', '300A02EB'), _defineProperty2(_keywordToTag, 'RadiationMassNumber', '300A0302'), _defineProperty2(_keywordToTag, 'RadiationAtomicNumber', '300A0304'), _defineProperty2(_keywordToTag, 'RadiationChargeState', '300A0306'), _defineProperty2(_keywordToTag, 'ScanMode', '300A0308'), _defineProperty2(_keywordToTag, 'ModulatedScanModeType', '300A0309'), _defineProperty2(_keywordToTag, 'VirtualSourceAxisDistances', '300A030A'), _defineProperty2(_keywordToTag, 'SnoutSequence', '300A030C'), _defineProperty2(_keywordToTag, 'SnoutPosition', '300A030D'), _defineProperty2(_keywordToTag, 'SnoutID', '300A030F'), _defineProperty2(_keywordToTag, 'NumberOfRangeShifters', '300A0312'), _defineProperty2(_keywordToTag, 'RangeShifterSequence', '300A0314'), _defineProperty2(_keywordToTag, 'RangeShifterNumber', '300A0316'), _defineProperty2(_keywordToTag, 'RangeShifterID', '300A0318'), _defineProperty2(_keywordToTag, 'RangeShifterType', '300A0320'), _defineProperty2(_keywordToTag, 'RangeShifterDescription', '300A0322'), _defineProperty2(_keywordToTag, 'NumberOfLateralSpreadingDevices', '300A0330'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceSequence', '300A0332'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceNumber', '300A0334'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceID', '300A0336'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceType', '300A0338'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceDescription', '300A033A'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceWaterEquivalentThickness', '300A033C'), _defineProperty2(_keywordToTag, 'NumberOfRangeModulators', '300A0340'), _defineProperty2(_keywordToTag, 'RangeModulatorSequence', '300A0342'), _defineProperty2(_keywordToTag, 'RangeModulatorNumber', '300A0344'), _defineProperty2(_keywordToTag, 'RangeModulatorID', '300A0346'), _defineProperty2(_keywordToTag, 'RangeModulatorType', '300A0348'), _defineProperty2(_keywordToTag, 'RangeModulatorDescription', '300A034A'), _defineProperty2(_keywordToTag, 'BeamCurrentModulationID', '300A034C'), _defineProperty2(_keywordToTag, 'PatientSupportType', '300A0350'), _defineProperty2(_keywordToTag, 'PatientSupportID', '300A0352'), _defineProperty2(_keywordToTag, 'PatientSupportAccessoryCode', '300A0354'), _defineProperty2(_keywordToTag, 'TrayAccessoryCode', '300A0355'), _defineProperty2(_keywordToTag, 'FixationLightAzimuthalAngle', '300A0356'), _defineProperty2(_keywordToTag, 'FixationLightPolarAngle', '300A0358'), _defineProperty2(_keywordToTag, 'MetersetRate', '300A035A'), _defineProperty2(_keywordToTag, 'RangeShifterSettingsSequence', '300A0360'), _defineProperty2(_keywordToTag, 'RangeShifterSetting', '300A0362'), _defineProperty2(_keywordToTag, 'IsocenterToRangeShifterDistance', '300A0364'), _defineProperty2(_keywordToTag, 'RangeShifterWaterEquivalentThickness', '300A0366'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceSettingsSequence', '300A0370'), _defineProperty2(_keywordToTag, 'LateralSpreadingDeviceSetting', '300A0372'), _defineProperty2(_keywordToTag, 'IsocenterToLateralSpreadingDeviceDistance', '300A0374'), _defineProperty2(_keywordToTag, 'RangeModulatorSettingsSequence', '300A0380'), _defineProperty2(_keywordToTag, 'RangeModulatorGatingStartValue', '300A0382'), _defineProperty2(_keywordToTag, 'RangeModulatorGatingStopValue', '300A0384'), _defineProperty2(_keywordToTag, 'RangeModulatorGatingStartWaterEquivalentThickness', '300A0386'), _defineProperty2(_keywordToTag, 'RangeModulatorGatingStopWaterEquivalentThickness', '300A0388'), _defineProperty2(_keywordToTag, 'IsocenterToRangeModulatorDistance', '300A038A'), _defineProperty2(_keywordToTag, 'ScanSpotTimeOffset', '300A038F'), _defineProperty2(_keywordToTag, 'ScanSpotTuneID', '300A0390'), _defineProperty2(_keywordToTag, 'ScanSpotPrescribedIndices', '300A0391'), _defineProperty2(_keywordToTag, 'NumberOfScanSpotPositions', '300A0392'), _defineProperty2(_keywordToTag, 'ScanSpotReordered', '300A0393'), _defineProperty2(_keywordToTag, 'ScanSpotPositionMap', '300A0394'), _defineProperty2(_keywordToTag, 'ScanSpotReorderingAllowed', '300A0395'), _defineProperty2(_keywordToTag, 'ScanSpotMetersetWeights', '300A0396'), _defineProperty2(_keywordToTag, 'ScanningSpotSize', '300A0398'), _defineProperty2(_keywordToTag, 'NumberOfPaintings', '300A039A'), _defineProperty2(_keywordToTag, 'IonToleranceTableSequence', '300A03A0'), _defineProperty2(_keywordToTag, 'IonBeamSequence', '300A03A2'), _defineProperty2(_keywordToTag, 'IonBeamLimitingDeviceSequence', '300A03A4'), _defineProperty2(_keywordToTag, 'IonBlockSequence', '300A03A6'), _defineProperty2(_keywordToTag, 'IonControlPointSequence', '300A03A8'), _defineProperty2(_keywordToTag, 'IonWedgeSequence', '300A03AA'), _defineProperty2(_keywordToTag, 'IonWedgePositionSequence', '300A03AC'), _defineProperty2(_keywordToTag, 'ReferencedSetupImageSequence', '300A0401'), _defineProperty2(_keywordToTag, 'SetupImageComment', '300A0402'), _defineProperty2(_keywordToTag, 'MotionSynchronizationSequence', '300A0410'), _defineProperty2(_keywordToTag, 'ControlPointOrientation', '300A0412'), _defineProperty2(_keywordToTag, 'GeneralAccessorySequence', '300A0420'), _defineProperty2(_keywordToTag, 'GeneralAccessoryID', '300A0421'), _defineProperty2(_keywordToTag, 'GeneralAccessoryDescription', '300A0422'), _defineProperty2(_keywordToTag, 'GeneralAccessoryType', '300A0423'), _defineProperty2(_keywordToTag, 'GeneralAccessoryNumber', '300A0424'), _defineProperty2(_keywordToTag, 'SourceToGeneralAccessoryDistance', '300A0425'), _defineProperty2(_keywordToTag, 'ApplicatorGeometrySequence', '300A0431'), _defineProperty2(_keywordToTag, 'ApplicatorApertureShape', '300A0432'), _defineProperty2(_keywordToTag, 'ApplicatorOpening', '300A0433'), _defineProperty2(_keywordToTag, 'ApplicatorOpeningX', '300A0434'), _defineProperty2(_keywordToTag, 'ApplicatorOpeningY', '300A0435'), _defineProperty2(_keywordToTag, 'SourceToApplicatorMountingPositionDistance', '300A0436'), _defineProperty2(_keywordToTag, 'NumberOfBlockSlabItems', '300A0440'), _defineProperty2(_keywordToTag, 'BlockSlabSequence', '300A0441'), _defineProperty2(_keywordToTag, 'BlockSlabThickness', '300A0442'), _defineProperty2(_keywordToTag, 'BlockSlabNumber', '300A0443'), _defineProperty2(_keywordToTag, 'DeviceMotionControlSequence', '300A0450'), _defineProperty2(_keywordToTag, 'DeviceMotionExecutionMode', '300A0451'), _defineProperty2(_keywordToTag, 'DeviceMotionObservationMode', '300A0452'), _defineProperty2(_keywordToTag, 'DeviceMotionParameterCodeSequence', '300A0453'), _defineProperty2(_keywordToTag, 'DistalDepthFraction', '300A0501'), _defineProperty2(_keywordToTag, 'DistalDepth', '300A0502'), _defineProperty2(_keywordToTag, 'NominalRangeModulationFractions', '300A0503'), _defineProperty2(_keywordToTag, 'NominalRangeModulatedRegionDepths', '300A0504'), _defineProperty2(_keywordToTag, 'DepthDoseParametersSequence', '300A0505'), _defineProperty2(_keywordToTag, 'DeliveredDepthDoseParametersSequence', '300A0506'), _defineProperty2(_keywordToTag, 'DeliveredDistalDepthFraction', '300A0507'), _defineProperty2(_keywordToTag, 'DeliveredDistalDepth', '300A0508'), _defineProperty2(_keywordToTag, 'DeliveredNominalRangeModulationFractions', '300A0509'), _defineProperty2(_keywordToTag, 'DeliveredNominalRangeModulatedRegionDepths', '300A0510'), _defineProperty2(_keywordToTag, 'DeliveredReferenceDoseDefinition', '300A0511'), _defineProperty2(_keywordToTag, 'ReferenceDoseDefinition', '300A0512'), _defineProperty2(_keywordToTag, 'ReferencedRTPlanSequence', '300C0002'), _defineProperty2(_keywordToTag, 'ReferencedBeamSequence', '300C0004'), _defineProperty2(_keywordToTag, 'ReferencedBeamNumber', '300C0006'), _defineProperty2(_keywordToTag, 'ReferencedReferenceImageNumber', '300C0007'), _defineProperty2(_keywordToTag, 'StartCumulativeMetersetWeight', '300C0008'), _defineProperty2(_keywordToTag, 'EndCumulativeMetersetWeight', '300C0009'), _defineProperty2(_keywordToTag, 'ReferencedBrachyApplicationSetupSequence', '300C000A'), _defineProperty2(_keywordToTag, 'ReferencedBrachyApplicationSetupNumber', '300C000C'), _defineProperty2(_keywordToTag, 'ReferencedSourceNumber', '300C000E'), _defineProperty2(_keywordToTag, 'ReferencedFractionGroupSequence', '300C0020'), _defineProperty2(_keywordToTag, 'ReferencedFractionGroupNumber', '300C0022'), _defineProperty2(_keywordToTag, 'ReferencedVerificationImageSequence', '300C0040'), _defineProperty2(_keywordToTag, 'ReferencedReferenceImageSequence', '300C0042'), _defineProperty2(_keywordToTag, 'ReferencedDoseReferenceSequence', '300C0050'), _defineProperty2(_keywordToTag, 'ReferencedDoseReferenceNumber', '300C0051'), _defineProperty2(_keywordToTag, 'BrachyReferencedDoseReferenceSequence', '300C0055'), _defineProperty2(_keywordToTag, 'ReferencedStructureSetSequence', '300C0060'), _defineProperty2(_keywordToTag, 'ReferencedPatientSetupNumber', '300C006A'), _defineProperty2(_keywordToTag, 'ReferencedDoseSequence', '300C0080'), _defineProperty2(_keywordToTag, 'ReferencedToleranceTableNumber', '300C00A0'), _defineProperty2(_keywordToTag, 'ReferencedBolusSequence', '300C00B0'), _defineProperty2(_keywordToTag, 'ReferencedWedgeNumber', '300C00C0'), _defineProperty2(_keywordToTag, 'ReferencedCompensatorNumber', '300C00D0'), _defineProperty2(_keywordToTag, 'ReferencedBlockNumber', '300C00E0'), _defineProperty2(_keywordToTag, 'ReferencedControlPointIndex', '300C00F0'), _defineProperty2(_keywordToTag, 'ReferencedControlPointSequence', '300C00F2'), _defineProperty2(_keywordToTag, 'ReferencedStartControlPointIndex', '300C00F4'), _defineProperty2(_keywordToTag, 'ReferencedStopControlPointIndex', '300C00F6'), _defineProperty2(_keywordToTag, 'ReferencedRangeShifterNumber', '300C0100'), _defineProperty2(_keywordToTag, 'ReferencedLateralSpreadingDeviceNumber', '300C0102'), _defineProperty2(_keywordToTag, 'ReferencedRangeModulatorNumber', '300C0104'), _defineProperty2(_keywordToTag, 'OmittedBeamTaskSequence', '300C0111'), _defineProperty2(_keywordToTag, 'ReasonForOmission', '300C0112'), _defineProperty2(_keywordToTag, 'ReasonForOmissionDescription', '300C0113'), _defineProperty2(_keywordToTag, 'ApprovalStatus', '300E0002'), _defineProperty2(_keywordToTag, 'ReviewDate', '300E0004'), _defineProperty2(_keywordToTag, 'ReviewTime', '300E0005'), _defineProperty2(_keywordToTag, 'ReviewerName', '300E0008'), _defineProperty2(_keywordToTag, 'Arbitrary', '40000010'), _defineProperty2(_keywordToTag, 'TextComments', '40004000'), _defineProperty2(_keywordToTag, 'ResultsID', '40080040'), _defineProperty2(_keywordToTag, 'ResultsIDIssuer', '40080042'), _defineProperty2(_keywordToTag, 'ReferencedInterpretationSequence', '40080050'), _defineProperty2(_keywordToTag, 'ReportProductionStatusTrial', '400800FF'), _defineProperty2(_keywordToTag, 'InterpretationRecordedDate', '40080100'), _defineProperty2(_keywordToTag, 'InterpretationRecordedTime', '40080101'), _defineProperty2(_keywordToTag, 'InterpretationRecorder', '40080102'), _defineProperty2(_keywordToTag, 'ReferenceToRecordedSound', '40080103'), _defineProperty2(_keywordToTag, 'InterpretationTranscriptionDate', '40080108'), _defineProperty2(_keywordToTag, 'InterpretationTranscriptionTime', '40080109'), _defineProperty2(_keywordToTag, 'InterpretationTranscriber', '4008010A'), _defineProperty2(_keywordToTag, 'InterpretationText', '4008010B'), _defineProperty2(_keywordToTag, 'InterpretationAuthor', '4008010C'), _defineProperty2(_keywordToTag, 'InterpretationApproverSequence', '40080111'), _defineProperty2(_keywordToTag, 'InterpretationApprovalDate', '40080112'), _defineProperty2(_keywordToTag, 'InterpretationApprovalTime', '40080113'), _defineProperty2(_keywordToTag, 'PhysicianApprovingInterpretation', '40080114'), _defineProperty2(_keywordToTag, 'InterpretationDiagnosisDescription', '40080115'), _defineProperty2(_keywordToTag, 'InterpretationDiagnosisCodeSequence', '40080117'), _defineProperty2(_keywordToTag, 'ResultsDistributionListSequence', '40080118'), _defineProperty2(_keywordToTag, 'DistributionName', '40080119'), _defineProperty2(_keywordToTag, 'DistributionAddress', '4008011A'), _defineProperty2(_keywordToTag, 'InterpretationID', '40080200'), _defineProperty2(_keywordToTag, 'InterpretationIDIssuer', '40080202'), _defineProperty2(_keywordToTag, 'InterpretationTypeID', '40080210'), _defineProperty2(_keywordToTag, 'InterpretationStatusID', '40080212'), _defineProperty2(_keywordToTag, 'Impressions', '40080300'), _defineProperty2(_keywordToTag, 'ResultsComments', '40084000'), _defineProperty2(_keywordToTag, 'LowEnergyDetectors', '40100001'), _defineProperty2(_keywordToTag, 'HighEnergyDetectors', '40100002'), _defineProperty2(_keywordToTag, 'DetectorGeometrySequence', '40100004'), _defineProperty2(_keywordToTag, 'ThreatROIVoxelSequence', '40101001'), _defineProperty2(_keywordToTag, 'ThreatROIBase', '40101004'), _defineProperty2(_keywordToTag, 'ThreatROIExtents', '40101005'), _defineProperty2(_keywordToTag, 'ThreatROIBitmap', '40101006'), _defineProperty2(_keywordToTag, 'RouteSegmentID', '40101007'), _defineProperty2(_keywordToTag, 'GantryType', '40101008'), _defineProperty2(_keywordToTag, 'OOIOwnerType', '40101009'), _defineProperty2(_keywordToTag, 'RouteSegmentSequence', '4010100A'), _defineProperty2(_keywordToTag, 'PotentialThreatObjectID', '40101010'), _defineProperty2(_keywordToTag, 'ThreatSequence', '40101011'), _defineProperty2(_keywordToTag, 'ThreatCategory', '40101012'), _defineProperty2(_keywordToTag, 'ThreatCategoryDescription', '40101013'), _defineProperty2(_keywordToTag, 'ATDAbilityAssessment', '40101014'), _defineProperty2(_keywordToTag, 'ATDAssessmentFlag', '40101015'), _defineProperty2(_keywordToTag, 'ATDAssessmentProbability', '40101016'), _defineProperty2(_keywordToTag, 'Mass', '40101017'), _defineProperty2(_keywordToTag, 'Density', '40101018'), _defineProperty2(_keywordToTag, 'ZEffective', '40101019'), _defineProperty2(_keywordToTag, 'BoardingPassID', '4010101A'), _defineProperty2(_keywordToTag, 'CenterOfMass', '4010101B'), _defineProperty2(_keywordToTag, 'CenterOfPTO', '4010101C'), _defineProperty2(_keywordToTag, 'BoundingPolygon', '4010101D'), _defineProperty2(_keywordToTag, 'RouteSegmentStartLocationID', '4010101E'), _defineProperty2(_keywordToTag, 'RouteSegmentEndLocationID', '4010101F'), _defineProperty2(_keywordToTag, 'RouteSegmentLocationIDType', '40101020'), _defineProperty2(_keywordToTag, 'AbortReason', '40101021'), _defineProperty2(_keywordToTag, 'VolumeOfPTO', '40101023'), _defineProperty2(_keywordToTag, 'AbortFlag', '40101024'), _defineProperty2(_keywordToTag, 'RouteSegmentStartTime', '40101025'), _defineProperty2(_keywordToTag, 'RouteSegmentEndTime', '40101026'), _defineProperty2(_keywordToTag, 'TDRType', '40101027'), _defineProperty2(_keywordToTag, 'InternationalRouteSegment', '40101028'), _defineProperty2(_keywordToTag, 'ThreatDetectionAlgorithmandVersion', '40101029'), _defineProperty2(_keywordToTag, 'AssignedLocation', '4010102A'), _defineProperty2(_keywordToTag, 'AlarmDecisionTime', '4010102B'), _defineProperty2(_keywordToTag, 'AlarmDecision', '40101031'), _defineProperty2(_keywordToTag, 'NumberOfTotalObjects', '40101033'), _defineProperty2(_keywordToTag, 'NumberOfAlarmObjects', '40101034'), _defineProperty2(_keywordToTag, 'PTORepresentationSequence', '40101037'), _defineProperty2(_keywordToTag, 'ATDAssessmentSequence', '40101038'), _defineProperty2(_keywordToTag, 'TIPType', '40101039'), _defineProperty2(_keywordToTag, 'DICOSVersion', '4010103A'), _defineProperty2(_keywordToTag, 'OOIOwnerCreationTime', '40101041'), _defineProperty2(_keywordToTag, 'OOIType', '40101042'), _defineProperty2(_keywordToTag, 'OOISize', '40101043'), _defineProperty2(_keywordToTag, 'AcquisitionStatus', '40101044'), _defineProperty2(_keywordToTag, 'BasisMaterialsCodeSequence', '40101045'), _defineProperty2(_keywordToTag, 'PhantomType', '40101046'), _defineProperty2(_keywordToTag, 'OOIOwnerSequence', '40101047'), _defineProperty2(_keywordToTag, 'ScanType', '40101048'), _defineProperty2(_keywordToTag, 'ItineraryID', '40101051'), _defineProperty2(_keywordToTag, 'ItineraryIDType', '40101052'), _defineProperty2(_keywordToTag, 'ItineraryIDAssigningAuthority', '40101053'), _defineProperty2(_keywordToTag, 'RouteID', '40101054'), _defineProperty2(_keywordToTag, 'RouteIDAssigningAuthority', '40101055'), _defineProperty2(_keywordToTag, 'InboundArrivalType', '40101056'), _defineProperty2(_keywordToTag, 'CarrierID', '40101058'), _defineProperty2(_keywordToTag, 'CarrierIDAssigningAuthority', '40101059'), _defineProperty2(_keywordToTag, 'SourceOrientation', '40101060'), _defineProperty2(_keywordToTag, 'SourcePosition', '40101061'), _defineProperty2(_keywordToTag, 'BeltHeight', '40101062'), _defineProperty2(_keywordToTag, 'AlgorithmRoutingCodeSequence', '40101064'), _defineProperty2(_keywordToTag, 'TransportClassification', '40101067'), _defineProperty2(_keywordToTag, 'OOITypeDescriptor', '40101068'), _defineProperty2(_keywordToTag, 'TotalProcessingTime', '40101069'), _defineProperty2(_keywordToTag, 'DetectorCalibrationData', '4010106C'), _defineProperty2(_keywordToTag, 'AdditionalScreeningPerformed', '4010106D'), _defineProperty2(_keywordToTag, 'AdditionalInspectionSelectionCriteria', '4010106E'), _defineProperty2(_keywordToTag, 'AdditionalInspectionMethodSequence', '4010106F'), _defineProperty2(_keywordToTag, 'AITDeviceType', '40101070'), _defineProperty2(_keywordToTag, 'QRMeasurementsSequence', '40101071'), _defineProperty2(_keywordToTag, 'TargetMaterialSequence', '40101072'), _defineProperty2(_keywordToTag, 'SNRThreshold', '40101073'), _defineProperty2(_keywordToTag, 'ImageScaleRepresentation', '40101075'), _defineProperty2(_keywordToTag, 'ReferencedPTOSequence', '40101076'), _defineProperty2(_keywordToTag, 'ReferencedTDRInstanceSequence', '40101077'), _defineProperty2(_keywordToTag, 'PTOLocationDescription', '40101078'), _defineProperty2(_keywordToTag, 'AnomalyLocatorIndicatorSequence', '40101079'), _defineProperty2(_keywordToTag, 'AnomalyLocatorIndicator', '4010107A'), _defineProperty2(_keywordToTag, 'PTORegionSequence', '4010107B'), _defineProperty2(_keywordToTag, 'InspectionSelectionCriteria', '4010107C'), _defineProperty2(_keywordToTag, 'SecondaryInspectionMethodSequence', '4010107D'), _defineProperty2(_keywordToTag, 'PRCSToRCSOrientation', '4010107E'), _defineProperty2(_keywordToTag, 'MACParametersSequence', '4FFE0001'), _defineProperty2(_keywordToTag, 'SharedFunctionalGroupsSequence', '52009229'), _defineProperty2(_keywordToTag, 'PerFrameFunctionalGroupsSequence', '52009230'), _defineProperty2(_keywordToTag, 'WaveformSequence', '54000100'), _defineProperty2(_keywordToTag, 'ChannelMinimumValue', '54000110'), _defineProperty2(_keywordToTag, 'ChannelMaximumValue', '54000112'), _defineProperty2(_keywordToTag, 'WaveformBitsAllocated', '54001004'), _defineProperty2(_keywordToTag, 'WaveformSampleInterpretation', '54001006'), _defineProperty2(_keywordToTag, 'WaveformPaddingValue', '5400100A'), _defineProperty2(_keywordToTag, 'WaveformData', '54001010'), _defineProperty2(_keywordToTag, 'FirstOrderPhaseCorrectionAngle', '56000010'), _defineProperty2(_keywordToTag, 'SpectroscopyData', '56000020'), _defineProperty2(_keywordToTag, 'FloatPixelData', '7FE00008'), _defineProperty2(_keywordToTag, 'DoubleFloatPixelData', '7FE00009'), _defineProperty2(_keywordToTag, 'PixelData', '7FE00010'), _defineProperty2(_keywordToTag, 'CoefficientsSDVN', '7FE00020'), _defineProperty2(_keywordToTag, 'CoefficientsSDHN', '7FE00030'), _defineProperty2(_keywordToTag, 'CoefficientsSDDN', '7FE00040'), _defineProperty2(_keywordToTag, 'DigitalSignaturesSequence', 'FFFAFFFA'), _defineProperty2(_keywordToTag, 'DataSetTrailingPadding', 'FFFCFFFC'), _defineProperty2(_keywordToTag, 'Item', 'FFFEE000'), _defineProperty2(_keywordToTag, 'ItemDelimitationItem', 'FFFEE00D'), _defineProperty2(_keywordToTag, 'SequenceDelimitationItem', 'FFFEE0DD'), _keywordToTag);\n    Object.freeze(keywordToTag);\n\n    function getFrameMapping(metadata) {\n      var rows = metadata.Rows;\n      var columns = metadata.Columns;\n      var totalPixelMatrixColumns = metadata.TotalPixelMatrixColumns;\n      var totalPixelMatrixRows = metadata.TotalPixelMatrixRows;\n      var sopInstanceUID = metadata.SOPInstanceUID;\n      var numberOfFrames = metadata.NumberOfFrames || 1;\n      numberOfFrames = Number(numberOfFrames);\n      var frameOffsetNumber = metadata.ConcatenationFrameOffsetNumber || 0;\n      frameOffsetNumber = Number(frameOffsetNumber);\n      /*\n       * The values \"TILED_SPARSE\" and \"TILED_FULL\" were introduced in the 2018\n       * of the standard. Older datasets are equivalent to \"TILED_SPARSE\"\n       * even though they may not have a value or a different value.\n      */\n\n      var dimensionOrganizationType = metadata.DimensionOrganizationType || 'TILED_SPARSE';\n      var tilesPerRow = Math.ceil(totalPixelMatrixColumns / columns);\n      var frameMapping = {};\n\n      if (dimensionOrganizationType === 'TILED_FULL') {\n        var offset = frameOffsetNumber + 1;\n        var limit = frameOffsetNumber + numberOfFrames;\n\n        for (var j = offset; j <= limit; j++) {\n          var rowFraction = j / tilesPerRow;\n          var rowIndex = Math.ceil(rowFraction);\n          var colIndex = j - rowIndex * tilesPerRow + tilesPerRow;\n\n          var _index = rowIndex + '-' + colIndex;\n\n          var frameNumber = j - offset + 1;\n          frameMapping[_index] = \"\".concat(sopInstanceUID, \"/frames/\").concat(frameNumber);\n        }\n      } else {\n        var functionalGroups = metadata.PerFrameFunctionalGroupsSequence;\n\n        for (var _j = 0; _j < numberOfFrames; _j++) {\n          var planePositions = functionalGroups[_j].PlanePositionSlideSequence[0];\n          var rowPosition = planePositions.RowPositionInTotalImagePixelMatrix;\n          var columnPosition = planePositions.ColumnPositionInTotalImagePixelMatrix;\n\n          var _rowIndex = Math.ceil(rowPosition / columns);\n\n          var _colIndex = Math.ceil(columnPosition / rows);\n\n          var _index2 = _rowIndex + '-' + _colIndex;\n\n          var _frameNumber = _j + 1;\n\n          frameMapping[_index2] = \"\".concat(sopInstanceUID, \"/frames/\").concat(_frameNumber);\n        }\n      }\n\n      return frameMapping;\n    }\n\n    function formatImageMetadata(metadata) {\n      var sopClassUID = metadata['00080016']['Value'][0];\n\n      if (sopClassUID !== '1.2.840.10008.5.1.4.1.1.77.1.6') {\n        throw new Error('SOP Class UID \"' + sopClassUID + '\" is not supported');\n      }\n\n      var imageType = metadata['00080008']['Value'];\n\n      if (imageType[2] !== 'VOLUME') {\n        throw new Error('expected image type value 3 to be \"VOLUME\", is \"' + imageType[2] + '\" instead');\n      }\n\n      var loadJSONDataset = function loadJSONDataset(elements) {\n        var dataset = {};\n        Object.keys(elements).forEach(function (tag) {\n          var keyword = tagToKeyword[tag];\n          var vr = elements[tag]['vr'];\n\n          if ('BulkDataURI' in elements[tag]) {\n            console.log(\"skip bulk data element \\\"\".concat(keyword, \"\\\"\"));\n          } else if ('Value' in elements[tag]) {\n            var value = elements[tag]['Value'];\n\n            if (vr === 'SQ') {\n              dataset[keyword] = value.map(function (item) {\n                return loadJSONDataset(item);\n              });\n            } else {\n              // Handle value multiplicity.\n              if (value.length === 1) {\n                dataset[keyword] = value[0];\n              } else {\n                dataset[keyword] = value;\n              }\n            }\n          } else {\n            if (vr === 'SQ') {\n              dataset[keyword] = [];\n            } else {\n              dataset[keyword] = \"\"; // TODO: should rather be null?\n            }\n          }\n        });\n        return dataset;\n      };\n\n      var dataset = loadJSONDataset(metadata); // The top level (lowest resolution) image may be a single frame image in\n      // which case the \"NumberOfFrames\" attribute is optional. We include it for\n      // consistency.\n\n      if (!('NumberOfFrames' in dataset)) {\n        dataset.NumberOfFrames = 1;\n      }\n\n      return dataset;\n    }\n\n    function generateUID() {\n      /*\n       * http://dicom.nema.org/medical/dicom/current/output/chtml/part05/sect_B.2.html\n       * https://www.itu.int/rec/T-REC-X.667-201210-I/en\n       *  A UUID can be represented as a single integer value.\n       * To obtain the single integer value of the UUID, the 16 octets of the\n       * binary representation shall be treated as an unsigned integer encoding\n       * with the most significant bit of the integer encoding as the most\n       * significant bit (bit 7) of the first of the sixteen octets (octet 15) and\n       * the least significant bit as the least significant bit (bit 0) of the last\n       * of the sixteen octets (octet 0).\n      */\n      // FIXME: This is not a valid UUID!\n      var uid = '2.25.' + Math.floor(1 + Math.random() * 9);\n\n      while (uid.length < 44) {\n        uid += Math.floor(1 + Math.random() * 10);\n      }\n\n      return uid;\n    }\n\n    var _uid = Symbol('uid');\n\n    var _scoord3d = Symbol('scoord3d');\n    /* Region of interest.\n     */\n\n\n    var ROI =\n    /*#__PURE__*/\n    function () {\n      /* @constructor\n       * @param{Scoord3D} scoord3d spatial coordinates\n       * @param{Object} properties qualititative evaluations\n       */\n      function ROI(options) {\n        _classCallCheck2(this, ROI);\n\n        if (!('scoord3d' in options)) {\n          throw new Error('spatial coordinates are required for ROI');\n        }\n\n        if (!(typeof options.scoord3d === 'object' || options.scoord3d !== null)) {\n          throw new Error('scoord3d of ROI must be a Scoord3D object');\n        }\n\n        if (!('uid' in options)) {\n          this[_uid] = generateUID();\n        } else {\n          if (!(typeof options.uid === 'string' || options.uid instanceof String)) {\n            throw new Error('uid of ROI must be a string');\n          }\n\n          this[_uid] = options.uid;\n        }\n\n        this[_scoord3d] = options.scoord3d; // TODO: store SOPInstanceUID, SOPClassUID and FrameNumbers as reference\n      }\n\n      _createClass2(ROI, [{\n        key: \"uid\",\n        get: function get() {\n          return this[_uid];\n        }\n      }, {\n        key: \"scoord3d\",\n        get: function get() {\n          return this[_scoord3d];\n        }\n      }]);\n\n      return ROI;\n    }();\n\n    var _coordinates = Symbol('coordinates');\n\n    var _frameOfReferenceUID = Symbol('frameOfReferenceUID');\n\n    var _fiducialUID = Symbol('fiducialUID');\n    /*\n     * Spatial coordinates of geometric region(s) of interest (ROI) in the DICOM\n     * slide coordinate system in millimeter unit.\n     */\n\n\n    var Scoord3D =\n    /*#__PURE__*/\n    function () {\n      function Scoord3D(options) {\n        _classCallCheck2(this, Scoord3D);\n\n        if (!(typeof options.frameOfReferenceUID === 'string' || options.frameOfReferenceUID instanceof String)) {\n          throw new Error('frameOfReferenceUID of Scoord3D must be a string');\n        }\n\n        this[_frameOfReferenceUID] = options.frameOfReferenceUID;\n        options.fiducialUID = options.fiducialUID || generateUID();\n\n        if (!(typeof options.fiducialUID === 'string' || options.fiducialUID instanceof String)) {\n          throw new Error('fiducialUID of Scoord3D must be a string');\n        }\n\n        this[_fiducialUID] = options.fiducialUID;\n\n        if (!Array.isArray(options.coordinates)) {\n          throw new Error('coordinates of Scoord3D must be an array');\n        }\n\n        this[_coordinates] = options.coordinates;\n      }\n\n      _createClass2(Scoord3D, [{\n        key: \"graphicData\",\n        get: function get() {\n          return this[_coordinates];\n        }\n      }, {\n        key: \"graphicType\",\n        get: function get() {\n          throw new Error('Prototype property \"graphicType\" must be implemented');\n        }\n      }, {\n        key: \"frameOfReferenceUID\",\n        get: function get() {\n          return this[_frameOfReferenceUID];\n        }\n      }, {\n        key: \"fiducialUID\",\n        get: function get() {\n          return this[_fiducialUID];\n        }\n      }]);\n\n      return Scoord3D;\n    }();\n\n    var Point$1 =\n    /*#__PURE__*/\n    function (_Scoord3D) {\n      _inherits2(Point$1, _Scoord3D);\n\n      /*\n       * Single location denoted by a single (x,y,z) triplet.\n       */\n      function Point$1(options) {\n        _classCallCheck2(this, Point$1);\n\n        if (!Array.isArray(options.coordinates)) {\n          throw new Error('coordinates of Point must be an array');\n        }\n\n        if (options.coordinates.length !== 3) {\n          throw new Error('coordinates of Point must be an array of length 3');\n        }\n\n        if (options.coordinates.some(function (c) {\n          return c < 0;\n        })) {\n          throw new Error('coordinates of Point must be positive numbers');\n        }\n\n        return _possibleConstructorReturn2(this, _getPrototypeOf2(Point$1).call(this, {\n          coordinates: options.coordinates,\n          frameOfReferenceUID: options.frameOfReferenceUID,\n          fiducialUID: options.fiducialUID\n        }));\n      }\n\n      _createClass2(Point$1, [{\n        key: \"graphicType\",\n        get: function get() {\n          return 'POINT';\n        }\n      }]);\n\n      return Point$1;\n    }(Scoord3D);\n\n    var Multipoint =\n    /*#__PURE__*/\n    function (_Scoord3D2) {\n      _inherits2(Multipoint, _Scoord3D2);\n\n      /*\n       * Multiple points each denoted by an (x,y,z) triplet.\n       * Points need not be coplanar.\n       */\n      function Multipoint(options) {\n        _classCallCheck2(this, Multipoint);\n\n        if (!Array.isArray(options.coordinates)) {\n          throw new Error('coordinates of Multipoint must be an array');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.length !== 3;\n        }) !== undefined) {\n          throw new Error('coordinates of Multipoint must be an array of (x,y,z) triplets');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.some(function (item) {\n            return item < 0;\n          });\n        })) {\n          throw new Error('coordinates of Multipoint must be positive numbers');\n        }\n\n        return _possibleConstructorReturn2(this, _getPrototypeOf2(Multipoint).call(this, {\n          coordinates: options.coordinates,\n          frameOfReferenceUID: options.frameOfReferenceUID,\n          fiducialUID: options.fiducialUID\n        }));\n      }\n\n      _createClass2(Multipoint, [{\n        key: \"graphicType\",\n        get: function get() {\n          return 'MULTIPOINT';\n        }\n      }]);\n\n      return Multipoint;\n    }(Scoord3D);\n\n    var Polyline =\n    /*#__PURE__*/\n    function (_Scoord3D3) {\n      _inherits2(Polyline, _Scoord3D3);\n\n      /*\n       * Multiple points denoted by (x,y,z) triplets that represent\n       * connected line segments with ordered vertices\n       * Points need not be coplanar.\n       */\n      function Polyline(options) {\n        _classCallCheck2(this, Polyline);\n\n        if (!Array.isArray(options.coordinates)) {\n          throw new Error('coordinates of Polyline must be an array');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.length !== 3;\n        }) !== undefined) {\n          throw new Error('coordinates of Polyline must be an array of (x,y,z) triplets');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.some(function (item) {\n            return item < 0;\n          });\n        })) {\n          throw new Error('coordinates of Polyline must be positive numbers');\n        }\n\n        return _possibleConstructorReturn2(this, _getPrototypeOf2(Polyline).call(this, {\n          coordinates: options.coordinates,\n          frameOfReferenceUID: options.frameOfReferenceUID,\n          fiducialUID: options.fiducialUID\n        }));\n      }\n\n      _createClass2(Polyline, [{\n        key: \"graphicType\",\n        get: function get() {\n          return 'POLYLINE';\n        }\n      }]);\n\n      return Polyline;\n    }(Scoord3D);\n\n    var Polygon$1 =\n    /*#__PURE__*/\n    function (_Scoord3D4) {\n      _inherits2(Polygon$1, _Scoord3D4);\n\n      /*\n       * Multiple points denoted by (x,y,z) triplets that represent\n       * connected line segments with ordered vertices.\n       * First and last point shall be the same.\n       * Points shall be coplanar.\n       */\n      function Polygon$1(options) {\n        _classCallCheck2(this, Polygon$1);\n\n        if (!Array.isArray(options.coordinates)) {\n          throw new Error('coordinates of Polygon must be an array');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.length !== 3;\n        }) !== undefined) {\n          throw new Error('coordinates of Polygon must be an array of (x,y,z) triplets');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.some(function (item) {\n            return item < 0;\n          });\n        })) {\n          throw new Error('coordinates of Polygon must be positive numbers');\n        }\n\n        var n = options.coordinates.length;\n\n        if (options.coordinates[0][0] !== options.coordinates[n - 1][0] || options.coordinates[0][1] !== options.coordinates[n - 1][1] || options.coordinates[0][2] !== options.coordinates[n - 1][2]) {\n          throw new Error('first and last coordinate of Polygon must be the same');\n        }\n\n        return _possibleConstructorReturn2(this, _getPrototypeOf2(Polygon$1).call(this, {\n          coordinates: options.coordinates,\n          frameOfReferenceUID: options.frameOfReferenceUID,\n          fiducialUID: options.fiducialUID\n        }));\n      }\n\n      _createClass2(Polygon$1, [{\n        key: \"graphicType\",\n        get: function get() {\n          return 'POLYGON';\n        }\n      }]);\n\n      return Polygon$1;\n    }(Scoord3D);\n\n    var Ellipsoid =\n    /*#__PURE__*/\n    function (_Scoord3D5) {\n      _inherits2(Ellipsoid, _Scoord3D5);\n\n      /*\n       * Six points denoted by (x,y,z) triplets, where the first two points represent\n       * the endpoints of the first axis and the second two points represent the\n       * endpoints of the second axis and the third two points represent the\n       * endpoints of the third axis. respectively.\n       */\n      function Ellipsoid(options) {\n        _classCallCheck2(this, Ellipsoid);\n\n        if (!Array.isArray(options.coordinates)) {\n          throw new Error('coordinates of Ellipsoid must be an array');\n        }\n\n        if (options.coordinates.length !== 6) {\n          throw new Error('coordinates of Ellipsoid must be an array of length 6');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.length !== 3;\n        }) !== undefined) {\n          throw new Error('coordinates of Ellipsoid must be an array of (x,y,z) triplets');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.some(function (item) {\n            return item < 0;\n          });\n        })) {\n          throw new Error('coordinates of Ellipsoid must be positive numbers');\n        }\n\n        return _possibleConstructorReturn2(this, _getPrototypeOf2(Ellipsoid).call(this, {\n          coordinates: options.coordinates,\n          frameOfReferenceUID: options.frameOfReferenceUID,\n          fiducialUID: options.fiducialUID\n        }));\n      }\n\n      _createClass2(Ellipsoid, [{\n        key: \"graphicType\",\n        get: function get() {\n          return 'ELLIPSOID';\n        }\n      }]);\n\n      return Ellipsoid;\n    }(Scoord3D);\n\n    var Ellipse =\n    /*#__PURE__*/\n    function (_Scoord3D6) {\n      _inherits2(Ellipse, _Scoord3D6);\n\n      /*\n       * Four points denoted by (x,y,z) triplets, where the first two points represent\n       * the endpoints of the major axis and the second two points represent the\n       * endpoints of the minor axis.\n       */\n      function Ellipse(options) {\n        _classCallCheck2(this, Ellipse);\n\n        if (!Array.isArray(options.coordinates)) {\n          throw new Error('coordinates of Ellipse must be an array');\n        }\n\n        if (options.coordinates.length !== 4) {\n          throw new Error('coordinates of Ellipse must be an array of length 4');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.length !== 3;\n        }) !== undefined) {\n          throw new Error('coordinates of Ellipse must be an array of (x,y,z) triplets');\n        }\n\n        if (options.coordinates.find(function (c) {\n          return c.some(function (item) {\n            return item < 0;\n          });\n        })) {\n          throw new Error('coordinates of Ellipse must be positive numbers');\n        } // TODO: assert major and minor axes are in right angle\n\n\n        return _possibleConstructorReturn2(this, _getPrototypeOf2(Ellipse).call(this, {\n          coordinates: options.coordinates,\n          frameOfReferenceUID: options.frameOfReferenceUID,\n          fiducialUID: options.fiducialUID\n        }));\n      }\n\n      _createClass2(Ellipse, [{\n        key: \"graphicType\",\n        get: function get() {\n          return 'ELLIPSE';\n        }\n      }]);\n\n      return Ellipse;\n    }(Scoord3D);\n\n    var dicomwebClient = createCommonjsModule$$1(function (module, exports) {\n      (function (global, factory) {\n        factory(exports);\n      })(commonjsGlobal$$1, function (exports) {\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n        /**\n         * Converts a Uint8Array to a String.\n         * @param {Uint8Array} array that should be converted\n         * @param {Number} offset array offset in case only subset of array items should be extracted (default: 0)\n         * @param {Number} limit maximum number of array items that should be extracted (defaults to length of array)\n         * @returns {String}\n         */\n\n\n        function uint8ArrayToString(arr, offset, limit) {\n          offset = offset || 0;\n          limit = limit || arr.length - offset;\n          var str = '';\n\n          for (var i = offset; i < offset + limit; i++) {\n            str += String.fromCharCode(arr[i]);\n          }\n\n          return str;\n        }\n        /**\n         * Converts a String to a Uint8Array.\n         * @param {String} str string that should be converted\n         * @returns {Uint8Array}\n         */\n\n\n        function stringToUint8Array(str) {\n          var arr = new Uint8Array(str.length);\n\n          for (var i = 0, j = str.length; i < j; i++) {\n            arr[i] = str.charCodeAt(i);\n          }\n\n          return arr;\n        }\n        /**\n         * Identifies the boundary in a multipart/related message header.\n         * @param {String} header message header\n         * @returns {String} boundary\n         */\n\n\n        function identifyBoundary(header) {\n          var parts = header.split('\\r\\n');\n\n          for (var i = 0; i < parts.length; i++) {\n            if (parts[i].substr(0, 2) === '--') {\n              return parts[i];\n            }\n          }\n        }\n        /**\n         * Checks whether a given token is contained by a message at a given offset.\n         * @param {Uint8Array} message message content\n         * @param {Uint8Array} token substring that should be present\n         * @param {Number} offset offset in message content from where search should start\n         * @returns {Boolean} whether message contains token at offset\n         */\n\n\n        function containsToken(message, token) {\n          var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n          if (offset + token.length > message.length) {\n            return false;\n          }\n\n          var index = offset;\n\n          for (var i = 0; i < token.length; i++) {\n            if (token[i] !== message[index++]) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n        /**\n         * Finds a given token in a message at a given offset.\n         * @param {Uint8Array} message message content\n         * @param {Uint8Array} token substring that should be found\n         * @param {String} offset message body offset from where search should start\n         * @returns {Boolean} whether message has a part at given offset or not\n         */\n\n\n        function findToken(message, token) {\n          var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var maxSearchLength = arguments.length > 3 ? arguments[3] : undefined;\n          var searchLength = message.length;\n\n          if (maxSearchLength) {\n            searchLength = Math.min(offset + maxSearchLength, message.length);\n          }\n\n          for (var i = offset; i < searchLength; i++) {\n            // If the first value of the message matches\n            // the first value of the token, check if\n            // this is the full token.\n            if (message[i] === token[0]) {\n              if (containsToken(message, token, i)) {\n                return i;\n              }\n            }\n          }\n\n          return -1;\n        }\n        /**\n         * @typedef {Object} MultipartEncodedData\n         * @property {ArrayBuffer} data The encoded Multipart Data\n         * @property {String} boundary The boundary used to divide pieces of the encoded data\n         */\n\n        /**\n         * Encode one or more DICOM datasets into a single body so it can be\n         * sent using the Multipart Content-Type.\n         *\n         * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the multipart body, passed as ArrayBuffers.\n         * @param {String} [boundary] Optional string to define a boundary between each part of the multipart body. If this is not specified, a random GUID will be generated.\n         * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This contains both the data itself, and the boundary string used to divide it.\n         */\n\n\n        function multipartEncode(datasets) {\n          var boundary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : guid();\n          var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'application/dicom';\n          var contentTypeString = \"Content-Type: \".concat(contentType);\n          var header = \"\\r\\n--\".concat(boundary, \"\\r\\n\").concat(contentTypeString, \"\\r\\n\\r\\n\");\n          var footer = \"\\r\\n--\".concat(boundary, \"--\");\n          var headerArray = stringToUint8Array(header);\n          var footerArray = stringToUint8Array(footer);\n          var headerLength = headerArray.length;\n          var footerLength = footerArray.length;\n          var length = 0; // Calculate the total length for the final array\n\n          var contentArrays = datasets.map(function (datasetBuffer) {\n            var contentArray = new Uint8Array(datasetBuffer);\n            var contentLength = contentArray.length;\n            length += headerLength + contentLength + footerLength;\n            return contentArray;\n          }); // Allocate the array\n\n          var multipartArray = new Uint8Array(length); // Set the initial header\n\n          multipartArray.set(headerArray, 0); // Write each dataset into the multipart array\n\n          var position = 0;\n          contentArrays.forEach(function (contentArray) {\n            var contentLength = contentArray.length;\n            multipartArray.set(headerArray, position);\n            multipartArray.set(contentArray, position + headerLength);\n            position += headerLength + contentArray.length;\n          });\n          multipartArray.set(footerArray, position);\n          return {\n            data: multipartArray.buffer,\n            boundary: boundary\n          };\n        }\n        /**\n         * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n         *\n         * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n         * @returns {Array} The content\n         */\n\n\n        function multipartDecode(response) {\n          var message = new Uint8Array(response);\n          /* Set a maximum length to search for the header boundaries, otherwise\n             findToken can run for a long time\n          */\n\n          var maxSearchLength = 1000; // First look for the multipart mime header\n\n          var separator = stringToUint8Array('\\r\\n\\r\\n');\n          var headerIndex = findToken(message, separator, 0, maxSearchLength);\n\n          if (headerIndex === -1) {\n            throw new Error('Response message has no multipart mime header');\n          }\n\n          var header = uint8ArrayToString(message, 0, headerIndex);\n          var boundaryString = identifyBoundary(header);\n\n          if (!boundaryString) {\n            throw new Error('Header of response message does not specify boundary');\n          }\n\n          var boundary = stringToUint8Array(boundaryString);\n          var boundaryLength = boundary.length;\n          var components = [];\n          var offset = headerIndex + separator.length; // Loop until we cannot find any more boundaries\n\n          var boundaryIndex;\n\n          while (boundaryIndex !== -1) {\n            // Search for the next boundary in the message, starting\n            // from the current offset position\n            boundaryIndex = findToken(message, boundary, offset); // If no further boundaries are found, stop here.\n\n            if (boundaryIndex === -1) {\n              break;\n            } // Extract data from response message, excluding \"\\r\\n\"\n\n\n            var spacingLength = 2;\n            var length = boundaryIndex - offset - spacingLength;\n            var data = response.slice(offset, offset + length); // Add the data to the array of results\n\n            components.push(data); // Move the offset to the end of the current section,\n            // plus the identified boundary\n\n            offset += length + spacingLength + boundaryLength;\n          }\n\n          return components;\n        }\n        /**\n         * Create a random GUID\n         *\n         * @return {string}\n         */\n\n\n        function guid() {\n          function s4() {\n            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n          }\n\n          return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n        }\n\n        function isEmptyObject(obj) {\n          return Object.keys(obj).length === 0 && obj.constructor === Object;\n        }\n\n        var getFirstResult = function getFirstResult(result) {\n          return result[0];\n        };\n\n        var MIMETYPES = {\n          DICOM: 'application/dicom',\n          DICOM_JSON: 'application/dicom+json',\n          OCTET_STREAM: 'application/octet-stream',\n          JPEG: 'image/jpeg',\n          PNG: 'image/png'\n        };\n        /**\n        * Class for interacting with DICOMweb RESTful services.\n        */\n\n        var DICOMwebClient =\n        /*#__PURE__*/\n        function () {\n          /**\n          * @constructor\n          * @param {Object} options (choices: \"url\", \"username\", \"password\", \"headers\")\n          */\n          function DICOMwebClient(options) {\n            _classCallCheck(this, DICOMwebClient);\n\n            this.baseURL = options.url;\n\n            if (!this.baseURL) {\n              console.error('no DICOMweb base url provided - calls will fail');\n            }\n\n            if ('username' in options) {\n              this.username = options.username;\n\n              if (!('password' in options)) {\n                console.error('no password provided to authenticate with DICOMweb service');\n              }\n\n              this.password = options.password;\n            }\n\n            if ('qidoURLPrefix' in options) {\n              console.log(\"use URL prefix for QIDO-RS: \".concat(options.qidoURLPrefix));\n              this.qidoURL = this.baseURL + '/' + options.qidoURLPrefix;\n            } else {\n              this.qidoURL = this.baseURL;\n            }\n\n            if ('wadoURLPrefix' in options) {\n              console.log(\"use URL prefix for WADO-RS: \".concat(options.wadoURLPrefix));\n              this.wadoURL = this.baseURL + '/' + options.wadoURLPrefix;\n            } else {\n              this.wadoURL = this.baseURL;\n            }\n\n            if ('stowURLPrefix' in options) {\n              console.log(\"use URL prefix for STOW-RS: \".concat(options.stowURLPrefix));\n              this.stowURL = this.baseURL + '/' + options.stowURLPrefix;\n            } else {\n              this.stowURL = this.baseURL;\n            }\n\n            this.headers = options.headers || {};\n          }\n\n          _createClass(DICOMwebClient, [{\n            key: \"_httpRequest\",\n            value: function _httpRequest(url, method, headers) {\n              var _this = this;\n\n              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n              return new Promise(function (resolve, reject) {\n                var request = new XMLHttpRequest();\n                request.open(method, url, true);\n\n                if ('responseType' in options) {\n                  request.responseType = options.responseType;\n                }\n\n                if (_typeof(headers) === 'object') {\n                  Object.keys(headers).forEach(function (key) {\n                    request.setRequestHeader(key, headers[key]);\n                  });\n                } // now add custom headers from the user\n                // (e.g. access tokens)\n\n\n                var userHeaders = _this.headers;\n                Object.keys(userHeaders).forEach(function (key) {\n                  request.setRequestHeader(key, userHeaders[key]);\n                }); // Event triggered when upload starts\n\n                request.onloadstart = function (event) {//console.log('upload started: ', url)\n                }; // Event triggered when upload ends\n\n\n                request.onloadend = function (event) {//console.log('upload finished')\n                }; // Handle response message\n\n\n                request.onreadystatechange = function (event) {\n                  if (request.readyState === 4) {\n                    if (request.status === 200) {\n                      resolve(request.response);\n                    } else if (request.status === 202) {\n                      console.warn('some resources already existed: ', request);\n                      resolve(request.response);\n                    } else if (request.status === 204) {\n                      console.warn('empty response for request: ', request);\n                      resolve([]);\n                    } else {\n                      console.error('request failed: ', request);\n                      var error = new Error('request failed');\n                      error.request = request;\n                      error.response = request.response;\n                      error.status = request.status;\n                      console.error(error);\n                      console.error(error.response);\n                      reject(error);\n                    }\n                  }\n                }; // Event triggered while download progresses\n\n\n                if ('progressCallback' in options) {\n                  if (typeof options.progressCallback === 'function') {\n                    request.onprogress = options.progressCallback;\n                  }\n                } // request.onprogress = function (event) {\n                //   const loaded = progress.loaded;\n                //   let total;\n                //   let percentComplete;\n                //   if (progress.lengthComputable) {\n                //     total = progress.total;\n                //     percentComplete = Math.round((loaded / total) * 100);\n                //   j\n                //   // console.log('download progress: ', percentComplete, ' %');\n                //   return(percentComplete);\n                // };\n\n\n                if ('data' in options) {\n                  request.send(options.data);\n                } else {\n                  request.send();\n                }\n              });\n            }\n          }, {\n            key: \"_httpGet\",\n            value: function _httpGet(url, headers, responseType, progressCallback) {\n              return this._httpRequest(url, 'get', headers, {\n                responseType: responseType,\n                progressCallback: progressCallback\n              });\n            }\n          }, {\n            key: \"_httpGetApplicationJson\",\n            value: function _httpGetApplicationJson(url) {\n              var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n              var progressCallback = arguments.length > 2 ? arguments[2] : undefined;\n\n              if (_typeof(params) === 'object') {\n                if (!isEmptyObject(params)) {\n                  url += DICOMwebClient._parseQueryParameters(params);\n                }\n              }\n\n              var headers = {\n                'Accept': MIMETYPES.DICOM_JSON\n              };\n              var responseType = 'json';\n              return this._httpGet(url, headers, responseType, progressCallback);\n            }\n          }, {\n            key: \"_httpGetByMimeType\",\n            value: function _httpGetByMimeType(url, mimeType, params) {\n              var responseType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'arraybuffer';\n              var progressCallback = arguments.length > 4 ? arguments[4] : undefined;\n\n              if (_typeof(params) === 'object') {\n                if (!isEmptyObject(params)) {\n                  url += DICOMwebClient._parseQueryParameters(params);\n                }\n              }\n\n              var headers = {\n                'Accept': \"multipart/related; type=\\\"\".concat(mimeType, \"\\\"\")\n              };\n              return this._httpGet(url, headers, responseType, progressCallback);\n            }\n          }, {\n            key: \"_httpPost\",\n            value: function _httpPost(url, headers, data, progressCallback) {\n              return this._httpRequest(url, 'post', headers, {\n                data: data,\n                progressCallback: progressCallback\n              });\n            }\n          }, {\n            key: \"_httpPostApplicationJson\",\n            value: function _httpPostApplicationJson(url, data, progressCallback) {\n              var headers = {\n                'Content-Type': MIMETYPES.DICOM_JSON\n              };\n              return this._httpPost(url, headers, data, progressCallback);\n            }\n            /**\n             * Searches for DICOM studies.\n             * @param {Object} options options object\n             * @return {Array} study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n             */\n\n          }, {\n            key: \"searchForStudies\",\n            value: function searchForStudies() {\n              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              console.log('search for studies');\n              var url = this.qidoURL + '/studies';\n\n              if ('queryParams' in options) {\n                url += DICOMwebClient._parseQueryParameters(options.queryParams);\n              }\n\n              return this._httpGetApplicationJson(url);\n            }\n            /**\n             * Retrieves metadata for a DICOM study.\n             * @param {Object} options options object\n             * @returns {Array} metadata elements in DICOM JSON format for each instance belonging to the study\n             */\n\n          }, {\n            key: \"retrieveStudyMetadata\",\n            value: function retrieveStudyMetadata(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required for retrieval of study metadata');\n              }\n\n              console.log(\"retrieve metadata of study \".concat(options.studyInstanceUID));\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID + '/metadata';\n              return this._httpGetApplicationJson(url);\n            }\n            /**\n             * Searches for DICOM series.\n             * @param {Object} options options object\n             * @returns {Array} series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n             */\n\n          }, {\n            key: \"searchForSeries\",\n            value: function searchForSeries() {\n              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              var url = this.qidoURL;\n\n              if ('studyInstanceUID' in options) {\n                console.log(\"search series of study \".concat(options.studyInstanceUID));\n                url += '/studies/' + options.studyInstanceUID;\n              }\n\n              url += '/series';\n\n              if ('queryParams' in options) {\n                url += DICOMwebClient._parseQueryParameters(options.queryParams);\n              }\n\n              return this._httpGetApplicationJson(url);\n            }\n            /**\n             * Retrieves metadata for a DICOM series.\n             * @param {Object} options options object\n             * @returns {Array} metadata elements in DICOM JSON format for each instance belonging to the series\n             */\n\n          }, {\n            key: \"retrieveSeriesMetadata\",\n            value: function retrieveSeriesMetadata(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required for retrieval of series metadata');\n              }\n\n              if (!('seriesInstanceUID' in options)) {\n                throw new Error('Series Instance UID is required for retrieval of series metadata');\n              }\n\n              console.log(\"retrieve metadata of series \".concat(options.seriesInstanceUID));\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/metadata';\n              return this._httpGetApplicationJson(url);\n            }\n            /**\n             * Searches for DICOM instances.\n             * @param {Object} options options object\n             * @returns {Array} instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n             */\n\n          }, {\n            key: \"searchForInstances\",\n            value: function searchForInstances() {\n              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              var url = this.qidoURL;\n\n              if ('studyInstanceUID' in options) {\n                url += '/studies/' + options.studyInstanceUID;\n\n                if ('seriesInstanceUID' in options) {\n                  console.log(\"search for instances of series \".concat(options.seriesInstanceUID));\n                  url += '/series/' + options.seriesInstanceUID;\n                } else {\n                  console.log(\"search for instances of study \".concat(options.studyInstanceUID));\n                }\n              } else {\n                console.log('search for instances');\n              }\n\n              url += '/instances';\n\n              if ('queryParams' in options) {\n                url += DICOMwebClient._parseQueryParameters(options.queryParams);\n              }\n\n              return this._httpGetApplicationJson(url);\n            }\n            /** Returns a WADO-URI URL for an instance\n             * @param {Object} options options object\n             * @returns {String} WADO-URI URL\n             */\n\n          }, {\n            key: \"buildInstanceWadoURIUrl\",\n            value: function buildInstanceWadoURIUrl(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required.');\n              }\n\n              if (!('seriesInstanceUID' in options)) {\n                throw new Error('Series Instance UID is required.');\n              }\n\n              if (!('sopInstanceUID' in options)) {\n                throw new Error('SOP Instance UID is required.');\n              }\n\n              var contentType = options.contentType || MIMETYPES.DICOM;\n              var transferSyntax = options.transferSyntax || '*';\n              var params = [];\n              params.push('requestType=WADO');\n              params.push(\"studyUID=\".concat(options.studyInstanceUID));\n              params.push(\"seriesUID=\".concat(options.seriesInstanceUID));\n              params.push(\"objectUID=\".concat(options.sopInstanceUID));\n              params.push(\"contentType=\".concat(contentType));\n              params.push(\"transferSyntax=\".concat(transferSyntax));\n              var paramString = params.join('&');\n              return \"\".concat(this.wadoURL, \"?\").concat(paramString);\n            }\n            /**\n             * Retrieves metadata for a DICOM instance.\n             *\n             * @param {Object} options object\n             * @returns {Object} metadata elements in DICOM JSON format\n             */\n\n          }, {\n            key: \"retrieveInstanceMetadata\",\n            value: function retrieveInstanceMetadata(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required for retrieval of instance metadata');\n              }\n\n              if (!('seriesInstanceUID' in options)) {\n                throw new Error('Series Instance UID is required for retrieval of instance metadata');\n              }\n\n              if (!('sopInstanceUID' in options)) {\n                throw new Error('SOP Instance UID is required for retrieval of instance metadata');\n              }\n\n              console.log(\"retrieve metadata of instance \".concat(options.sopInstanceUID));\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/instances/' + options.sopInstanceUID + '/metadata';\n              return this._httpGetApplicationJson(url);\n            }\n            /**\n             * Retrieves frames for a DICOM instance.\n             * @param {Object} options options object\n             * @returns {Array} frame items as byte arrays of the pixel data element\n             */\n\n          }, {\n            key: \"retrieveInstanceFrames\",\n            value: function retrieveInstanceFrames(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required for retrieval of instance frames');\n              }\n\n              if (!('seriesInstanceUID' in options)) {\n                throw new Error('Series Instance UID is required for retrieval of instance frames');\n              }\n\n              if (!('sopInstanceUID' in options)) {\n                throw new Error('SOP Instance UID is required for retrieval of instance frames');\n              }\n\n              if (!('frameNumbers' in options)) {\n                throw new Error('frame numbers are required for retrieval of instance frames');\n              }\n\n              console.log(\"retrieve frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/instances/' + options.sopInstanceUID + '/frames/' + options.frameNumbers.toString();\n              var mimeType = options.mimeType ? \"\".concat(options.mimeType) : MIMETYPES.OCTET_STREAM;\n              return this._httpGetByMimeType(url, mimeType).then(multipartDecode);\n            }\n            /**\n             * Retrieves rendered frames for a DICOM instance.\n             * @param {Object} options options object\n             * @returns {Array} frame items as byte arrays of the pixel data element\n             */\n\n          }, {\n            key: \"retrieveInstanceFramesRendered\",\n            value: function retrieveInstanceFramesRendered(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required for retrieval of rendered instance frames');\n              }\n\n              if (!('seriesInstanceUID' in options)) {\n                throw new Error('Series Instance UID is required for retrieval of rendered instance frames');\n              }\n\n              if (!('sopInstanceUID' in options)) {\n                throw new Error('SOP Instance UID is required for retrieval of rendered instance frames');\n              }\n\n              if (!('frameNumbers' in options)) {\n                throw new Error('frame numbers are required for retrieval of rendered instance frames');\n              }\n\n              console.log(\"retrieve rendered frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/instances/' + options.sopInstanceUID + '/frames/' + options.frameNumbers.toString() + '/rendered';\n              var headers = {}; // The choice of an acceptable media type depends on a variety of things:\n              // http://dicom.nema.org/medical/dicom/current/output/chtml/part18/chapter_6.html#table_6.1.1-3\n\n              if ('mimeType' in options) {\n                headers['Accept'] = options.mimeType;\n              }\n\n              var responseType = 'arraybuffer';\n              return this._httpGet(url, headers, responseType);\n            }\n            /**\n             * Retrieves a DICOM instance.\n             * @param {Object} options options object\n             * @returns {Arraybuffer} DICOM Part 10 file as Arraybuffer\n             */\n\n          }, {\n            key: \"retrieveInstance\",\n            value: function retrieveInstance(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required');\n              }\n\n              if (!('seriesInstanceUID' in options)) {\n                throw new Error('Series Instance UID is required');\n              }\n\n              if (!('sopInstanceUID' in options)) {\n                throw new Error('SOP Instance UID is required');\n              }\n\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/instances/' + options.sopInstanceUID;\n              return this._httpGetByMimeType(url, MIMETYPES.DICOM).then(multipartDecode).then(getFirstResult);\n            }\n            /**\n             * Retrieves a set of DICOM instance for a series.\n             * @param {Object} options options object\n             * @returns {Arraybuffer[]} Array of DICOM Part 10 files as Arraybuffers\n             */\n\n          }, {\n            key: \"retrieveSeries\",\n            value: function retrieveSeries(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required');\n              }\n\n              if (!('seriesInstanceUID' in options)) {\n                throw new Error('Series Instance UID is required');\n              }\n\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID;\n              return this._httpGetByMimeType(url, MIMETYPES.DICOM).then(multipartDecode);\n            }\n            /**\n             * Retrieves a set of DICOM instance for a study.\n             * @param {Object} options options object\n             * @returns {Arraybuffer[]} Array of DICOM Part 10 files as Arraybuffers\n             */\n\n          }, {\n            key: \"retrieveStudy\",\n            value: function retrieveStudy(options) {\n              if (!('studyInstanceUID' in options)) {\n                throw new Error('Study Instance UID is required');\n              }\n\n              var url = this.wadoURL + '/studies/' + options.studyInstanceUID;\n              return this._httpGetByMimeType(url, MIMETYPES.DICOM).then(multipartDecode);\n            }\n            /**\n             * Retrieves and parses BulkData from a BulkDataURI location.\n             * Decodes the multipart encoded data and returns the resulting data\n             * as an ArrayBuffer.\n             *\n             * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n             *\n             * @param {Object} options options object\n             * @return {Promise}\n             */\n\n          }, {\n            key: \"retrieveBulkData\",\n            value: function retrieveBulkData(options) {\n              if (!('BulkDataURI' in options)) {\n                throw new Error('BulkDataURI is required.');\n              }\n\n              return this._httpGetByMimeType(options.BulkDataURI, MIMETYPES.OCTET_STREAM).then(multipartDecode).then(getFirstResult);\n            }\n            /**\n             * Stores DICOM instances.\n             *\n             * @param {Object} options options object\n             */\n\n          }, {\n            key: \"storeInstances\",\n            value: function storeInstances(options) {\n              if (!('datasets' in options)) {\n                throw new Error('datasets are required for storing');\n              }\n\n              var url = \"\".concat(this.stowURL, \"/studies\");\n\n              if ('studyInstanceUID' in options) {\n                url += \"/\".concat(options.studyInstanceUID);\n              }\n\n              var _multipartEncode = multipartEncode(options.datasets),\n                  data = _multipartEncode.data,\n                  boundary = _multipartEncode.boundary;\n\n              var headers = {\n                'Content-Type': \"multipart/related; type=application/dicom; boundary=\".concat(boundary)\n              };\n              return this._httpPost(url, headers, data, options.progressCallback);\n            }\n          }], [{\n            key: \"_parseQueryParameters\",\n            value: function _parseQueryParameters() {\n              var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              var queryString = '?';\n              Object.keys(params).forEach(function (key, index) {\n                if (index !== 0) {\n                  queryString += '&';\n                }\n\n                queryString += key + '=' + encodeURIComponent(params[key]);\n              });\n              return queryString;\n            }\n          }]);\n\n          return DICOMwebClient;\n        }();\n\n        function findSubstring(str, before, after) {\n          var beforeIndex = str.lastIndexOf(before) + before.length;\n\n          if (beforeIndex < before.length) {\n            return null;\n          }\n\n          if (after !== undefined) {\n            var afterIndex = str.lastIndexOf(after);\n\n            if (afterIndex < 0) {\n              return null;\n            } else {\n              return str.substring(beforeIndex, afterIndex);\n            }\n          }\n\n          return str.substring(beforeIndex);\n        }\n\n        function getStudyInstanceUIDFromUri(uri) {\n          var uid = findSubstring(uri, \"studies/\", \"/series\");\n\n          if (!uid) {\n            uid = findSubstring(uri, \"studies/\");\n          }\n\n          if (!uid) {\n            console.debug('Study Instance UID could not be dertermined from URI \"' + uri + '\"');\n          }\n\n          return uid;\n        }\n\n        function getSeriesInstanceUIDFromUri(uri) {\n          var uid = findSubstring(uri, \"series/\", \"/instances\");\n\n          if (!uid) {\n            uid = findSubstring(uri, \"series/\");\n          }\n\n          if (!uid) {\n            console.debug('Series Instance UID could not be dertermined from URI \"' + uri + '\"');\n          }\n\n          return uid;\n        }\n\n        function getSOPInstanceUIDFromUri(uri) {\n          var uid = findSubstring(uri, \"/instances/\", \"/frames\");\n\n          if (!uid) {\n            uid = findSubstring(uri, \"/instances/\", \"/metadata\");\n          }\n\n          if (!uid) {\n            uid = findSubstring(uri, \"/instances/\");\n          }\n\n          if (!uid) {\n            console.debug('SOP Instance UID could not be dertermined from URI\"' + uri + '\"');\n          }\n\n          return uid;\n        }\n\n        function getFrameNumbersFromUri(uri) {\n          var numbers = findSubstring(uri, \"/frames/\", \"/rendered\");\n\n          if (!numbers) {\n            numbers = findSubstring(uri, \"/frames/\");\n          }\n\n          if (numbers === undefined) {\n            console.debug('Frames Numbers could not be dertermined from URI\"' + uri + '\"');\n          }\n\n          return numbers.split(',');\n        }\n\n        var version = '0.3.2';\n        var api = {\n          DICOMwebClient: DICOMwebClient\n        };\n        var utils = {\n          getStudyInstanceUIDFromUri: getStudyInstanceUIDFromUri,\n          getSeriesInstanceUIDFromUri: getSeriesInstanceUIDFromUri,\n          getSOPInstanceUIDFromUri: getSOPInstanceUIDFromUri,\n          getFrameNumbersFromUri: getFrameNumbersFromUri\n        };\n        exports.api = api;\n        exports.utils = utils;\n        exports.version = version;\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n      });\n    });\n    var DICOMwebClient = unwrapExports$$1(dicomwebClient);\n\n    function _getPixelSpacing(metadata) {\n      var functionalGroup = metadata.SharedFunctionalGroupsSequence[0];\n      var pixelMeasures = functionalGroup.PixelMeasuresSequence[0];\n      return pixelMeasures.PixelSpacing;\n    }\n\n    function _geometry2Scoord3d(geometry, pyramid) {\n      var frameOfReferenceUID = pyramid[pyramid.length - 1].FrameOfReferenceUID;\n      var type = geometry.getType();\n\n      if (type === 'Point') {\n        var _coordinates2 = geometry.getCoordinates();\n\n        _coordinates2 = _geometryCoordinates2scoord3dCoordinates(_coordinates2, pyramid);\n        return new Point$1({\n          coordinates: _coordinates2,\n          frameOfReferenceUID: frameOfReferenceUID\n        });\n      } else if (type === 'Polygon') {\n        /*\n         * The first linear ring of the array defines the outer-boundary (surface).\n         * Each subsequent linear ring defines a hole in the surface.\n         */\n        var _coordinates3 = geometry.getCoordinates()[0].map(function (c) {\n          return _geometryCoordinates2scoord3dCoordinates(c, pyramid);\n        });\n\n        return new Polygon$1({\n          coordinates: _coordinates3,\n          frameOfReferenceUID: frameOfReferenceUID\n        });\n      } else if (type === 'LineString') {\n        var _coordinates4 = geometry.getCoordinates().map(function (c) {\n          return _geometryCoordinates2scoord3dCoordinates(c, pyramid);\n        });\n\n        return new Polyline({\n          coordinates: _coordinates4,\n          frameOfReferenceUID: frameOfReferenceUID\n        });\n      } else if (type === 'Circle') {\n        var centerCoordinate = geometry.getCenter();\n        var radius = geometry.getRadius(); // Endpoints of major and  minor axis of the ellipse.\n        // In case of a circle they both have the same length.\n\n        var _coordinates5 = [[centerCoordinate[0] - radius, centerCoordinate[1]], [centerCoordinate[0] + radius, centerCoordinate[1]], [centerCoordinate[0], centerCoordinate[1] - radius], [centerCoordinate[0], centerCoordinate[1] + radius]];\n        _coordinates5 = _coordinates5.map(function (c) {\n          c.push(0);\n          return _geometryCoordinates2scoord3dCoordinates(c, pyramid);\n        });\n        return new Ellipse({\n          coordinates: _coordinates5,\n          frameOfReferenceUID: frameOfReferenceUID\n        });\n      } else {\n        // TODO: Combine multiple points into MULTIPOINT.\n        console.error(\"unknown geometry type \\\"\".concat(type, \"\\\"\"));\n      }\n    }\n\n    function _scoord3d2Geometry(scoord3d, pyramid) {\n      var type = scoord3d.graphicType;\n      var data = scoord3d.graphicData;\n\n      if (type === 'POINT') {\n        var _coordinates6 = _scoord3dCoordinates2geometryCoordinates(data, pyramid);\n\n        return new Point(_coordinates6);\n      } else if (type === 'POLYLINE') {\n        var _coordinates7 = data.map(function (d) {\n          return _scoord3dCoordinates2geometryCoordinates(d, pyramid);\n        });\n\n        return new LineString(_coordinates7);\n      } else if (type === 'POLYGON') {\n        var _coordinates8 = data.map(function (d) {\n          return _scoord3dCoordinates2geometryCoordinates(d, pyramid);\n        });\n\n        return new Polygon([_coordinates8]);\n      } else if (type === 'ELLIPSE') {\n        // TODO: ensure that the ellipse represents a circle, i.e. that\n        // major and minor axis form a right angle and have the same length\n        var majorAxisCoordinates = data.slice(0, 2);\n        var minorAxisCoordinates = data.slice(2, 4); // Circle is defined by two points: the center point and a point on the\n        // circumference.\n\n        var point1 = majorAxisCoordinates[0];\n        var point2 = majorAxisCoordinates[1];\n        var _coordinates9 = [[(point1[0] + point2[0]) / parseFloat(2), (point1[1] + point2[1]) / parseFloat(2), 0], point2];\n        _coordinates9 = _coordinates9.map(function (d) {\n          return _scoord3dCoordinates2geometryCoordinates(d, pyramid);\n        }); // to flat coordinates\n\n        _coordinates9 = [].concat(_toConsumableArray(_coordinates9[0].slice(0, 2)), _toConsumableArray(_coordinates9[1].slice(0, 2))); // flat coordinates in combination with opt_layout and no opt_radius are also accepted\n        // and internaly it calculates the Radius\n\n        return new Circle(_coordinates9, null, \"XY\");\n      } else {\n        console.error(\"unsupported graphic type \\\"\".concat(type, \"\\\"\"));\n      }\n    }\n\n    function _geometryCoordinates2scoord3dCoordinates(coordinates, pyramid) {\n      return _coordinateFormatGeometry2Scoord3d([coordinates[0] + 1, coordinates[1], coordinates[2]], pyramid);\n    }\n\n    function _scoord3dCoordinates2geometryCoordinates(coordinates, pyramid) {\n      return _coordinateFormatScoord3d2Geometry([coordinates[0], coordinates[1], coordinates[2]], pyramid);\n    }\n    /*\n      * Translate pixel units of total pixel matrix into millimeters of\n      * slide coordinate system\n    */\n\n\n    function _coordinateFormatGeometry2Scoord3d(coordinates, pyramid) {\n      var transform = false;\n\n      if (!(coordinates[0] instanceof Array)) {\n        coordinates = [coordinates];\n        transform = true;\n      }\n\n      var metadata = pyramid[pyramid.length - 1];\n      var origin = metadata.TotalPixelMatrixOriginSequence[0];\n      var xOffset = Number(origin.XOffsetInSlideCoordinateSystem);\n      var yOffset = Number(origin.YOffsetInSlideCoordinateSystem);\n\n      var pixelSpacing = _getPixelSpacing(metadata);\n\n      coordinates = coordinates.map(function (point) {\n        var x = Number((xOffset + point[0] * pixelSpacing[0]).toFixed(4));\n        var y = Number((yOffset - (point[1] - 1) * pixelSpacing[1]).toFixed(4));\n        var z = Number(0 .toFixed(4));\n        return [x, y, z];\n      });\n\n      if (transform) {\n        return coordinates[0];\n      }\n\n      return coordinates;\n    }\n    /*\n      * Translate millimeters into pixel units of total pixel matrix of\n      * slide coordinate system\n    */\n\n\n    function _coordinateFormatScoord3d2Geometry(coordinates, pyramid) {\n      var transform = false;\n\n      if (!(coordinates[0] instanceof Array)) {\n        coordinates = [coordinates];\n        transform = true;\n      }\n\n      var metadata = pyramid[pyramid.length - 1];\n      var origin = metadata.TotalPixelMatrixOriginSequence[0];\n      var xOffset = Number(origin.XOffsetInSlideCoordinateSystem);\n      var yOffset = Number(origin.YOffsetInSlideCoordinateSystem);\n      coordinates = coordinates.map(function (coord) {\n        var pixelSpacing = _getPixelSpacing(pyramid[pyramid.length - 1]);\n\n        var x = coord[0] / pixelSpacing[0] - 1 - xOffset;\n        var y = -(coord[1] / pixelSpacing[1] - 1) - yOffset;\n        var z = coord[2];\n        return [x, y, z];\n      });\n\n      if (transform) {\n        return coordinates[0];\n      }\n\n      return coordinates;\n    }\n\n    function _getROIFromFeature(feature, pyramid) {\n      var roi = {};\n\n      if (feature !== undefined) {\n        var geometry = feature.getGeometry();\n\n        var _scoord3d2 = _geometry2Scoord3d(geometry, pyramid);\n\n        var properties = feature.getProperties(); // Remove geometry from properties mapping\n\n        var geometryName = feature.getGeometryName();\n        delete properties[geometryName];\n        var uid = feature.getId();\n        roi = new ROI({\n          scoord3d: _scoord3d2,\n          properties: properties,\n          uid: uid\n        });\n      }\n\n      return roi;\n    }\n\n    var _usewebgl = Symbol('usewebgl');\n\n    var _map = Symbol('map');\n\n    var _features = Symbol('features');\n\n    var _drawingSource = Symbol('drawingSource');\n\n    var _drawingLayer = Symbol('drawingLayer');\n\n    var _segmentations = Symbol('segmentations');\n\n    var _client = Symbol('client');\n\n    var _controls = Symbol('controls');\n\n    var _interactions = Symbol('interactions');\n\n    var _pyramidMetadata = Symbol('pyramidMetadata');\n\n    var _pyramidFrameMappings = Symbol('pyramidFrameMappings');\n\n    var _pyramidBaseMetadata = Symbol('pyramidMetadataBase');\n\n    var _metadata = Symbol('metadata');\n\n    var VLWholeSlideMicroscopyImageViewer =\n    /*#__PURE__*/\n    function () {\n      /*\n       * options:\n       *   - client (instance of DICOMwebClient)\n       *   - metadata (array of DICOM JSON metadata for each image instance)\n       *   - retrieveRendered (whether frames should be retrieved using DICOMweb RetrieveRenderedTransaction)\n       *   - useWebGL (whether WebGL renderer should be used; default: true)\n       */\n      function VLWholeSlideMicroscopyImageViewer(options) {\n        _classCallCheck2(this, VLWholeSlideMicroscopyImageViewer);\n\n        if ('useWebGL' in options) {\n          this[_usewebgl] = options.useWebGL;\n        } else {\n          this[_usewebgl] = true;\n        }\n\n        this[_client] = options.client;\n\n        if (!('retrieveRendered' in options)) {\n          options.retrieveRendered = false;\n        }\n\n        if (!('controls' in options)) {\n          options.controls = [];\n        }\n\n        options.controls = new Set(options.controls); // Collection of Openlayers \"VectorLayer\" instances indexable by\n        // DICOM Series Instance UID\n\n        this[_segmentations] = {}; // Collection of Openlayers \"Feature\" instances\n\n        this[_features] = new Collection([], {\n          unique: true\n        }); // Add unique identifier to each created \"Feature\" instance\n\n        this[_features].on('add', function (e) {\n          // The ID may have already been set when drawn. However, features could\n          // have also been added without a draw event.\n          if (e.element.getId() === undefined) {\n            e.element.setId(generateUID());\n          }\n        });\n        /*\n         * To visualize images accross multiple scales, we first need to\n         * determine the image pyramid structure, i.e. the size and resolution\n         * images at the different pyramid levels.\n        */\n\n\n        this[_metadata] = options.metadata.map(function (m) {\n          return formatImageMetadata(m);\n        }); // Sort instances and optionally concatenation parts if present.\n\n        this[_metadata].sort(function (a, b) {\n          var sizeDiff = a.TotalPixelMatrixColumns - b.TotalPixelMatrixColumns;\n\n          if (sizeDiff === 0) {\n            if (a.ConcatenationFrameOffsetNumber !== undefined) {\n              return a.ConcatenationFrameOffsetNumber - b.ConcatenationFrameOffsetNumber;\n            }\n\n            return sizeDiff;\n          }\n\n          return sizeDiff;\n        });\n\n        this[_pyramidMetadata] = [];\n        this[_pyramidFrameMappings] = [];\n\n        var frameMappings = this[_metadata].map(function (m) {\n          return getFrameMapping(m);\n        });\n\n        for (var i = 0; i < this[_metadata].length; i++) {\n          var cols = this[_metadata][i].TotalPixelMatrixColumns;\n          var rows = this[_metadata][i].TotalPixelMatrixRows;\n          var numberOfFrames = this[_metadata][i].NumberOfFrames;\n          var perFrameFunctionalGroups = this[_metadata][i].PerFrameFunctionalGroupsSequence;\n          /*\n           * Instances may be broken down into multiple concatentation parts.\n           * Therefore, we have to re-assemble instance metadata.\n          */\n\n          var alreadyExists = false;\n          var _index3 = null;\n\n          for (var j = 0; j < this[_pyramidMetadata].length; j++) {\n            if (this[_pyramidMetadata][j].TotalPixelMatrixColumns === cols && this[_pyramidMetadata][j].TotalPixelMatrixRows === rows) {\n              alreadyExists = true;\n              _index3 = j;\n            }\n          }\n\n          if (alreadyExists) {\n            var _this$_pyramidMetadat;\n\n            // Update with information obtained from current concatentation part.\n            Object.assign(this[_pyramidFrameMappings][_index3], frameMappings[i]);\n            this[_pyramidMetadata][_index3].NumberOfFrames += numberOfFrames;\n\n            (_this$_pyramidMetadat = this[_pyramidMetadata][_index3].PerFrameFunctionalGroupsSequence).push.apply(_this$_pyramidMetadat, _toConsumableArray(perFrameFunctionalGroups));\n\n            if (!\"SOPInstanceUIDOfConcatenationSource\" in this[_metadata][i]) {\n              throw new Error('Attribute \"SOPInstanceUIDOfConcatenationSource\" is required ' + 'for concatenation parts.');\n            }\n\n            var sopInstanceUID = this[_metadata][i].SOPInstanceUIDOfConcatenationSource;\n            this[_pyramidMetadata][_index3].SOPInstanceUID = sopInstanceUID;\n            delete this[_pyramidMetadata][_index3].SOPInstanceUIDOfConcatenationSource;\n            delete this[_pyramidMetadata][_index3].ConcatenationUID;\n            delete this[_pyramidMetadata][_index3].InConcatenationNumber;\n            delete this[_pyramidMetadata][_index3].ConcatenationFrameOffsetNumber;\n          } else {\n            this[_pyramidMetadata].push(this[_metadata][i]);\n\n            this[_pyramidFrameMappings].push(frameMappings[i]);\n          }\n        }\n\n        var nLevels = this[_pyramidMetadata].length;\n\n        if (nLevels === 0) {\n          console.error('empty pyramid - no levels found');\n        }\n\n        this[_pyramidBaseMetadata] = this[_pyramidMetadata][nLevels - 1];\n        /*\n         * Collect relevant information from DICOM metadata for each pyramid\n         * level to construct the Openlayers map.\n        */\n\n        var tileSizes = [];\n        var totalSizes = [];\n        var resolutions = [];\n        var origins = [];\n        var offset = [0, -1];\n\n        var basePixelSpacing = _getPixelSpacing(this[_pyramidBaseMetadata]);\n\n        var baseColumns = this[_pyramidBaseMetadata].Columns;\n        var baseRows = this[_pyramidBaseMetadata].Rows;\n        var baseTotalPixelMatrixColumns = this[_pyramidBaseMetadata].TotalPixelMatrixColumns;\n        var baseTotalPixelMatrixRows = this[_pyramidBaseMetadata].TotalPixelMatrixRows;\n\n        for (var _j2 = nLevels - 1; _j2 >= 0; _j2--) {\n          var columns = this[_pyramidMetadata][_j2].Columns;\n          var _rows = this[_pyramidMetadata][_j2].Rows;\n          var totalPixelMatrixColumns = this[_pyramidMetadata][_j2].TotalPixelMatrixColumns;\n          var totalPixelMatrixRows = this[_pyramidMetadata][_j2].TotalPixelMatrixRows;\n\n          var pixelSpacing = _getPixelSpacing(this[_pyramidMetadata][_j2]);\n\n          var colFactor = Math.ceil(totalPixelMatrixColumns / columns);\n          var rowFactor = Math.ceil(totalPixelMatrixRows / _rows);\n          var adjustedTotalPixelMatrixColumns = columns * colFactor;\n          var adjustedTotalPixelMatrixRows = _rows * rowFactor;\n          tileSizes.push([columns, _rows]);\n          totalSizes.push([adjustedTotalPixelMatrixColumns, adjustedTotalPixelMatrixRows]);\n          /*\n           * Compute the resolution at each pyramid level, since the zoom\n           * factor may not be the same between adjacent pyramid levels.\n          */\n\n          var zoomFactor = pixelSpacing[0] / basePixelSpacing[0];\n          resolutions.push(zoomFactor);\n          /*\n           * TODO: One may have to adjust the offset slightly due to the\n           * difference between extent of the image at a given resolution level\n           * and the actual number of tiles (frames).\n          */\n\n          origins.push(offset);\n        }\n\n        resolutions.reverse();\n        tileSizes.reverse();\n        origins.reverse(); // Functions won't be able to access \"this\"\n\n        var pyramid = this[_pyramidMetadata];\n        var pyramidFrameMappings = this[_pyramidFrameMappings];\n        /*\n         * Define custom tile URL function to retrive frames via DICOMweb\n         * WADO-RS.\n         */\n\n        var tileUrlFunction = function tileUrlFunction(tileCoord, pixelRatio, projection) {\n          /*\n           * Variables x and y correspond to the X and Y axes of the slide\n           * coordinate system. Since we want to view the slide horizontally\n           * with the label on the right side, the x axis of the slide\n           * coordinate system is the vertical axis of the viewport and the\n           * y axis of the slide coordinate system the horizontal axis of the\n           * viewport. Note that this is in contrast to the nomenclature used\n           * by Openlayers.\n           */\n          var z = tileCoord[0];\n          var y = tileCoord[1] + 1;\n          /*\n           * The vertical axis is inverted for the chosen tile source, i.e.\n           * it starts at -1 at the top left corner and descreases along the\n           * vertical axis to the lower left corner of the viewport.\n           */\n\n          var x = -(tileCoord[2] + 1) + 1;\n          var index = x + \"-\" + y;\n          var path = pyramidFrameMappings[z][index];\n\n          if (path === undefined) {\n            console.warn(\"tile \" + index + \" not found at level \" + z);\n            return null;\n          }\n\n          var url = options.client.wadoURL + \"/studies/\" + pyramid[z].StudyInstanceUID + \"/series/\" + pyramid[z].SeriesInstanceUID + '/instances/' + path;\n\n          if (options.retrieveRendered) {\n            url = url + '/rendered';\n          }\n\n          return url;\n        };\n\n        var tileLoadFunction = function tileLoadFunction(tile, src) {\n          if (src !== null) {\n            var studyInstanceUID = DICOMwebClient.utils.getStudyInstanceUIDFromUri(src);\n            var seriesInstanceUID = DICOMwebClient.utils.getSeriesInstanceUIDFromUri(src);\n\n            var _sopInstanceUID = DICOMwebClient.utils.getSOPInstanceUIDFromUri(src);\n\n            var frameNumbers = DICOMwebClient.utils.getFrameNumbersFromUri(src);\n            var img = tile.getImage();\n\n            if (options.retrieveRendered) {\n              var mimeType = 'image/png';\n              var retrieveOptions = {\n                studyInstanceUID: studyInstanceUID,\n                seriesInstanceUID: seriesInstanceUID,\n                sopInstanceUID: _sopInstanceUID,\n                frameNumbers: frameNumbers,\n                mimeType: mimeType\n              };\n              options.client.retrieveInstanceFramesRendered(retrieveOptions).then(function (renderedFrame) {\n                var blob = new Blob([renderedFrame], {\n                  type: mimeType\n                });\n                img.src = window.URL.createObjectURL(blob);\n              });\n            } else {\n              // TODO: support \"image/jp2\" and \"image/jls\"\n              var _mimeType = 'image/jpeg';\n              var _retrieveOptions = {\n                studyInstanceUID: studyInstanceUID,\n                seriesInstanceUID: seriesInstanceUID,\n                sopInstanceUID: _sopInstanceUID,\n                frameNumbers: frameNumbers,\n                mimeType: _mimeType\n              };\n              options.client.retrieveInstanceFrames(_retrieveOptions).then(function (rawFrames) {\n                var blob = new Blob(rawFrames, {\n                  type: _mimeType\n                });\n                img.src = window.URL.createObjectURL(blob);\n              });\n            }\n          } else {\n            console.warn('could not load tile');\n          }\n        };\n        /*\n         * Frames may extend beyond the size of the total pixel matrix.\n         * The excess pixels are empty, i.e. have only a padding value.\n         * We set the extent to the size of the actual image without taken\n         * excess pixels into account.\n         * Note that the vertical axis is flipped in the used tile source,\n         * i.e. values on the axis lie in the range [-n, -1], where n is the\n         * number of rows in the total pixel matrix.\n        */\n\n\n        var extent = [0, // min X\n        -baseTotalPixelMatrixRows, // min Y\n        baseTotalPixelMatrixColumns, // max X\n        -1 // max Y\n        ];\n        /*\n         * Determine whether image needs to be rotated relative to slide\n         * coordinate system based on direction cosines.\n         * There are only planar rotations, since the total pixel matrix is\n         * parallel to the slide surface. Here, we further assume that rows and\n         * columns of total pixel matrix are parallel to the borders of the slide,\n         * i.e. the x and y axis of the slide coordinate system.\n         * Hence, we only account for the case where the image may be rotated by\n         * 180 degrees.\n        */\n\n        var degrees = 0;\n\n        if (this[_pyramidBaseMetadata].ImageOrientationSlide[1] === -1 && this[_pyramidBaseMetadata].ImageOrientationSlide[3] === -1) {\n          /*\n           * The row direction (left to right) of the total pixel matrix\n           * is defined by the first three values.\n           * The three values specify how the direction changes from the last pixel\n           * to the first pixel in the row along each of the three axes of the\n           * slide coordinate system (x, y, z), i.e. it express in which direction one\n           * is moving in the slide coordinate system when the COLUMN index changes.\n           * The column direction (top to bottom) of the total pixel matrix\n           * is defined by the first three values.\n           * The three values specify how the direction changes from the last pixel\n           * to the first pixel in the column along each of the three axes of the\n           * slide coordinate system (x, y, z), i.e. it express in which direction one\n           * is moving in the slide coordinate system when the ROW index changes.\n          */\n          degrees = 180;\n        }\n\n        var rotation = degrees * (Math.PI / 180);\n        /*\n         * Specify projection to prevent default automatic projection\n         * with the default Mercator projection.\n         */\n\n        var projection = new Projection({\n          code: \"NONE\",\n          units: 'metric',\n          extent: extent,\n          getPointResolution: function getPointResolution(pixelRes, point) {\n            /*\n             * DICOM pixel spacing has millimeter unit while the projection has\n             * has meter unit.\n             */\n            var spacing = _getPixelSpacing(pyramid[nLevels - 1])[0] / Math.pow(10, 3);\n            var res = pixelRes * spacing;\n            return res;\n          }\n        });\n        /*\n         * TODO: Register custom projection:\n         *  - http://openlayers.org/en/latest/apidoc/ol.proj.html\n         *  - http://openlayers.org/en/latest/apidoc/module-ol_proj.html#~ProjectionLike\n         * Direction cosines could be handled via projection rather\n         * than specifying a rotation\n         */\n\n        /*\n         * We need to specify the tile grid, since DICOM allows tiles to\n         * have different sizes at each resolution level and a different zoom\n         * factor between individual levels.\n         */\n\n        var tileGrid = new TileGrid({\n          extent: extent,\n          origins: origins,\n          resolutions: resolutions,\n          sizes: totalSizes,\n          tileSizes: tileSizes\n        });\n        /*\n         * We use the implemented XYZ tile source but customize it to retrieve\n         * frames (load tiles) via DICOMweb WADO-RS.\n         */\n\n        var rasterSource = new XYZ({\n          crossOrigin: \"Anonymous\",\n          tileGrid: tileGrid,\n          projection: projection,\n          wrapX: false\n        });\n        rasterSource.setTileUrlFunction(tileUrlFunction);\n        rasterSource.setTileLoadFunction(tileLoadFunction);\n        var imageLayer = new TileLayer({\n          extent: extent,\n          source: rasterSource,\n          preload: 1,\n          projection: projection\n        });\n        this[_drawingSource] = new VectorSource({\n          tileGrid: tileGrid,\n          projection: projection,\n          features: this[_features],\n          wrapX: false\n        });\n        this[_drawingLayer] = new VectorLayer({\n          extent: extent,\n          source: this[_drawingSource],\n          projection: projection,\n          updateWhileAnimating: true,\n          updateWhileInteracting: true\n        });\n        var view = new View({\n          center: getCenter(extent),\n          extent: extent,\n          projection: projection,\n          resolutions: resolutions,\n          rotation: rotation\n        });\n        var overviewView = new View({\n          projection: projection,\n          resolutions: resolutions,\n          rotation: rotation\n        });\n        this[_interactions] = {\n          draw: undefined,\n          select: undefined,\n          modify: undefined\n        };\n        this[_controls] = {\n          scale: new ScaleLine({\n            units: 'metric',\n            className: ''\n          })\n        };\n\n        if (options.controls.has('fullscreen')) {\n          this[_controls].fullscreen = new FullScreen();\n        }\n\n        if (options.controls.has('overview')) {\n          this[_controls].overview = new OverviewMap({\n            view: overviewView,\n            collapsed: true\n          });\n        }\n        /*\n         * Creates the map with the defined layers and view and renders it via\n         * WebGL.\n         */\n\n\n        if (this[_usewebgl]) {\n          this[_map] = new WebGLMap({\n            layers: [imageLayer, this[_drawingLayer]],\n            view: view,\n            controls: [],\n            loadTilesWhileAnimating: true,\n            loadTilesWhileInteracting: true,\n            logo: false\n          });\n        } else {\n          this[_map] = new Map({\n            layers: [imageLayer, this[_drawingLayer]],\n            view: view,\n            controls: [],\n            loadTilesWhileAnimating: true,\n            loadTilesWhileInteracting: true,\n            logo: false\n          });\n        }\n\n        for (var control in this[_controls]) {\n          this[_map].addControl(this[_controls][control]);\n        }\n\n        this[_map].getView().fit(extent, this[_map].getSize());\n      }\n      /* Renders the images.\n       */\n\n\n      _createClass2(VLWholeSlideMicroscopyImageViewer, [{\n        key: \"render\",\n        value: function render(options) {\n          var _this2 = this;\n\n          if (!('container' in options)) {\n            console.error('container must be provided for rendering images');\n          }\n\n          this[_map].setTarget(options.container); // Style scale element (overriding default Openlayers CSS \"ol-scale-line\")\n\n\n          var scaleElement = this[_controls]['scale'].element;\n          scaleElement.style.position = 'absolute';\n          scaleElement.style.right = '.5em';\n          scaleElement.style.bottom = '.5em';\n          scaleElement.style.left = 'auto';\n          scaleElement.style.padding = '2px';\n          scaleElement.style.backgroundColor = 'rgba(255,255,255,.5)';\n          scaleElement.style.borderRadius = '4px';\n          scaleElement.style.margin = '1px';\n          var scaleInnerElement = this[_controls]['scale'].innerElement_;\n          scaleInnerElement.style.color = 'black';\n          scaleInnerElement.style.fontWeight = '600';\n          scaleInnerElement.style.fontSize = '10px';\n          scaleInnerElement.style.textAlign = 'center';\n          scaleInnerElement.style.borderWidth = '1.5px';\n          scaleInnerElement.style.borderStyle = 'solid';\n          scaleInnerElement.style.borderTop = 'none';\n          scaleInnerElement.style.borderRightColor = 'black';\n          scaleInnerElement.style.borderLeftColor = 'black';\n          scaleInnerElement.style.borderBottomColor = 'black';\n          scaleInnerElement.style.margin = '1px';\n          scaleInnerElement.style.willChange = 'contents,width';\n\n          var container = this[_map].getTargetElement();\n\n          this[_drawingSource].on(VectorEventType.ADDFEATURE, function (e) {\n            publish(container, EVENTS.ROI_ADDED, _getROIFromFeature(e.feature, _this2[_pyramidMetadata]));\n          });\n\n          this[_drawingSource].on(VectorEventType.CHANGEFEATURE, function (e) {\n            publish(container, EVENTS.ROI_MODIFIED, _getROIFromFeature(e.feature, _this2[_pyramidMetadata]));\n          });\n\n          this[_drawingSource].on(VectorEventType.REMOVEFEATURE, function (e) {\n            publish(container, EVENTS.ROI_REMOVED, _getROIFromFeature(e.feature, _this2[_pyramidMetadata]));\n          });\n\n          this[_map].on(MapEventType.MOVESTART, function (e) {\n            publish(container, EVENTS.MOVE_STARTED, _this2.getAllROIs());\n          });\n\n          this[_map].on(MapEventType.MOVEEND, function (e) {\n            publish(container, EVENTS.MOVE_ENDED, _this2.getAllROIs());\n          });\n        }\n        /* Activate draw interaction.\n         */\n\n      }, {\n        key: \"activateDrawInteraction\",\n        value: function activateDrawInteraction(options) {\n          var _this3 = this;\n\n          this.deactivateDrawInteraction();\n          var customOptionsMapping = {\n            point: {\n              type: 'Point',\n              geometryName: 'Point'\n            },\n            circle: {\n              type: 'Circle',\n              geometryName: 'Circle'\n            },\n            box: {\n              type: 'Circle',\n              geometryName: 'Box',\n              geometryFunction: createRegularPolygon(4)\n            },\n            polygon: {\n              type: 'Polygon',\n              geometryName: 'Polygon',\n              freehand: false\n            },\n            freehandpolygon: {\n              type: 'Polygon',\n              geometryName: 'FreeHandPolygon',\n              freehand: true\n            },\n            line: {\n              type: 'LineString',\n              geometryName: 'Line',\n              freehand: false\n            },\n            freehandline: {\n              type: 'LineString',\n              geometryName: 'FreeHandLine',\n              freehand: true\n            }\n          };\n\n          if (!('geometryType' in options)) {\n            console.error('geometry type must be specified for drawing interaction');\n          }\n\n          if (!(options.geometryType in customOptionsMapping)) {\n            console.error(\"unsupported geometry type \\\"\".concat(options.geometryType, \"\\\"\"));\n          }\n\n          var defaultDrawOptions = {\n            source: this[_drawingSource]\n          };\n          var customDrawOptions = customOptionsMapping[options.geometryType];\n\n          if ('style' in options) {\n            customDrawOptions.style = options.style;\n          }\n\n          var allDrawOptions = Object.assign(defaultDrawOptions, customDrawOptions);\n          this[_interactions].draw = new Draw(allDrawOptions);\n\n          var container = this[_map].getTargetElement(); //attaching openlayers events handling\n\n\n          this[_interactions].draw.on('drawend', function (e) {\n            e.feature.setId(generateUID());\n            publish(container, EVENTS.ROI_DRAWN, _getROIFromFeature(e.feature, _this3[_pyramidMetadata]));\n          });\n\n          this[_map].addInteraction(this[_interactions].draw);\n        }\n        /* Deactivate draw interaction.\n         */\n\n      }, {\n        key: \"deactivateDrawInteraction\",\n        value: function deactivateDrawInteraction() {\n          if (this[_interactions].draw !== undefined) {\n            this[_map].removeInteraction(this[_interactions].draw);\n\n            this[_interactions].draw = undefined;\n          }\n        }\n      }, {\n        key: \"activateSelectInteraction\",\n\n        /* Activate select interaction.\n         */\n        value: function activateSelectInteraction() {\n          var _this4 = this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          this.deactivateSelectInteraction();\n          this[_interactions].select = new Select({\n            layers: [this[_drawingLayer]]\n          });\n\n          var container = this[_map].getTargetElement();\n\n          this[_interactions].select.on('select', function (e) {\n            publish(container, EVENTS.ROI_SELECTED, _getROIFromFeature(e.selected[0], _this4[_pyramidMetadata]));\n          });\n\n          this[_map].addInteraction(this[_interactions].select);\n        }\n        /* Deactivate select interaction.\n         */\n\n      }, {\n        key: \"deactivateSelectInteraction\",\n        value: function deactivateSelectInteraction() {\n          if (this[_interactions].select) {\n            this[_map].removeInteraction(this[_interactions].select);\n\n            this[_interactions].select = undefined;\n          }\n        }\n      }, {\n        key: \"activateModifyInteraction\",\n\n        /* Activate modify interaction.\n         */\n        value: function activateModifyInteraction() {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          this.deactivateModifyInteraction();\n          this[_interactions].modify = new Modify({\n            features: this[_features] // TODO: or source, i.e. \"drawings\"???\n\n          });\n\n          this[_map].addInteraction(this[_interactions].modify);\n        }\n        /* Deactivate modify interaction.\n         */\n\n      }, {\n        key: \"deactivateModifyInteraction\",\n        value: function deactivateModifyInteraction() {\n          if (this[_interactions].modify) {\n            this[_map].removeInteraction(this[_interactions].modify);\n\n            this[_interactions].modify = undefined;\n          }\n        }\n      }, {\n        key: \"getAllROIs\",\n        value: function getAllROIs() {\n          var _this5 = this;\n\n          var rois = [];\n\n          this[_features].forEach(function (item) {\n            rois.push(_this5.getROI(item.getId()));\n          });\n\n          return rois;\n        }\n      }, {\n        key: \"getROI\",\n        value: function getROI(uid) {\n          var feature = this[_drawingSource].getFeatureById(uid);\n\n          return _getROIFromFeature(feature, this[_pyramidMetadata]);\n        }\n      }, {\n        key: \"popROI\",\n        value: function popROI() {\n          var feature = this[_features].pop();\n\n          return _getROIFromFeature(feature, this[_pyramidMetadata]);\n        }\n      }, {\n        key: \"addROI\",\n        value: function addROI(item) {\n          var geometry = _scoord3d2Geometry(item.scoord3d, this[_pyramidMetadata]);\n\n          var feature = new Feature(geometry);\n          feature.setProperties(item.properties, true);\n          feature.setId(item.uid);\n\n          this[_features].push(feature);\n        }\n      }, {\n        key: \"removeROI\",\n        value: function removeROI(uid) {\n          var feature = this[_drawingSource].getFeatureById(uid);\n\n          this[_features].remove(feature);\n        }\n      }, {\n        key: \"removeAllROI\",\n        value: function removeAllROI() {\n          this[_features].clear();\n        }\n      }, {\n        key: \"hideROIs\",\n        value: function hideROIs() {\n          this[_drawingLayer].setVisible(false);\n        }\n      }, {\n        key: \"showROIs\",\n        value: function showROIs() {\n          this[_drawingLayer].setVisible(true);\n        }\n      }, {\n        key: \"isDrawInteractionActive\",\n        get: function get() {\n          return this[_interactions].draw !== undefined;\n        }\n      }, {\n        key: \"isSelectInteractionActive\",\n        get: function get() {\n          return this[_interactions].select !== undefined;\n        }\n      }, {\n        key: \"isModifyInteractionActive\",\n        get: function get() {\n          return this[_interactions].modify !== undefined;\n        }\n      }, {\n        key: \"numberOfROIs\",\n        get: function get() {\n          return this[_features].getLength();\n        }\n      }, {\n        key: \"areROIsVisible\",\n        get: function get() {\n          return this[_drawingLayer].getVisible();\n        }\n      }, {\n        key: \"imageMetadata\",\n        get: function get() {\n          return this[_pyramidMetadata];\n        }\n      }]);\n\n      return VLWholeSlideMicroscopyImageViewer;\n    }();\n\n    var api = {\n      VLWholeSlideMicroscopyImageViewer: VLWholeSlideMicroscopyImageViewer\n    };\n    var scoord3d = {\n      Point: Point$1,\n      Multipoint: Multipoint,\n      Polyline: Polyline,\n      Polygon: Polygon$1,\n      Ellipsoid: Ellipsoid,\n      Ellipse: Ellipse\n    };\n    var roi = {\n      ROI: ROI\n    };\n    exports.api = api;\n    exports.scoord3d = scoord3d;\n    exports.roi = roi;\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n  });\n});\nunwrapExports(dicomMicroscopyViewer);\nvar dicomMicroscopyViewer_1 = dicomMicroscopyViewer.api;\nvar microscopyViewer = dicomMicroscopyViewer_1.VLWholeSlideMicroscopyImageViewer;\n\nvar DicomMicroscopyViewport =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(DicomMicroscopyViewport, _Component);\n\n  function DicomMicroscopyViewport(props) {\n    var _this;\n\n    _classCallCheck(this, DicomMicroscopyViewport);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DicomMicroscopyViewport).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      error: null\n    });\n\n    _this.container = React.createRef();\n    return _this;\n  } // install the microscopy renderer into the web page.\n  // you should only do this once.\n\n\n  _createClass(DicomMicroscopyViewport, [{\n    key: \"installOpenLayersRenderer\",\n    value: function installOpenLayersRenderer(container, displaySet) {\n      var dicomWebClient = displaySet.dicomWebClient;\n      var searchInstanceOptions = {\n        studyInstanceUID: displaySet.studyInstanceUid,\n        seriesInstanceUID: displaySet.seriesInstanceUid\n      };\n      dicomWebClient.searchForInstances(searchInstanceOptions).then(function (instances) {\n        var promises = [];\n\n        for (var i = 0; i < instances.length; i++) {\n          var sopInstanceUID = instances[i]['00080018']['Value'][0];\n          var retrieveInstanceOptions = {\n            studyInstanceUID: displaySet.studyInstanceUid,\n            seriesInstanceUID: displaySet.seriesInstanceUid,\n            sopInstanceUID: sopInstanceUID\n          };\n          var promise = dicomWebClient.retrieveInstanceMetadata(retrieveInstanceOptions).then(function (metadata) {\n            var imageType = metadata[0]['00080008']['Value'];\n\n            if (imageType[2] === 'VOLUME') {\n              return metadata[0];\n            }\n          });\n          promises.push(promise);\n        }\n\n        return Promise.all(promises);\n      }).then(function (metadata) {\n        metadata = metadata.filter(function (m) {\n          return m;\n        });\n        var viewer = new microscopyViewer({\n          client: dicomWebClient,\n          metadata: metadata\n        });\n        viewer.render({\n          container: container,\n          retrieveRendered: true\n        });\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props$viewportD = this.props.viewportData,\n          studies = _this$props$viewportD.studies,\n          displaySet = _this$props$viewportD.displaySet;\n      this.installOpenLayersRenderer(this.container.current, displaySet);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var style = {\n        width: '100%',\n        height: '100%'\n      };\n      return React.createElement(\"div\", {\n        className: 'DicomMicroscopyViewer',\n        style: style\n      }, this.state.error ? React.createElement(\"h2\", null, JSON.stringify(this.state.error)) : React.createElement(\"div\", {\n        style: style,\n        ref: this.container\n      }));\n    }\n  }]);\n\n  return DicomMicroscopyViewport;\n}(Component);\n\nvar index = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id: 'microscopy',\n  getViewportModule: function getViewportModule() {\n    return DicomMicroscopyViewport;\n  },\n  getSopClassHandlerModule: function getSopClassHandlerModule() {\n    return DicomMicroscopySopClassHandler;\n  }\n};\nexport default index;","map":null,"metadata":{},"sourceType":"module"}