{"ast":null,"code":"import { measurements, utils } from 'ohif-core';\nvar MeasurementApi = measurements.MeasurementApi;\nvar studyMetadataManager = utils.studyMetadataManager; // TODO: Move this function to OHIF itself so we can use it on the OHIF measurment table (when it is finished)\n\n/**\n * Activates a set of measurements\n *\n * @param measurementData\n * @param viewportsState\n * @param timepointManagerState\n * @param options\n */\n\nexport default function jumpToRowItem(measurementData, viewportsState, timepointManagerState) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    invertViewportTimepointsOrder: false,\n    childToolKey: null\n  };\n  var numViewports = viewportsState.layout.viewports.length;\n  var numTimepoints = timepointManagerState.timepoints.length;\n  var measurements = timepointManagerState.measurements,\n      timepoints = timepointManagerState.timepoints;\n  var numViewportsToUpdate = Math.min(numTimepoints, numViewports);\n  var toolType = measurementData.toolType,\n      measurementNumber = measurementData.measurementNumber;\n\n  if (options.invertViewportTimepointsOrder) {\n    timepoints.reverse();\n  }\n\n  var measurementsForToolGroup = measurements[toolType]; // Retrieve the measurements data\n\n  var measurementsToJumpTo = [];\n\n  var _loop = function _loop(i) {\n    var timepointId = timepoints[i].timepointId;\n    var dataAtThisTimepoint = measurementsForToolGroup.find(function (entry) {\n      return entry.timepointId === timepointId && entry.measurementNumber === measurementNumber;\n    });\n\n    if (!dataAtThisTimepoint) {\n      measurementsToJumpTo.push(null);\n      return \"continue\";\n    }\n\n    var measurement = dataAtThisTimepoint;\n\n    var _MeasurementApi$getTo = MeasurementApi.getToolConfiguration(toolType),\n        tool = _MeasurementApi$getTo.tool;\n\n    if (options.childToolKey) {\n      measurement = dataAtThisTimepoint[options.childToolKey];\n    } else if (Array.isArray(tool.childTools)) {\n      var key = tool.childTools.find(function (key) {\n        return !!dataAtThisTimepoint[key];\n      });\n      measurement = dataAtThisTimepoint[key];\n    }\n\n    measurementsToJumpTo.push(measurement);\n  };\n\n  for (var i = 0; i < numViewportsToUpdate; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === \"continue\") continue;\n  } // TODO: Add a single viewports state action which allows\n  // - viewportData to be set\n  // - layout to be set\n  // - activeViewport to be set\n  // Needs to update viewports.viewportData state to set image set data\n\n\n  var displaySetContainsSopInstance = function displaySetContainsSopInstance(displaySet, sopInstanceUid) {\n    return displaySet.images.find(function (image) {\n      return image.getSOPInstanceUID() === sopInstanceUid;\n    });\n  };\n\n  var viewportSpecificData = [];\n  measurementsToJumpTo.forEach(function (data, viewportIndex) {\n    // Skip if there is no measurement to jump\n    if (!data) {\n      return;\n    }\n\n    var study = studyMetadataManager.get(data.studyInstanceUid);\n\n    if (!study) {\n      throw new Error('Study not found.');\n    }\n\n    var displaySet = study.findDisplaySet(function (displaySet) {\n      return displaySetContainsSopInstance(displaySet, data.sopInstanceUid);\n    });\n\n    if (!displaySet) {\n      throw new Error('Display set not found.');\n    }\n\n    displaySet.sopInstanceUid = data.sopInstanceUid;\n\n    if (data.frameIndex) {\n      displaySet.frameIndex = data.frameIndex;\n    }\n\n    viewportSpecificData.push({\n      viewportIndex: viewportIndex,\n      displaySet: displaySet\n    });\n  });\n  return {\n    viewportSpecificData: viewportSpecificData,\n    layout: [] // TODO: if we need to change layout, we should return this here\n\n  };\n}","map":{"version":3,"sources":["/home/bitnami/Viewers/src/lib/jumpToRowItem.js"],"names":["measurements","utils","MeasurementApi","studyMetadataManager","jumpToRowItem","measurementData","viewportsState","timepointManagerState","options","invertViewportTimepointsOrder","childToolKey","numViewports","layout","viewports","length","numTimepoints","timepoints","numViewportsToUpdate","Math","min","toolType","measurementNumber","reverse","measurementsForToolGroup","measurementsToJumpTo","i","timepointId","dataAtThisTimepoint","find","entry","push","measurement","getToolConfiguration","tool","Array","isArray","childTools","key","displaySetContainsSopInstance","displaySet","sopInstanceUid","images","image","getSOPInstanceUID","viewportSpecificData","forEach","data","viewportIndex","study","get","studyInstanceUid","Error","findDisplaySet","frameIndex"],"mappings":"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","sourcesContent":["import { measurements, utils } from 'ohif-core';\n\nconst { MeasurementApi } = measurements;\nconst { studyMetadataManager } = utils;\n\n// TODO: Move this function to OHIF itself so we can use it on the OHIF measurment table (when it is finished)\n\n/**\n * Activates a set of measurements\n *\n * @param measurementData\n * @param viewportsState\n * @param timepointManagerState\n * @param options\n */\nexport default function jumpToRowItem(\n  measurementData,\n  viewportsState,\n  timepointManagerState,\n  options = { invertViewportTimepointsOrder: false, childToolKey: null }\n) {\n  const numViewports = viewportsState.layout.viewports.length;\n  const numTimepoints = timepointManagerState.timepoints.length;\n  const { measurements, timepoints } = timepointManagerState;\n  const numViewportsToUpdate = Math.min(numTimepoints, numViewports);\n  const { toolType, measurementNumber } = measurementData;\n\n  if (options.invertViewportTimepointsOrder) {\n    timepoints.reverse();\n  }\n\n  const measurementsForToolGroup = measurements[toolType];\n\n  // Retrieve the measurements data\n  const measurementsToJumpTo = [];\n  for (let i = 0; i < numViewportsToUpdate; i++) {\n    const { timepointId } = timepoints[i];\n\n    const dataAtThisTimepoint = measurementsForToolGroup.find(entry => {\n      return (\n        entry.timepointId === timepointId &&\n        entry.measurementNumber === measurementNumber\n      );\n    });\n\n    if (!dataAtThisTimepoint) {\n      measurementsToJumpTo.push(null);\n      continue;\n    }\n\n    let measurement = dataAtThisTimepoint;\n\n    const { tool } = MeasurementApi.getToolConfiguration(toolType);\n    if (options.childToolKey) {\n      measurement = dataAtThisTimepoint[options.childToolKey];\n    } else if (Array.isArray(tool.childTools)) {\n      const key = tool.childTools.find(key => !!dataAtThisTimepoint[key]);\n      measurement = dataAtThisTimepoint[key];\n    }\n\n    measurementsToJumpTo.push(measurement);\n  }\n\n  // TODO: Add a single viewports state action which allows\n  // - viewportData to be set\n  // - layout to be set\n  // - activeViewport to be set\n\n  // Needs to update viewports.viewportData state to set image set data\n\n  const displaySetContainsSopInstance = (displaySet, sopInstanceUid) =>\n    displaySet.images.find(\n      image => image.getSOPInstanceUID() === sopInstanceUid\n    );\n\n  const viewportSpecificData = [];\n  measurementsToJumpTo.forEach((data, viewportIndex) => {\n    // Skip if there is no measurement to jump\n    if (!data) {\n      return;\n    }\n\n    const study = studyMetadataManager.get(data.studyInstanceUid);\n    if (!study) {\n      throw new Error('Study not found.');\n    }\n\n    const displaySet = study.findDisplaySet(displaySet => {\n      return displaySetContainsSopInstance(displaySet, data.sopInstanceUid);\n    });\n\n    if (!displaySet) {\n      throw new Error('Display set not found.');\n    }\n\n    displaySet.sopInstanceUid = data.sopInstanceUid;\n    if (data.frameIndex) {\n      displaySet.frameIndex = data.frameIndex;\n    }\n\n    viewportSpecificData.push({\n      viewportIndex,\n      displaySet,\n    });\n  });\n\n  return {\n    viewportSpecificData,\n    layout: [], // TODO: if we need to change layout, we should return this here\n  };\n}\n"]},"metadata":{},"sourceType":"module"}