'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var PropTypes = require('prop-types');
var React = require('react');
var hoistNonReactStatics = _interopDefault(require('hoist-non-react-statics'));

var clamp = function clamp(num, lower, upper) {
  num = num <= upper ? num : upper;
  num = num >= lower ? num : lower;
  return num;
};

var increment = function increment(progress) {
  var amount = 0;

  if (progress >= 0 && progress < 0.2) {
    amount = 0.1;
  } else if (progress >= 0.2 && progress < 0.5) {
    amount = 0.04;
  } else if (progress >= 0.5 && progress < 0.8) {
    amount = 0.02;
  } else if (progress >= 0.8 && progress < 0.99) {
    amount = 0.005;
  }

  return clamp(progress + amount, 0, 0.994);
};

var isRunning = false;
var pending = [];

var next = function next() {
  isRunning = true;
  var cb = pending.shift();

  if (cb) {
    return cb(next);
  }

  isRunning = false;
};

var clear = function clear() {
  isRunning = false;
  pending = [];
};
var queue = function queue(cb) {
  pending.push(cb);

  if (!isRunning && pending.length === 1) {
    next();
  }
};

var handle;
var cancel = function cancel() {
  if (handle) {
    window.cancelAnimationFrame(handle);
  }
};
var timeout = function timeout(callback, delay) {
  var deltaTime;
  var start;

  var frame = function frame(time) {
    start = start || time;
    deltaTime = time - start;

    if (deltaTime > delay) {
      callback();
      return;
    }

    handle = window.requestAnimationFrame(frame);
  };

  handle = window.requestAnimationFrame(frame);
};

var NProgress =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(NProgress, _React$Component);

  function NProgress() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.initialState = {
      isFinished: false,
      progress: 0
    };
    _this.state = _this.initialState;
    return _this;
  }

  var _proto = NProgress.prototype;

  _proto.start = function start() {
    var _this2 = this;

    var work = function work() {
      _this2.trickle();

      queue(function (next) {
        timeout(function () {
          work();
          next();
        }, _this2.props.incrementDuration);
      });
    };

    work();
  };

  _proto.trickle = function trickle() {
    this.set(increment(this.state.progress));
  };

  _proto.set = function set(n) {
    var _this3 = this;

    n = clamp(n, this.props.minimum, 1);

    if (n === 1) {
      this.cleanup();
      queue(function (next) {
        _this3.setState(function () {
          return {
            progress: n
          };
        }, function () {
          return timeout(next, _this3.props.animationDuration);
        });
      });
      queue(function () {
        _this3.setState(function () {
          return {
            isFinished: true
          };
        }, _this3.cleanup);
      });
      return;
    }

    queue(function (next) {
      _this3.setState(function () {
        return {
          progress: n
        };
      }, function () {
        return timeout(next, _this3.props.animationDuration);
      });
    });
  };

  _proto.cleanup = function cleanup() {
    cancel();
    clear();
  };

  _proto.done = function done() {
    this.set(1);
  };

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.isAnimating) {
      this.start();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this4 = this;

    if (prevProps.isAnimating && !this.props.isAnimating) {
      this.done();
    }

    if (!prevProps.isAnimating && this.props.isAnimating) {
      this.setState(function () {
        return _this4.initialState;
      }, function () {
        return _this4.start();
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cleanup();
  };

  _proto.render = function render() {
    return this.props.children(_extends({}, this.state, {
      animationDuration: this.props.animationDuration
    }));
  };

  return NProgress;
}(React.Component);
NProgress.defaultProps = {
  animationDuration: 200,
  incrementDuration: 800,
  isAnimating: false,
  minimum: 0.08
};
NProgress.propTypes = {
  animationDuration: PropTypes.number,
  children: PropTypes.func,
  incrementDuration: PropTypes.number,
  isAnimating: PropTypes.bool,
  minimum: PropTypes.number
};

function withNProgress(BaseComponent) {
  var WithNProgress = function WithNProgress(props) {
    return React.createElement(NProgress, props, function (p) {
      return React.createElement(BaseComponent, _extends({}, props, p));
    });
  };

  hoistNonReactStatics(WithNProgress, BaseComponent);
  return WithNProgress;
}

exports.NProgress = NProgress;
exports.withNProgress = withNProgress;
//# sourceMappingURL=react-nprogress.development.js.map
